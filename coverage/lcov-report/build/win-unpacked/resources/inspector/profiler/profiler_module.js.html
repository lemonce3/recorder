<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/win-unpacked/resources/inspector/profiler/profiler_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/win-unpacked/resources/inspector/profiler</a> profiler_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/3718</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/1283</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/808</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/1158</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a>
<a name='L559'></a><a href='#L559'>559</a>
<a name='L560'></a><a href='#L560'>560</a>
<a name='L561'></a><a href='#L561'>561</a>
<a name='L562'></a><a href='#L562'>562</a>
<a name='L563'></a><a href='#L563'>563</a>
<a name='L564'></a><a href='#L564'>564</a>
<a name='L565'></a><a href='#L565'>565</a>
<a name='L566'></a><a href='#L566'>566</a>
<a name='L567'></a><a href='#L567'>567</a>
<a name='L568'></a><a href='#L568'>568</a>
<a name='L569'></a><a href='#L569'>569</a>
<a name='L570'></a><a href='#L570'>570</a>
<a name='L571'></a><a href='#L571'>571</a>
<a name='L572'></a><a href='#L572'>572</a>
<a name='L573'></a><a href='#L573'>573</a>
<a name='L574'></a><a href='#L574'>574</a>
<a name='L575'></a><a href='#L575'>575</a>
<a name='L576'></a><a href='#L576'>576</a>
<a name='L577'></a><a href='#L577'>577</a>
<a name='L578'></a><a href='#L578'>578</a>
<a name='L579'></a><a href='#L579'>579</a>
<a name='L580'></a><a href='#L580'>580</a>
<a name='L581'></a><a href='#L581'>581</a>
<a name='L582'></a><a href='#L582'>582</a>
<a name='L583'></a><a href='#L583'>583</a>
<a name='L584'></a><a href='#L584'>584</a>
<a name='L585'></a><a href='#L585'>585</a>
<a name='L586'></a><a href='#L586'>586</a>
<a name='L587'></a><a href='#L587'>587</a>
<a name='L588'></a><a href='#L588'>588</a>
<a name='L589'></a><a href='#L589'>589</a>
<a name='L590'></a><a href='#L590'>590</a>
<a name='L591'></a><a href='#L591'>591</a>
<a name='L592'></a><a href='#L592'>592</a>
<a name='L593'></a><a href='#L593'>593</a>
<a name='L594'></a><a href='#L594'>594</a>
<a name='L595'></a><a href='#L595'>595</a>
<a name='L596'></a><a href='#L596'>596</a>
<a name='L597'></a><a href='#L597'>597</a>
<a name='L598'></a><a href='#L598'>598</a>
<a name='L599'></a><a href='#L599'>599</a>
<a name='L600'></a><a href='#L600'>600</a>
<a name='L601'></a><a href='#L601'>601</a>
<a name='L602'></a><a href='#L602'>602</a>
<a name='L603'></a><a href='#L603'>603</a>
<a name='L604'></a><a href='#L604'>604</a>
<a name='L605'></a><a href='#L605'>605</a>
<a name='L606'></a><a href='#L606'>606</a>
<a name='L607'></a><a href='#L607'>607</a>
<a name='L608'></a><a href='#L608'>608</a>
<a name='L609'></a><a href='#L609'>609</a>
<a name='L610'></a><a href='#L610'>610</a>
<a name='L611'></a><a href='#L611'>611</a>
<a name='L612'></a><a href='#L612'>612</a>
<a name='L613'></a><a href='#L613'>613</a>
<a name='L614'></a><a href='#L614'>614</a>
<a name='L615'></a><a href='#L615'>615</a>
<a name='L616'></a><a href='#L616'>616</a>
<a name='L617'></a><a href='#L617'>617</a>
<a name='L618'></a><a href='#L618'>618</a>
<a name='L619'></a><a href='#L619'>619</a>
<a name='L620'></a><a href='#L620'>620</a>
<a name='L621'></a><a href='#L621'>621</a>
<a name='L622'></a><a href='#L622'>622</a>
<a name='L623'></a><a href='#L623'>623</a>
<a name='L624'></a><a href='#L624'>624</a>
<a name='L625'></a><a href='#L625'>625</a>
<a name='L626'></a><a href='#L626'>626</a>
<a name='L627'></a><a href='#L627'>627</a>
<a name='L628'></a><a href='#L628'>628</a>
<a name='L629'></a><a href='#L629'>629</a>
<a name='L630'></a><a href='#L630'>630</a>
<a name='L631'></a><a href='#L631'>631</a>
<a name='L632'></a><a href='#L632'>632</a>
<a name='L633'></a><a href='#L633'>633</a>
<a name='L634'></a><a href='#L634'>634</a>
<a name='L635'></a><a href='#L635'>635</a>
<a name='L636'></a><a href='#L636'>636</a>
<a name='L637'></a><a href='#L637'>637</a>
<a name='L638'></a><a href='#L638'>638</a>
<a name='L639'></a><a href='#L639'>639</a>
<a name='L640'></a><a href='#L640'>640</a>
<a name='L641'></a><a href='#L641'>641</a>
<a name='L642'></a><a href='#L642'>642</a>
<a name='L643'></a><a href='#L643'>643</a>
<a name='L644'></a><a href='#L644'>644</a>
<a name='L645'></a><a href='#L645'>645</a>
<a name='L646'></a><a href='#L646'>646</a>
<a name='L647'></a><a href='#L647'>647</a>
<a name='L648'></a><a href='#L648'>648</a>
<a name='L649'></a><a href='#L649'>649</a>
<a name='L650'></a><a href='#L650'>650</a>
<a name='L651'></a><a href='#L651'>651</a>
<a name='L652'></a><a href='#L652'>652</a>
<a name='L653'></a><a href='#L653'>653</a>
<a name='L654'></a><a href='#L654'>654</a>
<a name='L655'></a><a href='#L655'>655</a>
<a name='L656'></a><a href='#L656'>656</a>
<a name='L657'></a><a href='#L657'>657</a>
<a name='L658'></a><a href='#L658'>658</a>
<a name='L659'></a><a href='#L659'>659</a>
<a name='L660'></a><a href='#L660'>660</a>
<a name='L661'></a><a href='#L661'>661</a>
<a name='L662'></a><a href='#L662'>662</a>
<a name='L663'></a><a href='#L663'>663</a>
<a name='L664'></a><a href='#L664'>664</a>
<a name='L665'></a><a href='#L665'>665</a>
<a name='L666'></a><a href='#L666'>666</a>
<a name='L667'></a><a href='#L667'>667</a>
<a name='L668'></a><a href='#L668'>668</a>
<a name='L669'></a><a href='#L669'>669</a>
<a name='L670'></a><a href='#L670'>670</a>
<a name='L671'></a><a href='#L671'>671</a>
<a name='L672'></a><a href='#L672'>672</a>
<a name='L673'></a><a href='#L673'>673</a>
<a name='L674'></a><a href='#L674'>674</a>
<a name='L675'></a><a href='#L675'>675</a>
<a name='L676'></a><a href='#L676'>676</a>
<a name='L677'></a><a href='#L677'>677</a>
<a name='L678'></a><a href='#L678'>678</a>
<a name='L679'></a><a href='#L679'>679</a>
<a name='L680'></a><a href='#L680'>680</a>
<a name='L681'></a><a href='#L681'>681</a>
<a name='L682'></a><a href='#L682'>682</a>
<a name='L683'></a><a href='#L683'>683</a>
<a name='L684'></a><a href='#L684'>684</a>
<a name='L685'></a><a href='#L685'>685</a>
<a name='L686'></a><a href='#L686'>686</a>
<a name='L687'></a><a href='#L687'>687</a>
<a name='L688'></a><a href='#L688'>688</a>
<a name='L689'></a><a href='#L689'>689</a>
<a name='L690'></a><a href='#L690'>690</a>
<a name='L691'></a><a href='#L691'>691</a>
<a name='L692'></a><a href='#L692'>692</a>
<a name='L693'></a><a href='#L693'>693</a>
<a name='L694'></a><a href='#L694'>694</a>
<a name='L695'></a><a href='#L695'>695</a>
<a name='L696'></a><a href='#L696'>696</a>
<a name='L697'></a><a href='#L697'>697</a>
<a name='L698'></a><a href='#L698'>698</a>
<a name='L699'></a><a href='#L699'>699</a>
<a name='L700'></a><a href='#L700'>700</a>
<a name='L701'></a><a href='#L701'>701</a>
<a name='L702'></a><a href='#L702'>702</a>
<a name='L703'></a><a href='#L703'>703</a>
<a name='L704'></a><a href='#L704'>704</a>
<a name='L705'></a><a href='#L705'>705</a>
<a name='L706'></a><a href='#L706'>706</a>
<a name='L707'></a><a href='#L707'>707</a>
<a name='L708'></a><a href='#L708'>708</a>
<a name='L709'></a><a href='#L709'>709</a>
<a name='L710'></a><a href='#L710'>710</a>
<a name='L711'></a><a href='#L711'>711</a>
<a name='L712'></a><a href='#L712'>712</a>
<a name='L713'></a><a href='#L713'>713</a>
<a name='L714'></a><a href='#L714'>714</a>
<a name='L715'></a><a href='#L715'>715</a>
<a name='L716'></a><a href='#L716'>716</a>
<a name='L717'></a><a href='#L717'>717</a>
<a name='L718'></a><a href='#L718'>718</a>
<a name='L719'></a><a href='#L719'>719</a>
<a name='L720'></a><a href='#L720'>720</a>
<a name='L721'></a><a href='#L721'>721</a>
<a name='L722'></a><a href='#L722'>722</a>
<a name='L723'></a><a href='#L723'>723</a>
<a name='L724'></a><a href='#L724'>724</a>
<a name='L725'></a><a href='#L725'>725</a>
<a name='L726'></a><a href='#L726'>726</a>
<a name='L727'></a><a href='#L727'>727</a>
<a name='L728'></a><a href='#L728'>728</a>
<a name='L729'></a><a href='#L729'>729</a>
<a name='L730'></a><a href='#L730'>730</a>
<a name='L731'></a><a href='#L731'>731</a>
<a name='L732'></a><a href='#L732'>732</a>
<a name='L733'></a><a href='#L733'>733</a>
<a name='L734'></a><a href='#L734'>734</a>
<a name='L735'></a><a href='#L735'>735</a>
<a name='L736'></a><a href='#L736'>736</a>
<a name='L737'></a><a href='#L737'>737</a>
<a name='L738'></a><a href='#L738'>738</a>
<a name='L739'></a><a href='#L739'>739</a>
<a name='L740'></a><a href='#L740'>740</a>
<a name='L741'></a><a href='#L741'>741</a>
<a name='L742'></a><a href='#L742'>742</a>
<a name='L743'></a><a href='#L743'>743</a>
<a name='L744'></a><a href='#L744'>744</a>
<a name='L745'></a><a href='#L745'>745</a>
<a name='L746'></a><a href='#L746'>746</a>
<a name='L747'></a><a href='#L747'>747</a>
<a name='L748'></a><a href='#L748'>748</a>
<a name='L749'></a><a href='#L749'>749</a>
<a name='L750'></a><a href='#L750'>750</a>
<a name='L751'></a><a href='#L751'>751</a>
<a name='L752'></a><a href='#L752'>752</a>
<a name='L753'></a><a href='#L753'>753</a>
<a name='L754'></a><a href='#L754'>754</a>
<a name='L755'></a><a href='#L755'>755</a>
<a name='L756'></a><a href='#L756'>756</a>
<a name='L757'></a><a href='#L757'>757</a>
<a name='L758'></a><a href='#L758'>758</a>
<a name='L759'></a><a href='#L759'>759</a>
<a name='L760'></a><a href='#L760'>760</a>
<a name='L761'></a><a href='#L761'>761</a>
<a name='L762'></a><a href='#L762'>762</a>
<a name='L763'></a><a href='#L763'>763</a>
<a name='L764'></a><a href='#L764'>764</a>
<a name='L765'></a><a href='#L765'>765</a>
<a name='L766'></a><a href='#L766'>766</a>
<a name='L767'></a><a href='#L767'>767</a>
<a name='L768'></a><a href='#L768'>768</a>
<a name='L769'></a><a href='#L769'>769</a>
<a name='L770'></a><a href='#L770'>770</a>
<a name='L771'></a><a href='#L771'>771</a>
<a name='L772'></a><a href='#L772'>772</a>
<a name='L773'></a><a href='#L773'>773</a>
<a name='L774'></a><a href='#L774'>774</a>
<a name='L775'></a><a href='#L775'>775</a>
<a name='L776'></a><a href='#L776'>776</a>
<a name='L777'></a><a href='#L777'>777</a>
<a name='L778'></a><a href='#L778'>778</a>
<a name='L779'></a><a href='#L779'>779</a>
<a name='L780'></a><a href='#L780'>780</a>
<a name='L781'></a><a href='#L781'>781</a>
<a name='L782'></a><a href='#L782'>782</a>
<a name='L783'></a><a href='#L783'>783</a>
<a name='L784'></a><a href='#L784'>784</a>
<a name='L785'></a><a href='#L785'>785</a>
<a name='L786'></a><a href='#L786'>786</a>
<a name='L787'></a><a href='#L787'>787</a>
<a name='L788'></a><a href='#L788'>788</a>
<a name='L789'></a><a href='#L789'>789</a>
<a name='L790'></a><a href='#L790'>790</a>
<a name='L791'></a><a href='#L791'>791</a>
<a name='L792'></a><a href='#L792'>792</a>
<a name='L793'></a><a href='#L793'>793</a>
<a name='L794'></a><a href='#L794'>794</a>
<a name='L795'></a><a href='#L795'>795</a>
<a name='L796'></a><a href='#L796'>796</a>
<a name='L797'></a><a href='#L797'>797</a>
<a name='L798'></a><a href='#L798'>798</a>
<a name='L799'></a><a href='#L799'>799</a>
<a name='L800'></a><a href='#L800'>800</a>
<a name='L801'></a><a href='#L801'>801</a>
<a name='L802'></a><a href='#L802'>802</a>
<a name='L803'></a><a href='#L803'>803</a>
<a name='L804'></a><a href='#L804'>804</a>
<a name='L805'></a><a href='#L805'>805</a>
<a name='L806'></a><a href='#L806'>806</a>
<a name='L807'></a><a href='#L807'>807</a>
<a name='L808'></a><a href='#L808'>808</a>
<a name='L809'></a><a href='#L809'>809</a>
<a name='L810'></a><a href='#L810'>810</a>
<a name='L811'></a><a href='#L811'>811</a>
<a name='L812'></a><a href='#L812'>812</a>
<a name='L813'></a><a href='#L813'>813</a>
<a name='L814'></a><a href='#L814'>814</a>
<a name='L815'></a><a href='#L815'>815</a>
<a name='L816'></a><a href='#L816'>816</a>
<a name='L817'></a><a href='#L817'>817</a>
<a name='L818'></a><a href='#L818'>818</a>
<a name='L819'></a><a href='#L819'>819</a>
<a name='L820'></a><a href='#L820'>820</a>
<a name='L821'></a><a href='#L821'>821</a>
<a name='L822'></a><a href='#L822'>822</a>
<a name='L823'></a><a href='#L823'>823</a>
<a name='L824'></a><a href='#L824'>824</a>
<a name='L825'></a><a href='#L825'>825</a>
<a name='L826'></a><a href='#L826'>826</a>
<a name='L827'></a><a href='#L827'>827</a>
<a name='L828'></a><a href='#L828'>828</a>
<a name='L829'></a><a href='#L829'>829</a>
<a name='L830'></a><a href='#L830'>830</a>
<a name='L831'></a><a href='#L831'>831</a>
<a name='L832'></a><a href='#L832'>832</a>
<a name='L833'></a><a href='#L833'>833</a>
<a name='L834'></a><a href='#L834'>834</a>
<a name='L835'></a><a href='#L835'>835</a>
<a name='L836'></a><a href='#L836'>836</a>
<a name='L837'></a><a href='#L837'>837</a>
<a name='L838'></a><a href='#L838'>838</a>
<a name='L839'></a><a href='#L839'>839</a>
<a name='L840'></a><a href='#L840'>840</a>
<a name='L841'></a><a href='#L841'>841</a>
<a name='L842'></a><a href='#L842'>842</a>
<a name='L843'></a><a href='#L843'>843</a>
<a name='L844'></a><a href='#L844'>844</a>
<a name='L845'></a><a href='#L845'>845</a>
<a name='L846'></a><a href='#L846'>846</a>
<a name='L847'></a><a href='#L847'>847</a>
<a name='L848'></a><a href='#L848'>848</a>
<a name='L849'></a><a href='#L849'>849</a>
<a name='L850'></a><a href='#L850'>850</a>
<a name='L851'></a><a href='#L851'>851</a>
<a name='L852'></a><a href='#L852'>852</a>
<a name='L853'></a><a href='#L853'>853</a>
<a name='L854'></a><a href='#L854'>854</a>
<a name='L855'></a><a href='#L855'>855</a>
<a name='L856'></a><a href='#L856'>856</a>
<a name='L857'></a><a href='#L857'>857</a>
<a name='L858'></a><a href='#L858'>858</a>
<a name='L859'></a><a href='#L859'>859</a>
<a name='L860'></a><a href='#L860'>860</a>
<a name='L861'></a><a href='#L861'>861</a>
<a name='L862'></a><a href='#L862'>862</a>
<a name='L863'></a><a href='#L863'>863</a>
<a name='L864'></a><a href='#L864'>864</a>
<a name='L865'></a><a href='#L865'>865</a>
<a name='L866'></a><a href='#L866'>866</a>
<a name='L867'></a><a href='#L867'>867</a>
<a name='L868'></a><a href='#L868'>868</a>
<a name='L869'></a><a href='#L869'>869</a>
<a name='L870'></a><a href='#L870'>870</a>
<a name='L871'></a><a href='#L871'>871</a>
<a name='L872'></a><a href='#L872'>872</a>
<a name='L873'></a><a href='#L873'>873</a>
<a name='L874'></a><a href='#L874'>874</a>
<a name='L875'></a><a href='#L875'>875</a>
<a name='L876'></a><a href='#L876'>876</a>
<a name='L877'></a><a href='#L877'>877</a>
<a name='L878'></a><a href='#L878'>878</a>
<a name='L879'></a><a href='#L879'>879</a>
<a name='L880'></a><a href='#L880'>880</a>
<a name='L881'></a><a href='#L881'>881</a>
<a name='L882'></a><a href='#L882'>882</a>
<a name='L883'></a><a href='#L883'>883</a>
<a name='L884'></a><a href='#L884'>884</a>
<a name='L885'></a><a href='#L885'>885</a>
<a name='L886'></a><a href='#L886'>886</a>
<a name='L887'></a><a href='#L887'>887</a>
<a name='L888'></a><a href='#L888'>888</a>
<a name='L889'></a><a href='#L889'>889</a>
<a name='L890'></a><a href='#L890'>890</a>
<a name='L891'></a><a href='#L891'>891</a>
<a name='L892'></a><a href='#L892'>892</a>
<a name='L893'></a><a href='#L893'>893</a>
<a name='L894'></a><a href='#L894'>894</a>
<a name='L895'></a><a href='#L895'>895</a>
<a name='L896'></a><a href='#L896'>896</a>
<a name='L897'></a><a href='#L897'>897</a>
<a name='L898'></a><a href='#L898'>898</a>
<a name='L899'></a><a href='#L899'>899</a>
<a name='L900'></a><a href='#L900'>900</a>
<a name='L901'></a><a href='#L901'>901</a>
<a name='L902'></a><a href='#L902'>902</a>
<a name='L903'></a><a href='#L903'>903</a>
<a name='L904'></a><a href='#L904'>904</a>
<a name='L905'></a><a href='#L905'>905</a>
<a name='L906'></a><a href='#L906'>906</a>
<a name='L907'></a><a href='#L907'>907</a>
<a name='L908'></a><a href='#L908'>908</a>
<a name='L909'></a><a href='#L909'>909</a>
<a name='L910'></a><a href='#L910'>910</a>
<a name='L911'></a><a href='#L911'>911</a>
<a name='L912'></a><a href='#L912'>912</a>
<a name='L913'></a><a href='#L913'>913</a>
<a name='L914'></a><a href='#L914'>914</a>
<a name='L915'></a><a href='#L915'>915</a>
<a name='L916'></a><a href='#L916'>916</a>
<a name='L917'></a><a href='#L917'>917</a>
<a name='L918'></a><a href='#L918'>918</a>
<a name='L919'></a><a href='#L919'>919</a>
<a name='L920'></a><a href='#L920'>920</a>
<a name='L921'></a><a href='#L921'>921</a>
<a name='L922'></a><a href='#L922'>922</a>
<a name='L923'></a><a href='#L923'>923</a>
<a name='L924'></a><a href='#L924'>924</a>
<a name='L925'></a><a href='#L925'>925</a>
<a name='L926'></a><a href='#L926'>926</a>
<a name='L927'></a><a href='#L927'>927</a>
<a name='L928'></a><a href='#L928'>928</a>
<a name='L929'></a><a href='#L929'>929</a>
<a name='L930'></a><a href='#L930'>930</a>
<a name='L931'></a><a href='#L931'>931</a>
<a name='L932'></a><a href='#L932'>932</a>
<a name='L933'></a><a href='#L933'>933</a>
<a name='L934'></a><a href='#L934'>934</a>
<a name='L935'></a><a href='#L935'>935</a>
<a name='L936'></a><a href='#L936'>936</a>
<a name='L937'></a><a href='#L937'>937</a>
<a name='L938'></a><a href='#L938'>938</a>
<a name='L939'></a><a href='#L939'>939</a>
<a name='L940'></a><a href='#L940'>940</a>
<a name='L941'></a><a href='#L941'>941</a>
<a name='L942'></a><a href='#L942'>942</a>
<a name='L943'></a><a href='#L943'>943</a>
<a name='L944'></a><a href='#L944'>944</a>
<a name='L945'></a><a href='#L945'>945</a>
<a name='L946'></a><a href='#L946'>946</a>
<a name='L947'></a><a href='#L947'>947</a>
<a name='L948'></a><a href='#L948'>948</a>
<a name='L949'></a><a href='#L949'>949</a>
<a name='L950'></a><a href='#L950'>950</a>
<a name='L951'></a><a href='#L951'>951</a>
<a name='L952'></a><a href='#L952'>952</a>
<a name='L953'></a><a href='#L953'>953</a>
<a name='L954'></a><a href='#L954'>954</a>
<a name='L955'></a><a href='#L955'>955</a>
<a name='L956'></a><a href='#L956'>956</a>
<a name='L957'></a><a href='#L957'>957</a>
<a name='L958'></a><a href='#L958'>958</a>
<a name='L959'></a><a href='#L959'>959</a>
<a name='L960'></a><a href='#L960'>960</a>
<a name='L961'></a><a href='#L961'>961</a>
<a name='L962'></a><a href='#L962'>962</a>
<a name='L963'></a><a href='#L963'>963</a>
<a name='L964'></a><a href='#L964'>964</a>
<a name='L965'></a><a href='#L965'>965</a>
<a name='L966'></a><a href='#L966'>966</a>
<a name='L967'></a><a href='#L967'>967</a>
<a name='L968'></a><a href='#L968'>968</a>
<a name='L969'></a><a href='#L969'>969</a>
<a name='L970'></a><a href='#L970'>970</a>
<a name='L971'></a><a href='#L971'>971</a>
<a name='L972'></a><a href='#L972'>972</a>
<a name='L973'></a><a href='#L973'>973</a>
<a name='L974'></a><a href='#L974'>974</a>
<a name='L975'></a><a href='#L975'>975</a>
<a name='L976'></a><a href='#L976'>976</a>
<a name='L977'></a><a href='#L977'>977</a>
<a name='L978'></a><a href='#L978'>978</a>
<a name='L979'></a><a href='#L979'>979</a>
<a name='L980'></a><a href='#L980'>980</a>
<a name='L981'></a><a href='#L981'>981</a>
<a name='L982'></a><a href='#L982'>982</a>
<a name='L983'></a><a href='#L983'>983</a>
<a name='L984'></a><a href='#L984'>984</a>
<a name='L985'></a><a href='#L985'>985</a>
<a name='L986'></a><a href='#L986'>986</a>
<a name='L987'></a><a href='#L987'>987</a>
<a name='L988'></a><a href='#L988'>988</a>
<a name='L989'></a><a href='#L989'>989</a>
<a name='L990'></a><a href='#L990'>990</a>
<a name='L991'></a><a href='#L991'>991</a>
<a name='L992'></a><a href='#L992'>992</a>
<a name='L993'></a><a href='#L993'>993</a>
<a name='L994'></a><a href='#L994'>994</a>
<a name='L995'></a><a href='#L995'>995</a>
<a name='L996'></a><a href='#L996'>996</a>
<a name='L997'></a><a href='#L997'>997</a>
<a name='L998'></a><a href='#L998'>998</a>
<a name='L999'></a><a href='#L999'>999</a>
<a name='L1000'></a><a href='#L1000'>1000</a>
<a name='L1001'></a><a href='#L1001'>1001</a>
<a name='L1002'></a><a href='#L1002'>1002</a>
<a name='L1003'></a><a href='#L1003'>1003</a>
<a name='L1004'></a><a href='#L1004'>1004</a>
<a name='L1005'></a><a href='#L1005'>1005</a>
<a name='L1006'></a><a href='#L1006'>1006</a>
<a name='L1007'></a><a href='#L1007'>1007</a>
<a name='L1008'></a><a href='#L1008'>1008</a>
<a name='L1009'></a><a href='#L1009'>1009</a>
<a name='L1010'></a><a href='#L1010'>1010</a>
<a name='L1011'></a><a href='#L1011'>1011</a>
<a name='L1012'></a><a href='#L1012'>1012</a>
<a name='L1013'></a><a href='#L1013'>1013</a>
<a name='L1014'></a><a href='#L1014'>1014</a>
<a name='L1015'></a><a href='#L1015'>1015</a>
<a name='L1016'></a><a href='#L1016'>1016</a>
<a name='L1017'></a><a href='#L1017'>1017</a>
<a name='L1018'></a><a href='#L1018'>1018</a>
<a name='L1019'></a><a href='#L1019'>1019</a>
<a name='L1020'></a><a href='#L1020'>1020</a>
<a name='L1021'></a><a href='#L1021'>1021</a>
<a name='L1022'></a><a href='#L1022'>1022</a>
<a name='L1023'></a><a href='#L1023'>1023</a>
<a name='L1024'></a><a href='#L1024'>1024</a>
<a name='L1025'></a><a href='#L1025'>1025</a>
<a name='L1026'></a><a href='#L1026'>1026</a>
<a name='L1027'></a><a href='#L1027'>1027</a>
<a name='L1028'></a><a href='#L1028'>1028</a>
<a name='L1029'></a><a href='#L1029'>1029</a>
<a name='L1030'></a><a href='#L1030'>1030</a>
<a name='L1031'></a><a href='#L1031'>1031</a>
<a name='L1032'></a><a href='#L1032'>1032</a>
<a name='L1033'></a><a href='#L1033'>1033</a>
<a name='L1034'></a><a href='#L1034'>1034</a>
<a name='L1035'></a><a href='#L1035'>1035</a>
<a name='L1036'></a><a href='#L1036'>1036</a>
<a name='L1037'></a><a href='#L1037'>1037</a>
<a name='L1038'></a><a href='#L1038'>1038</a>
<a name='L1039'></a><a href='#L1039'>1039</a>
<a name='L1040'></a><a href='#L1040'>1040</a>
<a name='L1041'></a><a href='#L1041'>1041</a>
<a name='L1042'></a><a href='#L1042'>1042</a>
<a name='L1043'></a><a href='#L1043'>1043</a>
<a name='L1044'></a><a href='#L1044'>1044</a>
<a name='L1045'></a><a href='#L1045'>1045</a>
<a name='L1046'></a><a href='#L1046'>1046</a>
<a name='L1047'></a><a href='#L1047'>1047</a>
<a name='L1048'></a><a href='#L1048'>1048</a>
<a name='L1049'></a><a href='#L1049'>1049</a>
<a name='L1050'></a><a href='#L1050'>1050</a>
<a name='L1051'></a><a href='#L1051'>1051</a>
<a name='L1052'></a><a href='#L1052'>1052</a>
<a name='L1053'></a><a href='#L1053'>1053</a>
<a name='L1054'></a><a href='#L1054'>1054</a>
<a name='L1055'></a><a href='#L1055'>1055</a>
<a name='L1056'></a><a href='#L1056'>1056</a>
<a name='L1057'></a><a href='#L1057'>1057</a>
<a name='L1058'></a><a href='#L1058'>1058</a>
<a name='L1059'></a><a href='#L1059'>1059</a>
<a name='L1060'></a><a href='#L1060'>1060</a>
<a name='L1061'></a><a href='#L1061'>1061</a>
<a name='L1062'></a><a href='#L1062'>1062</a>
<a name='L1063'></a><a href='#L1063'>1063</a>
<a name='L1064'></a><a href='#L1064'>1064</a>
<a name='L1065'></a><a href='#L1065'>1065</a>
<a name='L1066'></a><a href='#L1066'>1066</a>
<a name='L1067'></a><a href='#L1067'>1067</a>
<a name='L1068'></a><a href='#L1068'>1068</a>
<a name='L1069'></a><a href='#L1069'>1069</a>
<a name='L1070'></a><a href='#L1070'>1070</a>
<a name='L1071'></a><a href='#L1071'>1071</a>
<a name='L1072'></a><a href='#L1072'>1072</a>
<a name='L1073'></a><a href='#L1073'>1073</a>
<a name='L1074'></a><a href='#L1074'>1074</a>
<a name='L1075'></a><a href='#L1075'>1075</a>
<a name='L1076'></a><a href='#L1076'>1076</a>
<a name='L1077'></a><a href='#L1077'>1077</a>
<a name='L1078'></a><a href='#L1078'>1078</a>
<a name='L1079'></a><a href='#L1079'>1079</a>
<a name='L1080'></a><a href='#L1080'>1080</a>
<a name='L1081'></a><a href='#L1081'>1081</a>
<a name='L1082'></a><a href='#L1082'>1082</a>
<a name='L1083'></a><a href='#L1083'>1083</a>
<a name='L1084'></a><a href='#L1084'>1084</a>
<a name='L1085'></a><a href='#L1085'>1085</a>
<a name='L1086'></a><a href='#L1086'>1086</a>
<a name='L1087'></a><a href='#L1087'>1087</a>
<a name='L1088'></a><a href='#L1088'>1088</a>
<a name='L1089'></a><a href='#L1089'>1089</a>
<a name='L1090'></a><a href='#L1090'>1090</a>
<a name='L1091'></a><a href='#L1091'>1091</a>
<a name='L1092'></a><a href='#L1092'>1092</a>
<a name='L1093'></a><a href='#L1093'>1093</a>
<a name='L1094'></a><a href='#L1094'>1094</a>
<a name='L1095'></a><a href='#L1095'>1095</a>
<a name='L1096'></a><a href='#L1096'>1096</a>
<a name='L1097'></a><a href='#L1097'>1097</a>
<a name='L1098'></a><a href='#L1098'>1098</a>
<a name='L1099'></a><a href='#L1099'>1099</a>
<a name='L1100'></a><a href='#L1100'>1100</a>
<a name='L1101'></a><a href='#L1101'>1101</a>
<a name='L1102'></a><a href='#L1102'>1102</a>
<a name='L1103'></a><a href='#L1103'>1103</a>
<a name='L1104'></a><a href='#L1104'>1104</a>
<a name='L1105'></a><a href='#L1105'>1105</a>
<a name='L1106'></a><a href='#L1106'>1106</a>
<a name='L1107'></a><a href='#L1107'>1107</a>
<a name='L1108'></a><a href='#L1108'>1108</a>
<a name='L1109'></a><a href='#L1109'>1109</a>
<a name='L1110'></a><a href='#L1110'>1110</a>
<a name='L1111'></a><a href='#L1111'>1111</a>
<a name='L1112'></a><a href='#L1112'>1112</a>
<a name='L1113'></a><a href='#L1113'>1113</a>
<a name='L1114'></a><a href='#L1114'>1114</a>
<a name='L1115'></a><a href='#L1115'>1115</a>
<a name='L1116'></a><a href='#L1116'>1116</a>
<a name='L1117'></a><a href='#L1117'>1117</a>
<a name='L1118'></a><a href='#L1118'>1118</a>
<a name='L1119'></a><a href='#L1119'>1119</a>
<a name='L1120'></a><a href='#L1120'>1120</a>
<a name='L1121'></a><a href='#L1121'>1121</a>
<a name='L1122'></a><a href='#L1122'>1122</a>
<a name='L1123'></a><a href='#L1123'>1123</a>
<a name='L1124'></a><a href='#L1124'>1124</a>
<a name='L1125'></a><a href='#L1125'>1125</a>
<a name='L1126'></a><a href='#L1126'>1126</a>
<a name='L1127'></a><a href='#L1127'>1127</a>
<a name='L1128'></a><a href='#L1128'>1128</a>
<a name='L1129'></a><a href='#L1129'>1129</a>
<a name='L1130'></a><a href='#L1130'>1130</a>
<a name='L1131'></a><a href='#L1131'>1131</a>
<a name='L1132'></a><a href='#L1132'>1132</a>
<a name='L1133'></a><a href='#L1133'>1133</a>
<a name='L1134'></a><a href='#L1134'>1134</a>
<a name='L1135'></a><a href='#L1135'>1135</a>
<a name='L1136'></a><a href='#L1136'>1136</a>
<a name='L1137'></a><a href='#L1137'>1137</a>
<a name='L1138'></a><a href='#L1138'>1138</a>
<a name='L1139'></a><a href='#L1139'>1139</a>
<a name='L1140'></a><a href='#L1140'>1140</a>
<a name='L1141'></a><a href='#L1141'>1141</a>
<a name='L1142'></a><a href='#L1142'>1142</a>
<a name='L1143'></a><a href='#L1143'>1143</a>
<a name='L1144'></a><a href='#L1144'>1144</a>
<a name='L1145'></a><a href='#L1145'>1145</a>
<a name='L1146'></a><a href='#L1146'>1146</a>
<a name='L1147'></a><a href='#L1147'>1147</a>
<a name='L1148'></a><a href='#L1148'>1148</a>
<a name='L1149'></a><a href='#L1149'>1149</a>
<a name='L1150'></a><a href='#L1150'>1150</a>
<a name='L1151'></a><a href='#L1151'>1151</a>
<a name='L1152'></a><a href='#L1152'>1152</a>
<a name='L1153'></a><a href='#L1153'>1153</a>
<a name='L1154'></a><a href='#L1154'>1154</a>
<a name='L1155'></a><a href='#L1155'>1155</a>
<a name='L1156'></a><a href='#L1156'>1156</a>
<a name='L1157'></a><a href='#L1157'>1157</a>
<a name='L1158'></a><a href='#L1158'>1158</a>
<a name='L1159'></a><a href='#L1159'>1159</a>
<a name='L1160'></a><a href='#L1160'>1160</a>
<a name='L1161'></a><a href='#L1161'>1161</a>
<a name='L1162'></a><a href='#L1162'>1162</a>
<a name='L1163'></a><a href='#L1163'>1163</a>
<a name='L1164'></a><a href='#L1164'>1164</a>
<a name='L1165'></a><a href='#L1165'>1165</a>
<a name='L1166'></a><a href='#L1166'>1166</a>
<a name='L1167'></a><a href='#L1167'>1167</a>
<a name='L1168'></a><a href='#L1168'>1168</a>
<a name='L1169'></a><a href='#L1169'>1169</a>
<a name='L1170'></a><a href='#L1170'>1170</a>
<a name='L1171'></a><a href='#L1171'>1171</a>
<a name='L1172'></a><a href='#L1172'>1172</a>
<a name='L1173'></a><a href='#L1173'>1173</a>
<a name='L1174'></a><a href='#L1174'>1174</a>
<a name='L1175'></a><a href='#L1175'>1175</a>
<a name='L1176'></a><a href='#L1176'>1176</a>
<a name='L1177'></a><a href='#L1177'>1177</a>
<a name='L1178'></a><a href='#L1178'>1178</a>
<a name='L1179'></a><a href='#L1179'>1179</a>
<a name='L1180'></a><a href='#L1180'>1180</a>
<a name='L1181'></a><a href='#L1181'>1181</a>
<a name='L1182'></a><a href='#L1182'>1182</a>
<a name='L1183'></a><a href='#L1183'>1183</a>
<a name='L1184'></a><a href='#L1184'>1184</a>
<a name='L1185'></a><a href='#L1185'>1185</a>
<a name='L1186'></a><a href='#L1186'>1186</a>
<a name='L1187'></a><a href='#L1187'>1187</a>
<a name='L1188'></a><a href='#L1188'>1188</a>
<a name='L1189'></a><a href='#L1189'>1189</a>
<a name='L1190'></a><a href='#L1190'>1190</a>
<a name='L1191'></a><a href='#L1191'>1191</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >Profiler.ProfileType=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,name){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._id=id;<span class="cstat-no" title="statement not covered" >t</span>his._name=name;<span class="cstat-no" title="statement not covered" >t</span>his._profiles=[];<span class="cstat-no" title="statement not covered" >t</span>his._profileBeingRecorded=null;<span class="cstat-no" title="statement not covered" >t</span>his._nextProfileUid=1;<span class="cstat-no" title="statement not covered" >i</span>f(!window.opener)</span></span>
<span class="cstat-no" title="statement not covered" >window.addEventListener('unload',this._clearTempStorage.bind(this),false);}</span>
<span class="fstat-no" title="function not covered" >ty</span>peName(){<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >ne</span>xtProfileUid(){<span class="cstat-no" title="statement not covered" >return this._nextProfileUid;}</span>
<span class="fstat-no" title="function not covered" >in</span>crementProfileUid(){<span class="cstat-no" title="statement not covered" >return this._nextProfileUid++;}</span>
<span class="fstat-no" title="function not covered" >ha</span>sTemporaryView(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >fi</span>leExtension(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t buttonTooltip(){<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >ge</span>t id(){<span class="cstat-no" title="statement not covered" >return this._id;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t name(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >bu</span>ttonClicked(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >is</span>InstantProfile(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >is</span>Enabled(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tProfiles(){function <span class="fstat-no" title="function not covered" >isFinished(</span>profile){<span class="cstat-no" title="statement not covered" >return this._profileBeingRecorded!==profile;}</span>
<span class="cstat-no" title="statement not covered" >return this._profiles.filter(isFinished.bind(this));}</span>
<span class="fstat-no" title="function not covered" >cu</span>stomContent(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tProfile(uid){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._profiles.length;++i){<span class="cstat-no" title="statement not covered" >if(this._profiles[i].uid===uid)</span></span>
<span class="cstat-no" title="statement not covered" >return this._profiles[i];}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >lo</span>adFromFile(file){let name=<span class="cstat-no" title="statement not covered" >file.name;</span>const fileExtension=<span class="cstat-no" title="statement not covered" >this.fileExtension();<span class="cstat-no" title="statement not covered" ></span>if(fileExtension&amp;&amp;name.endsWith(fileExtension))</span>
<span class="cstat-no" title="statement not covered" >name=name.substr(0,name.length-fileExtension.length);c</span>onst profile=<span class="cstat-no" title="statement not covered" >this.createProfileLoadedFromFile(name);<span class="cstat-no" title="statement not covered" ></span>profile.setFromFile();<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(profile);<span class="cstat-no" title="statement not covered" >t</span>his.addProfile(profile);<span class="cstat-no" title="statement not covered" >r</span>eturn profile.loadFromFile(file);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProfileLoadedFromFile(title){<span class="cstat-no" title="statement not covered" >throw new Error('Needs implemented.');}</span>
<span class="fstat-no" title="function not covered" >ad</span>dProfile(profile){<span class="cstat-no" title="statement not covered" >this._profiles.push(profile);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.ProfileType.Events.AddProfileHeader,profile);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveProfile(profile){const index=<span class="cstat-no" title="statement not covered" >this._profiles.indexOf(profile);<span class="cstat-no" title="statement not covered" ></span>if(index===-1)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._profiles.splice(index,1);<span class="cstat-no" title="statement not covered" >t</span>his._disposeProfile(profile);}</span>
<span class="fstat-no" title="function not covered" >_c</span>learTempStorage(){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._profiles.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._profiles[i].removeTempFile();}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecorded(){<span class="cstat-no" title="statement not covered" >return this._profileBeingRecorded;}</span>
<span class="fstat-no" title="function not covered" >se</span>tProfileBeingRecorded(profile){<span class="cstat-no" title="statement not covered" >this._profileBeingRecorded=profile;}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecordedRemoved(){}
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >for(const profile of this._profiles.slice())</span>
<span class="cstat-no" title="statement not covered" >this._disposeProfile(profile);<span class="cstat-no" title="statement not covered" >t</span>his._profiles=[];<span class="cstat-no" title="statement not covered" >t</span>his._nextProfileUid=1;}</span>
<span class="fstat-no" title="function not covered" >_d</span>isposeProfile(profile){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.ProfileType.Events.RemoveProfileHeader,profile);<span class="cstat-no" title="statement not covered" >p</span>rofile.dispose();<span class="cstat-no" title="statement not covered" >i</span>f(this._profileBeingRecorded===profile){<span class="cstat-no" title="statement not covered" >this.profileBeingRecordedRemoved();<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(null);}</span>}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileType.Events={AddProfileHeader:Symbol('add-profile-header'),ProfileComplete:Symbol('profile-complete'),RemoveProfileHeader:Symbol('remove-profile-header'),ViewUpdated:Symbol('view-updated')};<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileType.DataDisplayDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileType.DataDisplayDelegate.prototype={showProfile(profile){},showObject(snapshotObjectId,perspectiveName){},async linkifyObject(nodeIndex){}};;<span class="cstat-no" title="statement not covered" ></span>Profiler.ProfileHeader=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileType,title){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._profileType=profileType;<span class="cstat-no" title="statement not covered" >t</span>his.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.uid=profileType.incrementProfileUid();<span class="cstat-no" title="statement not covered" >t</span>his._fromFile=false;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tTitle(title){<span class="cstat-no" title="statement not covered" >this.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.ProfileHeader.Events.ProfileTitleChanged,this);}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileType(){<span class="cstat-no" title="statement not covered" >return this._profileType;}</span>
<span class="fstat-no" title="function not covered" >up</span>dateStatus(subtitle,wait){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.ProfileHeader.Events.UpdateStatus,new Profiler.ProfileHeader.StatusUpdate(subtitle,wait));}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSidebarTreeElement(dataDisplayDelegate){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented.');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateView(dataDisplayDelegate){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented.');}</span>
<span class="fstat-no" title="function not covered" >re</span>moveTempFile(){<span class="cstat-no" title="statement not covered" >if(this._tempFile)</span>
<span class="cstat-no" title="statement not covered" >this._tempFile.remove();}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){}
<span class="fstat-no" title="function not covered" >ca</span>nSaveToFile(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >sa</span>veToFile(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >lo</span>adFromFile(file){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >fr</span>omFile(){<span class="cstat-no" title="statement not covered" >return this._fromFile;}</span>
<span class="fstat-no" title="function not covered" >se</span>tFromFile(){<span class="cstat-no" title="statement not covered" >this._fromFile=true;}</span>
<span class="fstat-no" title="function not covered" >se</span>tProfile(profile){}};<span class="cstat-no" title="statement not covered" >Profiler.ProfileHeader.StatusUpdate=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(subtitle,wait){<span class="cstat-no" title="statement not covered" >this.subtitle=subtitle;<span class="cstat-no" title="statement not covered" >t</span>his.wait=wait;}</span>};<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileHeader.Events={UpdateStatus:Symbol('UpdateStatus'),ProfileReceived:Symbol('ProfileReceived'),ProfileTitleChanged:Symbol('ProfileTitleChanged')};;<span class="cstat-no" title="statement not covered" ></span>Profiler.ProfilesPanel=class extends UI.PanelWithSidebar{<span class="fstat-no" title="function not covered" >co</span>nstructor(name,profileTypes,recordingActionId){<span class="cstat-no" title="statement not covered" >super(name);<span class="cstat-no" title="statement not covered" >t</span>his._profileTypes=profileTypes;<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('profiler/heapProfiler.css');<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('profiler/profilesPanel.css');<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('object_ui/objectValue.css');c</span>onst mainContainer=<span class="cstat-no" title="statement not covered" >new UI.VBox();<span class="cstat-no" title="statement not covered" ></span>this.splitWidget().setMainWidget(mainContainer);<span class="cstat-no" title="statement not covered" >t</span>his.profilesItemTreeElement=new Profiler.ProfilesSidebarTreeElement(this);<span class="cstat-no" title="statement not covered" >t</span>his._sidebarTree=new UI.TreeOutlineInShadow();<span class="cstat-no" title="statement not covered" >t</span>his._sidebarTree.registerRequiredCSS('profiler/profilesSidebarTree.css');<span class="cstat-no" title="statement not covered" >t</span>his._sidebarTree.element.classList.add('profiles-sidebar-tree-box');<span class="cstat-no" title="statement not covered" >t</span>his.panelSidebarElement().appendChild(this._sidebarTree.element);<span class="cstat-no" title="statement not covered" >t</span>his._sidebarTree.appendChild(this.profilesItemTreeElement);<span class="cstat-no" title="statement not covered" >t</span>his.profileViews=createElement('div');<span class="cstat-no" title="statement not covered" >t</span>his.profileViews.id='profile-views';<span class="cstat-no" title="statement not covered" >t</span>his.profileViews.classList.add('vbox');<span class="cstat-no" title="statement not covered" >m</span>ainContainer.element.appendChild(this.profileViews);<span class="cstat-no" title="statement not covered" >t</span>his._toolbarElement=createElementWithClass('div','profiles-toolbar');<span class="cstat-no" title="statement not covered" >m</span>ainContainer.element.insertBefore(this._toolbarElement,mainContainer.element.firstChild);<span class="cstat-no" title="statement not covered" >t</span>his.panelSidebarElement().classList.add('profiles-tree-sidebar');c</span>onst toolbarContainerLeft=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','profiles-toolbar');<span class="cstat-no" title="statement not covered" ></span>this.panelSidebarElement().insertBefore(toolbarContainerLeft,this.panelSidebarElement().firstChild);c</span>onst toolbar=<span class="cstat-no" title="statement not covered" >new UI.Toolbar('',toolbarContainerLeft);<span class="cstat-no" title="statement not covered" ></span>this._toggleRecordAction=(UI.actionRegistry.action(recordingActionId));<span class="cstat-no" title="statement not covered" >t</span>his._toggleRecordButton=UI.Toolbar.createActionButton(this._toggleRecordAction);<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(this._toggleRecordButton);<span class="cstat-no" title="statement not covered" >t</span>his.clearResultsButton=new UI.ToolbarButton(Common.UIString('Clear all profiles'),'largeicon-clear');<span class="cstat-no" title="statement not covered" >t</span>his.clearResultsButton.addEventListener(UI.ToolbarButton.Events.Click,this._reset,this);<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(this.clearResultsButton);<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendSeparator();<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(UI.Toolbar.createActionButtonForId('components.collect-garbage'));<span class="cstat-no" title="statement not covered" >t</span>his._profileViewToolbar=new UI.Toolbar('',this._toolbarElement);<span class="cstat-no" title="statement not covered" >t</span>his._profileGroups={};<span class="cstat-no" title="statement not covered" >t</span>his._launcherView=new Profiler.ProfileLauncherView(this);<span class="cstat-no" title="statement not covered" >t</span>his._launcherView.addEventListener(Profiler.ProfileLauncherView.Events.ProfileTypeSelected,this._onProfileTypeSelected,this);<span class="cstat-no" title="statement not covered" >t</span>his._profileToView=[];<span class="cstat-no" title="statement not covered" >t</span>his._typeIdToSidebarSection={};c</span>onst types=<span class="cstat-no" title="statement not covered" >this._profileTypes;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;types.length;i++)</span></span>
<span class="cstat-no" title="statement not covered" >this._registerProfileType(types[i]);<span class="cstat-no" title="statement not covered" >t</span>his._launcherView.restoreSelectedProfileType();<span class="cstat-no" title="statement not covered" >t</span>his.profilesItemTreeElement.select();<span class="cstat-no" title="statement not covered" >t</span>his._showLauncherView();<span class="cstat-no" title="statement not covered" >t</span>his._createFileSelectorElement();<span class="cstat-no" title="statement not covered" >t</span>his.element.addEventListener('contextmenu',this._handleContextMenuEvent.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.addEventListener('keydown',this._onKeyDown.bind(this),false);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addEventListener(SDK.TargetManager.Events.SuspendStateChanged,this._onSuspendStateChanged,this);<span class="cstat-no" title="statement not covered" >U</span>I.context.addFlavorChangeListener(SDK.CPUProfilerModel,this._updateProfileTypeSpecificUI,this);<span class="cstat-no" title="statement not covered" >U</span>I.context.addFlavorChangeListener(SDK.HeapProfilerModel,this._updateProfileTypeSpecificUI,this);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyDown(event){let handled=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(event.key==='ArrowDown'&amp;&amp;!event.altKey)</span>
<span class="cstat-no" title="statement not covered" >handled=this._sidebarTree.selectNext();e</span>lse <span class="cstat-no" title="statement not covered" >if(event.key==='ArrowUp'&amp;&amp;!event.altKey)</span>
<span class="cstat-no" title="statement not covered" >handled=this._sidebarTree.selectPrevious();<span class="cstat-no" title="statement not covered" >i</span>f(handled)</span>
<span class="cstat-no" title="statement not covered" >event.consume(true);}</span>
<span class="fstat-no" title="function not covered" >se</span>archableView(){<span class="cstat-no" title="statement not covered" >return this.visibleView&amp;&amp;this.visibleView.searchableView?this.visibleView.searchableView():null;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateFileSelectorElement(){<span class="cstat-no" title="statement not covered" >if(this._fileSelectorElement)</span>
<span class="cstat-no" title="statement not covered" >this.element.removeChild(this._fileSelectorElement);<span class="cstat-no" title="statement not covered" >t</span>his._fileSelectorElement=UI.createFileSelectorElement(this._loadFromFile.bind(this));<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfilesPanel._fileSelectorElement=this._fileSelectorElement;<span class="cstat-no" title="statement not covered" >t</span>his.element.appendChild(this._fileSelectorElement);}</span>
<span class="fstat-no" title="function not covered" >_f</span>indProfileTypeByExtension(fileName){<span class="cstat-no" title="statement not covered" >return this._profileTypes.find(<span class="fstat-no" title="function not covered" >ty</span>pe=&gt;<span class="cstat-no" title="statement not covered" >!!type.fileExtension()&amp;&amp;fileName.endsWith(type.fileExtension()||''))</span>||null;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _loadFromFile(file){<span class="cstat-no" title="statement not covered" >this._createFileSelectorElement();c</span>onst profileType=<span class="cstat-no" title="statement not covered" >this._findProfileTypeByExtension(file.name);<span class="cstat-no" title="statement not covered" ></span>if(!profileType){const extensions=<span class="cstat-no" title="statement not covered" >new Set(this._profileTypes.map(<span class="fstat-no" title="function not covered" >ty</span>pe=&gt;<span class="cstat-no" title="statement not covered" >type.fileExtension())</span>.filter(<span class="fstat-no" title="function not covered" >ex</span>t=&gt;<span class="cstat-no" title="statement not covered" >ext)</span>);<span class="cstat-no" title="statement not covered" ></span>Common.console.error(Common.UIString(`Can't load file. Supported file extensions: '%s'.`,Array.from(extensions).join(`', '`)));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!!profileType.profileBeingRecorded()){<span class="cstat-no" title="statement not covered" >Common.console.error(Common.UIString(`Can't load profile while another profile is being recorded.`));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const error=<span class="cstat-no" title="statement not covered" >await profileType.loadFromFile(file);<span class="cstat-no" title="statement not covered" ></span>if(error)</span>
<span class="cstat-no" title="statement not covered" >UI.MessageDialog.show(Common.UIString('Profile loading failed: %s.',error.message));}</span>
<span class="fstat-no" title="function not covered" >to</span>ggleRecord(){<span class="cstat-no" title="statement not covered" >if(!this._toggleRecordAction.enabled())</span>
<span class="cstat-no" title="statement not covered" >return true;c</span>onst type=<span class="cstat-no" title="statement not covered" >this._selectedProfileType;</span>const isProfiling=<span class="cstat-no" title="statement not covered" >type.buttonClicked();<span class="cstat-no" title="statement not covered" ></span>this._updateToggleRecordAction(isProfiling);<span class="cstat-no" title="statement not covered" >i</span>f(isProfiling){<span class="cstat-no" title="statement not covered" >this._launcherView.profileStarted();<span class="cstat-no" title="statement not covered" >i</span>f(type.hasTemporaryView())</span></span>
<span class="cstat-no" title="statement not covered" >this.showProfile(type.profileBeingRecorded());}</span>else{<span class="cstat-no" title="statement not covered" >this._launcherView.profileFinished();}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nSuspendStateChanged(){<span class="cstat-no" title="statement not covered" >this._updateToggleRecordAction(this._toggleRecordAction.toggled());}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateToggleRecordAction(toggled){const hasSelectedTarget=<span class="cstat-no" title="statement not covered" >!!(UI.context.flavor(SDK.CPUProfilerModel)||UI.context.flavor(SDK.HeapProfilerModel));</span>const enable=<span class="cstat-no" title="statement not covered" >toggled||(!SDK.targetManager.allTargetsSuspended()&amp;&amp;hasSelectedTarget);<span class="cstat-no" title="statement not covered" ></span>this._toggleRecordAction.setEnabled(enable);<span class="cstat-no" title="statement not covered" >t</span>his._toggleRecordAction.setToggled(toggled);<span class="cstat-no" title="statement not covered" >i</span>f(enable)</span>
<span class="cstat-no" title="statement not covered" >this._toggleRecordButton.setTitle(this._selectedProfileType?this._selectedProfileType.buttonTooltip:'');e</span>lse
<span class="cstat-no" title="statement not covered" >this._toggleRecordButton.setTitle(UI.anotherProfilerActiveLabel());<span class="cstat-no" title="statement not covered" >i</span>f(this._selectedProfileType)</span>
<span class="cstat-no" title="statement not covered" >this._launcherView.updateProfileType(this._selectedProfileType,enable);}</span>
<span class="fstat-no" title="function not covered" >_p</span>rofileBeingRecordedRemoved(){<span class="cstat-no" title="statement not covered" >this._updateToggleRecordAction(false);<span class="cstat-no" title="statement not covered" >t</span>his._launcherView.profileFinished();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nProfileTypeSelected(event){<span class="cstat-no" title="statement not covered" >this._selectedProfileType=(event.data);<span class="cstat-no" title="statement not covered" >t</span>his._updateProfileTypeSpecificUI();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateProfileTypeSpecificUI(){<span class="cstat-no" title="statement not covered" >this._updateToggleRecordAction(this._toggleRecordAction.toggled());}</span>
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >this._profileTypes.forEach(<span class="fstat-no" title="function not covered" >ty</span>pe=&gt;<span class="cstat-no" title="statement not covered" >type.reset())</span>;<span class="cstat-no" title="statement not covered" >d</span>elete this.visibleView;<span class="cstat-no" title="statement not covered" >t</span>his._profileGroups={};<span class="cstat-no" title="statement not covered" >t</span>his._updateToggleRecordAction(false);<span class="cstat-no" title="statement not covered" >t</span>his._launcherView.profileFinished();<span class="cstat-no" title="statement not covered" >t</span>his._sidebarTree.element.classList.remove('some-expandable');<span class="cstat-no" title="statement not covered" >t</span>his._launcherView.detach();<span class="cstat-no" title="statement not covered" >t</span>his.profileViews.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._profileViewToolbar.removeToolbarItems();<span class="cstat-no" title="statement not covered" >t</span>his.clearResultsButton.element.classList.remove('hidden');<span class="cstat-no" title="statement not covered" >t</span>his.profilesItemTreeElement.select();<span class="cstat-no" title="statement not covered" >t</span>his._showLauncherView();}</span>
<span class="fstat-no" title="function not covered" >_s</span>howLauncherView(){<span class="cstat-no" title="statement not covered" >this.closeVisibleView();<span class="cstat-no" title="statement not covered" >t</span>his._profileViewToolbar.removeToolbarItems();<span class="cstat-no" title="statement not covered" >t</span>his._launcherView.show(this.profileViews);<span class="cstat-no" title="statement not covered" >t</span>his.visibleView=this._launcherView;<span class="cstat-no" title="statement not covered" >t</span>his._toolbarElement.classList.add('hidden');}</span>
<span class="fstat-no" title="function not covered" >_r</span>egisterProfileType(profileType){<span class="cstat-no" title="statement not covered" >this._launcherView.addProfileType(profileType);c</span>onst profileTypeSection=<span class="cstat-no" title="statement not covered" >new Profiler.ProfileTypeSidebarSection(this,profileType);<span class="cstat-no" title="statement not covered" ></span>this._typeIdToSidebarSection[profileType.id]=profileTypeSection;<span class="cstat-no" title="statement not covered" >t</span>his._sidebarTree.appendChild(profileTypeSection);<span class="cstat-no" title="statement not covered" >p</span>rofileTypeSection.childrenListElement.addEventListener('contextmenu',this._handleContextMenuEvent.bind(this),false);f</span>unction <span class="fstat-no" title="function not covered" >onAddProfileHeader(</span>event){<span class="cstat-no" title="statement not covered" >this._addProfileHeader((event.data));}</span>
function <span class="fstat-no" title="function not covered" >onRemoveProfileHeader(</span>event){<span class="cstat-no" title="statement not covered" >this._removeProfileHeader((event.data));}</span>
function <span class="fstat-no" title="function not covered" >profileComplete(</span>event){<span class="cstat-no" title="statement not covered" >this.showProfile((event.data));}</span>
<span class="cstat-no" title="statement not covered" >profileType.addEventListener(Profiler.ProfileType.Events.ViewUpdated,this._updateProfileTypeSpecificUI,this);<span class="cstat-no" title="statement not covered" >p</span>rofileType.addEventListener(Profiler.ProfileType.Events.AddProfileHeader,onAddProfileHeader,this);<span class="cstat-no" title="statement not covered" >p</span>rofileType.addEventListener(Profiler.ProfileType.Events.RemoveProfileHeader,onRemoveProfileHeader,this);<span class="cstat-no" title="statement not covered" >p</span>rofileType.addEventListener(Profiler.ProfileType.Events.ProfileComplete,profileComplete,this);c</span>onst profiles=<span class="cstat-no" title="statement not covered" >profileType.getProfiles();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;profiles.length;i++)</span>
<span class="cstat-no" title="statement not covered" >this._addProfileHeader(profiles[i]);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleContextMenuEvent(event){const contextMenu=<span class="cstat-no" title="statement not covered" >new UI.ContextMenu(event);<span class="cstat-no" title="statement not covered" ></span>if(this.panelSidebarElement().isSelfOrAncestor(event.srcElement)){<span class="cstat-no" title="statement not covered" >contextMenu.defaultSection().appendItem(Common.UIString('Load\u2026'),this._fileSelectorElement.click.bind(this._fileSelectorElement));}</span></span>
<span class="cstat-no" title="statement not covered" >contextMenu.show();}</span>
<span class="fstat-no" title="function not covered" >sh</span>owLoadFromFileDialog(){<span class="cstat-no" title="statement not covered" >this._fileSelectorElement.click();}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddProfileHeader(profile){const profileType=<span class="cstat-no" title="statement not covered" >profile.profileType();</span>const typeId=<span class="cstat-no" title="statement not covered" >profileType.id;<span class="cstat-no" title="statement not covered" ></span>this._typeIdToSidebarSection[typeId].addProfileHeader(profile);<span class="cstat-no" title="statement not covered" >i</span>f(!this.visibleView||this.visibleView===this._launcherView)</span>
<span class="cstat-no" title="statement not covered" >this.showProfile(profile);}</span>
<span class="fstat-no" title="function not covered" >_r</span>emoveProfileHeader(profile){<span class="cstat-no" title="statement not covered" >if(profile.profileType().profileBeingRecorded()===profile)</span>
<span class="cstat-no" title="statement not covered" >this._profileBeingRecordedRemoved();c</span>onst i=<span class="cstat-no" title="statement not covered" >this._indexOfViewForProfile(profile);<span class="cstat-no" title="statement not covered" ></span>if(i!==-1)</span>
<span class="cstat-no" title="statement not covered" >this._profileToView.splice(i,1);c</span>onst typeId=<span class="cstat-no" title="statement not covered" >profile.profileType().id;</span>const sectionIsEmpty=<span class="cstat-no" title="statement not covered" >this._typeIdToSidebarSection[typeId].removeProfileHeader(profile);<span class="cstat-no" title="statement not covered" ></span>if(sectionIsEmpty){<span class="cstat-no" title="statement not covered" >this.profilesItemTreeElement.select();<span class="cstat-no" title="statement not covered" >t</span>his._showLauncherView();}</span>}</span>
<span class="fstat-no" title="function not covered" >sh</span>owProfile(profile){<span class="cstat-no" title="statement not covered" >if(!profile||(profile.profileType().profileBeingRecorded()===profile)&amp;&amp;!profile.profileType().hasTemporaryView())</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst view=<span class="cstat-no" title="statement not covered" >this.viewForProfile(profile);<span class="cstat-no" title="statement not covered" ></span>if(view===this.visibleView)</span>
<span class="cstat-no" title="statement not covered" >return view;<span class="cstat-no" title="statement not covered" >t</span>his.closeVisibleView();<span class="cstat-no" title="statement not covered" >v</span>iew.show(this.profileViews);<span class="cstat-no" title="statement not covered" >v</span>iew.focus();<span class="cstat-no" title="statement not covered" >t</span>his._toolbarElement.classList.remove('hidden');<span class="cstat-no" title="statement not covered" >t</span>his.visibleView=view;c</span>onst profileTypeSection=<span class="cstat-no" title="statement not covered" >this._typeIdToSidebarSection[profile.profileType().id];</span>const sidebarElement=<span class="cstat-no" title="statement not covered" >profileTypeSection.sidebarElementForProfile(profile);<span class="cstat-no" title="statement not covered" ></span>sidebarElement.revealAndSelect();<span class="cstat-no" title="statement not covered" >t</span>his._profileViewToolbar.removeToolbarItems();c</span>onst toolbarItems=<span class="cstat-no" title="statement not covered" >view.syncToolbarItems();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;toolbarItems.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._profileViewToolbar.appendToolbarItem(toolbarItems[i]);<span class="cstat-no" title="statement not covered" >r</span>eturn view;}</span>
<span class="fstat-no" title="function not covered" >sh</span>owObject(snapshotObjectId,perspectiveName){}
<span class="fstat-no" title="function not covered" >as</span>ync linkifyObject(nodeIndex){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >vi</span>ewForProfile(profile){const index=<span class="cstat-no" title="statement not covered" >this._indexOfViewForProfile(profile);<span class="cstat-no" title="statement not covered" ></span>if(index!==-1)</span>
<span class="cstat-no" title="statement not covered" >return this._profileToView[index].view;c</span>onst view=<span class="cstat-no" title="statement not covered" >profile.createView(this);<span class="cstat-no" title="statement not covered" ></span>view.element.classList.add('profile-view');<span class="cstat-no" title="statement not covered" >t</span>his._profileToView.push({profile:profile,view:view});<span class="cstat-no" title="statement not covered" >r</span>eturn view;}</span>
<span class="fstat-no" title="function not covered" >_i</span>ndexOfViewForProfile(profile){<span class="cstat-no" title="statement not covered" >return this._profileToView.findIndex(<span class="fstat-no" title="function not covered" >it</span>em=&gt;<span class="cstat-no" title="statement not covered" >item.profile===profile)</span>;}</span>
<span class="fstat-no" title="function not covered" >cl</span>oseVisibleView(){<span class="cstat-no" title="statement not covered" >if(this.visibleView)</span>
<span class="cstat-no" title="statement not covered" >this.visibleView.detach();<span class="cstat-no" title="statement not covered" >d</span>elete this.visibleView;}</span>
<span class="fstat-no" title="function not covered" >fo</span>cus(){<span class="cstat-no" title="statement not covered" >this._sidebarTree.focus();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeSidebarSection=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,profileType){<span class="cstat-no" title="statement not covered" >super(profileType.treeItemTitle.escapeHTML(),true);<span class="cstat-no" title="statement not covered" >t</span>his.selectable=false;<span class="cstat-no" title="statement not covered" >t</span>his._dataDisplayDelegate=dataDisplayDelegate;<span class="cstat-no" title="statement not covered" >t</span>his._profileTreeElements=[];<span class="cstat-no" title="statement not covered" >t</span>his._profileGroups={};<span class="cstat-no" title="statement not covered" >t</span>his.expand();<span class="cstat-no" title="statement not covered" >t</span>his.hidden=true;<span class="cstat-no" title="statement not covered" >t</span>his.setCollapsible(false);}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dProfileHeader(profile){<span class="cstat-no" title="statement not covered" >this.hidden=false;c</span>onst profileType=<span class="cstat-no" title="statement not covered" >profile.profileType();</span>let sidebarParent=<span class="cstat-no" title="statement not covered" >this;</span>const profileTreeElement=<span class="cstat-no" title="statement not covered" >profile.createSidebarTreeElement(this._dataDisplayDelegate);<span class="cstat-no" title="statement not covered" ></span>this._profileTreeElements.push(profileTreeElement);<span class="cstat-no" title="statement not covered" >i</span>f(!profile.fromFile()&amp;&amp;profileType.profileBeingRecorded()!==profile){const profileTitle=<span class="cstat-no" title="statement not covered" >profile.title;</span>let group=<span class="cstat-no" title="statement not covered" >this._profileGroups[profileTitle];<span class="cstat-no" title="statement not covered" ></span>if(!group){<span class="cstat-no" title="statement not covered" >group=new Profiler.ProfileTypeSidebarSection.ProfileGroup();<span class="cstat-no" title="statement not covered" >t</span>his._profileGroups[profileTitle]=group;}</span></span></span>
<span class="cstat-no" title="statement not covered" >group.profileSidebarTreeElements.push(profileTreeElement);c</span>onst groupSize=<span class="cstat-no" title="statement not covered" >group.profileSidebarTreeElements.length;<span class="cstat-no" title="statement not covered" ></span>if(groupSize===2){<span class="cstat-no" title="statement not covered" >group.sidebarTreeElement=new Profiler.ProfileGroupSidebarTreeElement(this._dataDisplayDelegate,profile.title);c</span>onst firstProfileTreeElement=<span class="cstat-no" title="statement not covered" >group.profileSidebarTreeElements[0];</span>const index=<span class="cstat-no" title="statement not covered" >this.children().indexOf(firstProfileTreeElement);<span class="cstat-no" title="statement not covered" ></span>this.insertChild(group.sidebarTreeElement,index);c</span>onst selected=<span class="cstat-no" title="statement not covered" >firstProfileTreeElement.selected;<span class="cstat-no" title="statement not covered" ></span>this.removeChild(firstProfileTreeElement);<span class="cstat-no" title="statement not covered" >g</span>roup.sidebarTreeElement.appendChild(firstProfileTreeElement);<span class="cstat-no" title="statement not covered" >i</span>f(selected)</span></span>
<span class="cstat-no" title="statement not covered" >firstProfileTreeElement.revealAndSelect();<span class="cstat-no" title="statement not covered" >f</span>irstProfileTreeElement.setSmall(true);<span class="cstat-no" title="statement not covered" >f</span>irstProfileTreeElement.setMainTitle(Common.UIString('Run %d',1));<span class="cstat-no" title="statement not covered" >t</span>his.treeOutline.element.classList.add('some-expandable');}</span>
<span class="cstat-no" title="statement not covered" >if(groupSize&gt;=2){<span class="cstat-no" title="statement not covered" >sidebarParent=group.sidebarTreeElement;<span class="cstat-no" title="statement not covered" >p</span>rofileTreeElement.setSmall(true);<span class="cstat-no" title="statement not covered" >p</span>rofileTreeElement.setMainTitle(Common.UIString('Run %d',groupSize));}</span>}</span>
<span class="cstat-no" title="statement not covered" >sidebarParent.appendChild(profileTreeElement);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveProfileHeader(profile){const index=<span class="cstat-no" title="statement not covered" >this._sidebarElementIndex(profile);<span class="cstat-no" title="statement not covered" ></span>if(index===-1)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst profileTreeElement=<span class="cstat-no" title="statement not covered" >this._profileTreeElements[index];<span class="cstat-no" title="statement not covered" ></span>this._profileTreeElements.splice(index,1);l</span>et sidebarParent=<span class="cstat-no" title="statement not covered" >this;</span>const group=<span class="cstat-no" title="statement not covered" >this._profileGroups[profile.title];<span class="cstat-no" title="statement not covered" ></span>if(group){const groupElements=<span class="cstat-no" title="statement not covered" >group.profileSidebarTreeElements;<span class="cstat-no" title="statement not covered" ></span>groupElements.splice(groupElements.indexOf(profileTreeElement),1);<span class="cstat-no" title="statement not covered" >i</span>f(groupElements.length===1){const pos=<span class="cstat-no" title="statement not covered" >sidebarParent.children().indexOf((group.sidebarTreeElement));<span class="cstat-no" title="statement not covered" ></span>group.sidebarTreeElement.removeChild(groupElements[0]);<span class="cstat-no" title="statement not covered" >t</span>his.insertChild(groupElements[0],pos);<span class="cstat-no" title="statement not covered" >g</span>roupElements[0].setSmall(false);<span class="cstat-no" title="statement not covered" >g</span>roupElements[0].setMainTitle(profile.title);<span class="cstat-no" title="statement not covered" >t</span>his.removeChild(group.sidebarTreeElement);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(groupElements.length!==0)</span>
<span class="cstat-no" title="statement not covered" >sidebarParent=group.sidebarTreeElement;}</span>
<span class="cstat-no" title="statement not covered" >sidebarParent.removeChild(profileTreeElement);<span class="cstat-no" title="statement not covered" >p</span>rofileTreeElement.dispose();<span class="cstat-no" title="statement not covered" >i</span>f(this.childCount())</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his.hidden=true;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >si</span>debarElementForProfile(profile){const index=<span class="cstat-no" title="statement not covered" >this._sidebarElementIndex(profile);<span class="cstat-no" title="statement not covered" ></span>return index===-1?null:this._profileTreeElements[index];}</span>
<span class="fstat-no" title="function not covered" >_s</span>idebarElementIndex(profile){const elements=<span class="cstat-no" title="statement not covered" >this._profileTreeElements;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;elements.length;i++){<span class="cstat-no" title="statement not covered" >if(elements[i].profile===profile)</span></span>
<span class="cstat-no" title="statement not covered" >return i;}</span>
<span class="cstat-no" title="statement not covered" >return-1;}</span>
<span class="fstat-no" title="function not covered" >on</span>attach(){<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.add('profiles-tree-section');}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeSidebarSection.ProfileGroup=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.profileSidebarTreeElements=[];<span class="cstat-no" title="statement not covered" >t</span>his.sidebarTreeElement=null;}</span>};<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileSidebarTreeElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,profile,className){<span class="cstat-no" title="statement not covered" >super('',false);<span class="cstat-no" title="statement not covered" >t</span>his._iconElement=createElementWithClass('div','icon');<span class="cstat-no" title="statement not covered" >t</span>his._titlesElement=createElementWithClass('div','titles no-subtitle');<span class="cstat-no" title="statement not covered" >t</span>his._titleContainer=this._titlesElement.createChild('span','title-container');<span class="cstat-no" title="statement not covered" >t</span>his._titleElement=this._titleContainer.createChild('span','title');<span class="cstat-no" title="statement not covered" >t</span>his._subtitleElement=this._titlesElement.createChild('span','subtitle');<span class="cstat-no" title="statement not covered" >t</span>his._titleElement.textContent=profile.title;<span class="cstat-no" title="statement not covered" >t</span>his._className=className;<span class="cstat-no" title="statement not covered" >t</span>his._small=false;<span class="cstat-no" title="statement not covered" >t</span>his._dataDisplayDelegate=dataDisplayDelegate;<span class="cstat-no" title="statement not covered" >t</span>his.profile=profile;<span class="cstat-no" title="statement not covered" >p</span>rofile.addEventListener(Profiler.ProfileHeader.Events.UpdateStatus,this._updateStatus,this);<span class="cstat-no" title="statement not covered" >i</span>f(profile.canSaveToFile())</span></span>
<span class="cstat-no" title="statement not covered" >this._createSaveLink();e</span>lse
<span class="cstat-no" title="statement not covered" >profile.addEventListener(Profiler.ProfileHeader.Events.ProfileReceived,this._onProfileReceived,this);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateSaveLink(){<span class="cstat-no" title="statement not covered" >this._saveLinkElement=this._titleContainer.createChild('span','save-link');<span class="cstat-no" title="statement not covered" >t</span>his._saveLinkElement.textContent=Common.UIString('Save');<span class="cstat-no" title="statement not covered" >t</span>his._saveLinkElement.addEventListener('click',this._saveProfile.bind(this),false);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nProfileReceived(event){<span class="cstat-no" title="statement not covered" >this._createSaveLink();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateStatus(event){const statusUpdate=<span class="cstat-no" title="statement not covered" >event.data;<span class="cstat-no" title="statement not covered" ></span>if(statusUpdate.subtitle!==null){<span class="cstat-no" title="statement not covered" >this._subtitleElement.textContent=statusUpdate.subtitle||'';<span class="cstat-no" title="statement not covered" >t</span>his._titlesElement.classList.toggle('no-subtitle',!statusUpdate.subtitle);}</span></span>
<span class="cstat-no" title="statement not covered" >if(typeof statusUpdate.wait==='boolean'&amp;&amp;this.listItemElement)</span>
<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.toggle('wait',statusUpdate.wait);}</span>
<span class="fstat-no" title="function not covered" >on</span>dblclick(event){<span class="cstat-no" title="statement not covered" >if(!this._editing)</span>
<span class="cstat-no" title="statement not covered" >this._startEditing((event.target));<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartEditing(eventTarget){const container=<span class="cstat-no" title="statement not covered" >eventTarget.enclosingNodeOrSelfWithClass('title');<span class="cstat-no" title="statement not covered" ></span>if(!container)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst config=<span class="cstat-no" title="statement not covered" >new UI.InplaceEditor.Config(this._editingCommitted.bind(this),this._editingCancelled.bind(this));<span class="cstat-no" title="statement not covered" ></span>this._editing=UI.InplaceEditor.startEditing(container,config);}</span>
<span class="fstat-no" title="function not covered" >_e</span>ditingCommitted(container,newTitle){<span class="cstat-no" title="statement not covered" >delete this._editing;<span class="cstat-no" title="statement not covered" >t</span>his.profile.setTitle(newTitle);}</span>
<span class="fstat-no" title="function not covered" >_e</span>ditingCancelled(){<span class="cstat-no" title="statement not covered" >delete this._editing;}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this.profile.removeEventListener(Profiler.ProfileHeader.Events.UpdateStatus,this._updateStatus,this);<span class="cstat-no" title="statement not covered" >t</span>his.profile.removeEventListener(Profiler.ProfileHeader.Events.ProfileReceived,this._onProfileReceived,this);}</span>
<span class="fstat-no" title="function not covered" >on</span>select(){<span class="cstat-no" title="statement not covered" >this._dataDisplayDelegate.showProfile(this.profile);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >on</span>delete(){<span class="cstat-no" title="statement not covered" >this.profile.profileType().removeProfile(this.profile);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >on</span>attach(){<span class="cstat-no" title="statement not covered" >if(this._className)</span>
<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.add(this._className);<span class="cstat-no" title="statement not covered" >i</span>f(this._small)</span>
<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.add('small');<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.appendChildren(this._iconElement,this._titlesElement);<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.addEventListener('contextmenu',this._handleContextMenuEvent.bind(this),true);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleContextMenuEvent(event){const profile=<span class="cstat-no" title="statement not covered" >this.profile;</span>const contextMenu=<span class="cstat-no" title="statement not covered" >new UI.ContextMenu(event);<span class="cstat-no" title="statement not covered" ></span>contextMenu.headerSection().appendItem(Common.UIString('Load\u2026'),Profiler.ProfilesPanel._fileSelectorElement.click.bind(Profiler.ProfilesPanel._fileSelectorElement));<span class="cstat-no" title="statement not covered" >i</span>f(profile.canSaveToFile())</span>
<span class="cstat-no" title="statement not covered" >contextMenu.saveSection().appendItem(Common.UIString('Save\u2026'),profile.saveToFile.bind(profile));<span class="cstat-no" title="statement not covered" >c</span>ontextMenu.footerSection().appendItem(Common.UIString('Delete'),this.ondelete.bind(this));<span class="cstat-no" title="statement not covered" >c</span>ontextMenu.show();}</span>
<span class="fstat-no" title="function not covered" >_s</span>aveProfile(event){<span class="cstat-no" title="statement not covered" >this.profile.saveToFile();}</span>
<span class="fstat-no" title="function not covered" >se</span>tSmall(small){<span class="cstat-no" title="statement not covered" >this._small=small;<span class="cstat-no" title="statement not covered" >i</span>f(this.listItemElement)</span>
<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.toggle('small',this._small);}</span>
<span class="fstat-no" title="function not covered" >se</span>tMainTitle(title){<span class="cstat-no" title="statement not covered" >this._titleElement.textContent=title;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileGroupSidebarTreeElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,title){<span class="cstat-no" title="statement not covered" >super('',true);<span class="cstat-no" title="statement not covered" >t</span>his.selectable=false;<span class="cstat-no" title="statement not covered" >t</span>his._dataDisplayDelegate=dataDisplayDelegate;<span class="cstat-no" title="statement not covered" >t</span>his._title=title;<span class="cstat-no" title="statement not covered" >t</span>his.expand();<span class="cstat-no" title="statement not covered" >t</span>his.toggleOnClick=true;}</span></span>
<span class="fstat-no" title="function not covered" >on</span>select(){const hasChildren=<span class="cstat-no" title="statement not covered" >this.childCount()&gt;0;<span class="cstat-no" title="statement not covered" ></span>if(hasChildren)</span>
<span class="cstat-no" title="statement not covered" >this._dataDisplayDelegate.showProfile(this.lastChild().profile);<span class="cstat-no" title="statement not covered" >r</span>eturn hasChildren;}</span>
<span class="fstat-no" title="function not covered" >on</span>attach(){<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.add('profile-group-sidebar-tree-item');<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.createChild('div','icon');<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.createChild('div','titles no-subtitle').createChild('span','title-container').createChild('span','title').textContent=this._title;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfilesSidebarTreeElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(panel){<span class="cstat-no" title="statement not covered" >super('',false);<span class="cstat-no" title="statement not covered" >t</span>his.selectable=true;<span class="cstat-no" title="statement not covered" >t</span>his._panel=panel;}</span></span>
<span class="fstat-no" title="function not covered" >on</span>select(){<span class="cstat-no" title="statement not covered" >this._panel._showLauncherView();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >on</span>attach(){<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.add('profile-launcher-view-tree-item');<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.createChild('div','icon');<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.createChild('div','titles no-subtitle').createChild('span','title-container').createChild('span','title').textContent=Common.UIString('Profiles');}</span>};<span class="cstat-no" title="statement not covered" >Profiler.JSProfilerPanel=class extends Profiler.ProfilesPanel{<span class="fstat-no" title="function not covered" >co</span>nstructor(){const registry=<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeRegistry.instance;<span class="cstat-no" title="statement not covered" ></span>super('js_profiler',[registry.cpuProfileType],'profiler.js-toggle-recording');}</span></span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >UI.context.setFlavor(Profiler.JSProfilerPanel,this);}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >UI.context.setFlavor(Profiler.JSProfilerPanel,null);}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleAction(context,actionId){const panel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(Profiler.JSProfilerPanel);<span class="cstat-no" title="statement not covered" ></span>console.assert(panel&amp;&amp;panel instanceof Profiler.JSProfilerPanel);<span class="cstat-no" title="statement not covered" >p</span>anel.toggleRecord();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.ProfileView=class extends UI.SimpleView{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Profile'));<span class="cstat-no" title="statement not covered" >t</span>his._profile=null;<span class="cstat-no" title="statement not covered" >t</span>his._searchableView=new UI.SearchableView(this);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.setPlaceholder(Common.UIString('Find by cost (&gt;50ms), name or file'));<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.show(this.element);c</span>onst columns=(<span class="cstat-no" title="statement not covered" >[])</span>;<span class="cstat-no" title="statement not covered" >columns.push({id:'self',title:this.columnHeader('self'),width:'120px',fixedWidth:true,sortable:true,sort:DataGrid.DataGrid.Order.Descending});<span class="cstat-no" title="statement not covered" >c</span>olumns.push({id:'total',title:this.columnHeader('total'),width:'120px',fixedWidth:true,sortable:true});<span class="cstat-no" title="statement not covered" >c</span>olumns.push({id:'function',title:Common.UIString('Function'),disclosure:true,sortable:true});<span class="cstat-no" title="statement not covered" >t</span>his.dataGrid=new DataGrid.DataGrid(columns);<span class="cstat-no" title="statement not covered" >t</span>his.dataGrid.addEventListener(DataGrid.DataGrid.Events.SortingChanged,this._sortProfile,this);<span class="cstat-no" title="statement not covered" >t</span>his.dataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._nodeSelected.bind(this,true));<span class="cstat-no" title="statement not covered" >t</span>his.dataGrid.addEventListener(DataGrid.DataGrid.Events.DeselectedNode,this._nodeSelected.bind(this,false));<span class="cstat-no" title="statement not covered" >t</span>his.viewSelectComboBox=new UI.ToolbarComboBox(this._changeView.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his.focusButton=new UI.ToolbarButton(Common.UIString('Focus selected function'),'largeicon-visibility');<span class="cstat-no" title="statement not covered" >t</span>his.focusButton.setEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his.focusButton.addEventListener(UI.ToolbarButton.Events.Click,this._focusClicked,this);<span class="cstat-no" title="statement not covered" >t</span>his.excludeButton=new UI.ToolbarButton(Common.UIString('Exclude selected function'),'largeicon-delete');<span class="cstat-no" title="statement not covered" >t</span>his.excludeButton.setEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his.excludeButton.addEventListener(UI.ToolbarButton.Events.Click,this._excludeClicked,this);<span class="cstat-no" title="statement not covered" >t</span>his.resetButton=new UI.ToolbarButton(Common.UIString('Restore all functions'),'largeicon-refresh');<span class="cstat-no" title="statement not covered" >t</span>his.resetButton.setEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his.resetButton.addEventListener(UI.ToolbarButton.Events.Click,this._resetClicked,this);<span class="cstat-no" title="statement not covered" >t</span>his._linkifier=new Components.Linkifier(Profiler.ProfileView._maxLinkLength);}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic buildPopoverTable(entryInfo){const table=<span class="cstat-no" title="statement not covered" >createElement('table');<span class="cstat-no" title="statement not covered" ></span>for(const entry of entryInfo){const row=<span class="cstat-no" title="statement not covered" >table.createChild('tr');<span class="cstat-no" title="statement not covered" ></span>row.createChild('td').textContent=entry.title;<span class="cstat-no" title="statement not covered" >r</span>ow.createChild('td').textContent=entry.value;}</span></span>
<span class="cstat-no" title="statement not covered" >return table;}</span>
<span class="fstat-no" title="function not covered" >se</span>tProfile(profile){<span class="cstat-no" title="statement not covered" >this._profile=profile;<span class="cstat-no" title="statement not covered" >t</span>his._bottomUpProfileDataGridTree=null;<span class="cstat-no" title="statement not covered" >t</span>his._topDownProfileDataGridTree=null;<span class="cstat-no" title="statement not covered" >t</span>his._changeView();<span class="cstat-no" title="statement not covered" >t</span>his.refresh();}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofile(){<span class="cstat-no" title="statement not covered" >return this._profile;}</span>
<span class="fstat-no" title="function not covered" >in</span>itialize(nodeFormatter,viewTypes){<span class="cstat-no" title="statement not covered" >this._nodeFormatter=nodeFormatter;<span class="cstat-no" title="statement not covered" >t</span>his._viewType=Common.settings.createSetting('profileView',Profiler.ProfileView.ViewTypes.Heavy);<span class="cstat-no" title="statement not covered" >v</span>iewTypes=viewTypes||[Profiler.ProfileView.ViewTypes.Flame,Profiler.ProfileView.ViewTypes.Heavy,Profiler.ProfileView.ViewTypes.Tree];c</span>onst optionNames=<span class="cstat-no" title="statement not covered" >new Map([[Profiler.ProfileView.ViewTypes.Flame,ls`Chart`],[Profiler.ProfileView.ViewTypes.Heavy,ls`Heavy (Bottom Up)`],[Profiler.ProfileView.ViewTypes.Tree,ls`Tree (Top Down)`],[Profiler.ProfileView.ViewTypes.Text,ls`Text (Top Down)`],]);</span>const options=<span class="cstat-no" title="statement not covered" >new Map(viewTypes.map(<span class="fstat-no" title="function not covered" >ty</span>pe=&gt;<span class="cstat-no" title="statement not covered" >[type,this.viewSelectComboBox.createOption(optionNames.get(type),'',type)])</span>);</span>const optionName=<span class="cstat-no" title="statement not covered" >this._viewType.get()||viewTypes[0];</span>const option=<span class="cstat-no" title="statement not covered" >options.get(optionName)||options.get(viewTypes[0]);<span class="cstat-no" title="statement not covered" ></span>this.viewSelectComboBox.select(option);<span class="cstat-no" title="statement not covered" >t</span>his._changeView();<span class="cstat-no" title="statement not covered" >i</span>f(this._flameChart)</span>
<span class="cstat-no" title="statement not covered" >this._flameChart.update();}</span>
<span class="fstat-no" title="function not covered" >fo</span>cus(){<span class="cstat-no" title="statement not covered" >if(this._flameChart)</span>
<span class="cstat-no" title="statement not covered" >this._flameChart.focus();e</span>lse
<span class="cstat-no" title="statement not covered" >super.focus();}</span>
<span class="fstat-no" title="function not covered" >co</span>lumnHeader(columnId){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>
<span class="fstat-no" title="function not covered" >se</span>lectRange(timeLeft,timeRight){<span class="cstat-no" title="statement not covered" >if(!this._flameChart)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.selectRange(timeLeft,timeRight);}</span>
<span class="fstat-no" title="function not covered" >sy</span>ncToolbarItems(){<span class="cstat-no" title="statement not covered" >return[this.viewSelectComboBox,this.focusButton,this.excludeButton,this.resetButton];}</span>
<span class="fstat-no" title="function not covered" >_g</span>etBottomUpProfileDataGridTree(){<span class="cstat-no" title="statement not covered" >if(!this._bottomUpProfileDataGridTree){<span class="cstat-no" title="statement not covered" >this._bottomUpProfileDataGridTree=new Profiler.BottomUpProfileDataGridTree(this._nodeFormatter,this._searchableView,this._profile.root,this.adjustedTotal);}</span></span>
<span class="cstat-no" title="statement not covered" >return this._bottomUpProfileDataGridTree;}</span>
<span class="fstat-no" title="function not covered" >_g</span>etTopDownProfileDataGridTree(){<span class="cstat-no" title="statement not covered" >if(!this._topDownProfileDataGridTree){<span class="cstat-no" title="statement not covered" >this._topDownProfileDataGridTree=new Profiler.TopDownProfileDataGridTree(this._nodeFormatter,this._searchableView,this._profile.root,this.adjustedTotal);}</span></span>
<span class="cstat-no" title="statement not covered" >return this._topDownProfileDataGridTree;}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >this._currentSearchResultIndex=-1;}</span>
<span class="fstat-no" title="function not covered" >re</span>fresh(){<span class="cstat-no" title="statement not covered" >if(!this.profileDataGridTree)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst selectedProfileNode=<span class="cstat-no" title="statement not covered" >this.dataGrid.selectedNode?this.dataGrid.selectedNode.profileNode:null;<span class="cstat-no" title="statement not covered" ></span>this.dataGrid.rootNode().removeChildren();c</span>onst children=<span class="cstat-no" title="statement not covered" >this.profileDataGridTree.children;</span>const count=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index)</span>
<span class="cstat-no" title="statement not covered" >this.dataGrid.rootNode().appendChild(children[index]);<span class="cstat-no" title="statement not covered" >i</span>f(selectedProfileNode)</span>
<span class="cstat-no" title="statement not covered" >selectedProfileNode.selected=true;}</span>
<span class="fstat-no" title="function not covered" >re</span>freshVisibleData(){let child=<span class="cstat-no" title="statement not covered" >this.dataGrid.rootNode().children[0];<span class="cstat-no" title="statement not covered" ></span>while(child){<span class="cstat-no" title="statement not covered" >child.refresh();<span class="cstat-no" title="statement not covered" >c</span>hild=child.traverseNextNode(false,null,true);}</span>}</span>
<span class="fstat-no" title="function not covered" >se</span>archableView(){<span class="cstat-no" title="statement not covered" >return this._searchableView;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsCaseSensitiveSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsRegexSearch(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >se</span>archCanceled(){<span class="cstat-no" title="statement not covered" >this._searchableElement.searchCanceled();}</span>
<span class="fstat-no" title="function not covered" >pe</span>rformSearch(searchConfig,shouldJump,jumpBackwards){<span class="cstat-no" title="statement not covered" >this._searchableElement.performSearch(searchConfig,shouldJump,jumpBackwards);}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToNextSearchResult(){<span class="cstat-no" title="statement not covered" >this._searchableElement.jumpToNextSearchResult();}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToPreviousSearchResult(){<span class="cstat-no" title="statement not covered" >this._searchableElement.jumpToPreviousSearchResult();}</span>
<span class="fstat-no" title="function not covered" >li</span>nkifier(){<span class="cstat-no" title="statement not covered" >return this._linkifier;}</span>
<span class="fstat-no" title="function not covered" >_e</span>nsureTextViewCreated(){<span class="cstat-no" title="statement not covered" >if(this._textView)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._textView=new UI.SimpleView(ls`Call tree`);<span class="cstat-no" title="statement not covered" >t</span>his._textView.registerRequiredCSS('profiler/profilesPanel.css');<span class="cstat-no" title="statement not covered" >t</span>his.populateTextView(this._textView);}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateTextView(view){}
<span class="fstat-no" title="function not covered" >cr</span>eateFlameChartDataProvider(){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>
<span class="fstat-no" title="function not covered" >_e</span>nsureFlameChartCreated(){<span class="cstat-no" title="statement not covered" >if(this._flameChart)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._dataProvider=this.createFlameChartDataProvider();<span class="cstat-no" title="statement not covered" >t</span>his._flameChart=new Profiler.CPUProfileFlameChart(this._searchableView,this._dataProvider);<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.addEventListener(PerfUI.FlameChart.Events.EntrySelected,this._onEntrySelected.bind(this));}</span>
<span class="fstat-no" title="function not covered" >_o</span>nEntrySelected(event){const entryIndex=<span class="cstat-no" title="statement not covered" >event.data;</span>const node=<span class="cstat-no" title="statement not covered" >this._dataProvider._entryNodes[entryIndex];</span>const debuggerModel=<span class="cstat-no" title="statement not covered" >this._profileHeader._debuggerModel;<span class="cstat-no" title="statement not covered" ></span>if(!node||!node.scriptId||!debuggerModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst script=<span class="cstat-no" title="statement not covered" >debuggerModel.scriptForId(node.scriptId);<span class="cstat-no" title="statement not covered" ></span>if(!script)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst location=(<span class="cstat-no" title="statement not covered" >debuggerModel.createRawLocation(script,node.lineNumber,node.columnNumber))</span>;<span class="cstat-no" title="statement not covered" >Common.Revealer.reveal(Bindings.debuggerWorkspaceBinding.rawLocationToUILocation(location));}</span>
<span class="fstat-no" title="function not covered" >_c</span>hangeView(){<span class="cstat-no" title="statement not covered" >if(!this._profile)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.closeSearch();<span class="cstat-no" title="statement not covered" >i</span>f(this._visibleView)</span>
<span class="cstat-no" title="statement not covered" >this._visibleView.detach();<span class="cstat-no" title="statement not covered" >t</span>his._viewType.set(this.viewSelectComboBox.selectedOption().value);<span class="cstat-no" title="statement not covered" >s</span>witch(this._viewType.get()){case Profiler.ProfileView.ViewTypes.Flame:<span class="cstat-no" title="statement not covered" >this._ensureFlameChartCreated();<span class="cstat-no" title="statement not covered" >t</span>his._visibleView=this._flameChart;<span class="cstat-no" title="statement not covered" >t</span>his._searchableElement=this._flameChart;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Profiler.ProfileView.ViewTypes.Tree:<span class="cstat-no" title="statement not covered" >this.profileDataGridTree=this._getTopDownProfileDataGridTree();<span class="cstat-no" title="statement not covered" >t</span>his._sortProfile();<span class="cstat-no" title="statement not covered" >t</span>his._visibleView=this.dataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._searchableElement=this.profileDataGridTree;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Profiler.ProfileView.ViewTypes.Heavy:<span class="cstat-no" title="statement not covered" >this.profileDataGridTree=this._getBottomUpProfileDataGridTree();<span class="cstat-no" title="statement not covered" >t</span>his._sortProfile();<span class="cstat-no" title="statement not covered" >t</span>his._visibleView=this.dataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._searchableElement=this.profileDataGridTree;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Profiler.ProfileView.ViewTypes.Text:<span class="cstat-no" title="statement not covered" >this._ensureTextViewCreated();<span class="cstat-no" title="statement not covered" >t</span>his._visibleView=this._textView;<span class="cstat-no" title="statement not covered" >t</span>his._searchableElement=this._textView;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
const isFlame=<span class="cstat-no" title="statement not covered" >this._viewType.get()===Profiler.ProfileView.ViewTypes.Flame;<span class="cstat-no" title="statement not covered" ></span>this.focusButton.setVisible(!isFlame);<span class="cstat-no" title="statement not covered" >t</span>his.excludeButton.setVisible(!isFlame);<span class="cstat-no" title="statement not covered" >t</span>his.resetButton.setVisible(!isFlame);<span class="cstat-no" title="statement not covered" >t</span>his._visibleView.show(this._searchableView.element);}</span>
<span class="fstat-no" title="function not covered" >_n</span>odeSelected(selected){<span class="cstat-no" title="statement not covered" >this.focusButton.setEnabled(selected);<span class="cstat-no" title="statement not covered" >t</span>his.excludeButton.setEnabled(selected);}</span>
<span class="fstat-no" title="function not covered" >_f</span>ocusClicked(event){<span class="cstat-no" title="statement not covered" >if(!this.dataGrid.selectedNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.resetButton.setEnabled(true);<span class="cstat-no" title="statement not covered" >t</span>his.profileDataGridTree.focus(this.dataGrid.selectedNode);<span class="cstat-no" title="statement not covered" >t</span>his.refresh();<span class="cstat-no" title="statement not covered" >t</span>his.refreshVisibleData();<span class="cstat-no" title="statement not covered" >H</span>ost.userMetrics.actionTaken(Host.UserMetrics.Action.CpuProfileNodeFocused);}</span>
<span class="fstat-no" title="function not covered" >_e</span>xcludeClicked(event){const selectedNode=<span class="cstat-no" title="statement not covered" >this.dataGrid.selectedNode;<span class="cstat-no" title="statement not covered" ></span>if(!selectedNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span>electedNode.deselect();<span class="cstat-no" title="statement not covered" >t</span>his.resetButton.setEnabled(true);<span class="cstat-no" title="statement not covered" >t</span>his.profileDataGridTree.exclude(selectedNode);<span class="cstat-no" title="statement not covered" >t</span>his.refresh();<span class="cstat-no" title="statement not covered" >t</span>his.refreshVisibleData();<span class="cstat-no" title="statement not covered" >H</span>ost.userMetrics.actionTaken(Host.UserMetrics.Action.CpuProfileNodeExcluded);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esetClicked(event){<span class="cstat-no" title="statement not covered" >this.resetButton.setEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his.profileDataGridTree.restore();<span class="cstat-no" title="statement not covered" >t</span>his._linkifier.reset();<span class="cstat-no" title="statement not covered" >t</span>his.refresh();<span class="cstat-no" title="statement not covered" >t</span>his.refreshVisibleData();}</span>
<span class="fstat-no" title="function not covered" >_s</span>ortProfile(){const sortAscending=<span class="cstat-no" title="statement not covered" >this.dataGrid.isSortOrderAscending();</span>const sortColumnId=<span class="cstat-no" title="statement not covered" >this.dataGrid.sortColumnId();</span>const sortProperty=<span class="cstat-no" title="statement not covered" >sortColumnId==='function'?'functionName':sortColumnId||'';<span class="cstat-no" title="statement not covered" ></span>this.profileDataGridTree.sort(Profiler.ProfileDataGridTree.propertyComparator(sortProperty,sortAscending));<span class="cstat-no" title="statement not covered" >t</span>his.refresh();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileView._maxLinkLength=30;<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileView.ViewTypes={Flame:'Flame',Tree:'Tree',Heavy:'Heavy',Text:'Text'};<span class="cstat-no" title="statement not covered" >P</span>rofiler.WritableProfileHeader=class extends Profiler.ProfileHeader{<span class="fstat-no" title="function not covered" >co</span>nstructor(debuggerModel,type,title){<span class="cstat-no" title="statement not covered" >super(type,title||Common.UIString('Profile %d',type.nextProfileUid()));<span class="cstat-no" title="statement not covered" >t</span>his._debuggerModel=debuggerModel;<span class="cstat-no" title="statement not covered" >t</span>his._tempFile=null;}</span></span>
<span class="fstat-no" title="function not covered" >_o</span>nChunkTransferred(reader){<span class="cstat-no" title="statement not covered" >this.updateStatus(Common.UIString('Loading\u2026 %d%%',Number.bytesToString(this._jsonifiedProfile.length)));}</span>
<span class="fstat-no" title="function not covered" >_o</span>nError(reader){<span class="cstat-no" title="statement not covered" >this.updateStatus(Common.UIString(`File '%s' read error: %s`,reader.fileName(),reader.error().message));}</span>
<span class="fstat-no" title="function not covered" >as</span>ync write(text){<span class="cstat-no" title="statement not covered" >this._jsonifiedProfile+=text;}</span>
<span class="fstat-no" title="function not covered" >cl</span>ose(){}
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this.removeTempFile();}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSidebarTreeElement(panel){<span class="cstat-no" title="statement not covered" >return new Profiler.ProfileSidebarTreeElement(panel,this,'profile-sidebar-tree-item');}</span>
<span class="fstat-no" title="function not covered" >ca</span>nSaveToFile(){<span class="cstat-no" title="statement not covered" >return!this.fromFile()&amp;&amp;this._protocolProfile;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync saveToFile(){const fileOutputStream=<span class="cstat-no" title="statement not covered" >new Bindings.FileOutputStream();<span class="cstat-no" title="statement not covered" ></span>this._fileName=this._fileName||`${this.profileType().typeName()}-${new Date().toISO8601Compact()}${this.profileType().fileExtension()}`;c</span>onst accepted=<span class="cstat-no" title="statement not covered" >await fileOutputStream.open(this._fileName);<span class="cstat-no" title="statement not covered" ></span>if(!accepted||!this._tempFile)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst data=<span class="cstat-no" title="statement not covered" >await this._tempFile.read();<span class="cstat-no" title="statement not covered" ></span>if(data)</span>
<span class="cstat-no" title="statement not covered" >await fileOutputStream.write(data);<span class="cstat-no" title="statement not covered" >f</span>ileOutputStream.close();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync loadFromFile(file){<span class="cstat-no" title="statement not covered" >this.updateStatus(Common.UIString('Loading\u2026'),true);c</span>onst fileReader=<span class="cstat-no" title="statement not covered" >new Bindings.ChunkedFileReader(file,10000000,this._onChunkTransferred.bind(this));<span class="cstat-no" title="statement not covered" ></span>this._jsonifiedProfile='';c</span>onst success=<span class="cstat-no" title="statement not covered" >await fileReader.read(this);<span class="cstat-no" title="statement not covered" ></span>if(!success){<span class="cstat-no" title="statement not covered" >this._onError(fileReader);<span class="cstat-no" title="statement not covered" >r</span>eturn new Error(Common.UIString('Failed to read file'));}</span></span>
<span class="cstat-no" title="statement not covered" >this.updateStatus(Common.UIString('Parsing\u2026'),true);l</span>et error=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >this._profile=(JSON.parse(this._jsonifiedProfile));<span class="cstat-no" title="statement not covered" >t</span>his.setProfile(this._profile);<span class="cstat-no" title="statement not covered" >t</span>his.updateStatus(Common.UIString('Loaded'),false);}</span>catch(e){<span class="cstat-no" title="statement not covered" >error=e;<span class="cstat-no" title="statement not covered" >t</span>his.profileType().removeProfile(this);}</span></span>
<span class="cstat-no" title="statement not covered" >this._jsonifiedProfile=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.profileType().profileBeingRecorded()===this)</span>
<span class="cstat-no" title="statement not covered" >this.profileType().setProfileBeingRecorded(null);<span class="cstat-no" title="statement not covered" >r</span>eturn error;}</span>
<span class="fstat-no" title="function not covered" >se</span>tProtocolProfile(profile){<span class="cstat-no" title="statement not covered" >this.setProfile(profile);<span class="cstat-no" title="statement not covered" >t</span>his._protocolProfile=profile;<span class="cstat-no" title="statement not covered" >t</span>his._tempFile=new Bindings.TempFile();<span class="cstat-no" title="statement not covered" >t</span>his._tempFile.write([JSON.stringify(profile)]);<span class="cstat-no" title="statement not covered" >i</span>f(this.canSaveToFile())</span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.ProfileHeader.Events.ProfileReceived);}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridNode=class extends DataGrid.DataGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileNode,owningTree,hasChildren){<span class="cstat-no" title="statement not covered" >super(null,hasChildren);<span class="cstat-no" title="statement not covered" >t</span>his._searchMatchedSelfColumn=false;<span class="cstat-no" title="statement not covered" >t</span>his._searchMatchedTotalColumn=false;<span class="cstat-no" title="statement not covered" >t</span>his._searchMatchedFunctionColumn=false;<span class="cstat-no" title="statement not covered" >t</span>his.profileNode=profileNode;<span class="cstat-no" title="statement not covered" >t</span>his.tree=owningTree;<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID=new Map();<span class="cstat-no" title="statement not covered" >t</span>his.lastComparator=null;<span class="cstat-no" title="statement not covered" >t</span>his.callUID=profileNode.callUID;<span class="cstat-no" title="statement not covered" >t</span>his.self=profileNode.self;<span class="cstat-no" title="statement not covered" >t</span>his.total=profileNode.total;<span class="cstat-no" title="statement not covered" >t</span>his.functionName=UI.beautifyFunctionName(profileNode.functionName);<span class="cstat-no" title="statement not covered" >t</span>his._deoptReason=profileNode.deoptReason||'';<span class="cstat-no" title="statement not covered" >t</span>his.url=profileNode.url;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic sort(gridNodeGroups,comparator,force){<span class="cstat-no" title="statement not covered" >for(let gridNodeGroupIndex=0;gridNodeGroupIndex&lt;gridNodeGroups.length;++gridNodeGroupIndex){const gridNodes=<span class="cstat-no" title="statement not covered" >gridNodeGroups[gridNodeGroupIndex];</span>const count=<span class="cstat-no" title="statement not covered" >gridNodes.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index){const gridNode=<span class="cstat-no" title="statement not covered" >gridNodes[index];<span class="cstat-no" title="statement not covered" ></span>if(!force&amp;&amp;(!gridNode.expanded||gridNode.lastComparator===comparator)){<span class="cstat-no" title="statement not covered" >if(gridNode.children.length)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >gridNode.shouldRefreshChildren=true;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>
<span class="cstat-no" title="statement not covered" >gridNode.lastComparator=comparator;c</span>onst children=<span class="cstat-no" title="statement not covered" >gridNode.children;</span>const childCount=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>if(childCount){<span class="cstat-no" title="statement not covered" >children.sort(comparator);<span class="cstat-no" title="statement not covered" >f</span>or(let childIndex=0;childIndex&lt;childCount;++childIndex)</span></span>
<span class="cstat-no" title="statement not covered" >children[childIndex].recalculateSiblings(childIndex);<span class="cstat-no" title="statement not covered" >g</span>ridNodeGroups.push(children);}</span>}}}
<span class="fstat-no" title="function not covered" >st</span>atic merge(container,child,shouldAbsorb){<span class="cstat-no" title="statement not covered" >container.self+=child.self;<span class="cstat-no" title="statement not covered" >i</span>f(!shouldAbsorb)</span>
<span class="cstat-no" title="statement not covered" >container.total+=child.total;l</span>et children=<span class="cstat-no" title="statement not covered" >container.children.slice();<span class="cstat-no" title="statement not covered" ></span>container.removeChildren();l</span>et count=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index){<span class="cstat-no" title="statement not covered" >if(!shouldAbsorb||children[index]!==child)</span></span>
<span class="cstat-no" title="statement not covered" >container.appendChild(children[index]);}</span>
<span class="cstat-no" title="statement not covered" >children=child.children.slice();<span class="cstat-no" title="statement not covered" >c</span>ount=children.length;<span class="cstat-no" title="statement not covered" >f</span>or(let index=0;index&lt;count;++index){const orphanedChild=<span class="cstat-no" title="statement not covered" >children[index];</span>const existingChild=<span class="cstat-no" title="statement not covered" >container.childrenByCallUID.get(orphanedChild.callUID);<span class="cstat-no" title="statement not covered" ></span>if(existingChild)</span></span>
<span class="cstat-no" title="statement not covered" >existingChild.merge((orphanedChild),false);e</span>lse
<span class="cstat-no" title="statement not covered" >container.appendChild(orphanedChild);}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic populate(container){<span class="cstat-no" title="statement not covered" >if(container._populated)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>ontainer._populated=true;<span class="cstat-no" title="statement not covered" >c</span>ontainer.populateChildren();c</span>onst currentComparator=<span class="cstat-no" title="statement not covered" >container.tree.lastComparator;<span class="cstat-no" title="statement not covered" ></span>if(currentComparator)</span>
<span class="cstat-no" title="statement not covered" >container.sort(currentComparator,true);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){let cell;<span class="cstat-no" title="statement not covered" >switch(columnId){case'self':<span class="cstat-no" title="statement not covered" >cell=this._createValueCell(this.self,this.selfPercent);<span class="cstat-no" title="statement not covered" >c</span>ell.classList.toggle('highlight',this._searchMatchedSelfColumn);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'total':<span class="cstat-no" title="statement not covered" >cell=this._createValueCell(this.total,this.totalPercent);<span class="cstat-no" title="statement not covered" >c</span>ell.classList.toggle('highlight',this._searchMatchedTotalColumn);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'function':<span class="cstat-no" title="statement not covered" >cell=this.createTD(columnId);<span class="cstat-no" title="statement not covered" >c</span>ell.classList.toggle('highlight',this._searchMatchedFunctionColumn);<span class="cstat-no" title="statement not covered" >i</span>f(this._deoptReason){<span class="cstat-no" title="statement not covered" >cell.classList.add('not-optimized');c</span>onst warningIcon=<span class="cstat-no" title="statement not covered" >UI.Icon.create('smallicon-warning','profile-warn-marker');<span class="cstat-no" title="statement not covered" ></span>warningIcon.title=Common.UIString('Not optimized: %s',this._deoptReason);<span class="cstat-no" title="statement not covered" >c</span>ell.appendChild(warningIcon);}</span></span></span>
<span class="cstat-no" title="statement not covered" >cell.createTextChild(this.functionName);<span class="cstat-no" title="statement not covered" >i</span>f(this.profileNode.scriptId==='0')</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst urlElement=<span class="cstat-no" title="statement not covered" >this.tree._formatter.linkifyNode(this);<span class="cstat-no" title="statement not covered" ></span>if(!urlElement)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >u</span>rlElement.style.maxWidth='75%';<span class="cstat-no" title="statement not covered" >c</span>ell.appendChild(urlElement);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >cell=super.createCell(columnId);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >return cell;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateValueCell(value,percent){const cell=<span class="cstat-no" title="statement not covered" >createElementWithClass('td','numeric-column');</span>const div=<span class="cstat-no" title="statement not covered" >cell.createChild('div','profile-multiple-values');<span class="cstat-no" title="statement not covered" ></span>div.createChild('span').textContent=this.tree._formatter.formatValue(value,this);<span class="cstat-no" title="statement not covered" >d</span>iv.createChild('span','percent-column').textContent=this.tree._formatter.formatPercent(percent,this);<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >so</span>rt(comparator,force){<span class="cstat-no" title="statement not covered" >return Profiler.ProfileDataGridNode.sort([[this]],comparator,force);}</span>
<span class="fstat-no" title="function not covered" >in</span>sertChild(profileDataGridNode,index){<span class="cstat-no" title="statement not covered" >super.insertChild(profileDataGridNode,index);<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID.set(profileDataGridNode.callUID,(profileDataGridNode));}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChild(profileDataGridNode){<span class="cstat-no" title="statement not covered" >super.removeChild(profileDataGridNode);<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID.delete(((profileDataGridNode)).callUID);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChildren(){<span class="cstat-no" title="statement not covered" >super.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID.clear();}</span>
<span class="fstat-no" title="function not covered" >fi</span>ndChild(node){<span class="cstat-no" title="statement not covered" >if(!node)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.childrenByCallUID.get(node.callUID);}</span>
<span class="fstat-no" title="function not covered" >ge</span>t selfPercent(){<span class="cstat-no" title="statement not covered" >return this.self/this.tree.total*100.0;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t totalPercent(){<span class="cstat-no" title="statement not covered" >return this.total/this.tree.total*100.0;}</span>
<span class="fstat-no" title="function not covered" >po</span>pulate(){<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridNode.populate(this);}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateChildren(){}
<span class="fstat-no" title="function not covered" >sa</span>ve(){<span class="cstat-no" title="statement not covered" >if(this._savedChildren)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._savedSelf=this.self;<span class="cstat-no" title="statement not covered" >t</span>his._savedTotal=this.total;<span class="cstat-no" title="statement not covered" >t</span>his._savedChildren=this.children.slice();}</span>
<span class="fstat-no" title="function not covered" >re</span>store(){<span class="cstat-no" title="statement not covered" >if(!this._savedChildren)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.self=this._savedSelf;<span class="cstat-no" title="statement not covered" >t</span>his.total=this._savedTotal;<span class="cstat-no" title="statement not covered" >t</span>his.removeChildren();c</span>onst children=<span class="cstat-no" title="statement not covered" >this._savedChildren;</span>const count=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index){<span class="cstat-no" title="statement not covered" >children[index].restore();<span class="cstat-no" title="statement not covered" >t</span>his.appendChild(children[index]);}</span>}</span>
<span class="fstat-no" title="function not covered" >me</span>rge(child,shouldAbsorb){<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridNode.merge(this,child,shouldAbsorb);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridTree=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(formatter,searchableView,total){<span class="cstat-no" title="statement not covered" >this.tree=this;<span class="cstat-no" title="statement not covered" >t</span>his.children=[];<span class="cstat-no" title="statement not covered" >t</span>his._formatter=formatter;<span class="cstat-no" title="statement not covered" >t</span>his._searchableView=searchableView;<span class="cstat-no" title="statement not covered" >t</span>his.total=total;<span class="cstat-no" title="statement not covered" >t</span>his.lastComparator=null;<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID=new Map();<span class="cstat-no" title="statement not covered" >t</span>his.deepSearch=true;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic propertyComparator(property,isAscending){let comparator=<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridTree.propertyComparators[(isAscending?1:0)][property];<span class="cstat-no" title="statement not covered" ></span>if(!comparator){<span class="cstat-no" title="statement not covered" >if(isAscending){<span class="cstat-no" title="statement not covered" >comparator=<span class="fstat-no" title="function not covered" >fu</span>nction(lhs,rhs){<span class="cstat-no" title="statement not covered" >if(lhs[property]&lt;rhs[property])</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(lhs[property]&gt;rhs[property])</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>;}else{<span class="cstat-no" title="statement not covered" >comparator=<span class="fstat-no" title="function not covered" >fu</span>nction(lhs,rhs){<span class="cstat-no" title="statement not covered" >if(lhs[property]&gt;rhs[property])</span></span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(lhs[property]&lt;rhs[property])</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>;}
<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridTree.propertyComparators[(isAscending?1:0)][property]=comparator;}</span>
<span class="cstat-no" title="statement not covered" >return comparator;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t expanded(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendChild(child){<span class="cstat-no" title="statement not covered" >this.insertChild(child,this.children.length);}</span>
<span class="fstat-no" title="function not covered" >in</span>sertChild(child,index){<span class="cstat-no" title="statement not covered" >this.children.splice(index,0,child);<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID.set(child.callUID,child);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChildren(){<span class="cstat-no" title="statement not covered" >this.children=[];<span class="cstat-no" title="statement not covered" >t</span>his.childrenByCallUID.clear();}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateChildren(){}
<span class="fstat-no" title="function not covered" >fi</span>ndChild(node){<span class="cstat-no" title="statement not covered" >if(!node)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.childrenByCallUID.get(node.callUID);}</span>
<span class="fstat-no" title="function not covered" >so</span>rt(comparator,force){<span class="cstat-no" title="statement not covered" >return Profiler.ProfileDataGridNode.sort([[this]],comparator,force);}</span>
<span class="fstat-no" title="function not covered" >sa</span>ve(){<span class="cstat-no" title="statement not covered" >if(this._savedChildren)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._savedTotal=this.total;<span class="cstat-no" title="statement not covered" >t</span>his._savedChildren=this.children.slice();}</span>
<span class="fstat-no" title="function not covered" >re</span>store(){<span class="cstat-no" title="statement not covered" >if(!this._savedChildren)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.children=this._savedChildren;<span class="cstat-no" title="statement not covered" >t</span>his.total=this._savedTotal;c</span>onst children=<span class="cstat-no" title="statement not covered" >this.children;</span>const count=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index)</span>
<span class="cstat-no" title="statement not covered" >children[index].restore();<span class="cstat-no" title="statement not covered" >t</span>his._savedChildren=null;}</span>
<span class="fstat-no" title="function not covered" >_m</span>atchFunction(searchConfig){const query=<span class="cstat-no" title="statement not covered" >searchConfig.query.trim();<span class="cstat-no" title="statement not covered" ></span>if(!query.length)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst greaterThan=(<span class="cstat-no" title="statement not covered" >query.startsWith('&gt;'))</span>;const lessThan=(<span class="cstat-no" title="statement not covered" >query.startsWith('&lt;'))</span>;let equalTo=(<span class="cstat-no" title="statement not covered" >query.startsWith('=')||((greaterThan||lessThan)&amp;&amp;query.indexOf('=')===1))</span>;const percentUnits=(<span class="cstat-no" title="statement not covered" >query.endsWith('%'))</span>;const millisecondsUnits=(<span class="cstat-no" title="statement not covered" >query.length&gt;2&amp;&amp;query.endsWith('ms'))</span>;const secondsUnits=(<span class="cstat-no" title="statement not covered" >!millisecondsUnits&amp;&amp;query.endsWith('s'))</span>;let queryNumber=<span class="cstat-no" title="statement not covered" >parseFloat(query);<span class="cstat-no" title="statement not covered" ></span>if(greaterThan||lessThan||equalTo){<span class="cstat-no" title="statement not covered" >if(equalTo&amp;&amp;(greaterThan||lessThan))</span></span>
<span class="cstat-no" title="statement not covered" >queryNumber=parseFloat(query.substring(2));e</span>lse
<span class="cstat-no" title="statement not covered" >queryNumber=parseFloat(query.substring(1));}</span>
const queryNumberMilliseconds=(<span class="cstat-no" title="statement not covered" >secondsUnits?(queryNumber*1000):queryNumber)</span>;<span class="cstat-no" title="statement not covered" >if(!isNaN(queryNumber)&amp;&amp;!(greaterThan||lessThan))</span>
<span class="cstat-no" title="statement not covered" >equalTo=true;c</span>onst matcher=<span class="cstat-no" title="statement not covered" >createPlainTextSearchRegex(query,'i');</span>function <span class="fstat-no" title="function not covered" >matchesQuery(</span>profileDataGridNode){<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=false;<span class="cstat-no" title="statement not covered" >p</span>rofileDataGridNode._searchMatchedTotalColumn=false;<span class="cstat-no" title="statement not covered" >p</span>rofileDataGridNode._searchMatchedFunctionColumn=false;<span class="cstat-no" title="statement not covered" >i</span>f(percentUnits){<span class="cstat-no" title="statement not covered" >if(lessThan){<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.selfPercent&lt;queryNumber)</span></span></span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode.totalPercent&lt;queryNumber)</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedTotalColumn=true;}</span>else <span class="cstat-no" title="statement not covered" >if(greaterThan){<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.selfPercent&gt;queryNumber)</span></span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode.totalPercent&gt;queryNumber)</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedTotalColumn=true;}</span>
<span class="cstat-no" title="statement not covered" >if(equalTo){<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.selfPercent===queryNumber)</span></span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode.totalPercent===queryNumber)</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedTotalColumn=true;}</span>}else <span class="cstat-no" title="statement not covered" >if(millisecondsUnits||secondsUnits){<span class="cstat-no" title="statement not covered" >if(lessThan){<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.self&lt;queryNumberMilliseconds)</span></span></span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode.total&lt;queryNumberMilliseconds)</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedTotalColumn=true;}</span>else <span class="cstat-no" title="statement not covered" >if(greaterThan){<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.self&gt;queryNumberMilliseconds)</span></span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode.total&gt;queryNumberMilliseconds)</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedTotalColumn=true;}</span>
<span class="cstat-no" title="statement not covered" >if(equalTo){<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.self===queryNumberMilliseconds)</span></span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedSelfColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode.total===queryNumberMilliseconds)</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedTotalColumn=true;}</span>}
<span class="cstat-no" title="statement not covered" >if(profileDataGridNode.functionName.match(matcher)||(profileDataGridNode.url&amp;&amp;profileDataGridNode.url.match(matcher)))</span>
<span class="cstat-no" title="statement not covered" >profileDataGridNode._searchMatchedFunctionColumn=true;<span class="cstat-no" title="statement not covered" >i</span>f(profileDataGridNode._searchMatchedSelfColumn||profileDataGridNode._searchMatchedTotalColumn||profileDataGridNode._searchMatchedFunctionColumn){<span class="cstat-no" title="statement not covered" >profileDataGridNode.refresh();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return matchesQuery;}</span>
<span class="fstat-no" title="function not covered" >pe</span>rformSearch(searchConfig,shouldJump,jumpBackwards){<span class="cstat-no" title="statement not covered" >this.searchCanceled();c</span>onst matchesQuery=<span class="cstat-no" title="statement not covered" >this._matchFunction(searchConfig);<span class="cstat-no" title="statement not covered" ></span>if(!matchesQuery)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._searchResults=[];c</span>onst deepSearch=<span class="cstat-no" title="statement not covered" >this.deepSearch;<span class="cstat-no" title="statement not covered" ></span>for(let current=this.children[0];current;current=current.traverseNextNode(!deepSearch,null,!deepSearch)){<span class="cstat-no" title="statement not covered" >if(matchesQuery(current))</span></span>
<span class="cstat-no" title="statement not covered" >this._searchResults.push({profileNode:current});}</span>
<span class="cstat-no" title="statement not covered" >this._searchResultIndex=jumpBackwards?0:this._searchResults.length-1;<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateSearchMatchesCount(this._searchResults.length);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateCurrentMatchIndex(this._searchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >se</span>archCanceled(){<span class="cstat-no" title="statement not covered" >if(this._searchResults){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._searchResults.length;++i){const profileNode=<span class="cstat-no" title="statement not covered" >this._searchResults[i].profileNode;<span class="cstat-no" title="statement not covered" ></span>profileNode._searchMatchedSelfColumn=false;<span class="cstat-no" title="statement not covered" >p</span>rofileNode._searchMatchedTotalColumn=false;<span class="cstat-no" title="statement not covered" >p</span>rofileNode._searchMatchedFunctionColumn=false;<span class="cstat-no" title="statement not covered" >p</span>rofileNode.refresh();}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._searchResults=[];<span class="cstat-no" title="statement not covered" >t</span>his._searchResultIndex=-1;}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToNextSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults||!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._searchResultIndex=(this._searchResultIndex+1)%this._searchResults.length;<span class="cstat-no" title="statement not covered" >t</span>his._jumpToSearchResult(this._searchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToPreviousSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults||!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._searchResultIndex=(this._searchResultIndex-1+this._searchResults.length)%this._searchResults.length;<span class="cstat-no" title="statement not covered" >t</span>his._jumpToSearchResult(this._searchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsCaseSensitiveSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsRegexSearch(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >_j</span>umpToSearchResult(index){const searchResult=<span class="cstat-no" title="statement not covered" >this._searchResults[index];<span class="cstat-no" title="statement not covered" ></span>if(!searchResult)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst profileNode=<span class="cstat-no" title="statement not covered" >searchResult.profileNode;<span class="cstat-no" title="statement not covered" ></span>profileNode.revealAndSelect();<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateCurrentMatchIndex(index);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridTree.propertyComparators=[{},{}];<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileDataGridNode.Formatter=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileDataGridNode.Formatter.prototype={formatValue(value,node){},formatPercent(value,node){},linkifyNode(node){}};;<span class="cstat-no" title="statement not covered" ></span>Profiler.BottomUpProfileDataGridNode=class extends Profiler.ProfileDataGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileNode,owningTree){<span class="cstat-no" title="statement not covered" >super(profileNode,owningTree,!!profileNode.parent&amp;&amp;!!profileNode.parent.parent);<span class="cstat-no" title="statement not covered" >t</span>his._remainingNodeInfos=[];}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _sharedPopulate(container){const remainingNodeInfos=<span class="cstat-no" title="statement not covered" >container._remainingNodeInfos;</span>const count=<span class="cstat-no" title="statement not covered" >remainingNodeInfos.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index){const nodeInfo=<span class="cstat-no" title="statement not covered" >remainingNodeInfos[index];</span>const ancestor=<span class="cstat-no" title="statement not covered" >nodeInfo.ancestor;</span>const focusNode=<span class="cstat-no" title="statement not covered" >nodeInfo.focusNode;</span>let child=<span class="cstat-no" title="statement not covered" >container.findChild(ancestor);<span class="cstat-no" title="statement not covered" ></span>if(child){const totalAccountedFor=<span class="cstat-no" title="statement not covered" >nodeInfo.totalAccountedFor;<span class="cstat-no" title="statement not covered" ></span>child.self+=focusNode.self;<span class="cstat-no" title="statement not covered" >i</span>f(!totalAccountedFor)</span></span></span>
<span class="cstat-no" title="statement not covered" >child.total+=focusNode.total;}</span>else{<span class="cstat-no" title="statement not covered" >child=new Profiler.BottomUpProfileDataGridNode(ancestor,(container.tree));<span class="cstat-no" title="statement not covered" >i</span>f(ancestor!==focusNode){<span class="cstat-no" title="statement not covered" >child.self=focusNode.self;<span class="cstat-no" title="statement not covered" >c</span>hild.total=focusNode.total;}</span></span>
<span class="cstat-no" title="statement not covered" >container.appendChild(child);}</span>
const parent=<span class="cstat-no" title="statement not covered" >ancestor.parent;<span class="cstat-no" title="statement not covered" ></span>if(parent&amp;&amp;parent.parent){<span class="cstat-no" title="statement not covered" >nodeInfo.ancestor=parent;<span class="cstat-no" title="statement not covered" >c</span>hild._remainingNodeInfos.push(nodeInfo);}</span>}</span>
<span class="cstat-no" title="statement not covered" >delete container._remainingNodeInfos;}</span>
<span class="fstat-no" title="function not covered" >_t</span>akePropertiesFromProfileDataGridNode(profileDataGridNode){<span class="cstat-no" title="statement not covered" >this.save();<span class="cstat-no" title="statement not covered" >t</span>his.self=profileDataGridNode.self;<span class="cstat-no" title="statement not covered" >t</span>his.total=profileDataGridNode.total;}</span>
<span class="fstat-no" title="function not covered" >_k</span>eepOnlyChild(child){<span class="cstat-no" title="statement not covered" >this.save();<span class="cstat-no" title="statement not covered" >t</span>his.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his.appendChild(child);}</span>
<span class="fstat-no" title="function not covered" >_e</span>xclude(aCallUID){<span class="cstat-no" title="statement not covered" >if(this._remainingNodeInfos)</span>
<span class="cstat-no" title="statement not covered" >this.populate();<span class="cstat-no" title="statement not covered" >t</span>his.save();c</span>onst children=<span class="cstat-no" title="statement not covered" >this.children;</span>let index=<span class="cstat-no" title="statement not covered" >this.children.length;<span class="cstat-no" title="statement not covered" ></span>while(index--)</span>
<span class="cstat-no" title="statement not covered" >children[index]._exclude(aCallUID);c</span>onst child=<span class="cstat-no" title="statement not covered" >this.childrenByCallUID.get(aCallUID);<span class="cstat-no" title="statement not covered" ></span>if(child)</span>
<span class="cstat-no" title="statement not covered" >this.merge(child,true);}</span>
<span class="fstat-no" title="function not covered" >re</span>store(){<span class="cstat-no" title="statement not covered" >super.restore();<span class="cstat-no" title="statement not covered" >i</span>f(!this.children.length)</span>
<span class="cstat-no" title="statement not covered" >this.setHasChildren(this._willHaveChildren(this.profileNode));}</span>
<span class="fstat-no" title="function not covered" >me</span>rge(child,shouldAbsorb){<span class="cstat-no" title="statement not covered" >this.self-=child.self;<span class="cstat-no" title="statement not covered" >s</span>uper.merge(child,shouldAbsorb);}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateChildren(){<span class="cstat-no" title="statement not covered" >Profiler.BottomUpProfileDataGridNode._sharedPopulate(this);}</span>
<span class="fstat-no" title="function not covered" >_w</span>illHaveChildren(profileNode){<span class="cstat-no" title="statement not covered" >return!!(profileNode.parent&amp;&amp;profileNode.parent.parent);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.BottomUpProfileDataGridTree=class extends Profiler.ProfileDataGridTree{<span class="fstat-no" title="function not covered" >co</span>nstructor(formatter,searchableView,rootProfileNode,total){<span class="cstat-no" title="statement not covered" >super(formatter,searchableView,total);<span class="cstat-no" title="statement not covered" >t</span>his.deepSearch=false;l</span>et profileNodeUIDs=<span class="cstat-no" title="statement not covered" >0;</span>const profileNodeGroups=<span class="cstat-no" title="statement not covered" >[[],[rootProfileNode]];</span>const visitedProfileNodesForCallUID=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>this._remainingNodeInfos=[];<span class="cstat-no" title="statement not covered" >f</span>or(let profileNodeGroupIndex=0;profileNodeGroupIndex&lt;profileNodeGroups.length;++profileNodeGroupIndex){const parentProfileNodes=<span class="cstat-no" title="statement not covered" >profileNodeGroups[profileNodeGroupIndex];</span>const profileNodes=<span class="cstat-no" title="statement not covered" >profileNodeGroups[++profileNodeGroupIndex];</span>const count=<span class="cstat-no" title="statement not covered" >profileNodes.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index){const profileNode=<span class="cstat-no" title="statement not covered" >profileNodes[index];<span class="cstat-no" title="statement not covered" ></span>if(!profileNode.UID)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >profileNode.UID=++profileNodeUIDs;<span class="cstat-no" title="statement not covered" >i</span>f(profileNode.parent){let visitedNodes=<span class="cstat-no" title="statement not covered" >visitedProfileNodesForCallUID.get(profileNode.callUID);</span>let totalAccountedFor=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(!visitedNodes){<span class="cstat-no" title="statement not covered" >visitedNodes=new Set();<span class="cstat-no" title="statement not covered" >v</span>isitedProfileNodesForCallUID.set(profileNode.callUID,visitedNodes);}</span>else{const parentCount=<span class="cstat-no" title="statement not covered" >parentProfileNodes.length;<span class="cstat-no" title="statement not covered" ></span>for(let parentIndex=0;parentIndex&lt;parentCount;++parentIndex){<span class="cstat-no" title="statement not covered" >if(visitedNodes.has(parentProfileNodes[parentIndex].UID)){<span class="cstat-no" title="statement not covered" >totalAccountedFor=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >visitedNodes.add(profileNode.UID);<span class="cstat-no" title="statement not covered" >t</span>his._remainingNodeInfos.push({ancestor:profileNode,focusNode:profileNode,totalAccountedFor:totalAccountedFor});}</span>
const children=<span class="cstat-no" title="statement not covered" >profileNode.children;<span class="cstat-no" title="statement not covered" ></span>if(children.length){<span class="cstat-no" title="statement not covered" >profileNodeGroups.push(parentProfileNodes.concat([profileNode]));<span class="cstat-no" title="statement not covered" >p</span>rofileNodeGroups.push(children);}</span>}</span>}
<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridNode.populate(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>
<span class="fstat-no" title="function not covered" >fo</span>cus(profileDataGridNode){<span class="cstat-no" title="statement not covered" >if(!profileDataGridNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.save();l</span>et currentNode=<span class="cstat-no" title="statement not covered" >profileDataGridNode;</span>let focusNode=<span class="cstat-no" title="statement not covered" >profileDataGridNode;<span class="cstat-no" title="statement not covered" ></span>while(currentNode.parent&amp;&amp;(currentNode instanceof Profiler.ProfileDataGridNode)){<span class="cstat-no" title="statement not covered" >currentNode._takePropertiesFromProfileDataGridNode(profileDataGridNode);<span class="cstat-no" title="statement not covered" >f</span>ocusNode=currentNode;<span class="cstat-no" title="statement not covered" >c</span>urrentNode=currentNode.parent;<span class="cstat-no" title="statement not covered" >i</span>f(currentNode instanceof Profiler.ProfileDataGridNode)</span></span>
<span class="cstat-no" title="statement not covered" >currentNode._keepOnlyChild(focusNode);}</span>
<span class="cstat-no" title="statement not covered" >this.children=[focusNode];<span class="cstat-no" title="statement not covered" >t</span>his.total=profileDataGridNode.total;}</span>
<span class="fstat-no" title="function not covered" >ex</span>clude(profileDataGridNode){<span class="cstat-no" title="statement not covered" >if(!profileDataGridNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.save();c</span>onst excludedCallUID=<span class="cstat-no" title="statement not covered" >profileDataGridNode.callUID;</span>const excludedTopLevelChild=<span class="cstat-no" title="statement not covered" >this.childrenByCallUID.get(excludedCallUID);<span class="cstat-no" title="statement not covered" ></span>if(excludedTopLevelChild)</span>
<span class="cstat-no" title="statement not covered" >this.children.remove(excludedTopLevelChild);c</span>onst children=<span class="cstat-no" title="statement not covered" >this.children;</span>const count=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;count;++index)</span>
<span class="cstat-no" title="statement not covered" >children[index]._exclude(excludedCallUID);<span class="cstat-no" title="statement not covered" >i</span>f(this.lastComparator)</span>
<span class="cstat-no" title="statement not covered" >this.sort(this.lastComparator,true);}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateChildren(){<span class="cstat-no" title="statement not covered" >Profiler.BottomUpProfileDataGridNode._sharedPopulate(this);}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.TopDownProfileDataGridNode=class extends Profiler.ProfileDataGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileNode,owningTree){const hasChildren=<span class="cstat-no" title="statement not covered" >!!(profileNode.children&amp;&amp;profileNode.children.length);<span class="cstat-no" title="statement not covered" ></span>super(profileNode,owningTree,hasChildren);<span class="cstat-no" title="statement not covered" >t</span>his._remainingChildren=profileNode.children;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _sharedPopulate(container){const children=<span class="cstat-no" title="statement not covered" >container._remainingChildren;</span>const childrenLength=<span class="cstat-no" title="statement not covered" >children.length;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;childrenLength;++i){<span class="cstat-no" title="statement not covered" >container.appendChild(new Profiler.TopDownProfileDataGridNode(children[i],(container.tree)));}</span></span>
<span class="cstat-no" title="statement not covered" >container._remainingChildren=null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _excludeRecursively(container,aCallUID){<span class="cstat-no" title="statement not covered" >if(container._remainingChildren)</span>
<span class="cstat-no" title="statement not covered" >container.populate();<span class="cstat-no" title="statement not covered" >c</span>ontainer.save();c</span>onst children=<span class="cstat-no" title="statement not covered" >container.children;</span>let index=<span class="cstat-no" title="statement not covered" >container.children.length;<span class="cstat-no" title="statement not covered" ></span>while(index--)</span>
<span class="cstat-no" title="statement not covered" >Profiler.TopDownProfileDataGridNode._excludeRecursively(children[index],aCallUID);c</span>onst child=<span class="cstat-no" title="statement not covered" >container.childrenByCallUID.get(aCallUID);<span class="cstat-no" title="statement not covered" ></span>if(child)</span>
<span class="cstat-no" title="statement not covered" >Profiler.ProfileDataGridNode.merge(container,child,true);}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateChildren(){<span class="cstat-no" title="statement not covered" >Profiler.TopDownProfileDataGridNode._sharedPopulate(this);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.TopDownProfileDataGridTree=class extends Profiler.ProfileDataGridTree{<span class="fstat-no" title="function not covered" >co</span>nstructor(formatter,searchableView,rootProfileNode,total){<span class="cstat-no" title="statement not covered" >super(formatter,searchableView,total);<span class="cstat-no" title="statement not covered" >t</span>his._remainingChildren=rootProfileNode.children;<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileDataGridNode.populate(this);}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>cus(profileDataGridNode){<span class="cstat-no" title="statement not covered" >if(!profileDataGridNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.save();<span class="cstat-no" title="statement not covered" >p</span>rofileDataGridNode.savePosition();<span class="cstat-no" title="statement not covered" >t</span>his.children=[profileDataGridNode];<span class="cstat-no" title="statement not covered" >t</span>his.total=profileDataGridNode.total;}</span>
<span class="fstat-no" title="function not covered" >ex</span>clude(profileDataGridNode){<span class="cstat-no" title="statement not covered" >if(!profileDataGridNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.save();<span class="cstat-no" title="statement not covered" >P</span>rofiler.TopDownProfileDataGridNode._excludeRecursively(this,profileDataGridNode.callUID);<span class="cstat-no" title="statement not covered" >i</span>f(this.lastComparator)</span>
<span class="cstat-no" title="statement not covered" >this.sort(this.lastComparator,true);}</span>
<span class="fstat-no" title="function not covered" >re</span>store(){<span class="cstat-no" title="statement not covered" >if(!this._savedChildren)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.children[0].restorePosition();<span class="cstat-no" title="statement not covered" >s</span>uper.restore();}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateChildren(){<span class="cstat-no" title="statement not covered" >Profiler.TopDownProfileDataGridNode._sharedPopulate(this);}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.ProfileFlameChartDataProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >PerfUI.FlameChartDataProvider.call(this);<span class="cstat-no" title="statement not covered" >t</span>his._colorGenerator=Profiler.ProfileFlameChartDataProvider.colorGenerator();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic colorGenerator(){<span class="cstat-no" title="statement not covered" >if(!Profiler.ProfileFlameChartDataProvider._colorGenerator){const colorGenerator=<span class="cstat-no" title="statement not covered" >new Common.Color.Generator({min:30,max:330},{min:50,max:80,count:5},{min:80,max:90,count:3});<span class="cstat-no" title="statement not covered" ></span>colorGenerator.setColorForID('(idle)','hsl(0, 0%, 94%)');<span class="cstat-no" title="statement not covered" >c</span>olorGenerator.setColorForID('(program)','hsl(0, 0%, 80%)');<span class="cstat-no" title="statement not covered" >c</span>olorGenerator.setColorForID('(garbage collector)','hsl(0, 0%, 80%)');<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileFlameChartDataProvider._colorGenerator=colorGenerator;}</span></span>
<span class="cstat-no" title="statement not covered" >return Profiler.ProfileFlameChartDataProvider._colorGenerator;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._cpuProfile.profileStartTime;}</span>
<span class="fstat-no" title="function not covered" >to</span>talTime(){<span class="cstat-no" title="statement not covered" >return this._cpuProfile.profileHead.total;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Number.preciseMillisToString(value,precision);}</span>
<span class="fstat-no" title="function not covered" >ma</span>xStackDepth(){<span class="cstat-no" title="statement not covered" >return this._maxStackDepth;}</span>
<span class="fstat-no" title="function not covered" >ti</span>melineData(){<span class="cstat-no" title="statement not covered" >return this._timelineData||this._calculateTimelineData();}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateTimelineData(){<span class="cstat-no" title="statement not covered" >throw'Not implemented.';}</span>
<span class="fstat-no" title="function not covered" >pr</span>epareHighlightedEntryInfo(entryIndex){<span class="cstat-no" title="statement not covered" >throw'Not implemented.';}</span>
<span class="fstat-no" title="function not covered" >ca</span>nJumpToEntry(entryIndex){<span class="cstat-no" title="statement not covered" >return this._entryNodes[entryIndex].scriptId!=='0';}</span>
<span class="fstat-no" title="function not covered" >en</span>tryTitle(entryIndex){const node=<span class="cstat-no" title="statement not covered" >this._entryNodes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>return UI.beautifyFunctionName(node.functionName);}</span>
<span class="fstat-no" title="function not covered" >en</span>tryFont(entryIndex){<span class="cstat-no" title="statement not covered" >if(!this._font){<span class="cstat-no" title="statement not covered" >this._font='11px '+Host.fontFamily();<span class="cstat-no" title="statement not covered" >t</span>his._boldFont='bold '+this._font;}</span></span>
const node=<span class="cstat-no" title="statement not covered" >this._entryNodes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>return node.deoptReason?this._boldFont:this._font;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryColor(entryIndex){const node=<span class="cstat-no" title="statement not covered" >this._entryNodes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>return this._colorGenerator.colorForID(node.url||(node.scriptId!=='0'?node.scriptId:node.functionName));}</span>
<span class="fstat-no" title="function not covered" >de</span>corateEntry(entryIndex,context,text,barX,barY,barWidth,barHeight){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rceDecoration(entryIndex){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >te</span>xtColor(entryIndex){<span class="cstat-no" title="statement not covered" >return'#333';}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileFlameChart=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(searchableView,dataProvider){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.id='cpu-flame-chart';<span class="cstat-no" title="statement not covered" >t</span>his._searchableView=searchableView;<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane=new Profiler.CPUProfileFlameChart.OverviewPane(dataProvider);<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.show(this.element);<span class="cstat-no" title="statement not covered" >t</span>his._mainPane=new PerfUI.FlameChart(dataProvider,this._overviewPane);<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.setBarHeight(15);<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.setTextBaseline(4);<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.setTextPadding(2);<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.show(this.element);<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.addEventListener(PerfUI.FlameChart.Events.EntrySelected,this._onEntrySelected,this);<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.addEventListener(PerfUI.OverviewGrid.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._dataProvider=dataProvider;<span class="cstat-no" title="statement not covered" >t</span>his._searchResults=[];}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>cus(){<span class="cstat-no" title="statement not covered" >this._mainPane.focus();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(event){const windowLeft=<span class="cstat-no" title="statement not covered" >event.data.windowTimeLeft;</span>const windowRight=<span class="cstat-no" title="statement not covered" >event.data.windowTimeRight;<span class="cstat-no" title="statement not covered" ></span>this._mainPane.setWindowTimes(windowLeft,windowRight,true);}</span>
<span class="fstat-no" title="function not covered" >se</span>lectRange(timeLeft,timeRight){<span class="cstat-no" title="statement not covered" >this._overviewPane._selectRange(timeLeft,timeRight);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nEntrySelected(event){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(PerfUI.FlameChart.Events.EntrySelected,event.data);}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >this._overviewPane.update();<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.update();}</span>
<span class="fstat-no" title="function not covered" >pe</span>rformSearch(searchConfig,shouldJump,jumpBackwards){const matcher=<span class="cstat-no" title="statement not covered" >createPlainTextSearchRegex(searchConfig.query,searchConfig.caseSensitive?'':'i');</span>const selectedEntryIndex=<span class="cstat-no" title="statement not covered" >this._searchResultIndex!==-1?this._searchResults[this._searchResultIndex]:-1;<span class="cstat-no" title="statement not covered" ></span>this._searchResults=[];c</span>onst entriesCount=<span class="cstat-no" title="statement not covered" >this._dataProvider._entryNodes.length;<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;entriesCount;++index){<span class="cstat-no" title="statement not covered" >if(this._dataProvider.entryTitle(index).match(matcher))</span></span>
<span class="cstat-no" title="statement not covered" >this._searchResults.push(index);}</span>
<span class="cstat-no" title="statement not covered" >if(this._searchResults.length){<span class="cstat-no" title="statement not covered" >this._searchResultIndex=this._searchResults.indexOf(selectedEntryIndex);<span class="cstat-no" title="statement not covered" >i</span>f(this._searchResultIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >this._searchResultIndex=jumpBackwards?this._searchResults.length-1:0;<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.setSelectedEntry(this._searchResults[this._searchResultIndex]);}</span>else{<span class="cstat-no" title="statement not covered" >this.searchCanceled();}</span>
<span class="cstat-no" title="statement not covered" >this._searchableView.updateSearchMatchesCount(this._searchResults.length);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateCurrentMatchIndex(this._searchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >se</span>archCanceled(){<span class="cstat-no" title="statement not covered" >this._mainPane.setSelectedEntry(-1);<span class="cstat-no" title="statement not covered" >t</span>his._searchResults=[];<span class="cstat-no" title="statement not covered" >t</span>his._searchResultIndex=-1;}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToNextSearchResult(){<span class="cstat-no" title="statement not covered" >this._searchResultIndex=(this._searchResultIndex+1)%this._searchResults.length;<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.setSelectedEntry(this._searchResults[this._searchResultIndex]);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateCurrentMatchIndex(this._searchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToPreviousSearchResult(){<span class="cstat-no" title="statement not covered" >this._searchResultIndex=(this._searchResultIndex-1+this._searchResults.length)%this._searchResults.length;<span class="cstat-no" title="statement not covered" >t</span>his._mainPane.setSelectedEntry(this._searchResults[this._searchResultIndex]);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateCurrentMatchIndex(this._searchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsCaseSensitiveSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsRegexSearch(){<span class="cstat-no" title="statement not covered" >return false;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileFlameChart.OverviewCalculator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataProvider){<span class="cstat-no" title="statement not covered" >this._dataProvider=dataProvider;}</span></span>
<span class="fstat-no" title="function not covered" >_u</span>pdateBoundaries(overviewPane){<span class="cstat-no" title="statement not covered" >this._minimumBoundaries=overviewPane._dataProvider.minimumBoundary();c</span>onst totalTime=<span class="cstat-no" title="statement not covered" >overviewPane._dataProvider.totalTime();<span class="cstat-no" title="statement not covered" ></span>this._maximumBoundaries=this._minimumBoundaries+totalTime;<span class="cstat-no" title="statement not covered" >t</span>his._xScaleFactor=overviewPane._overviewContainer.clientWidth/totalTime;}</span>
<span class="fstat-no" title="function not covered" >co</span>mputePosition(time){<span class="cstat-no" title="statement not covered" >return(time-this._minimumBoundaries)*this._xScaleFactor;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return this._dataProvider.formatValue(value-this._minimumBoundaries,precision);}</span>
<span class="fstat-no" title="function not covered" >ma</span>ximumBoundary(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundaries;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundaries;}</span>
<span class="fstat-no" title="function not covered" >ze</span>roTime(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundaries;}</span>
<span class="fstat-no" title="function not covered" >bo</span>undarySpan(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundaries-this._minimumBoundaries;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileFlameChart.OverviewPane=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataProvider){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('cpu-profile-flame-chart-overview-pane');<span class="cstat-no" title="statement not covered" >t</span>his._overviewContainer=this.element.createChild('div','cpu-profile-flame-chart-overview-container');<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid=new PerfUI.OverviewGrid('cpu-profile-flame-chart');<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.element.classList.add('fill');<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas=this._overviewContainer.createChild('canvas','cpu-profile-flame-chart-overview-canvas');<span class="cstat-no" title="statement not covered" >t</span>his._overviewContainer.appendChild(this._overviewGrid.element);<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator=new Profiler.CPUProfileFlameChart.OverviewCalculator(dataProvider);<span class="cstat-no" title="statement not covered" >t</span>his._dataProvider=dataProvider;<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.addEventListener(PerfUI.OverviewGrid.Events.WindowChanged,this._onWindowChanged,this);}</span></span>
<span class="fstat-no" title="function not covered" >wi</span>ndowChanged(windowStartTime,windowEndTime){<span class="cstat-no" title="statement not covered" >this._selectRange(windowStartTime,windowEndTime);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateRangeSelection(startTime,endTime){}
<span class="fstat-no" title="function not covered" >up</span>dateSelectedGroup(flameChart,group){}
<span class="fstat-no" title="function not covered" >_s</span>electRange(timeLeft,timeRight){const startTime=<span class="cstat-no" title="statement not covered" >this._dataProvider.minimumBoundary();</span>const totalTime=<span class="cstat-no" title="statement not covered" >this._dataProvider.totalTime();<span class="cstat-no" title="statement not covered" ></span>this._overviewGrid.setWindow((timeLeft-startTime)/totalTime,(timeRight-startTime)/totalTime);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(event){const startTime=<span class="cstat-no" title="statement not covered" >this._dataProvider.minimumBoundary();</span>const totalTime=<span class="cstat-no" title="statement not covered" >this._dataProvider.totalTime();</span>const data=<span class="cstat-no" title="statement not covered" >{windowTimeLeft:startTime+this._overviewGrid.windowLeft()*totalTime,windowTimeRight:startTime+this._overviewGrid.windowRight()*totalTime};<span class="cstat-no" title="statement not covered" ></span>this.dispatchEventToListeners(PerfUI.OverviewGrid.Events.WindowChanged,data);}</span>
<span class="fstat-no" title="function not covered" >_t</span>imelineData(){<span class="cstat-no" title="statement not covered" >return this._dataProvider.timelineData();}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >this._scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_s</span>cheduleUpdate(){<span class="cstat-no" title="statement not covered" >if(this._updateTimerId)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimerId=this.element.window().requestAnimationFrame(this.update.bind(this));}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >this._updateTimerId=0;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._resetCanvas(this._overviewContainer.clientWidth,this._overviewContainer.clientHeight-PerfUI.FlameChart.HeaderHeight);<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator._updateBoundaries(this);<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.updateDividers(this._overviewCalculator);<span class="cstat-no" title="statement not covered" >t</span>his._drawOverviewCanvas();}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawOverviewCanvas(){const canvasWidth=<span class="cstat-no" title="statement not covered" >this._overviewCanvas.width;</span>const canvasHeight=<span class="cstat-no" title="statement not covered" >this._overviewCanvas.height;</span>const drawData=<span class="cstat-no" title="statement not covered" >this._calculateDrawData(canvasWidth);</span>const context=<span class="cstat-no" title="statement not covered" >this._overviewCanvas.getContext('2d');</span>const ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;</span>const offsetFromBottom=<span class="cstat-no" title="statement not covered" >ratio;</span>const lineWidth=<span class="cstat-no" title="statement not covered" >1;</span>const yScaleFactor=<span class="cstat-no" title="statement not covered" >canvasHeight/(this._dataProvider.maxStackDepth()*1.1);<span class="cstat-no" title="statement not covered" ></span>context.lineWidth=lineWidth;<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(0.5,0.5);<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='rgba(20,0,0,0.4)';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='rgba(214,225,254,0.8)';<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(-lineWidth,canvasHeight+lineWidth);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(-lineWidth,Math.round(canvasHeight-drawData[0]*yScaleFactor-offsetFromBottom));l</span>et value;<span class="cstat-no" title="statement not covered" >for(let x=0;x&lt;canvasWidth;++x){<span class="cstat-no" title="statement not covered" >value=Math.round(canvasHeight-drawData[x]*yScaleFactor-offsetFromBottom);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(x,value);}</span></span>
<span class="cstat-no" title="statement not covered" >context.lineTo(canvasWidth+lineWidth,value);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(canvasWidth+lineWidth,canvasHeight+lineWidth);<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateDrawData(width){const dataProvider=<span class="cstat-no" title="statement not covered" >this._dataProvider;</span>const timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();</span>const entryStartTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes;</span>const entryTotalTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryTotalTimes;</span>const entryLevels=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels;</span>const length=<span class="cstat-no" title="statement not covered" >entryStartTimes.length;</span>const minimumBoundary=<span class="cstat-no" title="statement not covered" >this._dataProvider.minimumBoundary();</span>const drawData=<span class="cstat-no" title="statement not covered" >new Uint8Array(width);</span>const scaleFactor=<span class="cstat-no" title="statement not covered" >width/dataProvider.totalTime();<span class="cstat-no" title="statement not covered" ></span>for(let entryIndex=0;entryIndex&lt;length;++entryIndex){const start=<span class="cstat-no" title="statement not covered" >Math.floor((entryStartTimes[entryIndex]-minimumBoundary)*scaleFactor);</span>const finish=<span class="cstat-no" title="statement not covered" >Math.floor((entryStartTimes[entryIndex]-minimumBoundary+entryTotalTimes[entryIndex])*scaleFactor);<span class="cstat-no" title="statement not covered" ></span>for(let x=start;x&lt;=finish;++x)</span></span>
<span class="cstat-no" title="statement not covered" >drawData[x]=Math.max(drawData[x],entryLevels[entryIndex]+1);}</span>
<span class="cstat-no" title="statement not covered" >return drawData;}</span>
<span class="fstat-no" title="function not covered" >_r</span>esetCanvas(width,height){const ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>this._overviewCanvas.width=width*ratio;<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas.height=height*ratio;<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas.style.width=width+'px';<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas.style.height=height+'px';}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileView=class extends Profiler.ProfileView{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileHeader){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._profileHeader=profileHeader;<span class="cstat-no" title="statement not covered" >t</span>his.initialize(new Profiler.CPUProfileView.NodeFormatter(this));c</span>onst profile=<span class="cstat-no" title="statement not covered" >profileHeader.profileModel();<span class="cstat-no" title="statement not covered" ></span>this.adjustedTotal=profile.profileHead.total;<span class="cstat-no" title="statement not covered" >t</span>his.adjustedTotal-=profile.idleNode?profile.idleNode.total:0;<span class="cstat-no" title="statement not covered" >t</span>his.setProfile(profile);}</span></span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >super.wasShown();c</span>onst lineLevelProfile=<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile.instance();<span class="cstat-no" title="statement not covered" ></span>lineLevelProfile.reset();<span class="cstat-no" title="statement not covered" >l</span>ineLevelProfile.appendCPUProfile(this._profileHeader.profileModel());}</span>
<span class="fstat-no" title="function not covered" >co</span>lumnHeader(columnId){<span class="cstat-no" title="statement not covered" >switch(columnId){case'self':<span class="cstat-no" title="statement not covered" >return Common.UIString('Self Time');c</span>ase'total':<span class="cstat-no" title="statement not covered" >return Common.UIString('Total Time');}</span></span>
<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateFlameChartDataProvider(){<span class="cstat-no" title="statement not covered" >return new Profiler.CPUFlameChartDataProvider(this._profileHeader.profileModel(),this._profileHeader._cpuProfilerModel);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileType=class extends Profiler.ProfileType{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Profiler.CPUProfileType.TypeId,Common.UIString('Record JavaScript CPU Profile'));<span class="cstat-no" title="statement not covered" >t</span>his._recording=false;<span class="cstat-no" title="statement not covered" >P</span>rofiler.CPUProfileType.instance=this;<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addModelListener(SDK.CPUProfilerModel,SDK.CPUProfilerModel.Events.ConsoleProfileFinished,this._consoleProfileFinished,this);}</span></span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecorded(){<span class="cstat-no" title="statement not covered" >return(super.profileBeingRecorded());}</span>
<span class="fstat-no" title="function not covered" >ty</span>peName(){<span class="cstat-no" title="statement not covered" >return'CPU';}</span>
<span class="fstat-no" title="function not covered" >fi</span>leExtension(){<span class="cstat-no" title="statement not covered" >return'.cpuprofile';}</span>
<span class="fstat-no" title="function not covered" >ge</span>t buttonTooltip(){<span class="cstat-no" title="statement not covered" >return this._recording?Common.UIString('Stop CPU profiling'):Common.UIString('Start CPU profiling');}</span>
<span class="fstat-no" title="function not covered" >bu</span>ttonClicked(){<span class="cstat-no" title="statement not covered" >if(this._recording){<span class="cstat-no" title="statement not covered" >this._stopRecordingProfile();<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>else{<span class="cstat-no" title="statement not covered" >this._startRecordingProfile();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}</span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return Common.UIString('CPU PROFILES');}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return Common.UIString('CPU profiles show where the execution time is spent in your page\'s JavaScript functions.');}</span>
<span class="fstat-no" title="function not covered" >_c</span>onsoleProfileFinished(event){const data=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const cpuProfile=(<span class="cstat-no" title="statement not covered" >data.cpuProfile)</span>;const profile=<span class="cstat-no" title="statement not covered" >new Profiler.CPUProfileHeader(data.cpuProfilerModel,this,data.title);<span class="cstat-no" title="statement not covered" ></span>profile.setProtocolProfile(cpuProfile);<span class="cstat-no" title="statement not covered" >t</span>his.addProfile(profile);}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartRecordingProfile(){const cpuProfilerModel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(SDK.CPUProfilerModel);<span class="cstat-no" title="statement not covered" ></span>if(this.profileBeingRecorded()||!cpuProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst profile=<span class="cstat-no" title="statement not covered" >new Profiler.CPUProfileHeader(cpuProfilerModel,this);<span class="cstat-no" title="statement not covered" ></span>this.setProfileBeingRecorded(profile);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.suspendAllTargets();<span class="cstat-no" title="statement not covered" >t</span>his.addProfile(profile);<span class="cstat-no" title="statement not covered" >p</span>rofile.updateStatus(Common.UIString('Recording\u2026'));<span class="cstat-no" title="statement not covered" >t</span>his._recording=true;<span class="cstat-no" title="statement not covered" >c</span>puProfilerModel.startRecording();<span class="cstat-no" title="statement not covered" >H</span>ost.userMetrics.actionTaken(Host.UserMetrics.Action.ProfilesCPUProfileTaken);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _stopRecordingProfile(){<span class="cstat-no" title="statement not covered" >this._recording=false;<span class="cstat-no" title="statement not covered" >i</span>f(!this.profileBeingRecorded()||!this.profileBeingRecorded()._cpuProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst profile=<span class="cstat-no" title="statement not covered" >await this.profileBeingRecorded()._cpuProfilerModel.stopRecording();</span>const recordedProfile=<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded();<span class="cstat-no" title="statement not covered" ></span>if(recordedProfile){<span class="cstat-no" title="statement not covered" >console.assert(profile);<span class="cstat-no" title="statement not covered" >r</span>ecordedProfile.setProtocolProfile(profile);<span class="cstat-no" title="statement not covered" >r</span>ecordedProfile.updateStatus('');<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(null);}</span></span>
<span class="cstat-no" title="statement not covered" >await SDK.targetManager.resumeAllTargets();<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.ProfileType.Events.ProfileComplete,recordedProfile);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProfileLoadedFromFile(title){<span class="cstat-no" title="statement not covered" >return new Profiler.CPUProfileHeader(null,this,title);}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecordedRemoved(){<span class="cstat-no" title="statement not covered" >this._stopRecordingProfile();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileType.TypeId='CPU';<span class="cstat-no" title="statement not covered" >P</span>rofiler.CPUProfileHeader=class extends Profiler.WritableProfileHeader{<span class="fstat-no" title="function not covered" >co</span>nstructor(cpuProfilerModel,type,title){<span class="cstat-no" title="statement not covered" >super(cpuProfilerModel&amp;&amp;cpuProfilerModel.debuggerModel(),type,title);<span class="cstat-no" title="statement not covered" >t</span>his._cpuProfilerModel=cpuProfilerModel;}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateView(){<span class="cstat-no" title="statement not covered" >return new Profiler.CPUProfileView(this);}</span>
<span class="fstat-no" title="function not covered" >pr</span>otocolProfile(){<span class="cstat-no" title="statement not covered" >return this._protocolProfile;}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileModel(){<span class="cstat-no" title="statement not covered" >return this._profileModel;}</span>
<span class="fstat-no" title="function not covered" >se</span>tProfile(profile){<span class="cstat-no" title="statement not covered" >this._profileModel=new SDK.CPUProfileDataModel(profile);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUProfileView.NodeFormatter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileView){<span class="cstat-no" title="statement not covered" >this._profileView=profileView;}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value){<span class="cstat-no" title="statement not covered" >return Common.UIString('%.1f\xa0ms',value);}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatPercent(value,node){<span class="cstat-no" title="statement not covered" >return node.profileNode===this._profileView.profile().idleNode?'':Common.UIString('%.2f\xa0%%',value);}</span>
<span class="fstat-no" title="function not covered" >li</span>nkifyNode(node){const cpuProfilerModel=<span class="cstat-no" title="statement not covered" >this._profileView._profileHeader._cpuProfilerModel;<span class="cstat-no" title="statement not covered" ></span>return this._profileView.linkifier().maybeLinkifyConsoleCallFrame(cpuProfilerModel?cpuProfilerModel.target():null,node.profileNode.callFrame,'profile-node-file');}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUFlameChartDataProvider=class extends Profiler.ProfileFlameChartDataProvider{<span class="fstat-no" title="function not covered" >co</span>nstructor(cpuProfile,cpuProfilerModel){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._cpuProfile=cpuProfile;<span class="cstat-no" title="statement not covered" >t</span>his._cpuProfilerModel=cpuProfilerModel;}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>alculateTimelineData(){const entries=<span class="cstat-no" title="statement not covered" >[];</span>const stack=<span class="cstat-no" title="statement not covered" >[];</span>let maxDepth=<span class="cstat-no" title="statement not covered" >5;</span>function <span class="fstat-no" title="function not covered" >onOpenFrame(</span>){<span class="cstat-no" title="statement not covered" >stack.push(entries.length);<span class="cstat-no" title="statement not covered" >e</span>ntries.push(null);}</span>
function <span class="fstat-no" title="function not covered" >onCloseFrame(</span>depth,node,startTime,totalTime,selfTime){const index=<span class="cstat-no" title="statement not covered" >stack.pop();<span class="cstat-no" title="statement not covered" ></span>entries[index]=new Profiler.CPUFlameChartDataProvider.ChartEntry(depth,totalTime,startTime,selfTime,node);<span class="cstat-no" title="statement not covered" >m</span>axDepth=Math.max(maxDepth,depth);}</span>
<span class="cstat-no" title="statement not covered" >this._cpuProfile.forEachFrame(onOpenFrame,onCloseFrame);c</span>onst entryNodes=<span class="cstat-no" title="statement not covered" >new Array(entries.length);</span>const entryLevels=<span class="cstat-no" title="statement not covered" >new Uint16Array(entries.length);</span>const entryTotalTimes=<span class="cstat-no" title="statement not covered" >new Float32Array(entries.length);</span>const entrySelfTimes=<span class="cstat-no" title="statement not covered" >new Float32Array(entries.length);</span>const entryStartTimes=<span class="cstat-no" title="statement not covered" >new Float64Array(entries.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;entries.length;++i){const entry=<span class="cstat-no" title="statement not covered" >entries[i];<span class="cstat-no" title="statement not covered" ></span>entryNodes[i]=entry.node;<span class="cstat-no" title="statement not covered" >e</span>ntryLevels[i]=entry.depth;<span class="cstat-no" title="statement not covered" >e</span>ntryTotalTimes[i]=entry.duration;<span class="cstat-no" title="statement not covered" >e</span>ntryStartTimes[i]=entry.startTime;<span class="cstat-no" title="statement not covered" >e</span>ntrySelfTimes[i]=entry.selfTime;}</span></span>
<span class="cstat-no" title="statement not covered" >this._maxStackDepth=maxDepth+1;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=new PerfUI.FlameChart.TimelineData(entryLevels,entryTotalTimes,entryStartTimes,null);<span class="cstat-no" title="statement not covered" >t</span>his._entryNodes=entryNodes;<span class="cstat-no" title="statement not covered" >t</span>his._entrySelfTimes=entrySelfTimes;<span class="cstat-no" title="statement not covered" >r</span>eturn this._timelineData;}</span>
<span class="fstat-no" title="function not covered" >pr</span>epareHighlightedEntryInfo(entryIndex){const timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData;</span>const node=<span class="cstat-no" title="statement not covered" >this._entryNodes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(!node)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst entryInfo=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >pushEntryInfoRow(</span>title,value){<span class="cstat-no" title="statement not covered" >entryInfo.push({title:title,value:value});}</span>
function <span class="fstat-no" title="function not covered" >millisecondsToString(</span>ms){<span class="cstat-no" title="statement not covered" >if(ms===0)</span>
<span class="cstat-no" title="statement not covered" >return'0';<span class="cstat-no" title="statement not covered" >i</span>f(ms&lt;1000)</span>
<span class="cstat-no" title="statement not covered" >return Common.UIString('%.1f\xa0ms',ms);<span class="cstat-no" title="statement not covered" >r</span>eturn Number.secondsToString(ms/1000,true);}</span>
const name=<span class="cstat-no" title="statement not covered" >UI.beautifyFunctionName(node.functionName);<span class="cstat-no" title="statement not covered" ></span>pushEntryInfoRow(Common.UIString('Name'),name);c</span>onst selfTime=<span class="cstat-no" title="statement not covered" >millisecondsToString(this._entrySelfTimes[entryIndex]);</span>const totalTime=<span class="cstat-no" title="statement not covered" >millisecondsToString(timelineData.entryTotalTimes[entryIndex]);<span class="cstat-no" title="statement not covered" ></span>pushEntryInfoRow(Common.UIString('Self time'),selfTime);<span class="cstat-no" title="statement not covered" >p</span>ushEntryInfoRow(Common.UIString('Total time'),totalTime);c</span>onst linkifier=<span class="cstat-no" title="statement not covered" >new Components.Linkifier();</span>const link=<span class="cstat-no" title="statement not covered" >linkifier.maybeLinkifyConsoleCallFrame(this._cpuProfilerModel&amp;&amp;this._cpuProfilerModel.target(),node.callFrame);<span class="cstat-no" title="statement not covered" ></span>if(link)</span>
<span class="cstat-no" title="statement not covered" >pushEntryInfoRow(Common.UIString('URL'),link.textContent);<span class="cstat-no" title="statement not covered" >l</span>inkifier.dispose();<span class="cstat-no" title="statement not covered" >p</span>ushEntryInfoRow(Common.UIString('Aggregated self time'),Number.secondsToString(node.self/1000,true));<span class="cstat-no" title="statement not covered" >p</span>ushEntryInfoRow(Common.UIString('Aggregated total time'),Number.secondsToString(node.total/1000,true));<span class="cstat-no" title="statement not covered" >i</span>f(node.deoptReason)</span>
<span class="cstat-no" title="statement not covered" >pushEntryInfoRow(Common.UIString('Not optimized'),node.deoptReason);<span class="cstat-no" title="statement not covered" >r</span>eturn Profiler.ProfileView.buildPopoverTable(entryInfo);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.CPUFlameChartDataProvider.ChartEntry=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(depth,duration,startTime,selfTime,node){<span class="cstat-no" title="statement not covered" >this.depth=depth;<span class="cstat-no" title="statement not covered" >t</span>his.duration=duration;<span class="cstat-no" title="statement not covered" >t</span>his.startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his.selfTime=selfTime;<span class="cstat-no" title="statement not covered" >t</span>his.node=node;}</span>};;<span class="cstat-no" title="statement not covered" ></span>Profiler.HeapProfileView=class extends Profiler.ProfileView{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileHeader){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._profileHeader=profileHeader;<span class="cstat-no" title="statement not covered" >t</span>his._profileType=profileHeader.profileType();c</span>onst views=<span class="cstat-no" title="statement not covered" >[Profiler.ProfileView.ViewTypes.Flame,Profiler.ProfileView.ViewTypes.Heavy,Profiler.ProfileView.ViewTypes.Tree];</span>const isNativeProfile=<span class="cstat-no" title="statement not covered" >this._profileType.id===Profiler.SamplingNativeHeapProfileType.TypeId||this._profileType.id===Profiler.SamplingNativeHeapSnapshotType.TypeId;<span class="cstat-no" title="statement not covered" ></span>if(isNativeProfile)</span></span>
<span class="cstat-no" title="statement not covered" >views.push(Profiler.ProfileView.ViewTypes.Text);<span class="cstat-no" title="statement not covered" >t</span>his.initialize(new Profiler.HeapProfileView.NodeFormatter(this),views);c</span>onst profile=<span class="cstat-no" title="statement not covered" >new Profiler.SamplingHeapProfileModel(profileHeader._profile||profileHeader.protocolProfile());<span class="cstat-no" title="statement not covered" ></span>this.adjustedTotal=profile.total;<span class="cstat-no" title="statement not covered" >t</span>his.setProfile(profile);<span class="cstat-no" title="statement not covered" >t</span>his._selectedSizeText=new UI.ToolbarText();<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('samplingHeapProfilerTimeline')){<span class="cstat-no" title="statement not covered" >this._timelineOverview=new Profiler.HeapTimelineOverview();<span class="cstat-no" title="statement not covered" >t</span>his._timelineOverview.addEventListener(Profiler.HeapTimelineOverview.IdsRangeChanged,this._onIdsRangeChanged.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._timelineOverview.show(this.element,this.element.firstChild);<span class="cstat-no" title="statement not covered" >t</span>his._timelineOverview.start();<span class="cstat-no" title="statement not covered" >t</span>his._profileType.addEventListener(Profiler.SamplingHeapProfileType.Events.StatsUpdate,this._onStatsUpdate,this);<span class="cstat-no" title="statement not covered" >t</span>his._profileType.once(Profiler.ProfileType.Events.ProfileComplete).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._profileType.removeEventListener(Profiler.SamplingHeapProfileType.Events.StatsUpdate,this._onStatsUpdate,this);<span class="cstat-no" title="statement not covered" >t</span>his._timelineOverview.stop();<span class="cstat-no" title="statement not covered" >t</span>his._timelineOverview.updateGrid();}</span>);}</span>}</span>
<span class="fstat-no" title="function not covered" >sy</span>ncToolbarItems(){<span class="cstat-no" title="statement not covered" >return[...super.syncToolbarItems(),this._selectedSizeText];}</span>
<span class="fstat-no" title="function not covered" >_o</span>nIdsRangeChanged(event){const minId=(<span class="cstat-no" title="statement not covered" >event.data.minId)</span>;const maxId=(<span class="cstat-no" title="statement not covered" >event.data.maxId)</span>;<span class="cstat-no" title="statement not covered" >this._selectedSizeText.setText(ls`Selected size: ${Number.bytesToString(event.data.size)}`);<span class="cstat-no" title="statement not covered" >t</span>his._setSelectionRange(minId,maxId);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etSelectionRange(minId,maxId){const profile=<span class="cstat-no" title="statement not covered" >new Profiler.SamplingHeapProfileModel(this._profileHeader._profile||this._profileHeader.protocolProfile(),minId,maxId);<span class="cstat-no" title="statement not covered" ></span>this.adjustedTotal=profile.total;<span class="cstat-no" title="statement not covered" >t</span>his.setProfile(profile);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nStatsUpdate(event){const profile=<span class="cstat-no" title="statement not covered" >event.data;<span class="cstat-no" title="statement not covered" ></span>if(!this._totalTime){<span class="cstat-no" title="statement not covered" >this._timestamps=[];<span class="cstat-no" title="statement not covered" >t</span>his._sizes=[];<span class="cstat-no" title="statement not covered" >t</span>his._max=[];<span class="cstat-no" title="statement not covered" >t</span>his._ordinals=[];<span class="cstat-no" title="statement not covered" >t</span>his._totalTime=30000;<span class="cstat-no" title="statement not covered" >t</span>his._lastOrdinal=0;}</span></span>
<span class="cstat-no" title="statement not covered" >this._sizes.fill(0);<span class="cstat-no" title="statement not covered" >t</span>his._sizes.push(0);<span class="cstat-no" title="statement not covered" >t</span>his._timestamps.push(Date.now());<span class="cstat-no" title="statement not covered" >t</span>his._ordinals.push(this._lastOrdinal+1);<span class="cstat-no" title="statement not covered" >t</span>his._lastOrdinal=profile.samples.reduce(<span class="fstat-no" title="function not covered" >(r</span>es,sample)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(res,sample.ordinal),</span>this._lastOrdinal);<span class="cstat-no" title="statement not covered" >f</span>or(const sample of profile.samples){const bucket=<span class="cstat-no" title="statement not covered" >this._ordinals.upperBound(sample.ordinal)-1;<span class="cstat-no" title="statement not covered" ></span>this._sizes[bucket]+=sample.size;}</span></span>
<span class="cstat-no" title="statement not covered" >this._max.push(this._sizes.peekLast());<span class="cstat-no" title="statement not covered" >i</span>f(this._timestamps.peekLast()-this._timestamps[0]&gt;this._totalTime)</span>
<span class="cstat-no" title="statement not covered" >this._totalTime*=2;c</span>onst samples=(<span class="cstat-no" title="statement not covered" >{sizes:this._sizes,max:this._max,ids:this._ordinals,timestamps:this._timestamps,totalTime:this._totalTime})</span>;<span class="cstat-no" title="statement not covered" >this._timelineOverview.setSamples(samples);}</span>
<span class="fstat-no" title="function not covered" >co</span>lumnHeader(columnId){<span class="cstat-no" title="statement not covered" >switch(columnId){case'self':<span class="cstat-no" title="statement not covered" >return Common.UIString('Self Size (bytes)');c</span>ase'total':<span class="cstat-no" title="statement not covered" >return Common.UIString('Total Size (bytes)');}</span></span>
<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateFlameChartDataProvider(){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapFlameChartDataProvider((this.profile()),this._profileHeader.heapProfilerModel());}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateTextView(view){const guides=<span class="cstat-no" title="statement not covered" >'+!:|';</span>let text=<span class="cstat-no" title="statement not covered" >`Sampling memory profile.\n\nDate/Time:       ${new Date()}\n`+`Report Version:  7\n`+`App Version:     ${/Chrom\S*/.exec(navigator.appVersion)[0] || 'Unknown'}\n`+`Node Weight:     1 KiB\n`+`Total Size:      ${Math.round(this.profile().root.total / 1024)} KiB\n`+`----\n\nCall graph:\n`;</span>const sortedChildren=<span class="cstat-no" title="statement not covered" >this.profile().root.children.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >b.total-a.total)</span>;</span>const modules=<span class="cstat-no" title="statement not covered" >this.profile().modules.map(<span class="fstat-no" title="function not covered" >m=</span>&gt;<span class="cstat-no" title="statement not covered" >Object.assign({address:BigInt(m.baseAddress),endAddress:BigInt(m.baseAddress)+BigInt(m.size)},m))</span>;<span class="cstat-no" title="statement not covered" ></span>modules.sort(<span class="fstat-no" title="function not covered" >(m</span>1,m2)=&gt;<span class="cstat-no" title="statement not covered" >m1.address&gt;m2.address?1:m1.address&lt;m2.address?-1:0)</span>;<span class="cstat-no" title="statement not covered" >f</span>or(const child of sortedChildren)</span>
<span class="cstat-no" title="statement not covered" >printTree('    ',child!==sortedChildren.peekLast(),child);<span class="cstat-no" title="statement not covered" >t</span>ext+='\nBinary Images:\n';<span class="cstat-no" title="statement not covered" >f</span>or(const module of modules){const fileName=<span class="cstat-no" title="statement not covered" >/[^/\\]*$/.exec(module.name)[0];</span>const version=<span class="cstat-no" title="statement not covered" >'1.0';</span>const formattedUuid=<span class="cstat-no" title="statement not covered" >module.uuid.includes('-')?module.uuid:module.uuid.replace(/(.{8})(.{4})(.{4})(.{4})(.{12}).*/,'$1-$2-$3-$4-$5');<span class="cstat-no" title="statement not covered" ></span>text+=`${('0x' + module.address.toString(16)).padStart(18)} - `;<span class="cstat-no" title="statement not covered" >t</span>ext+=`${('0x' + (module.endAddress - BigInt(1)).toString(16)).padStart(18)}`;<span class="cstat-no" title="statement not covered" >t</span>ext+=`  ${fileName} (${version}) &lt;${formattedUuid}&gt; ${module.name}\n`;}</span></span>
<span class="cstat-no" title="statement not covered" >view.contentElement.createChild('pre','profile-text-view monospace').textContent=text;f</span>unction <span class="fstat-no" title="function not covered" >printTree(</span>padding,drawGuide,node){const addressText=<span class="cstat-no" title="statement not covered" >/0x[0-9a-f]*|[0-9]*/.exec(node.functionName)[0]||'';</span>let module;<span class="cstat-no" title="statement not covered" >if(addressText){const address=<span class="cstat-no" title="statement not covered" >BigInt(addressText);</span>const pos=<span class="cstat-no" title="statement not covered" >modules.upperBound(address,<span class="fstat-no" title="function not covered" >(a</span>ddress,module)=&gt;<span class="cstat-no" title="statement not covered" >address-module.address)</span>;<span class="cstat-no" title="statement not covered" ></span>if(pos&gt;0&amp;&amp;address&lt;modules[pos-1].endAddress)</span></span>
<span class="cstat-no" title="statement not covered" >module=modules[pos-1];}</span>
const functionName=<span class="cstat-no" title="statement not covered" >(addressText?node.functionName.substr(addressText.length+1):node.functionName)||'???';<span class="cstat-no" title="statement not covered" ></span>text+=`${padding}${Math.round(node.total / 1024)}  ${functionName}  `;<span class="cstat-no" title="statement not covered" >i</span>f(module){const fileName=<span class="cstat-no" title="statement not covered" >/[^/\\]*$/.exec(module.name);<span class="cstat-no" title="statement not covered" ></span>if(fileName)</span></span>
<span class="cstat-no" title="statement not covered" >text+=`(in ${fileName})  `;c</span>onst offset=<span class="cstat-no" title="statement not covered" >BigInt(addressText)-module.address;<span class="cstat-no" title="statement not covered" ></span>text+=`load address ${module.baseAddress} + 0x${offset.toString(16)}  `;}</span>
<span class="cstat-no" title="statement not covered" >if(addressText)</span>
<span class="cstat-no" title="statement not covered" >text+=`[${addressText}]`;<span class="cstat-no" title="statement not covered" >t</span>ext+='\n';c</span>onst guideChar=<span class="cstat-no" title="statement not covered" >drawGuide?guides[padding.length/2%guides.length]:' ';</span>const nextPadding=<span class="cstat-no" title="statement not covered" >padding+guideChar+' ';</span>const sortedChildren=<span class="cstat-no" title="statement not covered" >node.children.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >b.total-a.total)</span>;<span class="cstat-no" title="statement not covered" ></span>for(const child of sortedChildren)</span>
<span class="cstat-no" title="statement not covered" >printTree(nextPadding,child!==sortedChildren.peekLast(),child);}</span>}};<span class="cstat-no" title="statement not covered" >Profiler.SamplingHeapProfileTypeBase=class extends Profiler.ProfileType{<span class="fstat-no" title="function not covered" >co</span>nstructor(typeId,description){<span class="cstat-no" title="statement not covered" >super(typeId,description);<span class="cstat-no" title="statement not covered" >t</span>his._recording=false;}</span></span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecorded(){<span class="cstat-no" title="statement not covered" >return(super.profileBeingRecorded());}</span>
<span class="fstat-no" title="function not covered" >ty</span>peName(){<span class="cstat-no" title="statement not covered" >return'Heap';}</span>
<span class="fstat-no" title="function not covered" >fi</span>leExtension(){<span class="cstat-no" title="statement not covered" >return'.heapprofile';}</span>
<span class="fstat-no" title="function not covered" >ge</span>t buttonTooltip(){<span class="cstat-no" title="statement not covered" >return this._recording?ls`Stop heap profiling`:ls`Start heap profiling`;}</span>
<span class="fstat-no" title="function not covered" >bu</span>ttonClicked(){<span class="cstat-no" title="statement not covered" >if(this._recording)</span>
<span class="cstat-no" title="statement not covered" >this._stopRecordingProfile();e</span>lse
<span class="cstat-no" title="statement not covered" >this._startRecordingProfile();<span class="cstat-no" title="statement not covered" >r</span>eturn this._recording;}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartRecordingProfile(){const heapProfilerModel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(SDK.HeapProfilerModel);<span class="cstat-no" title="statement not covered" ></span>if(this.profileBeingRecorded()||!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst profileHeader=<span class="cstat-no" title="statement not covered" >new Profiler.SamplingHeapProfileHeader(heapProfilerModel,this);<span class="cstat-no" title="statement not covered" ></span>this.setProfileBeingRecorded(profileHeader);<span class="cstat-no" title="statement not covered" >t</span>his.addProfile(profileHeader);<span class="cstat-no" title="statement not covered" >p</span>rofileHeader.updateStatus(ls`Recording\u2026`);c</span>onst icon=<span class="cstat-no" title="statement not covered" >UI.Icon.create('smallicon-warning');<span class="cstat-no" title="statement not covered" ></span>icon.title=ls`Heap profiler is recording`;<span class="cstat-no" title="statement not covered" >U</span>I.inspectorView.setPanelIcon('heap_profiler',icon);<span class="cstat-no" title="statement not covered" >t</span>his._recording=true;<span class="cstat-no" title="statement not covered" >t</span>his._startSampling();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _stopRecordingProfile(){<span class="cstat-no" title="statement not covered" >this._recording=false;<span class="cstat-no" title="statement not covered" >i</span>f(!this.profileBeingRecorded()||!this.profileBeingRecorded().heapProfilerModel())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.profileBeingRecorded().updateStatus(ls`Stopping\u2026`);c</span>onst profile=<span class="cstat-no" title="statement not covered" >await this._stopSampling();</span>const recordedProfile=<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded();<span class="cstat-no" title="statement not covered" ></span>if(recordedProfile){<span class="cstat-no" title="statement not covered" >console.assert(profile);<span class="cstat-no" title="statement not covered" >r</span>ecordedProfile.setProtocolProfile(profile);<span class="cstat-no" title="statement not covered" >r</span>ecordedProfile.updateStatus('');<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(null);}</span></span>
<span class="cstat-no" title="statement not covered" >UI.inspectorView.setPanelIcon('heap_profiler',null);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.ProfileType.Events.ProfileComplete,recordedProfile);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProfileLoadedFromFile(title){<span class="cstat-no" title="statement not covered" >return new Profiler.SamplingHeapProfileHeader(null,this,title);}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecordedRemoved(){<span class="cstat-no" title="statement not covered" >this._stopRecordingProfile();}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartSampling(){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>
<span class="fstat-no" title="function not covered" >_s</span>topSampling(){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingHeapProfileType=class extends Profiler.SamplingHeapProfileTypeBase{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Profiler.SamplingHeapProfileType.TypeId,ls`Allocation sampling`);<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingHeapProfileType.instance=this;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer=null;<span class="cstat-no" title="statement not covered" >t</span>his._updateIntervalMs=200;}</span></span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return ls`SAMPLING PROFILES`;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return ls`Record memory allocations using sampling method.</span>
              This profile type has minimal performance overhead and can be used for long running operations.
              It provides good approximation of allocations broken down by JavaScript execution stack.`;}
<span class="fstat-no" title="function not covered" >ha</span>sTemporaryView(){<span class="cstat-no" title="statement not covered" >return Runtime.experiments.isEnabled('samplingHeapProfilerTimeline');}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartSampling(){<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded().heapProfilerModel().startSampling();<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('samplingHeapProfilerTimeline'))</span>
<span class="cstat-no" title="statement not covered" >this._updateTimer=setTimeout(this._updateStats.bind(this),this._updateIntervalMs);}</span>
<span class="fstat-no" title="function not covered" >_s</span>topSampling(){<span class="cstat-no" title="statement not covered" >clearTimeout(this._updateTimer);<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer=null;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.SamplingHeapProfileType.Events.RecordingStopped);<span class="cstat-no" title="statement not covered" >r</span>eturn this.profileBeingRecorded().heapProfilerModel().stopSampling();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _updateStats(){const profile=<span class="cstat-no" title="statement not covered" >await this.profileBeingRecorded().heapProfilerModel().getSamplingProfile();<span class="cstat-no" title="statement not covered" ></span>if(!this._updateTimer)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.SamplingHeapProfileType.Events.StatsUpdate,profile);<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer=setTimeout(this._updateStats.bind(this),this._updateIntervalMs);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingHeapProfileType.TypeId='SamplingHeap';<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingHeapProfileType.Events={RecordingStopped:Symbol('RecordingStopped'),StatsUpdate:Symbol('StatsUpdate')};<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingNativeHeapProfileType=class extends Profiler.SamplingHeapProfileTypeBase{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Profiler.SamplingNativeHeapProfileType.TypeId,ls`Native memory allocation sampling`);<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingNativeHeapProfileType.instance=this;}</span></span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return ls`NATIVE SAMPLING PROFILES`;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return ls`Allocation profiles show sampled native memory allocations from the renderer process.`;}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartSampling(){<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded().heapProfilerModel().startNativeSampling();}</span>
<span class="fstat-no" title="function not covered" >_s</span>topSampling(){<span class="cstat-no" title="statement not covered" >return this.profileBeingRecorded().heapProfilerModel().stopNativeSampling();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingNativeHeapProfileType.TypeId='SamplingNativeHeapRecording';<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingNativeHeapSnapshotType=class extends Profiler.SamplingHeapProfileTypeBase{<span class="fstat-no" title="function not covered" >co</span>nstructor(processType){<span class="cstat-no" title="statement not covered" >super(Profiler.SamplingNativeHeapSnapshotType.TypeId,ls`Native memory allocation snapshot (${processType})`);}</span></span>
<span class="fstat-no" title="function not covered" >is</span>InstantProfile(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return ls`NATIVE SNAPSHOTS`;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return ls`Native memory snapshots show sampled native allocations in the renderer process since start up.</span>
              Chrome has to be started with --sampling-heap-profiler flag.
              Check flags at chrome://flags`;}
<span class="fstat-no" title="function not covered" >bu</span>ttonClicked(){<span class="cstat-no" title="statement not covered" >this._takeSnapshot();<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _takeSnapshot(){<span class="cstat-no" title="statement not covered" >if(this.profileBeingRecorded())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst heapProfilerModel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(SDK.HeapProfilerModel);<span class="cstat-no" title="statement not covered" ></span>if(!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst profile=<span class="cstat-no" title="statement not covered" >new Profiler.SamplingHeapProfileHeader(heapProfilerModel,this,ls`Snapshot ${this.nextProfileUid()}`);<span class="cstat-no" title="statement not covered" ></span>this.setProfileBeingRecorded(profile);<span class="cstat-no" title="statement not covered" >t</span>his.addProfile(profile);<span class="cstat-no" title="statement not covered" >p</span>rofile.updateStatus(ls`Snapshotting\u2026`);c</span>onst protocolProfile=<span class="cstat-no" title="statement not covered" >await this._takeNativeSnapshot((heapProfilerModel));</span>const recordedProfile=<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded();<span class="cstat-no" title="statement not covered" ></span>if(recordedProfile){<span class="cstat-no" title="statement not covered" >console.assert(protocolProfile);<span class="cstat-no" title="statement not covered" >r</span>ecordedProfile.setProtocolProfile(protocolProfile);<span class="cstat-no" title="statement not covered" >r</span>ecordedProfile.updateStatus('');<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(null);}</span></span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.ProfileType.Events.ProfileComplete,recordedProfile);}</span>
<span class="fstat-no" title="function not covered" >_t</span>akeNativeSnapshot(heapProfilerModel){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingNativeHeapSnapshotType.TypeId='SamplingNativeHeapSnapshot';<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingNativeHeapSnapshotBrowserType=class extends Profiler.SamplingNativeHeapSnapshotType{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(ls`Browser`);<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingNativeHeapSnapshotBrowserType.instance=this;}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync _takeNativeSnapshot(heapProfilerModel){<span class="cstat-no" title="statement not covered" >return await heapProfilerModel.takeNativeBrowserSnapshot();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingNativeHeapSnapshotRendererType=class extends Profiler.SamplingNativeHeapSnapshotType{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(ls`Renderer`);<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingNativeHeapSnapshotRendererType.instance=this;}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync _takeNativeSnapshot(heapProfilerModel){<span class="cstat-no" title="statement not covered" >return await heapProfilerModel.takeNativeSnapshot();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingHeapProfileHeader=class extends Profiler.WritableProfileHeader{<span class="fstat-no" title="function not covered" >co</span>nstructor(heapProfilerModel,type,title){<span class="cstat-no" title="statement not covered" >super(heapProfilerModel&amp;&amp;heapProfilerModel.debuggerModel(),type,title||Common.UIString('Profile %d',type.nextProfileUid()));<span class="cstat-no" title="statement not covered" >t</span>his._heapProfilerModel=heapProfilerModel;<span class="cstat-no" title="statement not covered" >t</span>his._protocolProfile=({head:{callFrame:{},children:[]}});}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateView(){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapProfileView(this);}</span>
<span class="fstat-no" title="function not covered" >pr</span>otocolProfile(){<span class="cstat-no" title="statement not covered" >return this._protocolProfile;}</span>
<span class="fstat-no" title="function not covered" >he</span>apProfilerModel(){<span class="cstat-no" title="statement not covered" >return this._heapProfilerModel;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.SamplingHeapProfileNode=class extends SDK.ProfileNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(node){const callFrame=<span class="cstat-no" title="statement not covered" >node.callFrame||({functionName:node['functionName'],scriptId:node['scriptId'],url:node['url'],lineNumber:node['lineNumber']-1,columnNumber:node['columnNumber']-1});<span class="cstat-no" title="statement not covered" ></span>super(callFrame);<span class="cstat-no" title="statement not covered" >t</span>his.self=node.selfSize;}</span>};<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingHeapProfileModel=class extends SDK.ProfileTreeModel{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,minOrdinal,maxOrdinal){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.modules=profile.modules||[];l</span>et nodeIdToSizeMap=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(minOrdinal||maxOrdinal){<span class="cstat-no" title="statement not covered" >nodeIdToSizeMap=new Map();<span class="cstat-no" title="statement not covered" >m</span>inOrdinal=minOrdinal||0;<span class="cstat-no" title="statement not covered" >m</span>axOrdinal=maxOrdinal||Infinity;<span class="cstat-no" title="statement not covered" >f</span>or(const sample of profile.samples){<span class="cstat-no" title="statement not covered" >if(sample.ordinal&lt;minOrdinal||sample.ordinal&gt;maxOrdinal)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst size=<span class="cstat-no" title="statement not covered" >nodeIdToSizeMap.get(sample.nodeId)||0;<span class="cstat-no" title="statement not covered" ></span>nodeIdToSizeMap.set(sample.nodeId,size+sample.size);}</span>}
<span class="cstat-no" title="statement not covered" >this.initialize(translateProfileTree(profile.head));f</span>unction <span class="fstat-no" title="function not covered" >translateProfileTree(</span>root){const resultRoot=<span class="cstat-no" title="statement not covered" >new Profiler.SamplingHeapProfileNode(root);</span>const sourceNodeStack=<span class="cstat-no" title="statement not covered" >[root];</span>const targetNodeStack=<span class="cstat-no" title="statement not covered" >[resultRoot];<span class="cstat-no" title="statement not covered" ></span>while(sourceNodeStack.length){const sourceNode=<span class="cstat-no" title="statement not covered" >sourceNodeStack.pop();</span>const targetNode=<span class="cstat-no" title="statement not covered" >targetNodeStack.pop();<span class="cstat-no" title="statement not covered" ></span>targetNode.children=sourceNode.children.map(<span class="fstat-no" title="function not covered" >ch</span>ild=&gt;{const targetChild=<span class="cstat-no" title="statement not covered" >new Profiler.SamplingHeapProfileNode(child);<span class="cstat-no" title="statement not covered" ></span>if(nodeIdToSizeMap)</span></span></span>
<span class="cstat-no" title="statement not covered" >targetChild.self=nodeIdToSizeMap.get(child.id)||0;<span class="cstat-no" title="statement not covered" >r</span>eturn targetChild;}</span>);<span class="cstat-no" title="statement not covered" >sourceNodeStack.pushAll(sourceNode.children);<span class="cstat-no" title="statement not covered" >t</span>argetNodeStack.pushAll(targetNode.children);}</span>
<span class="cstat-no" title="statement not covered" >pruneEmptyBranches(resultRoot);<span class="cstat-no" title="statement not covered" >r</span>eturn resultRoot;}</span>
function <span class="fstat-no" title="function not covered" >pruneEmptyBranches(</span>node){<span class="cstat-no" title="statement not covered" >node.children=node.children.filter(pruneEmptyBranches);<span class="cstat-no" title="statement not covered" >r</span>eturn!!(node.children.length||node.self);}</span>}};<span class="cstat-no" title="statement not covered" >Profiler.HeapProfileView.NodeFormatter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileView){<span class="cstat-no" title="statement not covered" >this._profileView=profileView;}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value){<span class="cstat-no" title="statement not covered" >return Number.withThousandsSeparator(value);}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatPercent(value,node){<span class="cstat-no" title="statement not covered" >return Common.UIString('%.2f\xa0%%',value);}</span>
<span class="fstat-no" title="function not covered" >li</span>nkifyNode(node){const heapProfilerModel=<span class="cstat-no" title="statement not covered" >this._profileView._profileHeader.heapProfilerModel();<span class="cstat-no" title="statement not covered" ></span>return this._profileView.linkifier().maybeLinkifyConsoleCallFrame(heapProfilerModel?heapProfilerModel.target():null,node.profileNode.callFrame,'profile-node-file');}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapFlameChartDataProvider=class extends Profiler.ProfileFlameChartDataProvider{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,heapProfilerModel){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._profile=profile;<span class="cstat-no" title="statement not covered" >t</span>his._heapProfilerModel=heapProfilerModel;}</span></span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return 0;}</span>
<span class="fstat-no" title="function not covered" >to</span>talTime(){<span class="cstat-no" title="statement not covered" >return this._profile.root.total;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Common.UIString('%s\xa0KB',Number.withThousandsSeparator(value/1e3));}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateTimelineData(){function <span class="fstat-no" title="function not covered" >nodesCount(</span>node){<span class="cstat-no" title="statement not covered" >return node.children.reduce(<span class="fstat-no" title="function not covered" >(c</span>ount,node)=&gt;<span class="cstat-no" title="statement not covered" >count+nodesCount(node),</span>1);}</span>
const count=<span class="cstat-no" title="statement not covered" >nodesCount(this._profile.root);</span>const entryNodes=<span class="cstat-no" title="statement not covered" >new Array(count);</span>const entryLevels=<span class="cstat-no" title="statement not covered" >new Uint16Array(count);</span>const entryTotalTimes=<span class="cstat-no" title="statement not covered" >new Float32Array(count);</span>const entryStartTimes=<span class="cstat-no" title="statement not covered" >new Float64Array(count);</span>let depth=<span class="cstat-no" title="statement not covered" >0;</span>let maxDepth=<span class="cstat-no" title="statement not covered" >0;</span>let position=<span class="cstat-no" title="statement not covered" >0;</span>let index=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >addNode(</span>node){const start=<span class="cstat-no" title="statement not covered" >position;<span class="cstat-no" title="statement not covered" ></span>entryNodes[index]=node;<span class="cstat-no" title="statement not covered" >e</span>ntryLevels[index]=depth;<span class="cstat-no" title="statement not covered" >e</span>ntryTotalTimes[index]=node.total;<span class="cstat-no" title="statement not covered" >e</span>ntryStartTimes[index]=position;<span class="cstat-no" title="statement not covered" >+</span>+index;<span class="cstat-no" title="statement not covered" >+</span>+depth;<span class="cstat-no" title="statement not covered" >n</span>ode.children.forEach(addNode);<span class="cstat-no" title="statement not covered" >-</span>-depth;<span class="cstat-no" title="statement not covered" >m</span>axDepth=Math.max(maxDepth,depth);<span class="cstat-no" title="statement not covered" >p</span>osition=start+node.total;}</span>
<span class="cstat-no" title="statement not covered" >addNode(this._profile.root);<span class="cstat-no" title="statement not covered" >t</span>his._maxStackDepth=maxDepth+1;<span class="cstat-no" title="statement not covered" >t</span>his._entryNodes=entryNodes;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=new PerfUI.FlameChart.TimelineData(entryLevels,entryTotalTimes,entryStartTimes,null);<span class="cstat-no" title="statement not covered" >r</span>eturn this._timelineData;}</span>
<span class="fstat-no" title="function not covered" >pr</span>epareHighlightedEntryInfo(entryIndex){const node=<span class="cstat-no" title="statement not covered" >this._entryNodes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(!node)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst entryInfo=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >pushEntryInfoRow(</span>title,value){<span class="cstat-no" title="statement not covered" >entryInfo.push({title:title,value:value});}</span>
<span class="cstat-no" title="statement not covered" >pushEntryInfoRow(Common.UIString('Name'),UI.beautifyFunctionName(node.functionName));<span class="cstat-no" title="statement not covered" >p</span>ushEntryInfoRow(Common.UIString('Self size'),Number.bytesToString(node.self));<span class="cstat-no" title="statement not covered" >p</span>ushEntryInfoRow(Common.UIString('Total size'),Number.bytesToString(node.total));c</span>onst linkifier=<span class="cstat-no" title="statement not covered" >new Components.Linkifier();</span>const link=<span class="cstat-no" title="statement not covered" >linkifier.maybeLinkifyConsoleCallFrame(this._heapProfilerModel?this._heapProfilerModel.target():null,node.callFrame);<span class="cstat-no" title="statement not covered" ></span>if(link)</span>
<span class="cstat-no" title="statement not covered" >pushEntryInfoRow(Common.UIString('URL'),link.textContent);<span class="cstat-no" title="statement not covered" >l</span>inkifier.dispose();<span class="cstat-no" title="statement not covered" >r</span>eturn Profiler.ProfileView.buildPopoverTable(entryInfo);}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.HeapProfilerPanel=class extends Profiler.ProfilesPanel{<span class="fstat-no" title="function not covered" >co</span>nstructor(){const registry=<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeRegistry.instance;</span>const profileTypes=<span class="cstat-no" title="statement not covered" >[registry.heapSnapshotProfileType,registry.trackingHeapSnapshotProfileType,registry.samplingHeapProfileType];<span class="cstat-no" title="statement not covered" ></span>if(Runtime.experiments.isEnabled('nativeHeapProfiler')){<span class="cstat-no" title="statement not covered" >profileTypes.push(registry.samplingNativeHeapProfileType);<span class="cstat-no" title="statement not covered" >p</span>rofileTypes.push(registry.samplingNativeHeapSnapshotRendererType);<span class="cstat-no" title="statement not covered" >p</span>rofileTypes.push(registry.samplingNativeHeapSnapshotBrowserType);}</span></span></span>
<span class="cstat-no" title="statement not covered" >super('heap_profiler',profileTypes,'profiler.heap-toggle-recording');}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendApplicableItems(event,contextMenu,target){<span class="cstat-no" title="statement not covered" >if(!(target instanceof SDK.RemoteObject))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this.isShowing())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst object=(<span class="cstat-no" title="statement not covered" >target)</span>;<span class="cstat-no" title="statement not covered" >if(!object.objectId)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst objectId=(<span class="cstat-no" title="statement not covered" >object.objectId)</span>;const heapProfiles=<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeRegistry.instance.heapSnapshotProfileType.getProfiles();<span class="cstat-no" title="statement not covered" ></span>if(!heapProfiles.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst heapProfilerModel=<span class="cstat-no" title="statement not covered" >object.runtimeModel().heapProfilerModel();<span class="cstat-no" title="statement not covered" ></span>if(!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;f</span>unction <span class="fstat-no" title="function not covered" >revealInView(</span>viewName){<span class="cstat-no" title="statement not covered" >heapProfilerModel.snapshotObjectIdForObjectId(objectId).then(<span class="fstat-no" title="function not covered" >re</span>sult=&gt;{<span class="cstat-no" title="statement not covered" >if(this.isShowing()&amp;&amp;result)</span></span>
<span class="cstat-no" title="statement not covered" >this.showObject(result,viewName);}</span>);}
<span class="cstat-no" title="statement not covered" >contextMenu.revealSection().appendItem(Common.UIString('Reveal in Summary view'),revealInView.bind(this,'Summary'));}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleAction(context,actionId){const panel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(Profiler.HeapProfilerPanel);<span class="cstat-no" title="statement not covered" ></span>console.assert(panel&amp;&amp;panel instanceof Profiler.HeapProfilerPanel);<span class="cstat-no" title="statement not covered" >p</span>anel.toggleRecord();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >UI.context.setFlavor(Profiler.HeapProfilerPanel,this);}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >UI.context.setFlavor(Profiler.HeapProfilerPanel,null);}</span>
<span class="fstat-no" title="function not covered" >sh</span>owObject(snapshotObjectId,perspectiveName){const registry=<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeRegistry.instance;</span>const heapProfiles=<span class="cstat-no" title="statement not covered" >registry.heapSnapshotProfileType.getProfiles();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;heapProfiles.length;i++){const profile=<span class="cstat-no" title="statement not covered" >heapProfiles[i];<span class="cstat-no" title="statement not covered" ></span>if(profile.maxJSObjectId&gt;=snapshotObjectId){<span class="cstat-no" title="statement not covered" >this.showProfile(profile);c</span>onst view=<span class="cstat-no" title="statement not covered" >this.viewForProfile(profile);<span class="cstat-no" title="statement not covered" ></span>view.selectLiveObject(perspectiveName,snapshotObjectId);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotWorkerProxy=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(eventHandler){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._eventHandler=eventHandler;<span class="cstat-no" title="statement not covered" >t</span>his._nextObjectId=1;<span class="cstat-no" title="statement not covered" >t</span>his._nextCallId=1;<span class="cstat-no" title="statement not covered" >t</span>his._callbacks=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._previousCallbacks=new Set();<span class="cstat-no" title="statement not covered" >t</span>his._worker=new Common.Worker('heap_snapshot_worker');<span class="cstat-no" title="statement not covered" >t</span>his._worker.onmessage=this._messageReceived.bind(this);}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateLoader(profileUid,snapshotReceivedCallback){const objectId=<span class="cstat-no" title="statement not covered" >this._nextObjectId++;</span>const proxy=<span class="cstat-no" title="statement not covered" >new Profiler.HeapSnapshotLoaderProxy(this,objectId,profileUid,snapshotReceivedCallback);<span class="cstat-no" title="statement not covered" ></span>this._postMessage({callId:this._nextCallId++,disposition:'create',objectId:objectId,methodName:'HeapSnapshotWorker.HeapSnapshotLoader'});<span class="cstat-no" title="statement not covered" >r</span>eturn proxy;}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._worker.terminate();<span class="cstat-no" title="statement not covered" >i</span>f(this._interval)</span>
<span class="cstat-no" title="statement not covered" >clearInterval(this._interval);}</span>
<span class="fstat-no" title="function not covered" >di</span>sposeObject(objectId){<span class="cstat-no" title="statement not covered" >this._postMessage({callId:this._nextCallId++,disposition:'dispose',objectId:objectId});}</span>
<span class="fstat-no" title="function not covered" >ev</span>aluateForTest(script,callback){const callId=<span class="cstat-no" title="statement not covered" >this._nextCallId++;<span class="cstat-no" title="statement not covered" ></span>this._callbacks.set(callId,callback);<span class="cstat-no" title="statement not covered" >t</span>his._postMessage({callId:callId,disposition:'evaluateForTest',source:script});}</span>
<span class="fstat-no" title="function not covered" >ca</span>llFactoryMethod(callback,objectId,methodName,proxyConstructor){const callId=<span class="cstat-no" title="statement not covered" >this._nextCallId++;</span>const methodArguments=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments,4);</span>const newObjectId=<span class="cstat-no" title="statement not covered" >this._nextObjectId++;</span>function <span class="fstat-no" title="function not covered" >wrapCallback(</span>remoteResult){<span class="cstat-no" title="statement not covered" >callback(remoteResult?new proxyConstructor(this,newObjectId):null);}</span>
<span class="cstat-no" title="statement not covered" >if(callback){<span class="cstat-no" title="statement not covered" >this._callbacks.set(callId,wrapCallback.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._postMessage({callId:callId,disposition:'factory',objectId:objectId,methodName:methodName,methodArguments:methodArguments,newObjectId:newObjectId});<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>else{<span class="cstat-no" title="statement not covered" >this._postMessage({callId:callId,disposition:'factory',objectId:objectId,methodName:methodName,methodArguments:methodArguments,newObjectId:newObjectId});<span class="cstat-no" title="statement not covered" >r</span>eturn new proxyConstructor(this,newObjectId);}</span>}</span>
<span class="fstat-no" title="function not covered" >ca</span>llMethod(callback,objectId,methodName){const callId=<span class="cstat-no" title="statement not covered" >this._nextCallId++;</span>const methodArguments=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments,3);<span class="cstat-no" title="statement not covered" ></span>if(callback)</span>
<span class="cstat-no" title="statement not covered" >this._callbacks.set(callId,callback);<span class="cstat-no" title="statement not covered" >t</span>his._postMessage({callId:callId,disposition:'method',objectId:objectId,methodName:methodName,methodArguments:methodArguments});}</span>
<span class="fstat-no" title="function not covered" >st</span>artCheckingForLongRunningCalls(){<span class="cstat-no" title="statement not covered" >if(this._interval)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._checkLongRunningCalls();<span class="cstat-no" title="statement not covered" >t</span>his._interval=setInterval(this._checkLongRunningCalls.bind(this),300);}</span>
<span class="fstat-no" title="function not covered" >_c</span>heckLongRunningCalls(){<span class="cstat-no" title="statement not covered" >for(const callId of this._previousCallbacks){<span class="cstat-no" title="statement not covered" >if(!this._callbacks.has(callId))</span></span>
<span class="cstat-no" title="statement not covered" >this._previousCallbacks.delete(callId);}</span>
const hasLongRunningCalls=<span class="cstat-no" title="statement not covered" >!!this._previousCallbacks.size;<span class="cstat-no" title="statement not covered" ></span>this.dispatchEventToListeners(Profiler.HeapSnapshotWorkerProxy.Events.Wait,hasLongRunningCalls);<span class="cstat-no" title="statement not covered" >f</span>or(const callId of this._callbacks.keysArray())</span>
<span class="cstat-no" title="statement not covered" >this._previousCallbacks.add(callId);}</span>
<span class="fstat-no" title="function not covered" >_m</span>essageReceived(event){const data=<span class="cstat-no" title="statement not covered" >event.data;<span class="cstat-no" title="statement not covered" ></span>if(data.eventName){<span class="cstat-no" title="statement not covered" >if(this._eventHandler)</span></span>
<span class="cstat-no" title="statement not covered" >this._eventHandler(data.eventName,data.data);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(data.error){<span class="cstat-no" title="statement not covered" >if(data.errorMethodName){<span class="cstat-no" title="statement not covered" >Common.console.error(Common.UIString('An error occurred when a call to method \'%s\' was requested',data.errorMethodName));}</span></span></span>
<span class="cstat-no" title="statement not covered" >Common.console.error(data['errorCallStack']);<span class="cstat-no" title="statement not covered" >t</span>his._callbacks.delete(data.callId);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(!this._callbacks.has(data.callId))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst callback=<span class="cstat-no" title="statement not covered" >this._callbacks.get(data.callId);<span class="cstat-no" title="statement not covered" ></span>this._callbacks.delete(data.callId);<span class="cstat-no" title="statement not covered" >c</span>allback(data.result);}</span>
<span class="fstat-no" title="function not covered" >_p</span>ostMessage(message){<span class="cstat-no" title="statement not covered" >this._worker.postMessage(message);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotWorkerProxy.Events={Wait:Symbol('Wait')};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotProxyObject=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(worker,objectId){<span class="cstat-no" title="statement not covered" >this._worker=worker;<span class="cstat-no" title="statement not covered" >t</span>his._objectId=objectId;}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>allWorker(workerMethodName,args){<span class="cstat-no" title="statement not covered" >args.splice(1,0,this._objectId);<span class="cstat-no" title="statement not covered" >r</span>eturn this._worker[workerMethodName].apply(this._worker,args);}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._worker.disposeObject(this._objectId);}</span>
<span class="fstat-no" title="function not covered" >di</span>sposeWorker(){<span class="cstat-no" title="statement not covered" >this._worker.dispose();}</span>
<span class="fstat-no" title="function not covered" >ca</span>llFactoryMethod(callback,methodName,proxyConstructor,var_args){<span class="cstat-no" title="statement not covered" >return this._callWorker('callFactoryMethod',Array.prototype.slice.call(arguments,0));}</span>
<span class="fstat-no" title="function not covered" >_c</span>allMethodPromise(methodName,var_args){const args=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments);<span class="cstat-no" title="statement not covered" ></span>return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >this._callWorker('callMethod',[resolve,...args]))</span>;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotLoaderProxy=class extends Profiler.HeapSnapshotProxyObject{<span class="fstat-no" title="function not covered" >co</span>nstructor(worker,objectId,profileUid,snapshotReceivedCallback){<span class="cstat-no" title="statement not covered" >super(worker,objectId);<span class="cstat-no" title="statement not covered" >t</span>his._profileUid=profileUid;<span class="cstat-no" title="statement not covered" >t</span>his._snapshotReceivedCallback=snapshotReceivedCallback;}</span></span>
<span class="fstat-no" title="function not covered" >wr</span>ite(chunk){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('write',chunk);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync close(){<span class="cstat-no" title="statement not covered" >await this._callMethodPromise('close');c</span>onst snapshotProxy=<span class="cstat-no" title="statement not covered" >await new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >this.callFactoryMethod(resolve,'buildSnapshot',Profiler.HeapSnapshotProxy))</span>;<span class="cstat-no" title="statement not covered" ></span>this.dispose();<span class="cstat-no" title="statement not covered" >s</span>napshotProxy.setProfileUid(this._profileUid);<span class="cstat-no" title="statement not covered" >a</span>wait snapshotProxy.updateStaticData();<span class="cstat-no" title="statement not covered" >t</span>his._snapshotReceivedCallback(snapshotProxy);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotProxy=class extends Profiler.HeapSnapshotProxyObject{<span class="fstat-no" title="function not covered" >co</span>nstructor(worker,objectId){<span class="cstat-no" title="statement not covered" >super(worker,objectId);<span class="cstat-no" title="statement not covered" >t</span>his._staticData=null;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>arch(searchConfig,filter){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('search',searchConfig,filter);}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregatesWithFilter(filter){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('aggregatesWithFilter',filter);}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregatesForDiff(){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('aggregatesForDiff');}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateSnapshotDiff(baseSnapshotId,baseSnapshotAggregates){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('calculateSnapshotDiff',baseSnapshotId,baseSnapshotAggregates);}</span>
<span class="fstat-no" title="function not covered" >no</span>deClassName(snapshotObjectId){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('nodeClassName',snapshotObjectId);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdgesProvider(nodeIndex){<span class="cstat-no" title="statement not covered" >return this.callFactoryMethod(null,'createEdgesProvider',Profiler.HeapSnapshotProviderProxy,nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdgesProvider(nodeIndex){<span class="cstat-no" title="statement not covered" >return this.callFactoryMethod(null,'createRetainingEdgesProvider',Profiler.HeapSnapshotProviderProxy,nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateAddedNodesProvider(baseSnapshotId,className){<span class="cstat-no" title="statement not covered" >return this.callFactoryMethod(null,'createAddedNodesProvider',Profiler.HeapSnapshotProviderProxy,baseSnapshotId,className);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateDeletedNodesProvider(nodeIndexes){<span class="cstat-no" title="statement not covered" >return this.callFactoryMethod(null,'createDeletedNodesProvider',Profiler.HeapSnapshotProviderProxy,nodeIndexes);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateNodesProvider(filter){<span class="cstat-no" title="statement not covered" >return this.callFactoryMethod(null,'createNodesProvider',Profiler.HeapSnapshotProviderProxy,filter);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateNodesProviderForClass(className,nodeFilter){<span class="cstat-no" title="statement not covered" >return this.callFactoryMethod(null,'createNodesProviderForClass',Profiler.HeapSnapshotProviderProxy,className,nodeFilter);}</span>
<span class="fstat-no" title="function not covered" >al</span>locationTracesTops(){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('allocationTracesTops');}</span>
<span class="fstat-no" title="function not covered" >al</span>locationNodeCallers(nodeId){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('allocationNodeCallers',nodeId);}</span>
<span class="fstat-no" title="function not covered" >al</span>locationStack(nodeIndex){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('allocationStack',nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >throw new Error('Should never be called');}</span>
<span class="fstat-no" title="function not covered" >ge</span>t nodeCount(){<span class="cstat-no" title="statement not covered" >return this._staticData.nodeCount;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t rootNodeIndex(){<span class="cstat-no" title="statement not covered" >return this._staticData.rootNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync updateStaticData(){<span class="cstat-no" title="statement not covered" >this._staticData=await this._callMethodPromise('updateStaticData');}</span>
<span class="fstat-no" title="function not covered" >ge</span>tStatistics(){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('getStatistics');}</span>
<span class="fstat-no" title="function not covered" >ge</span>tLocation(nodeIndex){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('getLocation',nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >ge</span>tSamples(){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('getSamples');}</span>
<span class="fstat-no" title="function not covered" >ge</span>t totalSize(){<span class="cstat-no" title="statement not covered" >return this._staticData.totalSize;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t uid(){<span class="cstat-no" title="statement not covered" >return this._profileUid;}</span>
<span class="fstat-no" title="function not covered" >se</span>tProfileUid(profileUid){<span class="cstat-no" title="statement not covered" >this._profileUid=profileUid;}</span>
<span class="fstat-no" title="function not covered" >ma</span>xJSObjectId(){<span class="cstat-no" title="statement not covered" >return this._staticData.maxJSObjectId;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotProviderProxy=class extends Profiler.HeapSnapshotProxyObject{<span class="fstat-no" title="function not covered" >co</span>nstructor(worker,objectId){<span class="cstat-no" title="statement not covered" >super(worker,objectId);}</span></span>
<span class="fstat-no" title="function not covered" >no</span>dePosition(snapshotObjectId){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('nodePosition',snapshotObjectId);}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('isEmpty');}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeItemsRange(startPosition,endPosition){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('serializeItemsRange',startPosition,endPosition);}</span>
<span class="fstat-no" title="function not covered" >so</span>rtAndRewind(comparator){<span class="cstat-no" title="statement not covered" >return this._callMethodPromise('sortAndRewind',comparator);}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotSortableDataGrid=class extends DataGrid.DataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,columns){<span class="cstat-no" title="statement not covered" >super(columns);<span class="cstat-no" title="statement not covered" >t</span>his._dataDisplayDelegate=dataDisplayDelegate;c</span>onst tooltips=<span class="cstat-no" title="statement not covered" >[['distance',ls`Distance from window object`],['shallowSize',ls`Size of the object itself in bytes`],['retainedSize',ls`Size of the object plus the graph it retains in bytes`]];<span class="cstat-no" title="statement not covered" ></span>for(const info of tooltips){const headerCell=<span class="cstat-no" title="statement not covered" >this.headerTableHeader(info[0]);<span class="cstat-no" title="statement not covered" ></span>if(headerCell)</span></span></span>
<span class="cstat-no" title="statement not covered" >headerCell.setAttribute('title',info[1]);}</span>
<span class="cstat-no" title="statement not covered" >this._recursiveSortingDepth=0;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedNode=null;<span class="cstat-no" title="statement not covered" >t</span>his._populatedAndSorted=false;<span class="cstat-no" title="statement not covered" >t</span>his._nameFilter=null;<span class="cstat-no" title="statement not covered" >t</span>his._nodeFilter=new HeapSnapshotModel.NodeFilter();<span class="cstat-no" title="statement not covered" >t</span>his.addEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,this._sortingComplete,this);<span class="cstat-no" title="statement not covered" >t</span>his.addEventListener(DataGrid.DataGrid.Events.SortingChanged,this.sortingChanged,this);}</span>
<span class="fstat-no" title="function not covered" >da</span>taDisplayDelegate(){<span class="cstat-no" title="statement not covered" >return this._dataDisplayDelegate;}</span>
<span class="fstat-no" title="function not covered" >no</span>deFilter(){<span class="cstat-no" title="statement not covered" >return this._nodeFilter;}</span>
<span class="fstat-no" title="function not covered" >se</span>tNameFilter(nameFilter){<span class="cstat-no" title="statement not covered" >this._nameFilter=nameFilter;}</span>
<span class="fstat-no" title="function not covered" >de</span>faultPopulateCount(){<span class="cstat-no" title="statement not covered" >return 100;}</span>
<span class="fstat-no" title="function not covered" >_d</span>isposeAllNodes(){const children=<span class="cstat-no" title="statement not covered" >this.topLevelNodes();<span class="cstat-no" title="statement not covered" ></span>for(let i=0,l=children.length;i&lt;l;++i)</span>
<span class="cstat-no" title="statement not covered" >children[i].dispose();}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >if(this._nameFilter){<span class="cstat-no" title="statement not covered" >this._nameFilter.addEventListener(UI.ToolbarInput.Event.TextChanged,this._onNameFilterChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his.updateVisibleNodes(true);}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._populatedAndSorted)</span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.HeapSnapshotSortableDataGrid.Events.ContentShown,this);}</span>
<span class="fstat-no" title="function not covered" >_s</span>ortingComplete(){<span class="cstat-no" title="statement not covered" >this.removeEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,this._sortingComplete,this);<span class="cstat-no" title="statement not covered" >t</span>his._populatedAndSorted=true;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.HeapSnapshotSortableDataGrid.Events.ContentShown,this);}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >if(this._nameFilter)</span>
<span class="cstat-no" title="statement not covered" >this._nameFilter.removeEventListener(UI.ToolbarInput.Event.TextChanged,this._onNameFilterChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._clearCurrentHighlight();}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateContextMenu(contextMenu,event){const td=<span class="cstat-no" title="statement not covered" >event.target.enclosingNodeOrSelfWithNodeName('td');<span class="cstat-no" title="statement not covered" ></span>if(!td)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst node=<span class="cstat-no" title="statement not covered" >td.heapSnapshotNode;<span class="cstat-no" title="statement not covered" ></span>contextMenu.revealSection().appendItem(ls`Reveal in Summary view`,<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._dataDisplayDelegate.showObject(node.snapshotNodeId,ls`Summary`);}</span>);}</span>
<span class="fstat-no" title="function not covered" >re</span>setSortingCache(){<span class="cstat-no" title="statement not covered" >delete this._lastSortColumnId;<span class="cstat-no" title="statement not covered" >d</span>elete this._lastSortAscending;}</span>
<span class="fstat-no" title="function not covered" >to</span>pLevelNodes(){<span class="cstat-no" title="statement not covered" >return this.rootNode().children;}</span>
<span class="fstat-no" title="function not covered" >re</span>vealObjectByHeapSnapshotId(heapSnapshotObjectId){<span class="cstat-no" title="statement not covered" >return Promise.resolve((null));}</span>
<span class="fstat-no" title="function not covered" >hi</span>ghlightNode(node){<span class="cstat-no" title="statement not covered" >this._clearCurrentHighlight();<span class="cstat-no" title="statement not covered" >t</span>his._highlightedNode=node;<span class="cstat-no" title="statement not covered" >U</span>I.runCSSAnimationOnce(this._highlightedNode.element(),'highlighted-row');}</span>
<span class="fstat-no" title="function not covered" >_c</span>learCurrentHighlight(){<span class="cstat-no" title="statement not covered" >if(!this._highlightedNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedNode.element().classList.remove('highlighted-row');<span class="cstat-no" title="statement not covered" >t</span>his._highlightedNode=null;}</span>
<span class="fstat-no" title="function not covered" >re</span>setNameFilter(){<span class="cstat-no" title="statement not covered" >this._nameFilter.setValue('');}</span>
<span class="fstat-no" title="function not covered" >_o</span>nNameFilterChanged(){<span class="cstat-no" title="statement not covered" >this.updateVisibleNodes(true);}</span>
<span class="fstat-no" title="function not covered" >so</span>rtingChanged(){const sortAscending=<span class="cstat-no" title="statement not covered" >this.isSortOrderAscending();</span>const sortColumnId=<span class="cstat-no" title="statement not covered" >this.sortColumnId();<span class="cstat-no" title="statement not covered" ></span>if(this._lastSortColumnId===sortColumnId&amp;&amp;this._lastSortAscending===sortAscending)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._lastSortColumnId=sortColumnId;<span class="cstat-no" title="statement not covered" >t</span>his._lastSortAscending=sortAscending;c</span>onst sortFields=<span class="cstat-no" title="statement not covered" >this._sortFields(sortColumnId,sortAscending);</span>function <span class="fstat-no" title="function not covered" >SortByTwoFields(</span>nodeA,nodeB){let field1=<span class="cstat-no" title="statement not covered" >nodeA[sortFields[0]];</span>let field2=<span class="cstat-no" title="statement not covered" >nodeB[sortFields[0]];</span>let result=<span class="cstat-no" title="statement not covered" >field1&lt;field2?-1:(field1&gt;field2?1:0);<span class="cstat-no" title="statement not covered" ></span>if(!sortFields[1])</span>
<span class="cstat-no" title="statement not covered" >result=-result;<span class="cstat-no" title="statement not covered" >i</span>f(result!==0)</span>
<span class="cstat-no" title="statement not covered" >return result;<span class="cstat-no" title="statement not covered" >f</span>ield1=nodeA[sortFields[2]];<span class="cstat-no" title="statement not covered" >f</span>ield2=nodeB[sortFields[2]];<span class="cstat-no" title="statement not covered" >r</span>esult=field1&lt;field2?-1:(field1&gt;field2?1:0);<span class="cstat-no" title="statement not covered" >i</span>f(!sortFields[3])</span>
<span class="cstat-no" title="statement not covered" >result=-result;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="cstat-no" title="statement not covered" >this._performSorting(SortByTwoFields);}</span>
<span class="fstat-no" title="function not covered" >_p</span>erformSorting(sortFunction){<span class="cstat-no" title="statement not covered" >this.recursiveSortingEnter();c</span>onst children=<span class="cstat-no" title="statement not covered" >this.allChildren(this.rootNode());<span class="cstat-no" title="statement not covered" ></span>this.rootNode().removeChildren();<span class="cstat-no" title="statement not covered" >c</span>hildren.sort(sortFunction);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0,l=children.length;i&lt;l;++i){const child=<span class="cstat-no" title="statement not covered" >children[i];<span class="cstat-no" title="statement not covered" ></span>this.appendChildAfterSorting(child);<span class="cstat-no" title="statement not covered" >i</span>f(child.expanded)</span></span>
<span class="cstat-no" title="statement not covered" >child.sort();}</span>
<span class="cstat-no" title="statement not covered" >this.recursiveSortingLeave();}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendChildAfterSorting(child){const revealed=<span class="cstat-no" title="statement not covered" >child.revealed;<span class="cstat-no" title="statement not covered" ></span>this.rootNode().appendChild(child);<span class="cstat-no" title="statement not covered" >c</span>hild.revealed=revealed;}</span>
<span class="fstat-no" title="function not covered" >re</span>cursiveSortingEnter(){<span class="cstat-no" title="statement not covered" >++this._recursiveSortingDepth;}</span>
<span class="fstat-no" title="function not covered" >re</span>cursiveSortingLeave(){<span class="cstat-no" title="statement not covered" >if(!this._recursiveSortingDepth)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(--this._recursiveSortingDepth)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.updateVisibleNodes(true);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateVisibleNodes(force){}
<span class="fstat-no" title="function not covered" >al</span>lChildren(parent){<span class="cstat-no" title="statement not covered" >return parent.children;}</span>
<span class="fstat-no" title="function not covered" >in</span>sertChild(parent,node,index){<span class="cstat-no" title="statement not covered" >parent.insertChild(node,index);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChildByIndex(parent,index){<span class="cstat-no" title="statement not covered" >parent.removeChild(parent.children[index]);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveAllChildren(parent){<span class="cstat-no" title="statement not covered" >parent.removeChildren();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotSortableDataGrid.Events={ContentShown:Symbol('ContentShown'),SortingComplete:Symbol('SortingComplete')};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotViewportDataGrid=class extends Profiler.HeapSnapshotSortableDataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,columns){<span class="cstat-no" title="statement not covered" >super(dataDisplayDelegate,columns);<span class="cstat-no" title="statement not covered" >t</span>his.scrollContainer.addEventListener('scroll',this._onScroll.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._topPaddingHeight=0;<span class="cstat-no" title="statement not covered" >t</span>his._bottomPaddingHeight=0;}</span></span>
<span class="fstat-no" title="function not covered" >to</span>pLevelNodes(){<span class="cstat-no" title="statement not covered" >return this.allChildren(this.rootNode());}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendChildAfterSorting(child){}
<span class="fstat-no" title="function not covered" >up</span>dateVisibleNodes(force){const guardZoneHeight=<span class="cstat-no" title="statement not covered" >40;</span>const scrollHeight=<span class="cstat-no" title="statement not covered" >this.scrollContainer.scrollHeight;</span>let scrollTop=<span class="cstat-no" title="statement not covered" >this.scrollContainer.scrollTop;</span>let scrollBottom=<span class="cstat-no" title="statement not covered" >scrollHeight-scrollTop-this.scrollContainer.offsetHeight;<span class="cstat-no" title="statement not covered" ></span>scrollTop=Math.max(0,scrollTop-guardZoneHeight);<span class="cstat-no" title="statement not covered" >s</span>crollBottom=Math.max(0,scrollBottom-guardZoneHeight);l</span>et viewPortHeight=<span class="cstat-no" title="statement not covered" >scrollHeight-scrollTop-scrollBottom;<span class="cstat-no" title="statement not covered" ></span>if(!force&amp;&amp;scrollTop&gt;=this._topPaddingHeight&amp;&amp;scrollBottom&gt;=this._bottomPaddingHeight)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst hysteresisHeight=<span class="cstat-no" title="statement not covered" >500;<span class="cstat-no" title="statement not covered" ></span>scrollTop-=hysteresisHeight;<span class="cstat-no" title="statement not covered" >v</span>iewPortHeight+=2*hysteresisHeight;c</span>onst selectedNode=<span class="cstat-no" title="statement not covered" >this.selectedNode;<span class="cstat-no" title="statement not covered" ></span>this.rootNode().removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._topPaddingHeight=0;<span class="cstat-no" title="statement not covered" >t</span>his._bottomPaddingHeight=0;<span class="cstat-no" title="statement not covered" >t</span>his._addVisibleNodes(this.rootNode(),scrollTop,scrollTop+viewPortHeight);<span class="cstat-no" title="statement not covered" >t</span>his.setVerticalPadding(this._topPaddingHeight,this._bottomPaddingHeight);<span class="cstat-no" title="statement not covered" >i</span>f(selectedNode){<span class="cstat-no" title="statement not covered" >if(selectedNode.parent)</span></span>
<span class="cstat-no" title="statement not covered" >selectedNode.select(true);e</span>lse
<span class="cstat-no" title="statement not covered" >this.selectedNode=selectedNode;}</span>}
<span class="fstat-no" title="function not covered" >_a</span>ddVisibleNodes(parentNode,topBound,bottomBound){<span class="cstat-no" title="statement not covered" >if(!parentNode.expanded)</span>
<span class="cstat-no" title="statement not covered" >return 0;c</span>onst children=<span class="cstat-no" title="statement not covered" >this.allChildren(parentNode);</span>let topPadding=<span class="cstat-no" title="statement not covered" >0;</span>const nameFilterValue=<span class="cstat-no" title="statement not covered" >this._nameFilter?this._nameFilter.value().toLowerCase():'';</span>let i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;children.length;++i){const child=<span class="cstat-no" title="statement not covered" >children[i];<span class="cstat-no" title="statement not covered" ></span>if(nameFilterValue&amp;&amp;child.filteredOut&amp;&amp;child.filteredOut(nameFilterValue))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst newTop=<span class="cstat-no" title="statement not covered" >topPadding+this._nodeHeight(child);<span class="cstat-no" title="statement not covered" ></span>if(newTop&gt;topBound)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span>opPadding=newTop;}</span>
let position=<span class="cstat-no" title="statement not covered" >topPadding;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;children.length&amp;&amp;position&lt;bottomBound;++i){const child=<span class="cstat-no" title="statement not covered" >children[i];<span class="cstat-no" title="statement not covered" ></span>if(nameFilterValue&amp;&amp;child.filteredOut&amp;&amp;child.filteredOut(nameFilterValue))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst hasChildren=<span class="cstat-no" title="statement not covered" >child.hasChildren();<span class="cstat-no" title="statement not covered" ></span>child.removeChildren();<span class="cstat-no" title="statement not covered" >c</span>hild.setHasChildren(hasChildren);<span class="cstat-no" title="statement not covered" >p</span>arentNode.appendChild(child);<span class="cstat-no" title="statement not covered" >p</span>osition+=child.nodeSelfHeight();<span class="cstat-no" title="statement not covered" >p</span>osition+=this._addVisibleNodes(child,topBound-position,bottomBound-position);}</span>
let bottomPadding=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;children.length;++i){const child=<span class="cstat-no" title="statement not covered" >children[i];<span class="cstat-no" title="statement not covered" ></span>if(nameFilterValue&amp;&amp;child.filteredOut&amp;&amp;child.filteredOut(nameFilterValue))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span>ottomPadding+=this._nodeHeight(child);}</span>
<span class="cstat-no" title="statement not covered" >this._topPaddingHeight+=topPadding;<span class="cstat-no" title="statement not covered" >t</span>his._bottomPaddingHeight+=bottomPadding;<span class="cstat-no" title="statement not covered" >r</span>eturn position+bottomPadding;}</span>
<span class="fstat-no" title="function not covered" >_n</span>odeHeight(node){let result=<span class="cstat-no" title="statement not covered" >node.nodeSelfHeight();<span class="cstat-no" title="statement not covered" ></span>if(!node.expanded)</span>
<span class="cstat-no" title="statement not covered" >return result;c</span>onst children=<span class="cstat-no" title="statement not covered" >this.allChildren(node);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;children.length;i++)</span>
<span class="cstat-no" title="statement not covered" >result+=this._nodeHeight(children[i]);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >re</span>vealTreeNode(pathToReveal){const height=<span class="cstat-no" title="statement not covered" >this._calculateOffset(pathToReveal);</span>const node=(<span class="cstat-no" title="statement not covered" >pathToReveal.peekLast())</span>;const scrollTop=<span class="cstat-no" title="statement not covered" >this.scrollContainer.scrollTop;</span>const scrollBottom=<span class="cstat-no" title="statement not covered" >scrollTop+this.scrollContainer.offsetHeight;<span class="cstat-no" title="statement not covered" ></span>if(height&gt;=scrollTop&amp;&amp;height&lt;scrollBottom)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve(node);c</span>onst scrollGap=<span class="cstat-no" title="statement not covered" >40;<span class="cstat-no" title="statement not covered" ></span>this.scrollContainer.scrollTop=Math.max(0,height-scrollGap);<span class="cstat-no" title="statement not covered" >r</span>eturn new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;{<span class="cstat-no" title="statement not covered" >console.assert(!this._scrollToResolveCallback);<span class="cstat-no" title="statement not covered" >t</span>his._scrollToResolveCallback=resolve.bind(null,node);<span class="cstat-no" title="statement not covered" >t</span>his.scrollContainer.window().requestAnimationFrame(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!this._scrollToResolveCallback)</span></span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._scrollToResolveCallback();<span class="cstat-no" title="statement not covered" >t</span>his._scrollToResolveCallback=null;}</span>);});}
<span class="fstat-no" title="function not covered" >_c</span>alculateOffset(pathToReveal){let parentNode=<span class="cstat-no" title="statement not covered" >this.rootNode();</span>let height=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;pathToReveal.length;++i){const node=<span class="cstat-no" title="statement not covered" >pathToReveal[i];</span>const children=<span class="cstat-no" title="statement not covered" >this.allChildren(parentNode);<span class="cstat-no" title="statement not covered" ></span>for(let j=0;j&lt;children.length;++j){const child=<span class="cstat-no" title="statement not covered" >children[j];<span class="cstat-no" title="statement not covered" ></span>if(node===child){<span class="cstat-no" title="statement not covered" >height+=node.nodeSelfHeight();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >height+=this._nodeHeight(child);}</span>
<span class="cstat-no" title="statement not covered" >parentNode=node;}</span>
<span class="cstat-no" title="statement not covered" >return height-pathToReveal.peekLast().nodeSelfHeight();}</span>
<span class="fstat-no" title="function not covered" >al</span>lChildren(parent){<span class="cstat-no" title="statement not covered" >return parent._allChildren||(parent._allChildren=[]);}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendNode(parent,node){<span class="cstat-no" title="statement not covered" >this.allChildren(parent).push(node);}</span>
<span class="fstat-no" title="function not covered" >in</span>sertChild(parent,node,index){<span class="cstat-no" title="statement not covered" >this.allChildren(parent).splice(index,0,(node));}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChildByIndex(parent,index){<span class="cstat-no" title="statement not covered" >this.allChildren(parent).splice(index,1);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveAllChildren(parent){<span class="cstat-no" title="statement not covered" >parent._allChildren=[];}</span>
<span class="fstat-no" title="function not covered" >re</span>moveTopLevelNodes(){<span class="cstat-no" title="statement not covered" >this._disposeAllNodes();<span class="cstat-no" title="statement not covered" >t</span>his.rootNode().removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his.rootNode()._allChildren=[];}</span>
<span class="fstat-no" title="function not covered" >_i</span>sScrolledIntoView(element){const viewportTop=<span class="cstat-no" title="statement not covered" >this.scrollContainer.scrollTop;</span>const viewportBottom=<span class="cstat-no" title="statement not covered" >viewportTop+this.scrollContainer.clientHeight;</span>const elemTop=<span class="cstat-no" title="statement not covered" >element.offsetTop;</span>const elemBottom=<span class="cstat-no" title="statement not covered" >elemTop+element.offsetHeight;<span class="cstat-no" title="statement not covered" ></span>return elemBottom&lt;=viewportBottom&amp;&amp;elemTop&gt;=viewportTop;}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >super.onResize();<span class="cstat-no" title="statement not covered" >t</span>his.updateVisibleNodes(false);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nScroll(event){<span class="cstat-no" title="statement not covered" >this.updateVisibleNodes(false);<span class="cstat-no" title="statement not covered" >i</span>f(this._scrollToResolveCallback){<span class="cstat-no" title="statement not covered" >this._scrollToResolveCallback();<span class="cstat-no" title="statement not covered" >t</span>his._scrollToResolveCallback=null;}</span>}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotContainmentDataGrid=class extends Profiler.HeapSnapshotSortableDataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,columns){<span class="cstat-no" title="statement not covered" >columns=columns||(([{id:'object',title:ls`Object`,disclosure:true,sortable:true},{id:'distance',title:ls`Distance`,width:'70px',sortable:true,fixedWidth:true},{id:'shallowSize',title:ls`Shallow Size`,width:'110px',sortable:true,fixedWidth:true},{id:'retainedSize',title:ls`Retained Size`,width:'110px',sortable:true,fixedWidth:true,sort:DataGrid.DataGrid.Order.Descending}]));<span class="cstat-no" title="statement not covered" >s</span>uper(dataDisplayDelegate,columns);}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tDataSource(snapshot,nodeIndex){<span class="cstat-no" title="statement not covered" >this.snapshot=snapshot;c</span>onst node=<span class="cstat-no" title="statement not covered" >{nodeIndex:nodeIndex||snapshot.rootNodeIndex};</span>const fakeEdge=<span class="cstat-no" title="statement not covered" >{node:node};<span class="cstat-no" title="statement not covered" ></span>this.setRootNode(this._createRootNode(snapshot,fakeEdge));<span class="cstat-no" title="statement not covered" >t</span>his.rootNode().sort();}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateRootNode(snapshot,fakeEdge){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotObjectNode(this,snapshot,fakeEdge,null);}</span>
<span class="fstat-no" title="function not covered" >so</span>rtingChanged(){const rootNode=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>if(rootNode.hasChildren())</span>
<span class="cstat-no" title="statement not covered" >rootNode.sort();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotRetainmentDataGrid=class extends Profiler.HeapSnapshotContainmentDataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate){const columns=(<span class="cstat-no" title="statement not covered" >[{id:'object',title:ls`Object`,disclosure:true,sortable:true},{id:'distance',title:ls`Distance`,width:'70px',sortable:true,fixedWidth:true,sort:DataGrid.DataGrid.Order.Ascending},{id:'shallowSize',title:ls`Shallow Size`,width:'110px',sortable:true,fixedWidth:true},{id:'retainedSize',title:ls`Retained Size`,width:'110px',sortable:true,fixedWidth:true}])</span>;<span class="cstat-no" title="statement not covered" >super(dataDisplayDelegate,columns);}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>reateRootNode(snapshot,fakeEdge){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotRetainingObjectNode(this,snapshot,fakeEdge,null);}</span>
<span class="fstat-no" title="function not covered" >_s</span>ortFields(sortColumn,sortAscending){<span class="cstat-no" title="statement not covered" >return{object:['_name',sortAscending,'_count',false],count:['_count',sortAscending,'_name',true],shallowSize:['_shallowSize',sortAscending,'_name',true],retainedSize:['_retainedSize',sortAscending,'_name',true],distance:['_distance',sortAscending,'_name',true]}[sortColumn];}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this.rootNode().removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his.resetSortingCache();}</span>
<span class="fstat-no" title="function not covered" >se</span>tDataSource(snapshot,nodeIndex){<span class="cstat-no" title="statement not covered" >super.setDataSource(snapshot,nodeIndex);<span class="cstat-no" title="statement not covered" >t</span>his.rootNode().expand();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotRetainmentDataGrid.Events={ExpandRetainersComplete:Symbol('ExpandRetainersComplete')};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotConstructorsDataGrid=class extends Profiler.HeapSnapshotViewportDataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate){const columns=(<span class="cstat-no" title="statement not covered" >[{id:'object',title:ls`Constructor`,disclosure:true,sortable:true},{id:'distance',title:ls`Distance`,width:'70px',sortable:true,fixedWidth:true},{id:'shallowSize',title:ls`Shallow Size`,width:'110px',sortable:true,fixedWidth:true},{id:'retainedSize',title:ls`Retained Size`,width:'110px',sort:DataGrid.DataGrid.Order.Descending,sortable:true,fixedWidth:true}])</span>;<span class="cstat-no" title="statement not covered" >super(dataDisplayDelegate,columns);<span class="cstat-no" title="statement not covered" >t</span>his._profileIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._objectIdToSelect=null;}</span></span>
<span class="fstat-no" title="function not covered" >_s</span>ortFields(sortColumn,sortAscending){<span class="cstat-no" title="statement not covered" >return{object:['_name',sortAscending,'_retainedSize',false],distance:['_distance',sortAscending,'_retainedSize',false],shallowSize:['_shallowSize',sortAscending,'_name',true],retainedSize:['_retainedSize',sortAscending,'_name',true]}[sortColumn];}</span>
<span class="fstat-no" title="function not covered" >as</span>ync revealObjectByHeapSnapshotId(id){<span class="cstat-no" title="statement not covered" >if(!this.snapshot){<span class="cstat-no" title="statement not covered" >this._objectIdToSelect=id;<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span></span>
const className=<span class="cstat-no" title="statement not covered" >await this.snapshot.nodeClassName(parseInt(id,10));<span class="cstat-no" title="statement not covered" ></span>if(!className)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst parent=<span class="cstat-no" title="statement not covered" >this.topLevelNodes().find(<span class="fstat-no" title="function not covered" >cl</span>assNode=&gt;<span class="cstat-no" title="statement not covered" >classNode._name===className)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!parent)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst nodes=<span class="cstat-no" title="statement not covered" >await parent.populateNodeBySnapshotObjectId(parseInt(id,10));<span class="cstat-no" title="statement not covered" ></span>return nodes.length?this.revealTreeNode(nodes):null;}</span>
<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >this._nextRequestedFilter=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastFilter=null;<span class="cstat-no" title="statement not covered" >t</span>his.removeTopLevelNodes();}</span>
<span class="fstat-no" title="function not covered" >se</span>tDataSource(snapshot){<span class="cstat-no" title="statement not covered" >this.snapshot=snapshot;<span class="cstat-no" title="statement not covered" >i</span>f(this._profileIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >this._populateChildren();<span class="cstat-no" title="statement not covered" >i</span>f(this._objectIdToSelect){<span class="cstat-no" title="statement not covered" >this.revealObjectByHeapSnapshotId(this._objectIdToSelect);<span class="cstat-no" title="statement not covered" >t</span>his._objectIdToSelect=null;}</span>}</span>
<span class="fstat-no" title="function not covered" >se</span>tSelectionRange(minNodeId,maxNodeId){<span class="cstat-no" title="statement not covered" >this._nodeFilter=new HeapSnapshotModel.NodeFilter(minNodeId,maxNodeId);<span class="cstat-no" title="statement not covered" >t</span>his._populateChildren(this._nodeFilter);}</span>
<span class="fstat-no" title="function not covered" >se</span>tAllocationNodeId(allocationNodeId){<span class="cstat-no" title="statement not covered" >this._nodeFilter=new HeapSnapshotModel.NodeFilter();<span class="cstat-no" title="statement not covered" >t</span>his._nodeFilter.allocationNodeId=allocationNodeId;<span class="cstat-no" title="statement not covered" >t</span>his._populateChildren(this._nodeFilter);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ggregatesReceived(nodeFilter,aggregates){<span class="cstat-no" title="statement not covered" >this._filterInProgress=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._nextRequestedFilter){<span class="cstat-no" title="statement not covered" >this.snapshot.aggregatesWithFilter(this._nextRequestedFilter).then(this._aggregatesReceived.bind(this,this._nextRequestedFilter));<span class="cstat-no" title="statement not covered" >t</span>his._filterInProgress=this._nextRequestedFilter;<span class="cstat-no" title="statement not covered" >t</span>his._nextRequestedFilter=null;}</span></span>
<span class="cstat-no" title="statement not covered" >this.removeTopLevelNodes();<span class="cstat-no" title="statement not covered" >t</span>his.resetSortingCache();<span class="cstat-no" title="statement not covered" >f</span>or(const constructor in aggregates){<span class="cstat-no" title="statement not covered" >this.appendNode(this.rootNode(),new Profiler.HeapSnapshotConstructorNode(this,constructor,aggregates[constructor],nodeFilter));}</span></span>
<span class="cstat-no" title="statement not covered" >this.sortingChanged();<span class="cstat-no" title="statement not covered" >t</span>his._lastFilter=nodeFilter;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _populateChildren(maybeNodeFilter){const nodeFilter=<span class="cstat-no" title="statement not covered" >maybeNodeFilter||new HeapSnapshotModel.NodeFilter();<span class="cstat-no" title="statement not covered" ></span>if(this._filterInProgress){<span class="cstat-no" title="statement not covered" >this._nextRequestedFilter=this._filterInProgress.equals(nodeFilter)?null:nodeFilter;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._lastFilter&amp;&amp;this._lastFilter.equals(nodeFilter))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._filterInProgress=nodeFilter;c</span>onst aggregates=<span class="cstat-no" title="statement not covered" >await this.snapshot.aggregatesWithFilter(nodeFilter);<span class="cstat-no" title="statement not covered" ></span>this._aggregatesReceived(nodeFilter,aggregates);}</span>
<span class="fstat-no" title="function not covered" >fi</span>lterSelectIndexChanged(profiles,profileIndex){<span class="cstat-no" title="statement not covered" >this._profileIndex=profileIndex;<span class="cstat-no" title="statement not covered" >t</span>his._nodeFilter=undefined;<span class="cstat-no" title="statement not covered" >i</span>f(profileIndex!==-1){const minNodeId=<span class="cstat-no" title="statement not covered" >profileIndex&gt;0?profiles[profileIndex-1].maxJSObjectId:0;</span>const maxNodeId=<span class="cstat-no" title="statement not covered" >profiles[profileIndex].maxJSObjectId;<span class="cstat-no" title="statement not covered" ></span>this._nodeFilter=new HeapSnapshotModel.NodeFilter(minNodeId,maxNodeId);}</span></span>
<span class="cstat-no" title="statement not covered" >this._populateChildren(this._nodeFilter);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotDiffDataGrid=class extends Profiler.HeapSnapshotViewportDataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate){const columns=(<span class="cstat-no" title="statement not covered" >[{id:'object',title:ls`Constructor`,disclosure:true,sortable:true},{id:'addedCount',title:ls`# New`,width:'75px',sortable:true,fixedWidth:true},{id:'removedCount',title:ls`# Deleted`,width:'75px',sortable:true,fixedWidth:true},{id:'countDelta',title:ls`# Delta`,width:'65px',sortable:true,fixedWidth:true},{id:'addedSize',title:ls`Alloc. Size`,width:'75px',sortable:true,fixedWidth:true,sort:DataGrid.DataGrid.Order.Descending},{id:'removedSize',title:ls`Freed Size`,width:'75px',sortable:true,fixedWidth:true},{id:'sizeDelta',title:ls`Size Delta`,width:'75px',sortable:true,fixedWidth:true}])</span>;<span class="cstat-no" title="statement not covered" >super(dataDisplayDelegate,columns);}</span></span>
<span class="fstat-no" title="function not covered" >de</span>faultPopulateCount(){<span class="cstat-no" title="statement not covered" >return 50;}</span>
<span class="fstat-no" title="function not covered" >_s</span>ortFields(sortColumn,sortAscending){<span class="cstat-no" title="statement not covered" >return{object:['_name',sortAscending,'_count',false],addedCount:['_addedCount',sortAscending,'_name',true],removedCount:['_removedCount',sortAscending,'_name',true],countDelta:['_countDelta',sortAscending,'_name',true],addedSize:['_addedSize',sortAscending,'_name',true],removedSize:['_removedSize',sortAscending,'_name',true],sizeDelta:['_sizeDelta',sortAscending,'_name',true]}[sortColumn];}</span>
<span class="fstat-no" title="function not covered" >se</span>tDataSource(snapshot){<span class="cstat-no" title="statement not covered" >this.snapshot=snapshot;}</span>
<span class="fstat-no" title="function not covered" >se</span>tBaseDataSource(baseSnapshot){<span class="cstat-no" title="statement not covered" >this.baseSnapshot=baseSnapshot;<span class="cstat-no" title="statement not covered" >t</span>his.removeTopLevelNodes();<span class="cstat-no" title="statement not covered" >t</span>his.resetSortingCache();<span class="cstat-no" title="statement not covered" >i</span>f(this.baseSnapshot===this.snapshot){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._populateChildren();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _populateChildren(){const aggregatesForDiff=<span class="cstat-no" title="statement not covered" >await this.baseSnapshot.aggregatesForDiff();</span>const diffByClassName=<span class="cstat-no" title="statement not covered" >await this.snapshot.calculateSnapshotDiff(this.baseSnapshot.uid,aggregatesForDiff);<span class="cstat-no" title="statement not covered" ></span>for(const className in diffByClassName){const diff=<span class="cstat-no" title="statement not covered" >diffByClassName[className];<span class="cstat-no" title="statement not covered" ></span>this.appendNode(this.rootNode(),new Profiler.HeapSnapshotDiffNode(this,className,diff));}</span></span>
<span class="cstat-no" title="statement not covered" >this.sortingChanged();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.AllocationDataGrid=class extends Profiler.HeapSnapshotViewportDataGrid{<span class="fstat-no" title="function not covered" >co</span>nstructor(heapProfilerModel,dataDisplayDelegate){const columns=(<span class="cstat-no" title="statement not covered" >[{id:'liveCount',title:ls`Live Count`,width:'75px',sortable:true,fixedWidth:true},{id:'count',title:ls`Count`,width:'65px',sortable:true,fixedWidth:true},{id:'liveSize',title:ls`Live Size`,width:'75px',sortable:true,fixedWidth:true},{id:'size',title:ls`Size`,width:'75px',sortable:true,fixedWidth:true,sort:DataGrid.DataGrid.Order.Descending},{id:'name',title:ls`Function`,disclosure:true,sortable:true},])</span>;<span class="cstat-no" title="statement not covered" >super(dataDisplayDelegate,columns);<span class="cstat-no" title="statement not covered" >t</span>his._heapProfilerModel=heapProfilerModel;<span class="cstat-no" title="statement not covered" >t</span>his._linkifier=new Components.Linkifier();}</span></span>
<span class="fstat-no" title="function not covered" >he</span>apProfilerModel(){<span class="cstat-no" title="statement not covered" >return this._heapProfilerModel;}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._linkifier.reset();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync setDataSource(snapshot){<span class="cstat-no" title="statement not covered" >this.snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._topNodes=await this.snapshot.allocationTracesTops();<span class="cstat-no" title="statement not covered" >t</span>his._populateChildren();}</span>
<span class="fstat-no" title="function not covered" >_p</span>opulateChildren(){<span class="cstat-no" title="statement not covered" >this.removeTopLevelNodes();c</span>onst root=<span class="cstat-no" title="statement not covered" >this.rootNode();</span>const tops=<span class="cstat-no" title="statement not covered" >this._topNodes;<span class="cstat-no" title="statement not covered" ></span>for(const top of tops)</span>
<span class="cstat-no" title="statement not covered" >this.appendNode(root,new Profiler.AllocationGridNode(this,top));<span class="cstat-no" title="statement not covered" >t</span>his.updateVisibleNodes(true);}</span>
<span class="fstat-no" title="function not covered" >so</span>rtingChanged(){<span class="cstat-no" title="statement not covered" >this._topNodes.sort(this._createComparator());<span class="cstat-no" title="statement not covered" >t</span>his.rootNode().removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._populateChildren();}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateComparator(){const fieldName=<span class="cstat-no" title="statement not covered" >this.sortColumnId();</span>const compareResult=<span class="cstat-no" title="statement not covered" >(this.sortOrder()===DataGrid.DataGrid.Order.Ascending)?+1:-1;</span>function <span class="fstat-no" title="function not covered" >compare(</span>a,b){<span class="cstat-no" title="statement not covered" >if(a[fieldName]&gt;b[fieldName])</span>
<span class="cstat-no" title="statement not covered" >return compareResult;<span class="cstat-no" title="statement not covered" >i</span>f(a[fieldName]&lt;b[fieldName])</span>
<span class="cstat-no" title="statement not covered" >return-compareResult;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>
<span class="cstat-no" title="statement not covered" >return compare;}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotGridNode=class extends DataGrid.DataGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(tree,hasChildren){<span class="cstat-no" title="statement not covered" >super(null,hasChildren);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid=tree;<span class="cstat-no" title="statement not covered" >t</span>his._instanceCount=0;<span class="cstat-no" title="statement not covered" >t</span>his._savedChildren=null;<span class="cstat-no" title="statement not covered" >t</span>his._retrievedChildrenRanges=[];<span class="cstat-no" title="statement not covered" >t</span>his._providerObject=null;<span class="cstat-no" title="statement not covered" >t</span>his._reachableFromWindow=false;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic createComparator(fieldNames){<span class="cstat-no" title="statement not covered" >return({fieldName1:fieldNames[0],ascending1:fieldNames[1],fieldName2:fieldNames[2],ascending2:fieldNames[3]});}</span>
<span class="fstat-no" title="function not covered" >he</span>apSnapshotDataGrid(){<span class="cstat-no" title="statement not covered" >return this._dataGrid;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProvider(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented.');}</span>
<span class="fstat-no" title="function not covered" >re</span>tainersDataSource(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rovider(){<span class="cstat-no" title="statement not covered" >if(!this._providerObject)</span>
<span class="cstat-no" title="statement not covered" >this._providerObject=this.createProvider();<span class="cstat-no" title="statement not covered" >r</span>eturn this._providerObject;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){const cell=<span class="cstat-no" title="statement not covered" >super.createCell(columnId);<span class="cstat-no" title="statement not covered" ></span>if(this._searchMatched)</span>
<span class="cstat-no" title="statement not covered" >cell.classList.add('highlight');<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >co</span>llapse(){<span class="cstat-no" title="statement not covered" >super.collapse();<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.updateVisibleNodes(true);}</span>
<span class="fstat-no" title="function not covered" >ex</span>pand(){<span class="cstat-no" title="statement not covered" >super.expand();<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.updateVisibleNodes(true);}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >if(this._providerObject)</span>
<span class="cstat-no" title="statement not covered" >this._providerObject.dispose();<span class="cstat-no" title="statement not covered" >f</span>or(let node=this.children[0];node;node=node.traverseNextNode(true,this,true)){<span class="cstat-no" title="statement not covered" >if(node.dispose)</span></span>
<span class="cstat-no" title="statement not covered" >node.dispose();}</span>}
<span class="fstat-no" title="function not covered" >qu</span>eryObjectContent(heapProfilerModel,objectGroupName){}
<span class="fstat-no" title="function not covered" >_t</span>oPercentString(num){<span class="cstat-no" title="statement not covered" >return num.toFixed(0)+'\xa0%';}</span>
<span class="fstat-no" title="function not covered" >_t</span>oUIDistance(distance){const baseSystemDistance=<span class="cstat-no" title="statement not covered" >HeapSnapshotModel.baseSystemDistance;<span class="cstat-no" title="statement not covered" ></span>return distance&gt;=0&amp;&amp;distance&lt;baseSystemDistance?Common.UIString('%d',distance):Common.UIString('\u2212');}</span>
<span class="fstat-no" title="function not covered" >al</span>lChildren(){<span class="cstat-no" title="statement not covered" >return this._dataGrid.allChildren(this);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChildByIndex(index){<span class="cstat-no" title="statement not covered" >this._dataGrid.removeChildByIndex(this,index);}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildForPosition(nodePosition){let indexOfFirstChildInRange=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._retrievedChildrenRanges.length;i++){const range=<span class="cstat-no" title="statement not covered" >this._retrievedChildrenRanges[i];<span class="cstat-no" title="statement not covered" ></span>if(range.from&lt;=nodePosition&amp;&amp;nodePosition&lt;range.to){const childIndex=<span class="cstat-no" title="statement not covered" >indexOfFirstChildInRange+nodePosition-range.from;<span class="cstat-no" title="statement not covered" ></span>return this.allChildren()[childIndex];}</span></span></span>
<span class="cstat-no" title="statement not covered" >indexOfFirstChildInRange+=range.to-range.from+1;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateValueCell(columnId){const cell=<span class="cstat-no" title="statement not covered" >UI.html`&lt;td class="numeric-column" /&gt;`;<span class="cstat-no" title="statement not covered" ></span>if(this.dataGrid.snapshot.totalSize!==0){const div=<span class="cstat-no" title="statement not covered" >UI.html`&lt;div&gt;&lt;span&gt;${this.data[columnId]}&lt;/span&gt;&lt;/div&gt;`;</span>const percentColumn=<span class="cstat-no" title="statement not covered" >columnId+'-percent';<span class="cstat-no" title="statement not covered" ></span>if(percentColumn in this.data){<span class="cstat-no" title="statement not covered" >div.appendChild(UI.html`&lt;span class="percent-column"&gt;${this.data[percentColumn]}&lt;/span&gt;`);<span class="cstat-no" title="statement not covered" >d</span>iv.classList.add('profile-multiple-values');}</span></span></span>
<span class="cstat-no" title="statement not covered" >cell.appendChild(div);}</span>
<span class="cstat-no" title="statement not covered" >return cell;}</span>
<span class="fstat-no" title="function not covered" >po</span>pulate(){<span class="cstat-no" title="statement not covered" >if(this._populated)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._populated=true;<span class="cstat-no" title="statement not covered" >t</span>his._provider().sortAndRewind(this.comparator()).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._populateChildren())</span>;}</span>
<span class="fstat-no" title="function not covered" >ex</span>pandWithoutPopulate(){<span class="cstat-no" title="statement not covered" >this._populated=true;<span class="cstat-no" title="statement not covered" >t</span>his.expand();<span class="cstat-no" title="statement not covered" >r</span>eturn this._provider().sortAndRewind(this.comparator());}</span>
<span class="fstat-no" title="function not covered" >_p</span>opulateChildren(fromPosition,toPosition){let afterPopulate;const promise=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >afterPopulate=resolve)</span>;<span class="cstat-no" title="statement not covered" ></span>fromPosition=fromPosition||0;<span class="cstat-no" title="statement not covered" >t</span>oPosition=toPosition||fromPosition+this._dataGrid.defaultPopulateCount();l</span>et firstNotSerializedPosition=<span class="cstat-no" title="statement not covered" >fromPosition;<span class="cstat-no" title="statement not covered" ></span>serializeNextChunk.call(this);<span class="cstat-no" title="statement not covered" >r</span>eturn promise;f</span>unction <span class="fstat-no" title="function not covered" >serializeNextChunk(</span>){<span class="cstat-no" title="statement not covered" >if(firstNotSerializedPosition&gt;=toPosition)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst end=<span class="cstat-no" title="statement not covered" >Math.min(firstNotSerializedPosition+this._dataGrid.defaultPopulateCount(),toPosition);<span class="cstat-no" title="statement not covered" ></span>this._provider().serializeItemsRange(firstNotSerializedPosition,end).then(childrenRetrieved.bind(this));<span class="cstat-no" title="statement not covered" >f</span>irstNotSerializedPosition=end;}</span>
function <span class="fstat-no" title="function not covered" >insertRetrievedChild(</span>item,insertionIndex){<span class="cstat-no" title="statement not covered" >if(this._savedChildren){const hash=<span class="cstat-no" title="statement not covered" >this._childHashForEntity(item);<span class="cstat-no" title="statement not covered" ></span>if(hash in this._savedChildren){<span class="cstat-no" title="statement not covered" >this._dataGrid.insertChild(this,this._savedChildren[hash],insertionIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.insertChild(this,this._createChildNode(item),insertionIndex);}</span>
function <span class="fstat-no" title="function not covered" >insertShowMoreButton(</span>from,to,insertionIndex){const button=<span class="cstat-no" title="statement not covered" >new DataGrid.ShowMoreDataGridNode(this._populateChildren.bind(this),from,to,this._dataGrid.defaultPopulateCount());<span class="cstat-no" title="statement not covered" ></span>this._dataGrid.insertChild(this,button,insertionIndex);}</span>
function <span class="fstat-no" title="function not covered" >childrenRetrieved(</span>itemsRange){let itemIndex=<span class="cstat-no" title="statement not covered" >0;</span>let itemPosition=<span class="cstat-no" title="statement not covered" >itemsRange.startPosition;</span>const items=<span class="cstat-no" title="statement not covered" >itemsRange.items;</span>let insertionIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(!this._retrievedChildrenRanges.length){<span class="cstat-no" title="statement not covered" >if(itemsRange.startPosition&gt;0){<span class="cstat-no" title="statement not covered" >this._retrievedChildrenRanges.push({from:0,to:0});<span class="cstat-no" title="statement not covered" >i</span>nsertShowMoreButton.call(this,0,itemsRange.startPosition,insertionIndex++);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._retrievedChildrenRanges.push({from:itemsRange.startPosition,to:itemsRange.endPosition});<span class="cstat-no" title="statement not covered" >f</span>or(let i=0,l=items.length;i&lt;l;++i)</span>
<span class="cstat-no" title="statement not covered" >insertRetrievedChild.call(this,items[i],insertionIndex++);<span class="cstat-no" title="statement not covered" >i</span>f(itemsRange.endPosition&lt;itemsRange.totalLength)</span>
<span class="cstat-no" title="statement not covered" >insertShowMoreButton.call(this,itemsRange.endPosition,itemsRange.totalLength,insertionIndex++);}</span>else{let rangeIndex=<span class="cstat-no" title="statement not covered" >0;</span>let found=<span class="cstat-no" title="statement not covered" >false;</span>let range;<span class="cstat-no" title="statement not covered" >while(rangeIndex&lt;this._retrievedChildrenRanges.length){<span class="cstat-no" title="statement not covered" >range=this._retrievedChildrenRanges[rangeIndex];<span class="cstat-no" title="statement not covered" >i</span>f(range.to&gt;=itemPosition){<span class="cstat-no" title="statement not covered" >found=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span>
<span class="cstat-no" title="statement not covered" >insertionIndex+=range.to-range.from;<span class="cstat-no" title="statement not covered" >i</span>f(range.to&lt;itemsRange.totalLength)</span>
<span class="cstat-no" title="statement not covered" >insertionIndex+=1;<span class="cstat-no" title="statement not covered" >+</span>+rangeIndex;}</span>
<span class="cstat-no" title="statement not covered" >if(!found||itemsRange.startPosition&lt;range.from){<span class="cstat-no" title="statement not covered" >this.allChildren()[insertionIndex-1].setEndPosition(itemsRange.startPosition);<span class="cstat-no" title="statement not covered" >i</span>nsertShowMoreButton.call(this,itemsRange.startPosition,found?range.from:itemsRange.totalLength,insertionIndex);<span class="cstat-no" title="statement not covered" >r</span>ange={from:itemsRange.startPosition,to:itemsRange.startPosition};<span class="cstat-no" title="statement not covered" >i</span>f(!found)</span></span>
<span class="cstat-no" title="statement not covered" >rangeIndex=this._retrievedChildrenRanges.length;<span class="cstat-no" title="statement not covered" >t</span>his._retrievedChildrenRanges.splice(rangeIndex,0,range);}</span>else{<span class="cstat-no" title="statement not covered" >insertionIndex+=itemPosition-range.from;}</span>
<span class="cstat-no" title="statement not covered" >while(range.to&lt;itemsRange.endPosition){const skipCount=<span class="cstat-no" title="statement not covered" >range.to-itemPosition;<span class="cstat-no" title="statement not covered" ></span>insertionIndex+=skipCount;<span class="cstat-no" title="statement not covered" >i</span>temIndex+=skipCount;<span class="cstat-no" title="statement not covered" >i</span>temPosition=range.to;c</span>onst nextRange=<span class="cstat-no" title="statement not covered" >this._retrievedChildrenRanges[rangeIndex+1];</span>let newEndOfRange=<span class="cstat-no" title="statement not covered" >nextRange?nextRange.from:itemsRange.totalLength;<span class="cstat-no" title="statement not covered" ></span>if(newEndOfRange&gt;itemsRange.endPosition)</span></span>
<span class="cstat-no" title="statement not covered" >newEndOfRange=itemsRange.endPosition;<span class="cstat-no" title="statement not covered" >w</span>hile(itemPosition&lt;newEndOfRange){<span class="cstat-no" title="statement not covered" >insertRetrievedChild.call(this,items[itemIndex++],insertionIndex++);<span class="cstat-no" title="statement not covered" >+</span>+itemPosition;}</span></span>
<span class="cstat-no" title="statement not covered" >if(nextRange&amp;&amp;newEndOfRange===nextRange.from){<span class="cstat-no" title="statement not covered" >range.to=nextRange.to;<span class="cstat-no" title="statement not covered" >t</span>his.removeChildByIndex(insertionIndex);<span class="cstat-no" title="statement not covered" >t</span>his._retrievedChildrenRanges.splice(rangeIndex+1,1);}</span>else{<span class="cstat-no" title="statement not covered" >range.to=newEndOfRange;<span class="cstat-no" title="statement not covered" >i</span>f(newEndOfRange===itemsRange.totalLength)</span></span>
<span class="cstat-no" title="statement not covered" >this.removeChildByIndex(insertionIndex);e</span>lse
<span class="cstat-no" title="statement not covered" >this.allChildren()[insertionIndex].setStartPosition(itemsRange.endPosition);}</span>}}
<span class="cstat-no" title="statement not covered" >this._instanceCount+=items.length;<span class="cstat-no" title="statement not covered" >i</span>f(firstNotSerializedPosition&lt;toPosition){<span class="cstat-no" title="statement not covered" >serializeNextChunk.call(this);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.expanded)</span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.updateVisibleNodes(true);<span class="cstat-no" title="statement not covered" >a</span>fterPopulate();<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.HeapSnapshotGridNode.Events.PopulateComplete);}</span>}
<span class="fstat-no" title="function not covered" >_s</span>aveChildren(){<span class="cstat-no" title="statement not covered" >this._savedChildren=null;c</span>onst children=<span class="cstat-no" title="statement not covered" >this.allChildren();<span class="cstat-no" title="statement not covered" ></span>for(let i=0,l=children.length;i&lt;l;++i){const child=<span class="cstat-no" title="statement not covered" >children[i];<span class="cstat-no" title="statement not covered" ></span>if(!child.expanded)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(!this._savedChildren)</span>
<span class="cstat-no" title="statement not covered" >this._savedChildren={};<span class="cstat-no" title="statement not covered" >t</span>his._savedChildren[this._childHashForNode(child)]=child;}</span>}
<span class="fstat-no" title="function not covered" >as</span>ync sort(){<span class="cstat-no" title="statement not covered" >this._dataGrid.recursiveSortingEnter();<span class="cstat-no" title="statement not covered" >a</span>wait this._provider().sortAndRewind(this.comparator());<span class="cstat-no" title="statement not covered" >t</span>his._saveChildren();<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.removeAllChildren(this);<span class="cstat-no" title="statement not covered" >t</span>his._retrievedChildrenRanges=[];c</span>onst instanceCount=<span class="cstat-no" title="statement not covered" >this._instanceCount;<span class="cstat-no" title="statement not covered" ></span>this._instanceCount=0;<span class="cstat-no" title="statement not covered" >a</span>wait this._populateChildren(0,instanceCount);<span class="cstat-no" title="statement not covered" >f</span>or(const child of this.allChildren()){<span class="cstat-no" title="statement not covered" >if(child.expanded)</span></span>
<span class="cstat-no" title="statement not covered" >child.sort();}</span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.recursiveSortingLeave();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotGridNode.Events={PopulateComplete:Symbol('PopulateComplete')};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotGridNode.ChildrenProvider=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotGridNode.ChildrenProvider.prototype={dispose(){},nodePosition(snapshotObjectId){},isEmpty(){},serializeItemsRange(startPosition,endPosition){},sortAndRewind(comparator){}};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotGenericObjectNode=class extends Profiler.HeapSnapshotGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,node){<span class="cstat-no" title="statement not covered" >super(dataGrid,false);<span class="cstat-no" title="statement not covered" >i</span>f(!node)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._name=node.name;<span class="cstat-no" title="statement not covered" >t</span>his._type=node.type;<span class="cstat-no" title="statement not covered" >t</span>his._distance=node.distance;<span class="cstat-no" title="statement not covered" >t</span>his._shallowSize=node.selfSize;<span class="cstat-no" title="statement not covered" >t</span>his._retainedSize=node.retainedSize;<span class="cstat-no" title="statement not covered" >t</span>his.snapshotNodeId=node.id;<span class="cstat-no" title="statement not covered" >t</span>his.snapshotNodeIndex=node.nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(this._type==='string'){<span class="cstat-no" title="statement not covered" >this._reachableFromWindow=true;}</span>else <span class="cstat-no" title="statement not covered" >if(this._type==='object'&amp;&amp;this._name.startsWith('Window')){<span class="cstat-no" title="statement not covered" >this._name=this.shortenWindowURL(this._name,false);<span class="cstat-no" title="statement not covered" >t</span>his._reachableFromWindow=true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.canBeQueried){<span class="cstat-no" title="statement not covered" >this._reachableFromWindow=true;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(node.detachedDOMTreeNode)</span>
<span class="cstat-no" title="statement not covered" >this.detachedDOMTreeNode=true;c</span>onst snapshot=<span class="cstat-no" title="statement not covered" >dataGrid.snapshot;</span>const shallowSizePercent=<span class="cstat-no" title="statement not covered" >this._shallowSize/snapshot.totalSize*100.0;</span>const retainedSizePercent=<span class="cstat-no" title="statement not covered" >this._retainedSize/snapshot.totalSize*100.0;<span class="cstat-no" title="statement not covered" ></span>this.data={'distance':this._toUIDistance(this._distance),'shallowSize':Number.withThousandsSeparator(this._shallowSize),'retainedSize':Number.withThousandsSeparator(this._retainedSize),'shallowSize-percent':this._toPercentString(shallowSizePercent),'retainedSize-percent':this._toPercentString(retainedSizePercent)};}</span>
<span class="fstat-no" title="function not covered" >re</span>tainersDataSource(){<span class="cstat-no" title="statement not covered" >return{snapshot:this._dataGrid.snapshot,snapshotNodeIndex:this.snapshotNodeIndex};}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){const cell=<span class="cstat-no" title="statement not covered" >columnId!=='object'?this._createValueCell(columnId):this._createObjectCell();<span class="cstat-no" title="statement not covered" ></span>if(this._searchMatched)</span>
<span class="cstat-no" title="statement not covered" >cell.classList.add('highlight');<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateObjectCell(){let value=<span class="cstat-no" title="statement not covered" >this._name;</span>let valueStyle=<span class="cstat-no" title="statement not covered" >'object';<span class="cstat-no" title="statement not covered" ></span>switch(this._type){case'concatenated string':case'string':<span class="cstat-no" title="statement not covered" >value=`"${value}"`;<span class="cstat-no" title="statement not covered" >v</span>alueStyle='string';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'regexp':<span class="cstat-no" title="statement not covered" >value=`/${value}/`;<span class="cstat-no" title="statement not covered" >v</span>alueStyle='string';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'closure':<span class="cstat-no" title="statement not covered" >value=`${value}()`;<span class="cstat-no" title="statement not covered" >v</span>alueStyle='function';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'bigint':<span class="cstat-no" title="statement not covered" >valueStyle='bigint';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'number':<span class="cstat-no" title="statement not covered" >valueStyle='number';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'hidden':<span class="cstat-no" title="statement not covered" >valueStyle='null';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'array':<span class="cstat-no" title="statement not covered" >value=(value||ls`(internal array)`)+'[]';<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
<span class="cstat-no" title="statement not covered" >return this._createObjectCellWithValue(valueStyle,value);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateObjectCellWithValue(valueStyle,value){const fragment=<span class="cstat-no" title="statement not covered" >UI.Fragment.build`</span>
        &lt;td class="object-column disclosure"&gt;
          &lt;div class="source-code event-properties" style="overflow: visible" $="container"&gt;
            &lt;span class="value object-value-${valueStyle}"&gt;${value}&lt;/span&gt;
            &lt;span class="object-value-id"&gt;@${this.snapshotNodeId}&lt;/span&gt;
          &lt;/div&gt;
        &lt;/td&gt;`;const div=<span class="cstat-no" title="statement not covered" >fragment.$('container');<span class="cstat-no" title="statement not covered" ></span>this._prefixObjectCell(div);<span class="cstat-no" title="statement not covered" >i</span>f(this._reachableFromWindow){<span class="cstat-no" title="statement not covered" >div.appendChild(UI.html`&lt;span class="heap-object-tag" title="${ls`User object reachable from window`}"&gt;🗖&lt;/span&gt;`);}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.detachedDOMTreeNode)</span>
<span class="cstat-no" title="statement not covered" >div.appendChild(UI.html`&lt;span class="heap-object-tag" title="${ls`Detached from DOM tree`}"&gt;✀&lt;/span&gt;`);<span class="cstat-no" title="statement not covered" >t</span>his._appendSourceLocation(div);c</span>onst cell=<span class="cstat-no" title="statement not covered" >fragment.element();<span class="cstat-no" title="statement not covered" ></span>if(this.depth)</span>
<span class="cstat-no" title="statement not covered" >cell.style.setProperty('padding-left',(this.depth*this.dataGrid.indentWidth)+'px');<span class="cstat-no" title="statement not covered" >c</span>ell.heapSnapshotNode=this;<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >_p</span>refixObjectCell(div){}
<span class="fstat-no" title="function not covered" >as</span>ync _appendSourceLocation(div){const linkContainer=<span class="cstat-no" title="statement not covered" >UI.html`&lt;span class="heap-object-source-link" /&gt;`;<span class="cstat-no" title="statement not covered" ></span>div.appendChild(linkContainer);c</span>onst link=<span class="cstat-no" title="statement not covered" >await this._dataGrid.dataDisplayDelegate().linkifyObject(this.snapshotNodeIndex);<span class="cstat-no" title="statement not covered" ></span>if(link)</span>
<span class="cstat-no" title="statement not covered" >linkContainer.appendChild(link);e</span>lse
<span class="cstat-no" title="statement not covered" >linkContainer.remove();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync queryObjectContent(heapProfilerModel,objectGroupName){const runtimeModel=<span class="cstat-no" title="statement not covered" >heapProfilerModel.runtimeModel();</span>let result;<span class="cstat-no" title="statement not covered" >if(this._type==='string')</span>
<span class="cstat-no" title="statement not covered" >result=runtimeModel.createRemoteObjectFromPrimitiveValue(this._name);e</span>lse
<span class="cstat-no" title="statement not covered" >result=await heapProfilerModel.objectForSnapshotObjectId(String(this.snapshotNodeId),objectGroupName);<span class="cstat-no" title="statement not covered" >r</span>eturn result||runtimeModel.createRemoteObjectFromPrimitiveValue(ls`Preview is not available`);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync updateHasChildren(){const isEmpty=<span class="cstat-no" title="statement not covered" >await this._provider().isEmpty();<span class="cstat-no" title="statement not covered" ></span>this.setHasChildren(!isEmpty);}</span>
<span class="fstat-no" title="function not covered" >sh</span>ortenWindowURL(fullName,hasObjectId){const startPos=<span class="cstat-no" title="statement not covered" >fullName.indexOf('/');</span>const endPos=<span class="cstat-no" title="statement not covered" >hasObjectId?fullName.indexOf('@'):fullName.length;<span class="cstat-no" title="statement not covered" ></span>if(startPos===-1||endPos===-1)</span>
<span class="cstat-no" title="statement not covered" >return fullName;c</span>onst fullURL=<span class="cstat-no" title="statement not covered" >fullName.substring(startPos+1,endPos).trimLeft();</span>let url=<span class="cstat-no" title="statement not covered" >fullURL.trimURL();<span class="cstat-no" title="statement not covered" ></span>if(url.length&gt;40)</span>
<span class="cstat-no" title="statement not covered" >url=url.trimMiddle(40);<span class="cstat-no" title="statement not covered" >r</span>eturn fullName.substr(0,startPos+2)+url+fullName.substr(endPos);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotObjectNode=class extends Profiler.HeapSnapshotGenericObjectNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,snapshot,edge,parentObjectNode){<span class="cstat-no" title="statement not covered" >super(dataGrid,edge.node);<span class="cstat-no" title="statement not covered" >t</span>his._referenceName=edge.name;<span class="cstat-no" title="statement not covered" >t</span>his._referenceType=edge.type;<span class="cstat-no" title="statement not covered" >t</span>his._edgeIndex=edge.edgeIndex;<span class="cstat-no" title="statement not covered" >t</span>his._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._parentObjectNode=parentObjectNode;<span class="cstat-no" title="statement not covered" >t</span>his._cycledWithAncestorGridNode=this._findAncestorWithSameSnapshotNodeId();<span class="cstat-no" title="statement not covered" >i</span>f(!this._cycledWithAncestorGridNode)</span></span>
<span class="cstat-no" title="statement not covered" >this.updateHasChildren();c</span>onst data=<span class="cstat-no" title="statement not covered" >this.data;<span class="cstat-no" title="statement not covered" ></span>data['count']='';<span class="cstat-no" title="statement not covered" >d</span>ata['addedCount']='';<span class="cstat-no" title="statement not covered" >d</span>ata['removedCount']='';<span class="cstat-no" title="statement not covered" >d</span>ata['countDelta']='';<span class="cstat-no" title="statement not covered" >d</span>ata['addedSize']='';<span class="cstat-no" title="statement not covered" >d</span>ata['removedSize']='';<span class="cstat-no" title="statement not covered" >d</span>ata['sizeDelta']='';}</span>
<span class="fstat-no" title="function not covered" >re</span>tainersDataSource(){<span class="cstat-no" title="statement not covered" >return{snapshot:this._snapshot,snapshotNodeIndex:this.snapshotNodeIndex};}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProvider(){<span class="cstat-no" title="statement not covered" >return this._snapshot.createEdgesProvider(this.snapshotNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >_f</span>indAncestorWithSameSnapshotNodeId(){let ancestor=<span class="cstat-no" title="statement not covered" >this._parentObjectNode;<span class="cstat-no" title="statement not covered" ></span>while(ancestor){<span class="cstat-no" title="statement not covered" >if(ancestor.snapshotNodeId===this.snapshotNodeId)</span></span>
<span class="cstat-no" title="statement not covered" >return ancestor;<span class="cstat-no" title="statement not covered" >a</span>ncestor=ancestor._parentObjectNode;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateChildNode(item){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotObjectNode(this._dataGrid,this._snapshot,item,this);}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForEntity(edge){<span class="cstat-no" title="statement not covered" >return edge.edgeIndex;}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForNode(childNode){<span class="cstat-no" title="statement not covered" >return childNode._edgeIndex;}</span>
<span class="fstat-no" title="function not covered" >co</span>mparator(){const sortAscending=<span class="cstat-no" title="statement not covered" >this._dataGrid.isSortOrderAscending();</span>const sortColumnId=<span class="cstat-no" title="statement not covered" >this._dataGrid.sortColumnId();</span>const sortFields=<span class="cstat-no" title="statement not covered" >{object:['!edgeName',sortAscending,'retainedSize',false],count:['!edgeName',true,'retainedSize',false],shallowSize:['selfSize',sortAscending,'!edgeName',true],retainedSize:['retainedSize',sortAscending,'!edgeName',true],distance:['distance',sortAscending,'_name',true]}[sortColumnId]||['!edgeName',true,'retainedSize',false];<span class="cstat-no" title="statement not covered" ></span>return Profiler.HeapSnapshotGridNode.createComparator(sortFields);}</span>
<span class="fstat-no" title="function not covered" >_p</span>refixObjectCell(div){let name=<span class="cstat-no" title="statement not covered" >this._referenceName||'(empty)';</span>let nameClass=<span class="cstat-no" title="statement not covered" >'name';<span class="cstat-no" title="statement not covered" ></span>switch(this._referenceType){case'context':<span class="cstat-no" title="statement not covered" >nameClass='object-value-number';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'internal':case'hidden':case'weak':<span class="cstat-no" title="statement not covered" >nameClass='object-value-null';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'element':<span class="cstat-no" title="statement not covered" >name=`[${name}]`;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._cycledWithAncestorGridNode)</span>
<span class="cstat-no" title="statement not covered" >div.classList.add('cycled-ancessor-node');<span class="cstat-no" title="statement not covered" >d</span>iv.prepend(UI.html`&lt;span class="${nameClass}"&gt;${name}&lt;/span&gt;</span>
                        &lt;span class="grayed"&gt;${this._edgeNodeSeparator()}&lt;/span&gt;`);}
<span class="fstat-no" title="function not covered" >_e</span>dgeNodeSeparator(){<span class="cstat-no" title="statement not covered" >return'::';}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotRetainingObjectNode=class extends Profiler.HeapSnapshotObjectNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,snapshot,edge,parentRetainingObjectNode){<span class="cstat-no" title="statement not covered" >super(dataGrid,snapshot,edge,parentRetainingObjectNode);}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateProvider(){<span class="cstat-no" title="statement not covered" >return this._snapshot.createRetainingEdgesProvider(this.snapshotNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateChildNode(item){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotRetainingObjectNode(this._dataGrid,this._snapshot,item,this);}</span>
<span class="fstat-no" title="function not covered" >_e</span>dgeNodeSeparator(){<span class="cstat-no" title="statement not covered" >return ls`in`;}</span>
<span class="fstat-no" title="function not covered" >ex</span>pand(){<span class="cstat-no" title="statement not covered" >this._expandRetainersChain(20);}</span>
<span class="fstat-no" title="function not covered" >_e</span>xpandRetainersChain(maxExpandLevels){<span class="cstat-no" title="statement not covered" >if(!this._populated){<span class="cstat-no" title="statement not covered" >this.once(Profiler.HeapSnapshotGridNode.Events.PopulateComplete).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._expandRetainersChain(maxExpandLevels))</span>;<span class="cstat-no" title="statement not covered" >t</span>his.populate();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >super.expand();<span class="cstat-no" title="statement not covered" >i</span>f(--maxExpandLevels&gt;0&amp;&amp;this.children.length&gt;0){const retainer=<span class="cstat-no" title="statement not covered" >this.children[0];<span class="cstat-no" title="statement not covered" ></span>if(retainer._distance&gt;1){<span class="cstat-no" title="statement not covered" >retainer._expandRetainersChain(maxExpandLevels);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.dispatchEventToListeners(Profiler.HeapSnapshotRetainmentDataGrid.Events.ExpandRetainersComplete);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotInstanceNode=class extends Profiler.HeapSnapshotGenericObjectNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,snapshot,node,isDeletedNode){<span class="cstat-no" title="statement not covered" >super(dataGrid,node);<span class="cstat-no" title="statement not covered" >t</span>his._baseSnapshotOrSnapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._isDeletedNode=isDeletedNode;<span class="cstat-no" title="statement not covered" >t</span>his.updateHasChildren();c</span>onst data=<span class="cstat-no" title="statement not covered" >this.data;<span class="cstat-no" title="statement not covered" ></span>data['count']='';<span class="cstat-no" title="statement not covered" >d</span>ata['countDelta']='';<span class="cstat-no" title="statement not covered" >d</span>ata['sizeDelta']='';<span class="cstat-no" title="statement not covered" >i</span>f(this._isDeletedNode){<span class="cstat-no" title="statement not covered" >data['addedCount']='';<span class="cstat-no" title="statement not covered" >d</span>ata['addedSize']='';<span class="cstat-no" title="statement not covered" >d</span>ata['removedCount']='\u2022';<span class="cstat-no" title="statement not covered" >d</span>ata['removedSize']=Number.withThousandsSeparator(this._shallowSize);}</span>else{<span class="cstat-no" title="statement not covered" >data['addedCount']='\u2022';<span class="cstat-no" title="statement not covered" >d</span>ata['addedSize']=Number.withThousandsSeparator(this._shallowSize);<span class="cstat-no" title="statement not covered" >d</span>ata['removedCount']='';<span class="cstat-no" title="statement not covered" >d</span>ata['removedSize']='';}</span>}</span></span>
<span class="fstat-no" title="function not covered" >re</span>tainersDataSource(){<span class="cstat-no" title="statement not covered" >return{snapshot:this._baseSnapshotOrSnapshot,snapshotNodeIndex:this.snapshotNodeIndex};}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProvider(){<span class="cstat-no" title="statement not covered" >return this._baseSnapshotOrSnapshot.createEdgesProvider(this.snapshotNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateChildNode(item){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotObjectNode(this._dataGrid,this._baseSnapshotOrSnapshot,item,null);}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForEntity(edge){<span class="cstat-no" title="statement not covered" >return edge.edgeIndex;}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForNode(childNode){<span class="cstat-no" title="statement not covered" >return childNode._edgeIndex;}</span>
<span class="fstat-no" title="function not covered" >co</span>mparator(){const sortAscending=<span class="cstat-no" title="statement not covered" >this._dataGrid.isSortOrderAscending();</span>const sortColumnId=<span class="cstat-no" title="statement not covered" >this._dataGrid.sortColumnId();</span>const sortFields=<span class="cstat-no" title="statement not covered" >{object:['!edgeName',sortAscending,'retainedSize',false],distance:['distance',sortAscending,'retainedSize',false],count:['!edgeName',true,'retainedSize',false],addedSize:['selfSize',sortAscending,'!edgeName',true],removedSize:['selfSize',sortAscending,'!edgeName',true],shallowSize:['selfSize',sortAscending,'!edgeName',true],retainedSize:['retainedSize',sortAscending,'!edgeName',true]}[sortColumnId]||['!edgeName',true,'retainedSize',false];<span class="cstat-no" title="statement not covered" ></span>return Profiler.HeapSnapshotGridNode.createComparator(sortFields);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotConstructorNode=class extends Profiler.HeapSnapshotGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,className,aggregate,nodeFilter){<span class="cstat-no" title="statement not covered" >super(dataGrid,aggregate.count&gt;0);<span class="cstat-no" title="statement not covered" >t</span>his._name=className;<span class="cstat-no" title="statement not covered" >t</span>his._nodeFilter=nodeFilter;<span class="cstat-no" title="statement not covered" >t</span>his._distance=aggregate.distance;<span class="cstat-no" title="statement not covered" >t</span>his._count=aggregate.count;<span class="cstat-no" title="statement not covered" >t</span>his._shallowSize=aggregate.self;<span class="cstat-no" title="statement not covered" >t</span>his._retainedSize=aggregate.maxRet;c</span>onst snapshot=<span class="cstat-no" title="statement not covered" >dataGrid.snapshot;</span>const retainedSizePercent=<span class="cstat-no" title="statement not covered" >this._retainedSize/snapshot.totalSize*100.0;</span>const shallowSizePercent=<span class="cstat-no" title="statement not covered" >this._shallowSize/snapshot.totalSize*100.0;<span class="cstat-no" title="statement not covered" ></span>this.data={'object':className,'count':Number.withThousandsSeparator(this._count),'distance':this._toUIDistance(this._distance),'shallowSize':Number.withThousandsSeparator(this._shallowSize),'retainedSize':Number.withThousandsSeparator(this._retainedSize),'shallowSize-percent':this._toPercentString(shallowSizePercent),'retainedSize-percent':this._toPercentString(retainedSizePercent)};}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateProvider(){<span class="cstat-no" title="statement not covered" >return this._dataGrid.snapshot.createNodesProviderForClass(this._name,this._nodeFilter);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync populateNodeBySnapshotObjectId(snapshotObjectId){<span class="cstat-no" title="statement not covered" >this._dataGrid.resetNameFilter();<span class="cstat-no" title="statement not covered" >a</span>wait this.expandWithoutPopulate();c</span>onst nodePosition=<span class="cstat-no" title="statement not covered" >await this._provider().nodePosition(snapshotObjectId);<span class="cstat-no" title="statement not covered" ></span>if(nodePosition===-1){<span class="cstat-no" title="statement not covered" >this.collapse();<span class="cstat-no" title="statement not covered" >r</span>eturn[];}</span></span>
<span class="cstat-no" title="statement not covered" >await this._populateChildren(nodePosition,null);c</span>onst node=(<span class="cstat-no" title="statement not covered" >this.childForPosition(nodePosition))</span>;<span class="cstat-no" title="statement not covered" >return node?[this,node]:[];}</span>
<span class="fstat-no" title="function not covered" >fi</span>lteredOut(filterValue){<span class="cstat-no" title="statement not covered" >return this._name.toLowerCase().indexOf(filterValue)===-1;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){const cell=<span class="cstat-no" title="statement not covered" >columnId==='object'?super.createCell(columnId):this._createValueCell(columnId);<span class="cstat-no" title="statement not covered" ></span>if(columnId==='object'&amp;&amp;this._count&gt;1)</span>
<span class="cstat-no" title="statement not covered" >cell.appendChild(UI.html`&lt;span class="objects-count"&gt;×${this._count}&lt;/span&gt;`);<span class="cstat-no" title="statement not covered" >i</span>f(this._searchMatched)</span>
<span class="cstat-no" title="statement not covered" >cell.classList.add('highlight');<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateChildNode(item){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotInstanceNode(this._dataGrid,this._dataGrid.snapshot,item,false);}</span>
<span class="fstat-no" title="function not covered" >co</span>mparator(){const sortAscending=<span class="cstat-no" title="statement not covered" >this._dataGrid.isSortOrderAscending();</span>const sortColumnId=<span class="cstat-no" title="statement not covered" >this._dataGrid.sortColumnId();</span>const sortFields=<span class="cstat-no" title="statement not covered" >{object:['name',sortAscending,'id',true],distance:['distance',sortAscending,'retainedSize',false],shallowSize:['selfSize',sortAscending,'id',true],retainedSize:['retainedSize',sortAscending,'id',true]}[sortColumnId];<span class="cstat-no" title="statement not covered" ></span>return Profiler.HeapSnapshotGridNode.createComparator(sortFields);}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForEntity(node){<span class="cstat-no" title="statement not covered" >return node.id;}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForNode(childNode){<span class="cstat-no" title="statement not covered" >return childNode.snapshotNodeId;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotDiffNodesProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(addedNodesProvider,deletedNodesProvider,addedCount,removedCount){<span class="cstat-no" title="statement not covered" >this._addedNodesProvider=addedNodesProvider;<span class="cstat-no" title="statement not covered" >t</span>his._deletedNodesProvider=deletedNodesProvider;<span class="cstat-no" title="statement not covered" >t</span>his._addedCount=addedCount;<span class="cstat-no" title="statement not covered" >t</span>his._removedCount=removedCount;}</span></span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._addedNodesProvider.dispose();<span class="cstat-no" title="statement not covered" >t</span>his._deletedNodesProvider.dispose();}</span>
<span class="fstat-no" title="function not covered" >no</span>dePosition(snapshotObjectId){<span class="cstat-no" title="statement not covered" >throw new Error('Unreachable');}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return Promise.resolve(false);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync serializeItemsRange(beginPosition,endPosition){let itemsRange;let addedItems;<span class="cstat-no" title="statement not covered" >if(beginPosition&lt;this._addedCount){<span class="cstat-no" title="statement not covered" >itemsRange=await this._addedNodesProvider.serializeItemsRange(beginPosition,endPosition);<span class="cstat-no" title="statement not covered" >f</span>or(const item of itemsRange.items)</span></span>
<span class="cstat-no" title="statement not covered" >item.isAddedNotRemoved=true;<span class="cstat-no" title="statement not covered" >i</span>f(itemsRange.endPosition&gt;=endPosition){<span class="cstat-no" title="statement not covered" >itemsRange.totalLength=this._addedCount+this._removedCount;<span class="cstat-no" title="statement not covered" >r</span>eturn itemsRange;}</span></span>
<span class="cstat-no" title="statement not covered" >addedItems=itemsRange;<span class="cstat-no" title="statement not covered" >i</span>temsRange=await this._deletedNodesProvider.serializeItemsRange(0,endPosition-itemsRange.endPosition);}</span>else{<span class="cstat-no" title="statement not covered" >addedItems=new HeapSnapshotModel.ItemsRange(0,0,0,[]);<span class="cstat-no" title="statement not covered" >i</span>temsRange=await this._deletedNodesProvider.serializeItemsRange(beginPosition-this._addedCount,endPosition-this._addedCount);}</span>
<span class="cstat-no" title="statement not covered" >if(!addedItems.items.length)</span>
<span class="cstat-no" title="statement not covered" >addedItems.startPosition=this._addedCount+itemsRange.startPosition;<span class="cstat-no" title="statement not covered" >f</span>or(const item of itemsRange.items)</span>
<span class="cstat-no" title="statement not covered" >item.isAddedNotRemoved=false;<span class="cstat-no" title="statement not covered" >a</span>ddedItems.items.pushAll(itemsRange.items);<span class="cstat-no" title="statement not covered" >a</span>ddedItems.endPosition=this._addedCount+itemsRange.endPosition;<span class="cstat-no" title="statement not covered" >a</span>ddedItems.totalLength=this._addedCount+this._removedCount;<span class="cstat-no" title="statement not covered" >r</span>eturn addedItems;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync sortAndRewind(comparator){<span class="cstat-no" title="statement not covered" >await this._addedNodesProvider.sortAndRewind(comparator);<span class="cstat-no" title="statement not covered" >a</span>wait this._deletedNodesProvider.sortAndRewind(comparator);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotDiffNode=class extends Profiler.HeapSnapshotGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,className,diffForClass){<span class="cstat-no" title="statement not covered" >super(dataGrid,true);<span class="cstat-no" title="statement not covered" >t</span>his._name=className;<span class="cstat-no" title="statement not covered" >t</span>his._addedCount=diffForClass.addedCount;<span class="cstat-no" title="statement not covered" >t</span>his._removedCount=diffForClass.removedCount;<span class="cstat-no" title="statement not covered" >t</span>his._countDelta=diffForClass.countDelta;<span class="cstat-no" title="statement not covered" >t</span>his._addedSize=diffForClass.addedSize;<span class="cstat-no" title="statement not covered" >t</span>his._removedSize=diffForClass.removedSize;<span class="cstat-no" title="statement not covered" >t</span>his._sizeDelta=diffForClass.sizeDelta;<span class="cstat-no" title="statement not covered" >t</span>his._deletedIndexes=diffForClass.deletedIndexes;<span class="cstat-no" title="statement not covered" >t</span>his.data={'object':className,'addedCount':Number.withThousandsSeparator(this._addedCount),'removedCount':Number.withThousandsSeparator(this._removedCount),'countDelta':this._signForDelta(this._countDelta)+Number.withThousandsSeparator(Math.abs(this._countDelta)),'addedSize':Number.withThousandsSeparator(this._addedSize),'removedSize':Number.withThousandsSeparator(this._removedSize),'sizeDelta':this._signForDelta(this._sizeDelta)+Number.withThousandsSeparator(Math.abs(this._sizeDelta))};}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateProvider(){const tree=<span class="cstat-no" title="statement not covered" >this._dataGrid;<span class="cstat-no" title="statement not covered" ></span>return new Profiler.HeapSnapshotDiffNodesProvider(tree.snapshot.createAddedNodesProvider(tree.baseSnapshot.uid,this._name),tree.baseSnapshot.createDeletedNodesProvider(this._deletedIndexes),this._addedCount,this._removedCount);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){const cell=<span class="cstat-no" title="statement not covered" >super.createCell(columnId);<span class="cstat-no" title="statement not covered" ></span>if(columnId!=='object')</span>
<span class="cstat-no" title="statement not covered" >cell.classList.add('numeric-column');<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateChildNode(item){<span class="cstat-no" title="statement not covered" >if(item.isAddedNotRemoved)</span>
<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotInstanceNode(this._dataGrid,this._dataGrid.snapshot,item,false);e</span>lse
<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotInstanceNode(this._dataGrid,this._dataGrid.baseSnapshot,item,true);}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForEntity(node){<span class="cstat-no" title="statement not covered" >return node.id;}</span>
<span class="fstat-no" title="function not covered" >_c</span>hildHashForNode(childNode){<span class="cstat-no" title="statement not covered" >return childNode.snapshotNodeId;}</span>
<span class="fstat-no" title="function not covered" >co</span>mparator(){const sortAscending=<span class="cstat-no" title="statement not covered" >this._dataGrid.isSortOrderAscending();</span>const sortColumnId=<span class="cstat-no" title="statement not covered" >this._dataGrid.sortColumnId();</span>const sortFields=<span class="cstat-no" title="statement not covered" >{object:['name',sortAscending,'id',true],addedCount:['name',true,'id',true],removedCount:['name',true,'id',true],countDelta:['name',true,'id',true],addedSize:['selfSize',sortAscending,'id',true],removedSize:['selfSize',sortAscending,'id',true],sizeDelta:['selfSize',sortAscending,'id',true]}[sortColumnId];<span class="cstat-no" title="statement not covered" ></span>return Profiler.HeapSnapshotGridNode.createComparator(sortFields);}</span>
<span class="fstat-no" title="function not covered" >fi</span>lteredOut(filterValue){<span class="cstat-no" title="statement not covered" >return this._name.toLowerCase().indexOf(filterValue)===-1;}</span>
<span class="fstat-no" title="function not covered" >_s</span>ignForDelta(delta){<span class="cstat-no" title="statement not covered" >if(delta===0)</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(delta&gt;0)</span>
<span class="cstat-no" title="statement not covered" >return'+';e</span>lse
<span class="cstat-no" title="statement not covered" >return'\u2212';}</span>};<span class="cstat-no" title="statement not covered" >Profiler.AllocationGridNode=class extends Profiler.HeapSnapshotGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataGrid,data){<span class="cstat-no" title="statement not covered" >super(dataGrid,data.hasChildren);<span class="cstat-no" title="statement not covered" >t</span>his._populated=false;<span class="cstat-no" title="statement not covered" >t</span>his._allocationNode=data;<span class="cstat-no" title="statement not covered" >t</span>his.data={'liveCount':Number.withThousandsSeparator(data.liveCount),'count':Number.withThousandsSeparator(data.count),'liveSize':Number.withThousandsSeparator(data.liveSize),'size':Number.withThousandsSeparator(data.size),'name':data.name};}</span></span>
<span class="fstat-no" title="function not covered" >po</span>pulate(){<span class="cstat-no" title="statement not covered" >if(this._populated)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._doPopulate();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _doPopulate(){<span class="cstat-no" title="statement not covered" >this._populated=true;c</span>onst callers=<span class="cstat-no" title="statement not covered" >await this._dataGrid.snapshot.allocationNodeCallers(this._allocationNode.id);</span>const callersChain=<span class="cstat-no" title="statement not covered" >callers.nodesWithSingleCaller;</span>let parentNode=<span class="cstat-no" title="statement not covered" >this;</span>const dataGrid=(<span class="cstat-no" title="statement not covered" >this._dataGrid)</span>;<span class="cstat-no" title="statement not covered" >for(const caller of callersChain){const child=<span class="cstat-no" title="statement not covered" >new Profiler.AllocationGridNode(dataGrid,caller);<span class="cstat-no" title="statement not covered" ></span>dataGrid.appendNode(parentNode,child);<span class="cstat-no" title="statement not covered" >p</span>arentNode=child;<span class="cstat-no" title="statement not covered" >p</span>arentNode._populated=true;<span class="cstat-no" title="statement not covered" >i</span>f(this.expanded)</span></span>
<span class="cstat-no" title="statement not covered" >parentNode.expand();}</span>
const callersBranch=<span class="cstat-no" title="statement not covered" >callers.branchingCallers;<span class="cstat-no" title="statement not covered" ></span>callersBranch.sort(this._dataGrid._createComparator());<span class="cstat-no" title="statement not covered" >f</span>or(const caller of callersBranch)</span>
<span class="cstat-no" title="statement not covered" >dataGrid.appendNode(parentNode,new Profiler.AllocationGridNode(dataGrid,caller));<span class="cstat-no" title="statement not covered" >d</span>ataGrid.updateVisibleNodes(true);}</span>
<span class="fstat-no" title="function not covered" >ex</span>pand(){<span class="cstat-no" title="statement not covered" >super.expand();<span class="cstat-no" title="statement not covered" >i</span>f(this.children.length===1)</span>
<span class="cstat-no" title="statement not covered" >this.children[0].expand();}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){<span class="cstat-no" title="statement not covered" >if(columnId!=='name')</span>
<span class="cstat-no" title="statement not covered" >return this._createValueCell(columnId);c</span>onst cell=<span class="cstat-no" title="statement not covered" >super.createCell(columnId);</span>const allocationNode=<span class="cstat-no" title="statement not covered" >this._allocationNode;</span>const heapProfilerModel=<span class="cstat-no" title="statement not covered" >this._dataGrid.heapProfilerModel();<span class="cstat-no" title="statement not covered" ></span>if(allocationNode.scriptId){const linkifier=<span class="cstat-no" title="statement not covered" >this._dataGrid._linkifier;</span>const urlElement=<span class="cstat-no" title="statement not covered" >linkifier.linkifyScriptLocation(heapProfilerModel?heapProfilerModel.target():null,String(allocationNode.scriptId),allocationNode.scriptName,allocationNode.line-1,allocationNode.column-1,'profile-node-file');<span class="cstat-no" title="statement not covered" ></span>urlElement.style.maxWidth='75%';<span class="cstat-no" title="statement not covered" >c</span>ell.insertBefore(urlElement,cell.firstChild);}</span></span>
<span class="cstat-no" title="statement not covered" >return cell;}</span>
<span class="fstat-no" title="function not covered" >al</span>locationNodeId(){<span class="cstat-no" title="statement not covered" >return this._allocationNode.id;}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView=class extends UI.SimpleView{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataDisplayDelegate,profile){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Heap Snapshot'));<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('heap-snapshot-view');<span class="cstat-no" title="statement not covered" >t</span>his._profile=profile;<span class="cstat-no" title="statement not covered" >t</span>his._linkifier=new Components.Linkifier();c</span>onst profileType=<span class="cstat-no" title="statement not covered" >profile.profileType();<span class="cstat-no" title="statement not covered" ></span>profileType.addEventListener(Profiler.HeapSnapshotProfileType.SnapshotReceived,this._onReceiveSnapshot,this);<span class="cstat-no" title="statement not covered" >p</span>rofileType.addEventListener(Profiler.ProfileType.Events.RemoveProfileHeader,this._onProfileHeaderRemoved,this);c</span>onst isHeapTimeline=<span class="cstat-no" title="statement not covered" >profileType.id===Profiler.TrackingHeapSnapshotProfileType.TypeId;<span class="cstat-no" title="statement not covered" ></span>if(isHeapTimeline)</span></span>
<span class="cstat-no" title="statement not covered" >this._createOverview();<span class="cstat-no" title="statement not covered" >t</span>his._parentDataDisplayDelegate=dataDisplayDelegate;<span class="cstat-no" title="statement not covered" >t</span>his._searchableView=new UI.SearchableView(this);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.show(this.element);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget=new UI.SplitWidget(false,true,'heapSnapshotSplitViewState',200,200);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.show(this._searchableView.element);<span class="cstat-no" title="statement not covered" >t</span>his._containmentDataGrid=new Profiler.HeapSnapshotContainmentDataGrid(this);<span class="cstat-no" title="statement not covered" >t</span>his._containmentDataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._selectionChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._containmentWidget=this._containmentDataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._containmentWidget.setMinimumSize(50,25);<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView=new Profiler.HeapSnapshotStatisticsView();<span class="cstat-no" title="statement not covered" >t</span>his._constructorsDataGrid=new Profiler.HeapSnapshotConstructorsDataGrid(this);<span class="cstat-no" title="statement not covered" >t</span>his._constructorsDataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._selectionChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._constructorsWidget=this._constructorsDataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._constructorsWidget.setMinimumSize(50,25);<span class="cstat-no" title="statement not covered" >t</span>his._diffDataGrid=new Profiler.HeapSnapshotDiffDataGrid(this);<span class="cstat-no" title="statement not covered" >t</span>his._diffDataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._selectionChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._diffWidget=this._diffDataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._diffWidget.setMinimumSize(50,25);<span class="cstat-no" title="statement not covered" >i</span>f(isHeapTimeline){<span class="cstat-no" title="statement not covered" >this._allocationDataGrid=new Profiler.AllocationDataGrid(profile.heapProfilerModel(),this);<span class="cstat-no" title="statement not covered" >t</span>his._allocationDataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._onSelectAllocationNode,this);<span class="cstat-no" title="statement not covered" >t</span>his._allocationWidget=this._allocationDataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._allocationWidget.setMinimumSize(50,25);<span class="cstat-no" title="statement not covered" >t</span>his._allocationStackView=new Profiler.HeapAllocationStackView(profile.heapProfilerModel());<span class="cstat-no" title="statement not covered" >t</span>his._allocationStackView.setMinimumSize(50,25);<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane=new UI.TabbedPane();}</span></span>
<span class="cstat-no" title="statement not covered" >this._retainmentDataGrid=new Profiler.HeapSnapshotRetainmentDataGrid(this);<span class="cstat-no" title="statement not covered" >t</span>his._retainmentWidget=this._retainmentDataGrid.asWidget();<span class="cstat-no" title="statement not covered" >t</span>his._retainmentWidget.setMinimumSize(50,21);<span class="cstat-no" title="statement not covered" >t</span>his._retainmentWidget.element.classList.add('retaining-paths-view');l</span>et splitWidgetResizer;<span class="cstat-no" title="statement not covered" >if(this._allocationStackView){<span class="cstat-no" title="statement not covered" >this._tabbedPane=new UI.TabbedPane();<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane.appendTab('retainers',Common.UIString('Retainers'),this._retainmentWidget);<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane.appendTab('allocation-stack',Common.UIString('Allocation stack'),this._allocationStackView);<span class="cstat-no" title="statement not covered" >s</span>plitWidgetResizer=this._tabbedPane.headerElement();<span class="cstat-no" title="statement not covered" >t</span>his._objectDetailsView=this._tabbedPane;}</span>else{const retainmentViewHeader=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','heap-snapshot-view-resizer');</span>const retainingPathsTitleDiv=<span class="cstat-no" title="statement not covered" >retainmentViewHeader.createChild('div','title');</span>const retainingPathsTitle=<span class="cstat-no" title="statement not covered" >retainingPathsTitleDiv.createChild('span');<span class="cstat-no" title="statement not covered" ></span>retainingPathsTitle.textContent=Common.UIString('Retainers');<span class="cstat-no" title="statement not covered" >s</span>plitWidgetResizer=retainmentViewHeader;<span class="cstat-no" title="statement not covered" >t</span>his._objectDetailsView=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._objectDetailsView.element.appendChild(retainmentViewHeader);<span class="cstat-no" title="statement not covered" >t</span>his._retainmentWidget.show(this._objectDetailsView.element);}</span></span>
<span class="cstat-no" title="statement not covered" >this._splitWidget.hideDefaultResizer();<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.installResizer(splitWidgetResizer);<span class="cstat-no" title="statement not covered" >t</span>his._retainmentDataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._inspectedObjectChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._retainmentDataGrid.reset();<span class="cstat-no" title="statement not covered" >t</span>his._perspectives=[];<span class="cstat-no" title="statement not covered" >t</span>his._comparisonPerspective=new Profiler.HeapSnapshotView.ComparisonPerspective();<span class="cstat-no" title="statement not covered" >t</span>his._perspectives.push(new Profiler.HeapSnapshotView.SummaryPerspective());<span class="cstat-no" title="statement not covered" >i</span>f(profile.profileType()!==Profiler.ProfileTypeRegistry.instance.trackingHeapSnapshotProfileType)</span>
<span class="cstat-no" title="statement not covered" >this._perspectives.push(this._comparisonPerspective);<span class="cstat-no" title="statement not covered" >t</span>his._perspectives.push(new Profiler.HeapSnapshotView.ContainmentPerspective());<span class="cstat-no" title="statement not covered" >i</span>f(this._allocationWidget)</span>
<span class="cstat-no" title="statement not covered" >this._perspectives.push(new Profiler.HeapSnapshotView.AllocationPerspective());<span class="cstat-no" title="statement not covered" >t</span>his._perspectives.push(new Profiler.HeapSnapshotView.StatisticsPerspective());<span class="cstat-no" title="statement not covered" >t</span>his._perspectiveSelect=new UI.ToolbarComboBox(this._onSelectedPerspectiveChanged.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._updatePerspectiveOptions();<span class="cstat-no" title="statement not covered" >t</span>his._baseSelect=new UI.ToolbarComboBox(this._changeBase.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._baseSelect.setVisible(false);<span class="cstat-no" title="statement not covered" >t</span>his._updateBaseOptions();<span class="cstat-no" title="statement not covered" >t</span>his._filterSelect=new UI.ToolbarComboBox(this._changeFilter.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._filterSelect.setVisible(false);<span class="cstat-no" title="statement not covered" >t</span>his._updateFilterOptions();<span class="cstat-no" title="statement not covered" >t</span>his._classNameFilter=new UI.ToolbarInput('Class filter');<span class="cstat-no" title="statement not covered" >t</span>his._classNameFilter.setVisible(false);<span class="cstat-no" title="statement not covered" >t</span>his._constructorsDataGrid.setNameFilter(this._classNameFilter);<span class="cstat-no" title="statement not covered" >t</span>his._diffDataGrid.setNameFilter(this._classNameFilter);<span class="cstat-no" title="statement not covered" >t</span>his._selectedSizeText=new UI.ToolbarText();<span class="cstat-no" title="statement not covered" >t</span>his._popoverHelper=new UI.PopoverHelper(this.element,this._getPopoverRequest.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._popoverHelper.setDisableOnClick(true);<span class="cstat-no" title="statement not covered" >t</span>his._popoverHelper.setHasPadding(true);<span class="cstat-no" title="statement not covered" >t</span>his.element.addEventListener('scroll',this._popoverHelper.hidePopover.bind(this._popoverHelper),true);<span class="cstat-no" title="statement not covered" >t</span>his._currentPerspectiveIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._currentPerspective=this._perspectives[0];<span class="cstat-no" title="statement not covered" >t</span>his._currentPerspective.activate(this);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid=this._currentPerspective.masterGrid(this);<span class="cstat-no" title="statement not covered" >t</span>his._populate();<span class="cstat-no" title="statement not covered" >t</span>his._searchThrottler=new Common.Throttler(0);<span class="cstat-no" title="statement not covered" >t</span>his.element.addEventListener('contextmenu',this._handleContextMenuEvent.bind(this),true);<span class="cstat-no" title="statement not covered" >f</span>or(const existingProfile of this._profiles())</span>
<span class="cstat-no" title="statement not covered" >existingProfile.addEventListener(Profiler.ProfileHeader.Events.ProfileTitleChanged,this._updateControls,this);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateOverview(){const profileType=<span class="cstat-no" title="statement not covered" >this._profile.profileType();<span class="cstat-no" title="statement not covered" ></span>this._trackingOverviewGrid=new Profiler.HeapTimelineOverview();<span class="cstat-no" title="statement not covered" >t</span>his._trackingOverviewGrid.addEventListener(Profiler.HeapTimelineOverview.IdsRangeChanged,this._onIdsRangeChanged.bind(this));<span class="cstat-no" title="statement not covered" >i</span>f(!this._profile.fromFile()&amp;&amp;profileType.profileBeingRecorded()===this._profile){<span class="cstat-no" title="statement not covered" >profileType.addEventListener(Profiler.TrackingHeapSnapshotProfileType.HeapStatsUpdate,this._onHeapStatsUpdate,this);<span class="cstat-no" title="statement not covered" >p</span>rofileType.addEventListener(Profiler.TrackingHeapSnapshotProfileType.TrackingStopped,this._onStopTracking,this);<span class="cstat-no" title="statement not covered" >t</span>his._trackingOverviewGrid.start();}</span>}</span>
<span class="fstat-no" title="function not covered" >_o</span>nStopTracking(){<span class="cstat-no" title="statement not covered" >this._profile.profileType().removeEventListener(Profiler.TrackingHeapSnapshotProfileType.HeapStatsUpdate,this._onHeapStatsUpdate,this);<span class="cstat-no" title="statement not covered" >t</span>his._profile.profileType().removeEventListener(Profiler.TrackingHeapSnapshotProfileType.TrackingStopped,this._onStopTracking,this);<span class="cstat-no" title="statement not covered" >i</span>f(this._trackingOverviewGrid)</span>
<span class="cstat-no" title="statement not covered" >this._trackingOverviewGrid.stop();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nHeapStatsUpdate(event){const samples=<span class="cstat-no" title="statement not covered" >event.data;<span class="cstat-no" title="statement not covered" ></span>if(samples)</span>
<span class="cstat-no" title="statement not covered" >this._trackingOverviewGrid.setSamples(event.data);}</span>
<span class="fstat-no" title="function not covered" >se</span>archableView(){<span class="cstat-no" title="statement not covered" >return this._searchableView;}</span>
<span class="fstat-no" title="function not covered" >sh</span>owProfile(profile){<span class="cstat-no" title="statement not covered" >return this._parentDataDisplayDelegate.showProfile(profile);}</span>
<span class="fstat-no" title="function not covered" >sh</span>owObject(snapshotObjectId,perspectiveName){<span class="cstat-no" title="statement not covered" >if(snapshotObjectId&lt;=this._profile.maxJSObjectId)</span>
<span class="cstat-no" title="statement not covered" >this.selectLiveObject(perspectiveName,snapshotObjectId);e</span>lse
<span class="cstat-no" title="statement not covered" >this._parentDataDisplayDelegate.showObject(snapshotObjectId,perspectiveName);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync linkifyObject(nodeIndex){const heapProfilerModel=<span class="cstat-no" title="statement not covered" >this._profile.heapProfilerModel();<span class="cstat-no" title="statement not covered" ></span>if(!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst location=<span class="cstat-no" title="statement not covered" >await this._profile.getLocation(nodeIndex);<span class="cstat-no" title="statement not covered" ></span>if(!location)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst debuggerModel=<span class="cstat-no" title="statement not covered" >heapProfilerModel.runtimeModel().debuggerModel();</span>const rawLocation=<span class="cstat-no" title="statement not covered" >debuggerModel.createRawLocationByScriptId(String(location.scriptId),location.lineNumber,location.columnNumber);<span class="cstat-no" title="statement not covered" ></span>if(!rawLocation)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst sourceURL=<span class="cstat-no" title="statement not covered" >rawLocation.script()&amp;&amp;rawLocation.script().sourceURL;<span class="cstat-no" title="statement not covered" ></span>return sourceURL&amp;&amp;this._linkifier?this._linkifier.linkifyRawLocation(rawLocation,sourceURL):null;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _populate(){const heapSnapshotProxy=<span class="cstat-no" title="statement not covered" >await this._profile._loadPromise;<span class="cstat-no" title="statement not covered" ></span>this._retrieveStatistics(heapSnapshotProxy);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.setDataSource(heapSnapshotProxy);<span class="cstat-no" title="statement not covered" >i</span>f(this._profile.profileType().id===Profiler.TrackingHeapSnapshotProfileType.TypeId&amp;&amp;this._profile.fromFile()){const samples=<span class="cstat-no" title="statement not covered" >await heapSnapshotProxy.getSamples();<span class="cstat-no" title="statement not covered" ></span>if(samples){<span class="cstat-no" title="statement not covered" >console.assert(samples.timestamps.length);c</span>onst profileSamples=<span class="cstat-no" title="statement not covered" >new Profiler.HeapTimelineOverview.Samples();<span class="cstat-no" title="statement not covered" ></span>profileSamples.sizes=samples.sizes;<span class="cstat-no" title="statement not covered" >p</span>rofileSamples.ids=samples.lastAssignedIds;<span class="cstat-no" title="statement not covered" >p</span>rofileSamples.timestamps=samples.timestamps;<span class="cstat-no" title="statement not covered" >p</span>rofileSamples.max=samples.sizes;<span class="cstat-no" title="statement not covered" >p</span>rofileSamples.totalTime=Math.max(samples.timestamps.peekLast(),10000);<span class="cstat-no" title="statement not covered" >t</span>his._trackingOverviewGrid.setSamples(profileSamples);}</span>}</span></span>
const list=<span class="cstat-no" title="statement not covered" >this._profiles();</span>const profileIndex=<span class="cstat-no" title="statement not covered" >list.indexOf(this._profile);<span class="cstat-no" title="statement not covered" ></span>this._baseSelect.setSelectedIndex(Math.max(0,profileIndex-1));<span class="cstat-no" title="statement not covered" >i</span>f(this._trackingOverviewGrid)</span>
<span class="cstat-no" title="statement not covered" >this._trackingOverviewGrid.updateGrid();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _retrieveStatistics(heapSnapshotProxy){const statistics=<span class="cstat-no" title="statement not covered" >await heapSnapshotProxy.getStatistics();<span class="cstat-no" title="statement not covered" ></span>this._statisticsView.setTotal(statistics.total);<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView.addRecord(statistics.code,Common.UIString('Code'),'#f77');<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView.addRecord(statistics.strings,Common.UIString('Strings'),'#5e5');<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView.addRecord(statistics.jsArrays,Common.UIString('JS Arrays'),'#7af');<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView.addRecord(statistics.native,Common.UIString('Typed Arrays'),'#fc5');<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView.addRecord(statistics.system,Common.UIString('System Objects'),'#98f');<span class="cstat-no" title="statement not covered" >t</span>his._statisticsView.addRecord(statistics.total,Common.UIString('Total'));<span class="cstat-no" title="statement not covered" >r</span>eturn statistics;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nIdsRangeChanged(event){const minId=<span class="cstat-no" title="statement not covered" >event.data.minId;</span>const maxId=<span class="cstat-no" title="statement not covered" >event.data.maxId;<span class="cstat-no" title="statement not covered" ></span>this._selectedSizeText.setText(Common.UIString('Selected size: %s',Number.bytesToString(event.data.size)));<span class="cstat-no" title="statement not covered" >i</span>f(this._constructorsDataGrid.snapshot)</span>
<span class="cstat-no" title="statement not covered" >this._constructorsDataGrid.setSelectionRange(minId,maxId);}</span>
<span class="fstat-no" title="function not covered" >sy</span>ncToolbarItems(){const result=<span class="cstat-no" title="statement not covered" >[this._perspectiveSelect,this._classNameFilter];<span class="cstat-no" title="statement not covered" ></span>if(this._profile.profileType()!==Profiler.ProfileTypeRegistry.instance.trackingHeapSnapshotProfileType)</span>
<span class="cstat-no" title="statement not covered" >result.push(this._baseSelect,this._filterSelect);<span class="cstat-no" title="statement not covered" >r</span>esult.push(this._selectedSizeText);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >this._currentSearchResultIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._popoverHelper.hidePopover();}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsCaseSensitiveSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsRegexSearch(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >se</span>archCanceled(){<span class="cstat-no" title="statement not covered" >this._currentSearchResultIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._searchResults=[];}</span>
<span class="fstat-no" title="function not covered" >_s</span>electRevealedNode(node){<span class="cstat-no" title="statement not covered" >if(node)</span>
<span class="cstat-no" title="statement not covered" >node.select();}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleContextMenuEvent(event){const contextMenu=<span class="cstat-no" title="statement not covered" >new UI.ContextMenu(event);<span class="cstat-no" title="statement not covered" ></span>if(this._dataGrid)</span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.populateContextMenu(contextMenu,event);<span class="cstat-no" title="statement not covered" >c</span>ontextMenu.show();}</span>
<span class="fstat-no" title="function not covered" >pe</span>rformSearch(searchConfig,shouldJump,jumpBackwards){const nextQuery=<span class="cstat-no" title="statement not covered" >new HeapSnapshotModel.SearchConfig(searchConfig.query.trim(),searchConfig.caseSensitive,searchConfig.isRegex,shouldJump,jumpBackwards||false);<span class="cstat-no" title="statement not covered" ></span>this._searchThrottler.schedule(this._performSearch.bind(this,nextQuery));}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _performSearch(nextQuery){<span class="cstat-no" title="statement not covered" >this.searchCanceled();<span class="cstat-no" title="statement not covered" >i</span>f(!this._currentPerspective.supportsSearch())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.currentQuery=nextQuery;c</span>onst query=<span class="cstat-no" title="statement not covered" >nextQuery.query.trim();<span class="cstat-no" title="statement not covered" ></span>if(!query)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(query.charAt(0)==='@'){const snapshotNodeId=<span class="cstat-no" title="statement not covered" >parseInt(query.substring(1),10);<span class="cstat-no" title="statement not covered" ></span>if(isNaN(snapshotNodeId))</span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst node=<span class="cstat-no" title="statement not covered" >await this._dataGrid.revealObjectByHeapSnapshotId(String(snapshotNodeId));<span class="cstat-no" title="statement not covered" ></span>this._selectRevealedNode(node);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >this._searchResults=await this._profile._snapshotProxy.search(this.currentQuery,this._dataGrid.nodeFilter());<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateSearchMatchesCount(this._searchResults.length);<span class="cstat-no" title="statement not covered" >i</span>f(this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >this._currentSearchResultIndex=nextQuery.jumpBackwards?this._searchResults.length-1:0;<span class="cstat-no" title="statement not covered" >a</span>wait this._jumpToSearchResult(this._currentSearchResultIndex);}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToNextSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._currentSearchResultIndex=(this._currentSearchResultIndex+1)%this._searchResults.length;<span class="cstat-no" title="statement not covered" >t</span>his._searchThrottler.schedule(this._jumpToSearchResult.bind(this,this._currentSearchResultIndex));}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToPreviousSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._currentSearchResultIndex=(this._currentSearchResultIndex+this._searchResults.length-1)%this._searchResults.length;<span class="cstat-no" title="statement not covered" >t</span>his._searchThrottler.schedule(this._jumpToSearchResult.bind(this,this._currentSearchResultIndex));}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _jumpToSearchResult(searchResultIndex){<span class="cstat-no" title="statement not covered" >this._searchableView.updateCurrentMatchIndex(searchResultIndex);<span class="cstat-no" title="statement not covered" >i</span>f(searchResultIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst node=<span class="cstat-no" title="statement not covered" >await this._dataGrid.revealObjectByHeapSnapshotId(String(this._searchResults[searchResultIndex]));<span class="cstat-no" title="statement not covered" ></span>this._selectRevealedNode(node);}</span>
<span class="fstat-no" title="function not covered" >re</span>freshVisibleData(){<span class="cstat-no" title="statement not covered" >if(!this._dataGrid)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et child=<span class="cstat-no" title="statement not covered" >this._dataGrid.rootNode().children[0];<span class="cstat-no" title="statement not covered" ></span>while(child){<span class="cstat-no" title="statement not covered" >child.refresh();<span class="cstat-no" title="statement not covered" >c</span>hild=child.traverseNextNode(false,null,true);}</span>}</span>
<span class="fstat-no" title="function not covered" >_c</span>hangeBase(){<span class="cstat-no" title="statement not covered" >if(this._baseProfile===this._profiles()[this._baseSelect.selectedIndex()])</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._baseProfile=this._profiles()[this._baseSelect.selectedIndex()];c</span>onst dataGrid=(<span class="cstat-no" title="statement not covered" >this._dataGrid)</span>;<span class="cstat-no" title="statement not covered" >if(dataGrid.snapshot)</span>
<span class="cstat-no" title="statement not covered" >this._baseProfile._loadPromise.then(dataGrid.setBaseDataSource.bind(dataGrid));<span class="cstat-no" title="statement not covered" >i</span>f(!this.currentQuery||!this._searchResults)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.performSearch(this.currentQuery,false);}</span>
<span class="fstat-no" title="function not covered" >_c</span>hangeFilter(){const profileIndex=<span class="cstat-no" title="statement not covered" >this._filterSelect.selectedIndex()-1;<span class="cstat-no" title="statement not covered" ></span>this._dataGrid.filterSelectIndexChanged(this._profiles(),profileIndex);<span class="cstat-no" title="statement not covered" >i</span>f(!this.currentQuery||!this._searchResults)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.performSearch(this.currentQuery,false);}</span>
<span class="fstat-no" title="function not covered" >_p</span>rofiles(){<span class="cstat-no" title="statement not covered" >return this._profile.profileType().getProfiles();}</span>
<span class="fstat-no" title="function not covered" >_s</span>electionChanged(event){const selectedNode=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >this._setSelectedNodeForDetailsView(selectedNode);<span class="cstat-no" title="statement not covered" >t</span>his._inspectedObjectChanged(event);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nSelectAllocationNode(event){const selectedNode=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >this._constructorsDataGrid.setAllocationNodeId(selectedNode.allocationNodeId());<span class="cstat-no" title="statement not covered" >t</span>his._setSelectedNodeForDetailsView(null);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nspectedObjectChanged(event){const selectedNode=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const heapProfilerModel=<span class="cstat-no" title="statement not covered" >this._profile.heapProfilerModel();<span class="cstat-no" title="statement not covered" ></span>if(heapProfilerModel&amp;&amp;selectedNode instanceof Profiler.HeapSnapshotGenericObjectNode)</span>
<span class="cstat-no" title="statement not covered" >heapProfilerModel.addInspectedHeapObject(String(selectedNode.snapshotNodeId));}</span>
<span class="fstat-no" title="function not covered" >_s</span>etSelectedNodeForDetailsView(nodeItem){const dataSource=<span class="cstat-no" title="statement not covered" >nodeItem&amp;&amp;nodeItem.retainersDataSource();<span class="cstat-no" title="statement not covered" ></span>if(dataSource){<span class="cstat-no" title="statement not covered" >this._retainmentDataGrid.setDataSource(dataSource.snapshot,dataSource.snapshotNodeIndex);<span class="cstat-no" title="statement not covered" >i</span>f(this._allocationStackView)</span></span>
<span class="cstat-no" title="statement not covered" >this._allocationStackView.setAllocatedObject(dataSource.snapshot,dataSource.snapshotNodeIndex);}</span>else{<span class="cstat-no" title="statement not covered" >if(this._allocationStackView)</span>
<span class="cstat-no" title="statement not covered" >this._allocationStackView.clear();<span class="cstat-no" title="statement not covered" >t</span>his._retainmentDataGrid.reset();}</span>}
<span class="fstat-no" title="function not covered" >_c</span>hangePerspectiveAndWait(perspectiveTitle){const perspectiveIndex=<span class="cstat-no" title="statement not covered" >this._perspectives.findIndex(<span class="fstat-no" title="function not covered" >pe</span>rspective=&gt;<span class="cstat-no" title="statement not covered" >perspective.title()===perspectiveTitle)</span>;<span class="cstat-no" title="statement not covered" ></span>if(perspectiveIndex===-1||this._currentPerspectiveIndex===perspectiveIndex)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();c</span>onst promise=<span class="cstat-no" title="statement not covered" >this._perspectives[perspectiveIndex].masterGrid(this).once(Profiler.HeapSnapshotSortableDataGrid.Events.ContentShown);</span>const option=<span class="cstat-no" title="statement not covered" >this._perspectiveSelect.options().find(<span class="fstat-no" title="function not covered" >op</span>tion=&gt;<span class="cstat-no" title="statement not covered" >option.value===perspectiveIndex)</span>;<span class="cstat-no" title="statement not covered" ></span>this._perspectiveSelect.select((option));<span class="cstat-no" title="statement not covered" >t</span>his._changePerspective(perspectiveIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn promise;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _updateDataSourceAndView(){const dataGrid=<span class="cstat-no" title="statement not covered" >this._dataGrid;<span class="cstat-no" title="statement not covered" ></span>if(!dataGrid||dataGrid.snapshot)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst snapshotProxy=<span class="cstat-no" title="statement not covered" >await this._profile._loadPromise;<span class="cstat-no" title="statement not covered" ></span>if(this._dataGrid!==dataGrid)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(dataGrid.snapshot!==snapshotProxy)</span>
<span class="cstat-no" title="statement not covered" >dataGrid.setDataSource(snapshotProxy);<span class="cstat-no" title="statement not covered" >i</span>f(dataGrid!==this._diffDataGrid)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this._baseProfile)</span>
<span class="cstat-no" title="statement not covered" >this._baseProfile=this._profiles()[this._baseSelect.selectedIndex()];c</span>onst baseSnapshotProxy=<span class="cstat-no" title="statement not covered" >await this._baseProfile._loadPromise;<span class="cstat-no" title="statement not covered" ></span>if(this._diffDataGrid.baseSnapshot!==baseSnapshotProxy)</span>
<span class="cstat-no" title="statement not covered" >this._diffDataGrid.setBaseDataSource(baseSnapshotProxy);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nSelectedPerspectiveChanged(event){<span class="cstat-no" title="statement not covered" >this._changePerspective(event.target.selectedOptions[0].value);}</span>
<span class="fstat-no" title="function not covered" >_c</span>hangePerspective(selectedIndex){<span class="cstat-no" title="statement not covered" >if(selectedIndex===this._currentPerspectiveIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._currentPerspectiveIndex=selectedIndex;<span class="cstat-no" title="statement not covered" >t</span>his._currentPerspective.deactivate(this);c</span>onst perspective=<span class="cstat-no" title="statement not covered" >this._perspectives[selectedIndex];<span class="cstat-no" title="statement not covered" ></span>this._currentPerspective=perspective;<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid=perspective.masterGrid(this);<span class="cstat-no" title="statement not covered" >p</span>erspective.activate(this);<span class="cstat-no" title="statement not covered" >t</span>his.refreshVisibleData();<span class="cstat-no" title="statement not covered" >i</span>f(this._dataGrid)</span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.updateWidths();<span class="cstat-no" title="statement not covered" >t</span>his._updateDataSourceAndView();<span class="cstat-no" title="statement not covered" >i</span>f(!this.currentQuery||!this._searchResults)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.performSearch(this.currentQuery,false);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync selectLiveObject(perspectiveName,snapshotObjectId){<span class="cstat-no" title="statement not covered" >await this._changePerspectiveAndWait(perspectiveName);c</span>onst node=<span class="cstat-no" title="statement not covered" >await this._dataGrid.revealObjectByHeapSnapshotId(snapshotObjectId);<span class="cstat-no" title="statement not covered" ></span>if(node)</span>
<span class="cstat-no" title="statement not covered" >node.select();e</span>lse
<span class="cstat-no" title="statement not covered" >Common.console.error('Cannot find corresponding heap snapshot node');}</span>
<span class="fstat-no" title="function not covered" >_g</span>etPopoverRequest(event){const span=<span class="cstat-no" title="statement not covered" >event.target.enclosingNodeOrSelfWithNodeName('span');</span>const row=<span class="cstat-no" title="statement not covered" >event.target.enclosingNodeOrSelfWithNodeName('tr');</span>const heapProfilerModel=<span class="cstat-no" title="statement not covered" >this._profile.heapProfilerModel();<span class="cstat-no" title="statement not covered" ></span>if(!row||!span||!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst node=<span class="cstat-no" title="statement not covered" >row._dataGridNode;</span>let objectPopoverHelper;<span class="cstat-no" title="statement not covered" >return{box:span.boxInWindow(),show:<span class="fstat-no" title="function not covered" >as</span>ync popover=&gt;{const remoteObject=<span class="cstat-no" title="statement not covered" >await node.queryObjectContent(heapProfilerModel,'popover');<span class="cstat-no" title="statement not covered" ></span>if(!remoteObject)</span></span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >o</span>bjectPopoverHelper=await ObjectUI.ObjectPopoverHelper.buildObjectPopover(remoteObject,popover);<span class="cstat-no" title="statement not covered" >i</span>f(!objectPopoverHelper){<span class="cstat-no" title="statement not covered" >heapProfilerModel.runtimeModel().releaseObjectGroup('popover');<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span></span>
<span class="cstat-no" title="statement not covered" >return true;}</span>,hide:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >heapProfilerModel.runtimeModel().releaseObjectGroup('popover');<span class="cstat-no" title="statement not covered" >o</span>bjectPopoverHelper.dispose();}</span>};}
<span class="fstat-no" title="function not covered" >_u</span>pdatePerspectiveOptions(){const multipleSnapshots=<span class="cstat-no" title="statement not covered" >this._profiles().length&gt;1;<span class="cstat-no" title="statement not covered" ></span>this._perspectiveSelect.removeOptions();<span class="cstat-no" title="statement not covered" >t</span>his._perspectives.forEach(<span class="fstat-no" title="function not covered" >(p</span>erspective,index)=&gt;{<span class="cstat-no" title="statement not covered" >if(multipleSnapshots||perspective!==this._comparisonPerspective)</span></span>
<span class="cstat-no" title="statement not covered" >this._perspectiveSelect.createOption(perspective.title(),'',String(index));}</span>);}
<span class="fstat-no" title="function not covered" >_u</span>pdateBaseOptions(){const list=<span class="cstat-no" title="statement not covered" >this._profiles();</span>const selectedIndex=<span class="cstat-no" title="statement not covered" >this._baseSelect.selectedIndex();<span class="cstat-no" title="statement not covered" ></span>this._baseSelect.removeOptions();<span class="cstat-no" title="statement not covered" >f</span>or(const item of list)</span>
<span class="cstat-no" title="statement not covered" >this._baseSelect.createOption(item.title);<span class="cstat-no" title="statement not covered" >i</span>f(selectedIndex&gt;-1)</span>
<span class="cstat-no" title="statement not covered" >this._baseSelect.setSelectedIndex(selectedIndex);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateFilterOptions(){const list=<span class="cstat-no" title="statement not covered" >this._profiles();</span>const selectedIndex=<span class="cstat-no" title="statement not covered" >this._filterSelect.selectedIndex();<span class="cstat-no" title="statement not covered" ></span>this._filterSelect.removeOptions();<span class="cstat-no" title="statement not covered" >t</span>his._filterSelect.createOption(Common.UIString('All objects'));<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;list.length;++i){let title;<span class="cstat-no" title="statement not covered" >if(!i)</span></span>
<span class="cstat-no" title="statement not covered" >title=Common.UIString('Objects allocated before %s',list[i].title);e</span>lse
<span class="cstat-no" title="statement not covered" >title=Common.UIString('Objects allocated between %s and %s',list[i-1].title,list[i].title);<span class="cstat-no" title="statement not covered" >t</span>his._filterSelect.createOption(title);}</span>
<span class="cstat-no" title="statement not covered" >if(selectedIndex&gt;-1)</span>
<span class="cstat-no" title="statement not covered" >this._filterSelect.setSelectedIndex(selectedIndex);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateControls(){<span class="cstat-no" title="statement not covered" >this._updatePerspectiveOptions();<span class="cstat-no" title="statement not covered" >t</span>his._updateBaseOptions();<span class="cstat-no" title="statement not covered" >t</span>his._updateFilterOptions();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nReceiveSnapshot(event){<span class="cstat-no" title="statement not covered" >this._updateControls();c</span>onst profile=<span class="cstat-no" title="statement not covered" >event.data;<span class="cstat-no" title="statement not covered" ></span>profile.addEventListener(Profiler.ProfileHeader.Events.ProfileTitleChanged,this._updateControls,this);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nProfileHeaderRemoved(event){const profile=<span class="cstat-no" title="statement not covered" >event.data;<span class="cstat-no" title="statement not covered" ></span>profile.removeEventListener(Profiler.ProfileHeader.Events.ProfileTitleChanged,this._updateControls,this);<span class="cstat-no" title="statement not covered" >i</span>f(this._profile===profile){<span class="cstat-no" title="statement not covered" >this.detach();<span class="cstat-no" title="statement not covered" >t</span>his._profile.profileType().removeEventListener(Profiler.HeapSnapshotProfileType.SnapshotReceived,this._onReceiveSnapshot,this);<span class="cstat-no" title="statement not covered" >t</span>his._profile.profileType().removeEventListener(Profiler.ProfileType.Events.RemoveProfileHeader,this._onProfileHeaderRemoved,this);<span class="cstat-no" title="statement not covered" >t</span>his.dispose();}</span>else{<span class="cstat-no" title="statement not covered" >this._updateControls();}</span>}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._linkifier.dispose();<span class="cstat-no" title="statement not covered" >t</span>his._popoverHelper.dispose();<span class="cstat-no" title="statement not covered" >i</span>f(this._allocationStackView){<span class="cstat-no" title="statement not covered" >this._allocationStackView.clear();<span class="cstat-no" title="statement not covered" >t</span>his._allocationDataGrid.dispose();}</span></span>
<span class="cstat-no" title="statement not covered" >this._onStopTracking();<span class="cstat-no" title="statement not covered" >i</span>f(this._trackingOverviewGrid){<span class="cstat-no" title="statement not covered" >this._trackingOverviewGrid.removeEventListener(Profiler.HeapTimelineOverview.IdsRangeChanged,this._onIdsRangeChanged.bind(this));}</span>}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView.Perspective=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(title){<span class="cstat-no" title="statement not covered" >this._title=title;}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>tivate(heapSnapshotView){}
<span class="fstat-no" title="function not covered" >de</span>activate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >heapSnapshotView._baseSelect.setVisible(false);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._filterSelect.setVisible(false);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._classNameFilter.setVisible(false);<span class="cstat-no" title="statement not covered" >i</span>f(heapSnapshotView._trackingOverviewGrid)</span>
<span class="cstat-no" title="statement not covered" >heapSnapshotView._trackingOverviewGrid.detach();<span class="cstat-no" title="statement not covered" >i</span>f(heapSnapshotView._allocationWidget)</span>
<span class="cstat-no" title="statement not covered" >heapSnapshotView._allocationWidget.detach();<span class="cstat-no" title="statement not covered" >i</span>f(heapSnapshotView._statisticsView)</span>
<span class="cstat-no" title="statement not covered" >heapSnapshotView._statisticsView.detach();<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.detach();<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.detachChildWidgets();}</span>
<span class="fstat-no" title="function not covered" >ma</span>sterGrid(heapSnapshotView){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >ti</span>tle(){<span class="cstat-no" title="statement not covered" >return this._title;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsSearch(){<span class="cstat-no" title="statement not covered" >return false;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView.SummaryPerspective=class extends Profiler.HeapSnapshotView.Perspective{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Summary'));}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>tivate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >heapSnapshotView._splitWidget.setMainWidget(heapSnapshotView._constructorsWidget);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.setSidebarWidget(heapSnapshotView._objectDetailsView);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.show(heapSnapshotView._searchableView.element);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._filterSelect.setVisible(true);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._classNameFilter.setVisible(true);<span class="cstat-no" title="statement not covered" >i</span>f(!heapSnapshotView._trackingOverviewGrid)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._trackingOverviewGrid.show(heapSnapshotView._searchableView.element,heapSnapshotView._splitWidget.element);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._trackingOverviewGrid.update();<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._trackingOverviewGrid.updateGrid();}</span>
<span class="fstat-no" title="function not covered" >ma</span>sterGrid(heapSnapshotView){<span class="cstat-no" title="statement not covered" >return heapSnapshotView._constructorsDataGrid;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView.ComparisonPerspective=class extends Profiler.HeapSnapshotView.Perspective{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Comparison'));}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>tivate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >heapSnapshotView._splitWidget.setMainWidget(heapSnapshotView._diffWidget);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.setSidebarWidget(heapSnapshotView._objectDetailsView);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.show(heapSnapshotView._searchableView.element);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._baseSelect.setVisible(true);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._classNameFilter.setVisible(true);}</span>
<span class="fstat-no" title="function not covered" >ma</span>sterGrid(heapSnapshotView){<span class="cstat-no" title="statement not covered" >return heapSnapshotView._diffDataGrid;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView.ContainmentPerspective=class extends Profiler.HeapSnapshotView.Perspective{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Containment'));}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>tivate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >heapSnapshotView._splitWidget.setMainWidget(heapSnapshotView._containmentWidget);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.setSidebarWidget(heapSnapshotView._objectDetailsView);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.show(heapSnapshotView._searchableView.element);}</span>
<span class="fstat-no" title="function not covered" >ma</span>sterGrid(heapSnapshotView){<span class="cstat-no" title="statement not covered" >return heapSnapshotView._containmentDataGrid;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView.AllocationPerspective=class extends Profiler.HeapSnapshotView.Perspective{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Allocation'));<span class="cstat-no" title="statement not covered" >t</span>his._allocationSplitWidget=new UI.SplitWidget(false,true,'heapSnapshotAllocationSplitViewState',200,200);<span class="cstat-no" title="statement not covered" >t</span>his._allocationSplitWidget.setSidebarWidget(new UI.VBox());}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>tivate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >this._allocationSplitWidget.setMainWidget(heapSnapshotView._allocationWidget);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.setMainWidget(heapSnapshotView._constructorsWidget);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.setSidebarWidget(heapSnapshotView._objectDetailsView);c</span>onst allocatedObjectsView=<span class="cstat-no" title="statement not covered" >new UI.VBox();</span>const resizer=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','heap-snapshot-view-resizer');</span>const title=<span class="cstat-no" title="statement not covered" >resizer.createChild('div','title').createChild('span');<span class="cstat-no" title="statement not covered" ></span>title.textContent=Common.UIString('Live objects');<span class="cstat-no" title="statement not covered" >t</span>his._allocationSplitWidget.hideDefaultResizer();<span class="cstat-no" title="statement not covered" >t</span>his._allocationSplitWidget.installResizer(resizer);<span class="cstat-no" title="statement not covered" >a</span>llocatedObjectsView.element.appendChild(resizer);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._splitWidget.show(allocatedObjectsView.element);<span class="cstat-no" title="statement not covered" >t</span>his._allocationSplitWidget.setSidebarWidget(allocatedObjectsView);<span class="cstat-no" title="statement not covered" >t</span>his._allocationSplitWidget.show(heapSnapshotView._searchableView.element);<span class="cstat-no" title="statement not covered" >h</span>eapSnapshotView._constructorsDataGrid.clear();c</span>onst selectedNode=<span class="cstat-no" title="statement not covered" >heapSnapshotView._allocationDataGrid.selectedNode;<span class="cstat-no" title="statement not covered" ></span>if(selectedNode)</span>
<span class="cstat-no" title="statement not covered" >heapSnapshotView._constructorsDataGrid.setAllocationNodeId(selectedNode.allocationNodeId());}</span>
<span class="fstat-no" title="function not covered" >de</span>activate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >this._allocationSplitWidget.detach();<span class="cstat-no" title="statement not covered" >s</span>uper.deactivate(heapSnapshotView);}</span>
<span class="fstat-no" title="function not covered" >ma</span>sterGrid(heapSnapshotView){<span class="cstat-no" title="statement not covered" >return heapSnapshotView._allocationDataGrid;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotView.StatisticsPerspective=class extends Profiler.HeapSnapshotView.Perspective{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Common.UIString('Statistics'));}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>tivate(heapSnapshotView){<span class="cstat-no" title="statement not covered" >heapSnapshotView._statisticsView.show(heapSnapshotView._searchableView.element);}</span>
<span class="fstat-no" title="function not covered" >ma</span>sterGrid(heapSnapshotView){<span class="cstat-no" title="statement not covered" >return null;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotProfileType=class extends Profiler.ProfileType{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,title){<span class="cstat-no" title="statement not covered" >super(id||Profiler.HeapSnapshotProfileType.TypeId,title||ls`Heap snapshot`);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.observeModels(SDK.HeapProfilerModel,this);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addModelListener(SDK.HeapProfilerModel,SDK.HeapProfilerModel.Events.ResetProfiles,this._resetProfiles,this);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addModelListener(SDK.HeapProfilerModel,SDK.HeapProfilerModel.Events.AddHeapSnapshotChunk,this._addHeapSnapshotChunk,this);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addModelListener(SDK.HeapProfilerModel,SDK.HeapProfilerModel.Events.ReportHeapSnapshotProgress,this._reportHeapSnapshotProgress,this);}</span></span>
<span class="fstat-no" title="function not covered" >mo</span>delAdded(heapProfilerModel){<span class="cstat-no" title="statement not covered" >heapProfilerModel.enable();}</span>
<span class="fstat-no" title="function not covered" >mo</span>delRemoved(heapProfilerModel){}
<span class="fstat-no" title="function not covered" >ge</span>tProfiles(){<span class="cstat-no" title="statement not covered" >return(super.getProfiles());}</span>
<span class="fstat-no" title="function not covered" >fi</span>leExtension(){<span class="cstat-no" title="statement not covered" >return'.heapsnapshot';}</span>
<span class="fstat-no" title="function not covered" >ge</span>t buttonTooltip(){<span class="cstat-no" title="statement not covered" >return Common.UIString('Take heap snapshot');}</span>
<span class="fstat-no" title="function not covered" >is</span>InstantProfile(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >bu</span>ttonClicked(){<span class="cstat-no" title="statement not covered" >this._takeHeapSnapshot();<span class="cstat-no" title="statement not covered" >H</span>ost.userMetrics.actionTaken(Host.UserMetrics.Action.ProfilesHeapProfileTaken);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return Common.UIString('HEAP SNAPSHOTS');}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return Common.UIString('Heap snapshot profiles show memory distribution among your page\'s JavaScript objects and related DOM nodes.');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateProfileLoadedFromFile(title){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapProfileHeader(null,this,title);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _takeHeapSnapshot(){<span class="cstat-no" title="statement not covered" >if(this.profileBeingRecorded())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst heapProfilerModel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(SDK.HeapProfilerModel);<span class="cstat-no" title="statement not covered" ></span>if(!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et profile=<span class="cstat-no" title="statement not covered" >new Profiler.HeapProfileHeader(heapProfilerModel,this);<span class="cstat-no" title="statement not covered" ></span>this.setProfileBeingRecorded(profile);<span class="cstat-no" title="statement not covered" >t</span>his.addProfile(profile);<span class="cstat-no" title="statement not covered" >p</span>rofile.updateStatus(Common.UIString('Snapshotting\u2026'));<span class="cstat-no" title="statement not covered" >a</span>wait heapProfilerModel.takeHeapSnapshot(true);<span class="cstat-no" title="statement not covered" >p</span>rofile=this.profileBeingRecorded();<span class="cstat-no" title="statement not covered" >p</span>rofile.title=Common.UIString('Snapshot %d',profile.uid);<span class="cstat-no" title="statement not covered" >p</span>rofile._finishLoad();<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(null);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.ProfileType.Events.ProfileComplete,profile);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddHeapSnapshotChunk(event){<span class="cstat-no" title="statement not covered" >if(!this.profileBeingRecorded())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst chunk=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded().transferChunk(chunk);}</span>
<span class="fstat-no" title="function not covered" >_r</span>eportHeapSnapshotProgress(event){const profile=<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded();<span class="cstat-no" title="statement not covered" ></span>if(!profile)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst data=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >profile.updateStatus(Common.UIString('%.0f%%',(data.done/data.total)*100),true);<span class="cstat-no" title="statement not covered" >i</span>f(data.finished)</span>
<span class="cstat-no" title="statement not covered" >profile._prepareToLoad();}</span>
<span class="fstat-no" title="function not covered" >_r</span>esetProfiles(event){const heapProfilerModel=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >for(const profile of this.getProfiles()){<span class="cstat-no" title="statement not covered" >if(profile.heapProfilerModel()===heapProfilerModel)</span></span>
<span class="cstat-no" title="statement not covered" >this.removeProfile(profile);}</span>}
<span class="fstat-no" title="function not covered" >_s</span>napshotReceived(profile){<span class="cstat-no" title="statement not covered" >if(this.profileBeingRecorded()===profile)</span>
<span class="cstat-no" title="statement not covered" >this.setProfileBeingRecorded(null);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.HeapSnapshotProfileType.SnapshotReceived,profile);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotProfileType.TypeId='HEAP';<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotProfileType.SnapshotReceived='SnapshotReceived';<span class="cstat-no" title="statement not covered" >P</span>rofiler.TrackingHeapSnapshotProfileType=class extends Profiler.HeapSnapshotProfileType{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(Profiler.TrackingHeapSnapshotProfileType.TypeId,ls`Allocation instrumentation on timeline`);<span class="cstat-no" title="statement not covered" >t</span>his._recordAllocationStacksSetting=Common.settings.createSetting('recordAllocationStacks',false);}</span></span>
<span class="fstat-no" title="function not covered" >mo</span>delAdded(heapProfilerModel){<span class="cstat-no" title="statement not covered" >super.modelAdded(heapProfilerModel);<span class="cstat-no" title="statement not covered" >h</span>eapProfilerModel.addEventListener(SDK.HeapProfilerModel.Events.HeapStatsUpdate,this._heapStatsUpdate,this);<span class="cstat-no" title="statement not covered" >h</span>eapProfilerModel.addEventListener(SDK.HeapProfilerModel.Events.LastSeenObjectId,this._lastSeenObjectId,this);}</span>
<span class="fstat-no" title="function not covered" >mo</span>delRemoved(heapProfilerModel){<span class="cstat-no" title="statement not covered" >super.modelRemoved(heapProfilerModel);<span class="cstat-no" title="statement not covered" >h</span>eapProfilerModel.removeEventListener(SDK.HeapProfilerModel.Events.HeapStatsUpdate,this._heapStatsUpdate,this);<span class="cstat-no" title="statement not covered" >h</span>eapProfilerModel.removeEventListener(SDK.HeapProfilerModel.Events.LastSeenObjectId,this._lastSeenObjectId,this);}</span>
<span class="fstat-no" title="function not covered" >_h</span>eapStatsUpdate(event){<span class="cstat-no" title="statement not covered" >if(!this._profileSamples)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst samples=(<span class="cstat-no" title="statement not covered" >event.data)</span>;let index;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;samples.length;i+=3){<span class="cstat-no" title="statement not covered" >index=samples[i];c</span>onst size=<span class="cstat-no" title="statement not covered" >samples[i+2];<span class="cstat-no" title="statement not covered" ></span>this._profileSamples.sizes[index]=size;<span class="cstat-no" title="statement not covered" >i</span>f(!this._profileSamples.max[index])</span></span>
<span class="cstat-no" title="statement not covered" >this._profileSamples.max[index]=size;}</span>}
<span class="fstat-no" title="function not covered" >_l</span>astSeenObjectId(event){const profileSamples=<span class="cstat-no" title="statement not covered" >this._profileSamples;<span class="cstat-no" title="statement not covered" ></span>if(!profileSamples)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst data=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const currentIndex=<span class="cstat-no" title="statement not covered" >Math.max(profileSamples.ids.length,profileSamples.max.length-1);<span class="cstat-no" title="statement not covered" ></span>profileSamples.ids[currentIndex]=data.lastSeenObjectId;<span class="cstat-no" title="statement not covered" >i</span>f(!profileSamples.max[currentIndex]){<span class="cstat-no" title="statement not covered" >profileSamples.max[currentIndex]=0;<span class="cstat-no" title="statement not covered" >p</span>rofileSamples.sizes[currentIndex]=0;}</span></span>
<span class="cstat-no" title="statement not covered" >profileSamples.timestamps[currentIndex]=data.timestamp;<span class="cstat-no" title="statement not covered" >i</span>f(profileSamples.totalTime&lt;data.timestamp-profileSamples.timestamps[0])</span>
<span class="cstat-no" title="statement not covered" >profileSamples.totalTime*=2;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.TrackingHeapSnapshotProfileType.HeapStatsUpdate,this._profileSamples);<span class="cstat-no" title="statement not covered" >t</span>his.profileBeingRecorded().updateStatus(null,true);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sTemporaryView(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t buttonTooltip(){<span class="cstat-no" title="statement not covered" >return this._recording?ls`Stop recording heap profile`:ls`Start recording heap profile`;}</span>
<span class="fstat-no" title="function not covered" >is</span>InstantProfile(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >bu</span>ttonClicked(){<span class="cstat-no" title="statement not covered" >return this._toggleRecording();}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartRecordingProfile(){<span class="cstat-no" title="statement not covered" >if(this.profileBeingRecorded())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst heapProfilerModel=<span class="cstat-no" title="statement not covered" >this._addNewProfile();<span class="cstat-no" title="statement not covered" ></span>if(!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >h</span>eapProfilerModel.startTrackingHeapObjects(this._recordAllocationStacksSetting.get());}</span>
<span class="fstat-no" title="function not covered" >cu</span>stomContent(){<span class="cstat-no" title="statement not covered" >return UI.SettingsUI.createSettingCheckbox(ls`Record allocation stacks (extra performance overhead)`,this._recordAllocationStacksSetting,true);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddNewProfile(){const heapProfilerModel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(SDK.HeapProfilerModel);<span class="cstat-no" title="statement not covered" ></span>if(!heapProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(new Profiler.HeapProfileHeader(heapProfilerModel,this,undefined));<span class="cstat-no" title="statement not covered" >t</span>his._profileSamples=new Profiler.HeapTimelineOverview.Samples();<span class="cstat-no" title="statement not covered" >t</span>his.profileBeingRecorded()._profileSamples=this._profileSamples;<span class="cstat-no" title="statement not covered" >t</span>his._recording=true;<span class="cstat-no" title="statement not covered" >t</span>his.addProfile((this.profileBeingRecorded()));<span class="cstat-no" title="statement not covered" >t</span>his.profileBeingRecorded().updateStatus(Common.UIString('Recording\u2026'));<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.TrackingHeapSnapshotProfileType.TrackingStarted);<span class="cstat-no" title="statement not covered" >r</span>eturn heapProfilerModel;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _stopRecordingProfile(){<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded().updateStatus(Common.UIString('Snapshotting\u2026'));c</span>onst stopPromise=<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded().heapProfilerModel().stopTrackingHeapObjects(true);<span class="cstat-no" title="statement not covered" ></span>this._recording=false;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.TrackingHeapSnapshotProfileType.TrackingStopped);<span class="cstat-no" title="statement not covered" >a</span>wait stopPromise;c</span>onst profile=<span class="cstat-no" title="statement not covered" >this.profileBeingRecorded();<span class="cstat-no" title="statement not covered" ></span>if(!profile)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span>rofile._finishLoad();<span class="cstat-no" title="statement not covered" >t</span>his._profileSamples=null;<span class="cstat-no" title="statement not covered" >t</span>his.setProfileBeingRecorded(null);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Profiler.ProfileType.Events.ProfileComplete,profile);}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleRecording(){<span class="cstat-no" title="statement not covered" >if(this._recording)</span>
<span class="cstat-no" title="statement not covered" >this._stopRecordingProfile();e</span>lse
<span class="cstat-no" title="statement not covered" >this._startRecordingProfile();<span class="cstat-no" title="statement not covered" >r</span>eturn this._recording;}</span>
<span class="fstat-no" title="function not covered" >fi</span>leExtension(){<span class="cstat-no" title="statement not covered" >return'.heaptimeline';}</span>
<span class="fstat-no" title="function not covered" >ge</span>t treeItemTitle(){<span class="cstat-no" title="statement not covered" >return ls`ALLOCATION TIMELINES`;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t description(){<span class="cstat-no" title="statement not covered" >return ls`</span>
        Allocation timelines show instrumented JavaScript memory allocations over time.
        Once profile is recorded you can select a time interval to see objects that
        were allocated within it and still alive by the end of recording.
        Use this profile type to isolate memory leaks.`;}
<span class="fstat-no" title="function not covered" >_r</span>esetProfiles(event){const wasRecording=<span class="cstat-no" title="statement not covered" >this._recording;<span class="cstat-no" title="statement not covered" ></span>this.setProfileBeingRecorded(null);<span class="cstat-no" title="statement not covered" >s</span>uper._resetProfiles(event);<span class="cstat-no" title="statement not covered" >t</span>his._profileSamples=null;<span class="cstat-no" title="statement not covered" >i</span>f(wasRecording)</span>
<span class="cstat-no" title="statement not covered" >this._addNewProfile();}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileBeingRecordedRemoved(){<span class="cstat-no" title="statement not covered" >this._stopRecordingProfile();<span class="cstat-no" title="statement not covered" >t</span>his._profileSamples=null;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.TrackingHeapSnapshotProfileType.TypeId='HEAP-RECORD';<span class="cstat-no" title="statement not covered" >P</span>rofiler.TrackingHeapSnapshotProfileType.HeapStatsUpdate='HeapStatsUpdate';<span class="cstat-no" title="statement not covered" >P</span>rofiler.TrackingHeapSnapshotProfileType.TrackingStarted='TrackingStarted';<span class="cstat-no" title="statement not covered" >P</span>rofiler.TrackingHeapSnapshotProfileType.TrackingStopped='TrackingStopped';<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapProfileHeader=class extends Profiler.ProfileHeader{<span class="fstat-no" title="function not covered" >co</span>nstructor(heapProfilerModel,type,title){<span class="cstat-no" title="statement not covered" >super(type,title||Common.UIString('Snapshot %d',type.nextProfileUid()));<span class="cstat-no" title="statement not covered" >t</span>his._heapProfilerModel=heapProfilerModel;<span class="cstat-no" title="statement not covered" >t</span>his.maxJSObjectId=-1;<span class="cstat-no" title="statement not covered" >t</span>his._workerProxy=null;<span class="cstat-no" title="statement not covered" >t</span>his._receiver=null;<span class="cstat-no" title="statement not covered" >t</span>his._snapshotProxy=null;<span class="cstat-no" title="statement not covered" >t</span>his._loadPromise=new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >this._fulfillLoad=resolve)</span>;<span class="cstat-no" title="statement not covered" >t</span>his._totalNumberOfChunks=0;<span class="cstat-no" title="statement not covered" >t</span>his._bufferedWriter=null;<span class="cstat-no" title="statement not covered" >t</span>his._tempFile=null;}</span></span>
<span class="fstat-no" title="function not covered" >he</span>apProfilerModel(){<span class="cstat-no" title="statement not covered" >return this._heapProfilerModel;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tLocation(nodeIndex){<span class="cstat-no" title="statement not covered" >return this._snapshotProxy.getLocation(nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSidebarTreeElement(dataDisplayDelegate){<span class="cstat-no" title="statement not covered" >return new Profiler.ProfileSidebarTreeElement(dataDisplayDelegate,this,'heap-snapshot-sidebar-tree-item');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateView(dataDisplayDelegate){<span class="cstat-no" title="statement not covered" >return new Profiler.HeapSnapshotView(dataDisplayDelegate,this);}</span>
<span class="fstat-no" title="function not covered" >_p</span>repareToLoad(){<span class="cstat-no" title="statement not covered" >console.assert(!this._receiver,'Already loading');<span class="cstat-no" title="statement not covered" >t</span>his._setupWorker();<span class="cstat-no" title="statement not covered" >t</span>his.updateStatus(Common.UIString('Loading\u2026'),true);}</span>
<span class="fstat-no" title="function not covered" >_f</span>inishLoad(){<span class="cstat-no" title="statement not covered" >if(!this._wasDisposed)</span>
<span class="cstat-no" title="statement not covered" >this._receiver.close();<span class="cstat-no" title="statement not covered" >i</span>f(!this._bufferedWriter)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._didWriteToTempFile(this._bufferedWriter);}</span>
<span class="fstat-no" title="function not covered" >_d</span>idWriteToTempFile(tempFile){<span class="cstat-no" title="statement not covered" >if(this._wasDisposed){<span class="cstat-no" title="statement not covered" >if(tempFile)</span></span>
<span class="cstat-no" title="statement not covered" >tempFile.remove();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >this._tempFile=tempFile;<span class="cstat-no" title="statement not covered" >i</span>f(!tempFile)</span>
<span class="cstat-no" title="statement not covered" >this._failedToCreateTempFile=true;<span class="cstat-no" title="statement not covered" >i</span>f(this._onTempFileReady){<span class="cstat-no" title="statement not covered" >this._onTempFileReady();<span class="cstat-no" title="statement not covered" >t</span>his._onTempFileReady=null;}</span>}</span>
<span class="fstat-no" title="function not covered" >_s</span>etupWorker(){function <span class="fstat-no" title="function not covered" >setProfileWait(</span>event){<span class="cstat-no" title="statement not covered" >this.updateStatus(null,event.data);}</span>
<span class="cstat-no" title="statement not covered" >console.assert(!this._workerProxy,'HeapSnapshotWorkerProxy already exists');<span class="cstat-no" title="statement not covered" >t</span>his._workerProxy=new Profiler.HeapSnapshotWorkerProxy(this._handleWorkerEvent.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._workerProxy.addEventListener(Profiler.HeapSnapshotWorkerProxy.Events.Wait,setProfileWait,this);<span class="cstat-no" title="statement not covered" >t</span>his._receiver=this._workerProxy.createLoader(this.uid,this._snapshotReceived.bind(this));}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleWorkerEvent(eventName,data){<span class="cstat-no" title="statement not covered" >if(HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot===eventName){const error=(<span class="cstat-no" title="statement not covered" >data)</span>;<span class="cstat-no" title="statement not covered" >Common.console.error(error);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(HeapSnapshotModel.HeapSnapshotProgressEvent.Update!==eventName)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst subtitle=(<span class="cstat-no" title="statement not covered" >data)</span>;<span class="cstat-no" title="statement not covered" >this.updateStatus(subtitle);}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >if(this._workerProxy)</span>
<span class="cstat-no" title="statement not covered" >this._workerProxy.dispose();<span class="cstat-no" title="statement not covered" >t</span>his.removeTempFile();<span class="cstat-no" title="statement not covered" >t</span>his._wasDisposed=true;}</span>
<span class="fstat-no" title="function not covered" >_d</span>idCompleteSnapshotTransfer(){<span class="cstat-no" title="statement not covered" >if(!this._snapshotProxy)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.updateStatus(Number.bytesToString(this._snapshotProxy.totalSize),false);}</span>
<span class="fstat-no" title="function not covered" >tr</span>ansferChunk(chunk){<span class="cstat-no" title="statement not covered" >if(!this._bufferedWriter)</span>
<span class="cstat-no" title="statement not covered" >this._bufferedWriter=new Bindings.TempFile();<span class="cstat-no" title="statement not covered" >t</span>his._bufferedWriter.write([chunk]);<span class="cstat-no" title="statement not covered" >+</span>+this._totalNumberOfChunks;<span class="cstat-no" title="statement not covered" >t</span>his._receiver.write(chunk);}</span>
<span class="fstat-no" title="function not covered" >_s</span>napshotReceived(snapshotProxy){<span class="cstat-no" title="statement not covered" >if(this._wasDisposed)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._receiver=null;<span class="cstat-no" title="statement not covered" >t</span>his._snapshotProxy=snapshotProxy;<span class="cstat-no" title="statement not covered" >t</span>his.maxJSObjectId=snapshotProxy.maxJSObjectId();<span class="cstat-no" title="statement not covered" >t</span>his._didCompleteSnapshotTransfer();<span class="cstat-no" title="statement not covered" >t</span>his._workerProxy.startCheckingForLongRunningCalls();<span class="cstat-no" title="statement not covered" >t</span>his.notifySnapshotReceived();}</span>
<span class="fstat-no" title="function not covered" >no</span>tifySnapshotReceived(){<span class="cstat-no" title="statement not covered" >this._fulfillLoad(this._snapshotProxy);<span class="cstat-no" title="statement not covered" >t</span>his.profileType()._snapshotReceived(this);<span class="cstat-no" title="statement not covered" >i</span>f(this.canSaveToFile())</span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.ProfileHeader.Events.ProfileReceived);}</span>
<span class="fstat-no" title="function not covered" >ca</span>nSaveToFile(){<span class="cstat-no" title="statement not covered" >return!this.fromFile()&amp;&amp;!!this._snapshotProxy;}</span>
<span class="fstat-no" title="function not covered" >sa</span>veToFile(){const fileOutputStream=<span class="cstat-no" title="statement not covered" >new Bindings.FileOutputStream();<span class="cstat-no" title="statement not covered" ></span>this._fileName=this._fileName||'Heap-'+new Date().toISO8601Compact()+this.profileType().fileExtension();<span class="cstat-no" title="statement not covered" >f</span>ileOutputStream.open(this._fileName).then(onOpen.bind(this));a</span>sync function <span class="fstat-no" title="function not covered" >onOpen(</span>accepted){<span class="cstat-no" title="statement not covered" >if(!accepted)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._failedToCreateTempFile){<span class="cstat-no" title="statement not covered" >Common.console.error('Failed to open temp file with heap snapshot');<span class="cstat-no" title="statement not covered" >f</span>ileOutputStream.close();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._tempFile){const error=<span class="cstat-no" title="statement not covered" >await this._tempFile.copyToOutputStream(fileOutputStream,this._onChunkTransferred.bind(this));<span class="cstat-no" title="statement not covered" ></span>if(error)</span></span>
<span class="cstat-no" title="statement not covered" >Common.console.error('Failed to read heap snapshot from temp file: '+error.message);<span class="cstat-no" title="statement not covered" >t</span>his._didCompleteSnapshotTransfer();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >this._onTempFileReady=onOpen.bind(this,accepted);<span class="cstat-no" title="statement not covered" >t</span>his._updateSaveProgress(0,1);}</span>}
<span class="fstat-no" title="function not covered" >_o</span>nChunkTransferred(reader){<span class="cstat-no" title="statement not covered" >this._updateSaveProgress(reader.loadedSize(),reader.fileSize());}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateSaveProgress(value,total){const percentValue=<span class="cstat-no" title="statement not covered" >((total&amp;&amp;value/total)*100).toFixed(0);<span class="cstat-no" title="statement not covered" ></span>this.updateStatus(Common.UIString('Saving\u2026 %d%%',percentValue));}</span>
<span class="fstat-no" title="function not covered" >as</span>ync loadFromFile(file){<span class="cstat-no" title="statement not covered" >this.updateStatus(Common.UIString('Loading\u2026'),true);<span class="cstat-no" title="statement not covered" >t</span>his._setupWorker();c</span>onst reader=<span class="cstat-no" title="statement not covered" >new Bindings.ChunkedFileReader(file,10000000);</span>const success=<span class="cstat-no" title="statement not covered" >await reader.read((this._receiver));<span class="cstat-no" title="statement not covered" ></span>if(!success)</span>
<span class="cstat-no" title="statement not covered" >this.updateStatus(reader.error().message);<span class="cstat-no" title="statement not covered" >r</span>eturn success?null:reader.error();}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapSnapshotStatisticsView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('heap-snapshot-statistics-view');<span class="cstat-no" title="statement not covered" >t</span>his._pieChart=new PerfUI.PieChart(150,Profiler.HeapSnapshotStatisticsView._valueFormatter,true);<span class="cstat-no" title="statement not covered" >t</span>his._pieChart.element.classList.add('heap-snapshot-stats-pie-chart');<span class="cstat-no" title="statement not covered" >t</span>his.element.appendChild(this._pieChart.element);<span class="cstat-no" title="statement not covered" >t</span>his._labels=this.element.createChild('div','heap-snapshot-stats-legend');}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _valueFormatter(value){<span class="cstat-no" title="statement not covered" >return Common.UIString('%s KB',Number.withThousandsSeparator(Math.round(value/1024)));}</span>
<span class="fstat-no" title="function not covered" >se</span>tTotal(value){<span class="cstat-no" title="statement not covered" >this._pieChart.setTotal(value);}</span>
<span class="fstat-no" title="function not covered" >ad</span>dRecord(value,name,color){<span class="cstat-no" title="statement not covered" >if(color)</span>
<span class="cstat-no" title="statement not covered" >this._pieChart.addSlice(value,color);c</span>onst node=<span class="cstat-no" title="statement not covered" >this._labels.createChild('div');</span>const swatchDiv=<span class="cstat-no" title="statement not covered" >node.createChild('div','heap-snapshot-stats-swatch');</span>const nameDiv=<span class="cstat-no" title="statement not covered" >node.createChild('div','heap-snapshot-stats-name');</span>const sizeDiv=<span class="cstat-no" title="statement not covered" >node.createChild('div','heap-snapshot-stats-size');<span class="cstat-no" title="statement not covered" ></span>if(color)</span>
<span class="cstat-no" title="statement not covered" >swatchDiv.style.backgroundColor=color;e</span>lse
<span class="cstat-no" title="statement not covered" >swatchDiv.classList.add('heap-snapshot-stats-empty-swatch');<span class="cstat-no" title="statement not covered" >n</span>ameDiv.textContent=name;<span class="cstat-no" title="statement not covered" >s</span>izeDiv.textContent=Profiler.HeapSnapshotStatisticsView._valueFormatter(value);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapAllocationStackView=class extends UI.Widget{<span class="fstat-no" title="function not covered" >co</span>nstructor(heapProfilerModel){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._heapProfilerModel=heapProfilerModel;<span class="cstat-no" title="statement not covered" >t</span>his._linkifier=new Components.Linkifier();}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync setAllocatedObject(snapshot,snapshotNodeIndex){<span class="cstat-no" title="statement not covered" >this.clear();c</span>onst frames=<span class="cstat-no" title="statement not covered" >await snapshot.allocationStack(snapshotNodeIndex);<span class="cstat-no" title="statement not covered" ></span>if(!frames){const stackDiv=<span class="cstat-no" title="statement not covered" >this.element.createChild('div','no-heap-allocation-stack');<span class="cstat-no" title="statement not covered" ></span>stackDiv.createTextChild(Common.UIString('Stack was not recorded for this object because it had been allocated before this profile recording started.'));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const stackDiv=<span class="cstat-no" title="statement not covered" >this.element.createChild('div','heap-allocation-stack');<span class="cstat-no" title="statement not covered" ></span>for(const frame of frames){const frameDiv=<span class="cstat-no" title="statement not covered" >stackDiv.createChild('div','stack-frame');</span>const name=<span class="cstat-no" title="statement not covered" >frameDiv.createChild('div');<span class="cstat-no" title="statement not covered" ></span>name.textContent=UI.beautifyFunctionName(frame.functionName);<span class="cstat-no" title="statement not covered" >i</span>f(!frame.scriptId)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst urlElement=<span class="cstat-no" title="statement not covered" >this._linkifier.linkifyScriptLocation(this._heapProfilerModel?this._heapProfilerModel.target():null,String(frame.scriptId),frame.scriptName,frame.line-1,frame.column-1);<span class="cstat-no" title="statement not covered" ></span>frameDiv.appendChild(urlElement);}</span>}
<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >this.element.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._linkifier.reset();}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.HeapTimelineOverview=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.id='heap-recording-view';<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('heap-tracking-overview');<span class="cstat-no" title="statement not covered" >t</span>his._overviewContainer=this.element.createChild('div','heap-overview-container');<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid=new PerfUI.OverviewGrid('heap-recording');<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.element.classList.add('fill');<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas=this._overviewContainer.createChild('canvas','heap-recording-overview-canvas');<span class="cstat-no" title="statement not covered" >t</span>his._overviewContainer.appendChild(this._overviewGrid.element);<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator=new Profiler.HeapTimelineOverview.OverviewCalculator();<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.addEventListener(PerfUI.OverviewGrid.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._windowLeft=0.0;<span class="cstat-no" title="statement not covered" >t</span>his._windowRight=1.0;<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.setWindow(this._windowLeft,this._windowRight);<span class="cstat-no" title="statement not covered" >t</span>his._yScale=new Profiler.HeapTimelineOverview.SmoothScale();<span class="cstat-no" title="statement not covered" >t</span>his._xScale=new Profiler.HeapTimelineOverview.SmoothScale();<span class="cstat-no" title="statement not covered" >t</span>his._profileSamples=new Profiler.HeapTimelineOverview.Samples();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >this._running=true;c</span>onst drawFrame=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.update();<span class="cstat-no" title="statement not covered" >i</span>f(this._running)</span></span>
<span class="cstat-no" title="statement not covered" >this.element.window().requestAnimationFrame(drawFrame);}</span>;<span class="cstat-no" title="statement not covered" >drawFrame();}</span>
<span class="fstat-no" title="function not covered" >st</span>op(){<span class="cstat-no" title="statement not covered" >this._running=false;}</span>
<span class="fstat-no" title="function not covered" >se</span>tSamples(samples){<span class="cstat-no" title="statement not covered" >this._profileSamples=samples;<span class="cstat-no" title="statement not covered" >i</span>f(!this._running)</span>
<span class="cstat-no" title="statement not covered" >this.update();}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawOverviewCanvas(width,height){<span class="cstat-no" title="statement not covered" >if(!this._profileSamples)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst profileSamples=<span class="cstat-no" title="statement not covered" >this._profileSamples;</span>const sizes=<span class="cstat-no" title="statement not covered" >profileSamples.sizes;</span>const topSizes=<span class="cstat-no" title="statement not covered" >profileSamples.max;</span>const timestamps=<span class="cstat-no" title="statement not covered" >profileSamples.timestamps;</span>const startTime=<span class="cstat-no" title="statement not covered" >timestamps[0];</span>const scaleFactor=<span class="cstat-no" title="statement not covered" >this._xScale.nextScale(width/profileSamples.totalTime);</span>let maxSize=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >aggregateAndCall(</span>sizes,callback){let size=<span class="cstat-no" title="statement not covered" >0;</span>let currentX=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=1;i&lt;timestamps.length;++i){const x=<span class="cstat-no" title="statement not covered" >Math.floor((timestamps[i]-startTime)*scaleFactor);<span class="cstat-no" title="statement not covered" ></span>if(x!==currentX){<span class="cstat-no" title="statement not covered" >if(size)</span></span></span>
<span class="cstat-no" title="statement not covered" >callback(currentX,size);<span class="cstat-no" title="statement not covered" >s</span>ize=0;<span class="cstat-no" title="statement not covered" >c</span>urrentX=x;}</span>
<span class="cstat-no" title="statement not covered" >size+=sizes[i];}</span>
<span class="cstat-no" title="statement not covered" >callback(currentX,size);}</span>
function <span class="fstat-no" title="function not covered" >maxSizeCallback(</span>x,size){<span class="cstat-no" title="statement not covered" >maxSize=Math.max(maxSize,size);}</span>
<span class="cstat-no" title="statement not covered" >aggregateAndCall(sizes,maxSizeCallback);c</span>onst yScaleFactor=<span class="cstat-no" title="statement not covered" >this._yScale.nextScale(maxSize?height/(maxSize*1.1):0.0);<span class="cstat-no" title="statement not covered" ></span>this._overviewCanvas.width=width*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas.height=height*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas.style.width=width+'px';<span class="cstat-no" title="statement not covered" >t</span>his._overviewCanvas.style.height=height+'px';c</span>onst context=<span class="cstat-no" title="statement not covered" >this._overviewCanvas.getContext('2d');<span class="cstat-no" title="statement not covered" ></span>context.scale(window.devicePixelRatio,window.devicePixelRatio);<span class="cstat-no" title="statement not covered" >i</span>f(this._running){<span class="cstat-no" title="statement not covered" >context.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=2;<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='rgba(192, 192, 192, 0.6)';c</span>onst currentX=<span class="cstat-no" title="statement not covered" >(Date.now()-startTime)*scaleFactor;<span class="cstat-no" title="statement not covered" ></span>context.moveTo(currentX,height-1);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(currentX,0);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();}</span></span>
let gridY;let gridValue;const gridLabelHeight=<span class="cstat-no" title="statement not covered" >14;<span class="cstat-no" title="statement not covered" ></span>if(yScaleFactor){const maxGridValue=<span class="cstat-no" title="statement not covered" >(height-gridLabelHeight)/yScaleFactor;<span class="cstat-no" title="statement not covered" ></span>gridValue=Math.pow(1024,Math.floor(Math.log(maxGridValue)/Math.log(1024)));<span class="cstat-no" title="statement not covered" >g</span>ridValue*=Math.pow(10,Math.floor(Math.log(maxGridValue/gridValue)/Math.LN10));<span class="cstat-no" title="statement not covered" >i</span>f(gridValue*5&lt;=maxGridValue)</span></span>
<span class="cstat-no" title="statement not covered" >gridValue*=5;<span class="cstat-no" title="statement not covered" >g</span>ridY=Math.round(height-gridValue*yScaleFactor-0.5)+0.5;<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=1;<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='rgba(0, 0, 0, 0.2)';<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(0,gridY);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(width,gridY);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();}</span>
function <span class="fstat-no" title="function not covered" >drawBarCallback(</span>x,size){<span class="cstat-no" title="statement not covered" >context.moveTo(x,height-1);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(x,Math.round(height-size*yScaleFactor-1));}</span>
<span class="cstat-no" title="statement not covered" >context.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=2;<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='rgba(192, 192, 192, 0.6)';<span class="cstat-no" title="statement not covered" >a</span>ggregateAndCall(topSizes,drawBarCallback);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=2;<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='rgba(0, 0, 192, 0.8)';<span class="cstat-no" title="statement not covered" >a</span>ggregateAndCall(sizes,drawBarCallback);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();<span class="cstat-no" title="statement not covered" >i</span>f(gridValue){const label=<span class="cstat-no" title="statement not covered" >Number.bytesToString(gridValue);</span>const labelPadding=<span class="cstat-no" title="statement not covered" >4;</span>const labelX=<span class="cstat-no" title="statement not covered" >0;</span>const labelY=<span class="cstat-no" title="statement not covered" >gridY-0.5;</span>const labelWidth=<span class="cstat-no" title="statement not covered" >2*labelPadding+context.measureText(label).width;<span class="cstat-no" title="statement not covered" ></span>context.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.textBaseline='bottom';<span class="cstat-no" title="statement not covered" >c</span>ontext.font='10px '+window.getComputedStyle(this.element,null).getPropertyValue('font-family');<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='rgba(255, 255, 255, 0.75)';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(labelX,labelY-gridLabelHeight,labelWidth,gridLabelHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='rgb(64, 64, 64)';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillText(label,labelX+labelPadding,labelY);<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();}</span>}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >this._updateOverviewCanvas=true;<span class="cstat-no" title="statement not covered" >t</span>his._scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(){<span class="cstat-no" title="statement not covered" >if(!this._updateGridTimerId)</span>
<span class="cstat-no" title="statement not covered" >this._updateGridTimerId=setTimeout(this.updateGrid.bind(this),10);}</span>
<span class="fstat-no" title="function not covered" >_s</span>cheduleUpdate(){<span class="cstat-no" title="statement not covered" >if(this._updateTimerId)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimerId=setTimeout(this.update.bind(this),10);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateBoundaries(){<span class="cstat-no" title="statement not covered" >this._windowLeft=this._overviewGrid.windowLeft();<span class="cstat-no" title="statement not covered" >t</span>his._windowRight=this._overviewGrid.windowRight();<span class="cstat-no" title="statement not covered" >t</span>his._windowWidth=this._windowRight-this._windowLeft;}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >this._updateTimerId=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this.isShowing())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updateBoundaries();<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator._updateBoundaries(this);<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.updateDividers(this._overviewCalculator);<span class="cstat-no" title="statement not covered" >t</span>his._drawOverviewCanvas(this._overviewContainer.clientWidth,this._overviewContainer.clientHeight-20);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateGrid(){<span class="cstat-no" title="statement not covered" >this._updateGridTimerId=0;<span class="cstat-no" title="statement not covered" >t</span>his._updateBoundaries();c</span>onst ids=<span class="cstat-no" title="statement not covered" >this._profileSamples.ids;<span class="cstat-no" title="statement not covered" ></span>if(!ids.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timestamps=<span class="cstat-no" title="statement not covered" >this._profileSamples.timestamps;</span>const sizes=<span class="cstat-no" title="statement not covered" >this._profileSamples.sizes;</span>const startTime=<span class="cstat-no" title="statement not covered" >timestamps[0];</span>const totalTime=<span class="cstat-no" title="statement not covered" >this._profileSamples.totalTime;</span>const timeLeft=<span class="cstat-no" title="statement not covered" >startTime+totalTime*this._windowLeft;</span>const timeRight=<span class="cstat-no" title="statement not covered" >startTime+totalTime*this._windowRight;</span>const minIndex=<span class="cstat-no" title="statement not covered" >timestamps.lowerBound(timeLeft);</span>const maxIndex=<span class="cstat-no" title="statement not covered" >timestamps.upperBound(timeRight);</span>let size=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=minIndex;i&lt;=maxIndex;++i)</span>
<span class="cstat-no" title="statement not covered" >size+=sizes[i];c</span>onst minId=<span class="cstat-no" title="statement not covered" >minIndex&gt;0?ids[minIndex-1]:0;</span>const maxId=<span class="cstat-no" title="statement not covered" >maxIndex&lt;ids.length?ids[maxIndex]:Infinity;<span class="cstat-no" title="statement not covered" ></span>this.dispatchEventToListeners(Profiler.HeapTimelineOverview.IdsRangeChanged,{minId,maxId,size});}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapTimelineOverview.IdsRangeChanged=Symbol('IdsRangeChanged');<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapTimelineOverview.SmoothScale=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._lastUpdate=0;<span class="cstat-no" title="statement not covered" >t</span>his._currentScale=0.0;}</span></span>
<span class="fstat-no" title="function not covered" >ne</span>xtScale(target){<span class="cstat-no" title="statement not covered" >target=target||this._currentScale;<span class="cstat-no" title="statement not covered" >i</span>f(this._currentScale){const now=<span class="cstat-no" title="statement not covered" >Date.now();</span>const timeDeltaMs=<span class="cstat-no" title="statement not covered" >now-this._lastUpdate;<span class="cstat-no" title="statement not covered" ></span>this._lastUpdate=now;c</span>onst maxChangePerSec=<span class="cstat-no" title="statement not covered" >20;</span>const maxChangePerDelta=<span class="cstat-no" title="statement not covered" >Math.pow(maxChangePerSec,timeDeltaMs/1000);</span>const scaleChange=<span class="cstat-no" title="statement not covered" >target/this._currentScale;<span class="cstat-no" title="statement not covered" ></span>this._currentScale*=Number.constrain(scaleChange,1/maxChangePerDelta,maxChangePerDelta);}</span>else{<span class="cstat-no" title="statement not covered" >this._currentScale=target;}</span></span>
<span class="cstat-no" title="statement not covered" >return this._currentScale;}</span>};<span class="cstat-no" title="statement not covered" >Profiler.HeapTimelineOverview.Samples=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.sizes=[];<span class="cstat-no" title="statement not covered" >t</span>his.ids=[];<span class="cstat-no" title="statement not covered" >t</span>his.timestamps=[];<span class="cstat-no" title="statement not covered" >t</span>his.max=[];<span class="cstat-no" title="statement not covered" >t</span>his.totalTime=30000;}</span>};<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapTimelineOverview.OverviewCalculator=class{<span class="fstat-no" title="function not covered" >_u</span>pdateBoundaries(chart){<span class="cstat-no" title="statement not covered" >this._minimumBoundaries=0;<span class="cstat-no" title="statement not covered" >t</span>his._maximumBoundaries=chart._profileSamples.totalTime;<span class="cstat-no" title="statement not covered" >t</span>his._xScaleFactor=chart._overviewContainer.clientWidth/this._maximumBoundaries;}</span></span>
<span class="fstat-no" title="function not covered" >co</span>mputePosition(time){<span class="cstat-no" title="statement not covered" >return(time-this._minimumBoundaries)*this._xScaleFactor;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Number.secondsToString(value/1000,!!precision);}</span>
<span class="fstat-no" title="function not covered" >ma</span>ximumBoundary(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundaries;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundaries;}</span>
<span class="fstat-no" title="function not covered" >ze</span>roTime(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundaries;}</span>
<span class="fstat-no" title="function not covered" >bo</span>undarySpan(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundaries-this._minimumBoundaries;}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.IsolateSelector=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his._items=new UI.ListModel();<span class="cstat-no" title="statement not covered" >t</span>his._list=new UI.ListControl(this._items,this,UI.ListMode.NonViewport);<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.appendChild(this._list.element);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('profiler/profileLauncherView.css');<span class="cstat-no" title="statement not covered" >t</span>his._isolateByModel=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._itemByIsolate=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer=null;<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.observeModels(SDK.RuntimeModel,this);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addEventListener(SDK.TargetManager.Events.NameChanged,this._targetChanged,this);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addEventListener(SDK.TargetManager.Events.InspectedURLChanged,this._targetChanged,this);}</span></span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >this._updateStats();}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >clearTimeout(this._updateTimer);}</span>
<span class="fstat-no" title="function not covered" >mo</span>delAdded(model){<span class="cstat-no" title="statement not covered" >this._modelAdded(model);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _modelAdded(model){const isolatePromise=<span class="cstat-no" title="statement not covered" >model.isolateId();<span class="cstat-no" title="statement not covered" ></span>this._isolateByModel.set(model,isolatePromise);c</span>onst isolate=<span class="cstat-no" title="statement not covered" >await isolatePromise;</span>let item=<span class="cstat-no" title="statement not covered" >this._itemByIsolate.get(isolate);<span class="cstat-no" title="statement not covered" ></span>if(!item){<span class="cstat-no" title="statement not covered" >item=new Profiler.IsolateSelector.ListItem(model);c</span>onst index=<span class="cstat-no" title="statement not covered" >model.target()===SDK.targetManager.mainTarget()?0:this._items.length;<span class="cstat-no" title="statement not covered" ></span>this._items.insert(index,item);<span class="cstat-no" title="statement not covered" >t</span>his._itemByIsolate.set(isolate,item);<span class="cstat-no" title="statement not covered" >i</span>f(this._items.length===1)</span></span>
<span class="cstat-no" title="statement not covered" >this._list.selectItem(item);}</span>else{<span class="cstat-no" title="statement not covered" >item.addModel(model);}</span>
<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >mo</span>delRemoved(model){<span class="cstat-no" title="statement not covered" >this._modelRemoved(model);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _modelRemoved(model){const isolate=<span class="cstat-no" title="statement not covered" >await this._isolateByModel.get(model);<span class="cstat-no" title="statement not covered" ></span>this._isolateByModel.delete(model);c</span>onst item=<span class="cstat-no" title="statement not covered" >this._itemByIsolate.get(isolate);<span class="cstat-no" title="statement not covered" ></span>item.removeModel(model);<span class="cstat-no" title="statement not covered" >i</span>f(!item.models().length){<span class="cstat-no" title="statement not covered" >this._items.remove(this._items.indexOf(item));<span class="cstat-no" title="statement not covered" >t</span>his._itemByIsolate.delete(isolate);}</span></span>
<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _targetChanged(event){const target=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const model=<span class="cstat-no" title="statement not covered" >target.model(SDK.RuntimeModel);</span>const isolate=<span class="cstat-no" title="statement not covered" >model&amp;&amp;await this._isolateByModel.get(model);</span>const item=<span class="cstat-no" title="statement not covered" >isolate&amp;&amp;this._itemByIsolate.get(isolate);<span class="cstat-no" title="statement not covered" ></span>if(item)</span>
<span class="cstat-no" title="statement not covered" >item.updateTitle();}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateElementForItem(item){<span class="cstat-no" title="statement not covered" >return item.element;}</span>
<span class="fstat-no" title="function not covered" >he</span>ightForItem(item){}
<span class="fstat-no" title="function not covered" >is</span>ItemSelectable(item){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >se</span>lectedItemChanged(from,to,fromElement,toElement){<span class="cstat-no" title="statement not covered" >if(fromElement)</span>
<span class="cstat-no" title="statement not covered" >fromElement.classList.remove('selected');<span class="cstat-no" title="statement not covered" >i</span>f(toElement)</span>
<span class="cstat-no" title="statement not covered" >toElement.classList.add('selected');c</span>onst model=<span class="cstat-no" title="statement not covered" >to&amp;&amp;to.models()[0];<span class="cstat-no" title="statement not covered" ></span>UI.context.setFlavor(SDK.HeapProfilerModel,model&amp;&amp;model.heapProfilerModel());<span class="cstat-no" title="statement not covered" >U</span>I.context.setFlavor(SDK.CPUProfilerModel,model&amp;&amp;model.target().model(SDK.CPUProfilerModel));}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >this._list.invalidateRange(0,this._items.length);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateStats(){<span class="cstat-no" title="statement not covered" >for(const item of this._itemByIsolate.values())</span>
<span class="cstat-no" title="statement not covered" >item.updateStats();c</span>onst heapStatsUpdateIntervalMs=<span class="cstat-no" title="statement not covered" >2000;<span class="cstat-no" title="statement not covered" ></span>this._updateTimer=setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._updateStats(),</span>heapStatsUpdateIntervalMs);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.IsolateSelector.ListItem=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(model){<span class="cstat-no" title="statement not covered" >this._models=new Set([model]);<span class="cstat-no" title="statement not covered" >t</span>his.element=createElementWithClass('div','profile-isolate-item hbox');<span class="cstat-no" title="statement not covered" >t</span>his._heapDiv=this.element.createChild('div','profile-isolate-item-heap');<span class="cstat-no" title="statement not covered" >t</span>his._nameDiv=this.element.createChild('div','profile-isolate-item-name');<span class="cstat-no" title="statement not covered" >t</span>his._updatesDisabled=false;<span class="cstat-no" title="statement not covered" >t</span>his.updateTitle();<span class="cstat-no" title="statement not covered" >t</span>his.updateStats();}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dModel(model){<span class="cstat-no" title="statement not covered" >this._models.add(model);<span class="cstat-no" title="statement not covered" >t</span>his.updateTitle();}</span>
<span class="fstat-no" title="function not covered" >re</span>moveModel(model){<span class="cstat-no" title="statement not covered" >this._models.delete(model);<span class="cstat-no" title="statement not covered" >t</span>his.updateTitle();}</span>
<span class="fstat-no" title="function not covered" >mo</span>dels(){<span class="cstat-no" title="statement not covered" >return Array.from(this._models);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync updateStats(){<span class="cstat-no" title="statement not covered" >if(this._updatesDisabled)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst heapStats=<span class="cstat-no" title="statement not covered" >await this._models.values().next().value.heapUsage();<span class="cstat-no" title="statement not covered" ></span>if(!heapStats){<span class="cstat-no" title="statement not covered" >this._updatesDisabled=true;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const usedTitle=<span class="cstat-no" title="statement not covered" >ls`Heap size in use by live JS objects.`;</span>const totalTitle=<span class="cstat-no" title="statement not covered" >ls`Total JS heap size including live objects, garbage, and reserved space.`;<span class="cstat-no" title="statement not covered" ></span>this._heapDiv.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._heapDiv.append(UI.html`</span>
        &lt;span title="${usedTitle}"&gt;${Number.bytesToString(heapStats.usedSize)}&lt;/span&gt;
        &lt;span&gt; / &lt;/span&gt;
        &lt;span title="${totalTitle}"&gt;${Number.bytesToString(heapStats.totalSize)}&lt;/span&gt;`);}
<span class="fstat-no" title="function not covered" >up</span>dateTitle(){const modelCountByName=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(const model of this._models.values()){const target=<span class="cstat-no" title="statement not covered" >model.target();</span>const name=<span class="cstat-no" title="statement not covered" >SDK.targetManager.mainTarget()!==target?target.name():'';</span>const parsedURL=<span class="cstat-no" title="statement not covered" >new Common.ParsedURL(target.inspectedURL());</span>const domain=<span class="cstat-no" title="statement not covered" >parsedURL.isValid?parsedURL.domain():'';</span>const title=<span class="cstat-no" title="statement not covered" >target.decorateLabel(domain&amp;&amp;name?`${domain}: ${name}`:name||domain||ls`(empty)`);<span class="cstat-no" title="statement not covered" ></span>modelCountByName.set(title,(modelCountByName.get(title)||0)+1);}</span></span>
<span class="cstat-no" title="statement not covered" >this._nameDiv.removeChildren();<span class="cstat-no" title="statement not covered" >f</span>or(const[name,count]of modelCountByName){const title=<span class="cstat-no" title="statement not covered" >count&gt;1?`${name} (${count})`:name;<span class="cstat-no" title="statement not covered" ></span>this._nameDiv.appendChild(UI.html`&lt;div title="${title}"&gt;${title}&lt;/div&gt;`);}</span>}</span>};;<span class="cstat-no" title="statement not covered" >Profiler.ProfileLauncherView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(profilesPanel){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._panel=profilesPanel;<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('profile-launcher-view');<span class="cstat-no" title="statement not covered" >t</span>his._contentElement=this.element.createChild('div','profile-launcher-view-content');<span class="cstat-no" title="statement not covered" >t</span>his._innerContentElement=this._contentElement.createChild('div');c</span>onst controlDiv=<span class="cstat-no" title="statement not covered" >this._contentElement.createChild('div','vbox profile-launcher-control');<span class="cstat-no" title="statement not covered" ></span>controlDiv.createChild('h1').textContent=ls`Select JavaScript VM instance`;c</span>onst targetDiv=<span class="cstat-no" title="statement not covered" >controlDiv.createChild('div','vbox profile-launcher-target-list');<span class="cstat-no" title="statement not covered" ></span>new Profiler.IsolateSelector().show(targetDiv);<span class="cstat-no" title="statement not covered" >t</span>his._controlButton=UI.createTextButton('',this._controlButtonClicked.bind(this),'profile-launcher-button',true);<span class="cstat-no" title="statement not covered" >t</span>his._contentElement.appendChild(this._controlButton);<span class="cstat-no" title="statement not covered" >t</span>his._recordButtonEnabled=true;<span class="cstat-no" title="statement not covered" >t</span>his._loadButton=UI.createTextButton(Common.UIString('Load'),this._loadButtonClicked.bind(this),'profile-launcher-button');<span class="cstat-no" title="statement not covered" >t</span>his._contentElement.appendChild(this._loadButton);<span class="cstat-no" title="statement not covered" >t</span>his._selectedProfileTypeSetting=Common.settings.createSetting('selectedProfileType','CPU');<span class="cstat-no" title="statement not covered" >t</span>his._header=this._innerContentElement.createChild('h1');<span class="cstat-no" title="statement not covered" >t</span>his._profileTypeSelectorForm=this._innerContentElement.createChild('form');<span class="cstat-no" title="statement not covered" >t</span>his._innerContentElement.createChild('div','flexible-space');<span class="cstat-no" title="statement not covered" >t</span>his._typeIdToOptionElement=new Map();}</span></span>
<span class="fstat-no" title="function not covered" >_l</span>oadButtonClicked(){<span class="cstat-no" title="statement not covered" >this._panel.showLoadFromFileDialog();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateControls(){<span class="cstat-no" title="statement not covered" >if(this._isEnabled&amp;&amp;this._recordButtonEnabled)</span>
<span class="cstat-no" title="statement not covered" >this._controlButton.removeAttribute('disabled');e</span>lse
<span class="cstat-no" title="statement not covered" >this._controlButton.setAttribute('disabled','');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.title=this._recordButtonEnabled?'':UI.anotherProfilerActiveLabel();<span class="cstat-no" title="statement not covered" >i</span>f(this._isInstantProfile){<span class="cstat-no" title="statement not covered" >this._controlButton.classList.remove('running');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.classList.add('primary-button');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.textContent=Common.UIString('Take snapshot');}</span>else <span class="cstat-no" title="statement not covered" >if(this._isProfiling){<span class="cstat-no" title="statement not covered" >this._controlButton.classList.add('running');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.classList.remove('primary-button');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.textContent=Common.UIString('Stop');}</span>else{<span class="cstat-no" title="statement not covered" >this._controlButton.classList.remove('running');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.classList.add('primary-button');<span class="cstat-no" title="statement not covered" >t</span>his._controlButton.textContent=Common.UIString('Start');}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(const item of this._typeIdToOptionElement.values())</span>
<span class="cstat-no" title="statement not covered" >item.disabled=!!this._isProfiling;}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileStarted(){<span class="cstat-no" title="statement not covered" >this._isProfiling=true;<span class="cstat-no" title="statement not covered" >t</span>his._updateControls();}</span>
<span class="fstat-no" title="function not covered" >pr</span>ofileFinished(){<span class="cstat-no" title="statement not covered" >this._isProfiling=false;<span class="cstat-no" title="statement not covered" >t</span>his._updateControls();}</span>
<span class="fstat-no" title="function not covered" >up</span>dateProfileType(profileType,recordButtonEnabled){<span class="cstat-no" title="statement not covered" >this._isInstantProfile=profileType.isInstantProfile();<span class="cstat-no" title="statement not covered" >t</span>his._recordButtonEnabled=recordButtonEnabled;<span class="cstat-no" title="statement not covered" >t</span>his._isEnabled=profileType.isEnabled();<span class="cstat-no" title="statement not covered" >t</span>his._updateControls();}</span>
<span class="fstat-no" title="function not covered" >ad</span>dProfileType(profileType){const labelElement=<span class="cstat-no" title="statement not covered" >UI.createRadioLabel('profile-type',profileType.name);<span class="cstat-no" title="statement not covered" ></span>this._profileTypeSelectorForm.appendChild(labelElement);c</span>onst optionElement=<span class="cstat-no" title="statement not covered" >labelElement.radioElement;<span class="cstat-no" title="statement not covered" ></span>this._typeIdToOptionElement.set(profileType.id,optionElement);<span class="cstat-no" title="statement not covered" >o</span>ptionElement._profileType=profileType;<span class="cstat-no" title="statement not covered" >o</span>ptionElement.style.hidden=true;<span class="cstat-no" title="statement not covered" >o</span>ptionElement.addEventListener('change',this._profileTypeChanged.bind(this,profileType),false);c</span>onst descriptionElement=<span class="cstat-no" title="statement not covered" >this._profileTypeSelectorForm.createChild('p');<span class="cstat-no" title="statement not covered" ></span>descriptionElement.textContent=profileType.description;c</span>onst customContent=<span class="cstat-no" title="statement not covered" >profileType.customContent();<span class="cstat-no" title="statement not covered" ></span>if(customContent)</span>
<span class="cstat-no" title="statement not covered" >this._profileTypeSelectorForm.createChild('p').appendChild(customContent);<span class="cstat-no" title="statement not covered" >i</span>f(this._typeIdToOptionElement.size&gt;1)</span>
<span class="cstat-no" title="statement not covered" >this._header.textContent=ls`Select profiling type`;e</span>lse
<span class="cstat-no" title="statement not covered" >this._header.textContent=profileType.name;}</span>
<span class="fstat-no" title="function not covered" >re</span>storeSelectedProfileType(){let typeId=<span class="cstat-no" title="statement not covered" >this._selectedProfileTypeSetting.get();<span class="cstat-no" title="statement not covered" ></span>if(!this._typeIdToOptionElement.has(typeId))</span>
<span class="cstat-no" title="statement not covered" >typeId=this._typeIdToOptionElement.keys().next().value;<span class="cstat-no" title="statement not covered" >t</span>his._typeIdToOptionElement.get(typeId).checked=true;c</span>onst type=<span class="cstat-no" title="statement not covered" >this._typeIdToOptionElement.get(typeId)._profileType;<span class="cstat-no" title="statement not covered" ></span>this.dispatchEventToListeners(Profiler.ProfileLauncherView.Events.ProfileTypeSelected,type);}</span>
<span class="fstat-no" title="function not covered" >_c</span>ontrolButtonClicked(){<span class="cstat-no" title="statement not covered" >this._panel.toggleRecord();}</span>
<span class="fstat-no" title="function not covered" >_p</span>rofileTypeChanged(profileType){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Profiler.ProfileLauncherView.Events.ProfileTypeSelected,profileType);<span class="cstat-no" title="statement not covered" >t</span>his._isInstantProfile=profileType.isInstantProfile();<span class="cstat-no" title="statement not covered" >t</span>his._isEnabled=profileType.isEnabled();<span class="cstat-no" title="statement not covered" >t</span>his._updateControls();<span class="cstat-no" title="statement not covered" >t</span>his._selectedProfileTypeSetting.set(profileType.id);}</span>};<span class="cstat-no" title="statement not covered" >Profiler.ProfileLauncherView.Events={ProfileTypeSelected:Symbol('ProfileTypeSelected')};;<span class="cstat-no" title="statement not covered" ></span>Profiler.ProfileTypeRegistry=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.cpuProfileType=new Profiler.CPUProfileType();<span class="cstat-no" title="statement not covered" >t</span>his.heapSnapshotProfileType=new Profiler.HeapSnapshotProfileType();<span class="cstat-no" title="statement not covered" >t</span>his.samplingHeapProfileType=new Profiler.SamplingHeapProfileType();<span class="cstat-no" title="statement not covered" >t</span>his.samplingNativeHeapProfileType=new Profiler.SamplingNativeHeapProfileType();<span class="cstat-no" title="statement not covered" >t</span>his.samplingNativeHeapSnapshotBrowserType=new Profiler.SamplingNativeHeapSnapshotBrowserType();<span class="cstat-no" title="statement not covered" >t</span>his.samplingNativeHeapSnapshotRendererType=new Profiler.SamplingNativeHeapSnapshotRendererType();<span class="cstat-no" title="statement not covered" >t</span>his.trackingHeapSnapshotProfileType=new Profiler.TrackingHeapSnapshotProfileType();}</span>};<span class="cstat-no" title="statement not covered" >P</span>rofiler.ProfileTypeRegistry.instance=new Profiler.ProfileTypeRegistry();;<span class="cstat-no" title="statement not covered" ></span>Runtime.cachedResources["profiler/heapProfiler.css"]="/*\n * Copyright (C) 2009 Google Inc. All rights reserved.\n * Copyright (C) 2010 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.heap-snapshot-view {\n    overflow: hidden;\n}\n\n.heap-snapshot-view .data-grid {\n    border: none;\n}\n\n.heap-snapshot-view .data-grid tr:empty {\n    height: 16px;\n    visibility: hidden;\n}\n\n.heap-snapshot-view .data-grid span.percent-column {\n    width: 35px !important;\n}\n\n.heap-snapshot-view .object-value-object,\n.object-value-node {\n    display: inline;\n    position: static;\n}\n\n.heap-snapshot-view .object-value-string {\n    white-space: nowrap;\n}\n\n.heap-snapshot-view td.object-column .objects-count {\n    margin-left: 10px;\n    font-size: 11px;\n    color: grey;\n}\n\n.heap-snapshot-view tr:not(.selected) .object-value-id {\n    color: grey;\n}\n\n.heap-snapshot-view .data-grid {\n    flex: auto;\n}\n\n.profile-view .heap-tracking-overview {\n    flex: 0 0 80px;\n    height: 80px;\n}\n\n.heap-snapshot-view .retaining-paths-view {\n    overflow: hidden;\n}\n\n.heap-snapshot-view .heap-snapshot-view-resizer {\n    background-image: url(Images/toolbarResizerVertical.png);\n    background-color: #eee;\n    border-bottom: 1px solid rgb(179, 179, 179);\n    background-repeat: no-repeat;\n    background-position: right center, center;\n    flex: 0 0 21px;\n}\n\n.heap-snapshot-view .heap-snapshot-view-resizer .title &gt; span {\n    display: inline-block;\n    padding-top: 3px;\n    vertical-align: middle;\n    margin-left: 4px;\n    margin-right: 8px;\n}\n\n.heap-snapshot-view .heap-snapshot-view-resizer * {\n    pointer-events: none;\n}\n\n.heap-snapshot-view tr:not(.selected) td.object-column span.highlight {\n    background-color: inherit;\n}\n\n.heap-snapshot-view td.object-column &gt; div &gt; span {\n    margin-right: 6px;\n}\n\n.heap-snapshot-view td.object-column span.heap-object-source-link {\n    float: right;\n}\n\n.heap-snapshot-view td.object-column span.heap-object-source-link:empty {\n    animation: fadeInOut 2s infinite;\n}\n\n.heap-snapshot-view td.object-column span.heap-object-source-link:empty:before {\n    content: \"\\b7\\b7\";\n    font-weight: bold;\n}\n\n@keyframes fadeInOut {\n    0% {\n        transform: rotate(0);\n    }\n    50% {\n        transform: rotate(0.5turn);\n    }\n    100% {\n        transform: rotate(1turn);\n    }\n}\n\n.heap-snapshot-view tr:not(.selected) td.object-column span.heap-object-tag {\n    color: #888;\n}\n\n.heap-snapshot-view td.object-column span.grayed {\n    color: gray;\n}\n\n.cycled-ancessor-node {\n    opacity: 0.6;\n}\n\n#heap-recording-view .profile-view {\n    top: 80px;\n}\n\n.heap-overview-container {\n    overflow: hidden;\n    position: absolute;\n    top: 0;\n    width: 100%;\n    height: 80px;\n}\n\n#heap-recording-overview-grid .resources-dividers-label-bar {\n    pointer-events: auto;\n}\n\n#heap-recording-overview-container {\n    border-bottom: 1px solid rgba(0, 0, 0, 0.3);\n}\n\n.heap-recording-overview-canvas {\n    position: absolute;\n    top: 20px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\n.heap-snapshot-statistics-view {\n    overflow: auto;\n}\n\n.heap-snapshot-stats-pie-chart {\n    margin: 12px 30px;\n    flex-shrink: 0;\n}\n\n.heap-snapshot-stats-legend {\n    margin-left: 24px;\n    flex-shrink: 0;\n}\n\n.heap-snapshot-stats-legend &gt; div {\n    margin-top: 1px;\n    width: 170px;\n}\n\n.heap-snapshot-stats-swatch {\n    display: inline-block;\n    width: 10px;\n    height: 10px;\n    border: 1px solid rgba(100, 100, 100, 0.3);\n}\n\n.heap-snapshot-stats-swatch.heap-snapshot-stats-empty-swatch {\n    border: none;\n}\n\n.heap-snapshot-stats-name,\n.heap-snapshot-stats-size {\n    display: inline-block;\n    margin-left: 6px;\n}\n\n.heap-snapshot-stats-size {\n    float: right;\n    text-align: right;\n}\n\n.heap-allocation-stack .stack-frame {\n    display: flex;\n    justify-content: space-between;\n    border-bottom: 1px solid rgb(240, 240, 240);\n    padding: 2px;\n}\n\n.heap-allocation-stack .stack-frame .devtools-link {\n    color: rgb(33%, 33%, 33%);\n}\n\n.no-heap-allocation-stack {\n    padding: 5px;\n}\n\n/*# sourceURL=profiler/heapProfiler.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["profiler/profileLauncherView.css"]="/*\n * Copyright 2018 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.profile-isolate-item {\n    padding: 4px;\n    line-height: 16px;\n    border-left: 2px solid transparent;\n    overflow-x: hidden;\n}\n\n.profile-isolate-item:hover {\n    background-color: hsla(0, 0%, 0%, 0.05);\n}\n\n.profile-isolate-item.selected {\n    border-color: #4285f4;\n    background-color: #4285f420;\n}\n\n.profile-isolate-item &gt; div {\n    flex-shrink: 0;\n    margin-left: 9px;\n}\n\n.profile-isolate-item-heap {\n    width: 120px;\n}\n\n/*# sourceURL=profiler/profileLauncherView.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["profiler/profilesPanel.css"]="/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud &lt;rik@webkit.org&gt;\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Profiler Style */\n\n#profile-views {\n    flex: auto;\n    position: relative;\n}\n\n.profile-view .data-grid table.data {\n    background: white;\n}\n\n.profile-view .data-grid tr:not(.selected) .highlight {\n    background-color: rgb(255, 230, 179);\n}\n\n.profile-view .data-grid tr:hover td:not(.bottom-filler-td) {\n    background-color: rgba(0, 0, 0, 0.1);\n}\n\n.profile-view .data-grid td.numeric-column {\n    text-align: right;\n}\n\n.profile-view .data-grid div.profile-multiple-values {\n    float: right;\n}\n\n.profile-view .data-grid span.percent-column {\n    color: #999;\n    width: 50px;\n    display: inline-block;\n}\n\n.profile-view .data-grid tr.selected span {\n    color: inherit;\n}\n\n.profiles-toolbar {\n    background-color: var(--toolbar-bg-color);\n    border-bottom: 1px solid #ccc;\n    flex-shrink: 0;\n}\n\n.profiles-tree-sidebar {\n    flex: auto;\n    overflow: hidden;\n}\n\n.profiles-sidebar-tree-box {\n    overflow-y: auto;\n}\n\n.profile-view {\n    display: flex;\n    overflow: hidden;\n}\n\n.profile-view .data-grid {\n    border: none;\n    flex: auto;\n}\n\n.profile-view .data-grid th.self-column,\n.profile-view .data-grid th.total-column {\n    text-align: center;\n}\n\n.profile-node-file {\n    float: right;\n    color: gray;\n}\n\n.profile-warn-marker {\n    vertical-align: -1px;\n    margin-right: 2px;\n}\n\n.data-grid tr.selected .profile-node-file {\n    color: rgb(33%, 33%, 33%);\n}\n\n.data-grid:focus tr.selected .profile-node-file {\n    color: white;\n}\n\n\n.profile-launcher-view {\n    overflow: auto;\n}\n\n.profile-launcher-view-content {\n    padding: 10px 16px;\n}\n\n.profile-launcher-view-content h1 {\n    font-size: 15px;\n    font-weight: normal;\n    padding: 6px 0;\n    margin: 0 0 5px 0;\n}\n\n.profile-launcher-view-content [is=dt-radio] {\n    font-size: 13px;\n}\n\n.profile-launcher-control {\n    align-items: flex-start;\n    flex-wrap: wrap;\n    margin-top: 10px;\n    margin-right: 6px;\n}\n\n.profile-launcher-control button {\n    min-width: 110px;\n}\n\n.profile-launcher-target-list {\n    width: 100%;\n    height: 150px;\n    margin-bottom: 10px;\n    border: 1px solid #ddd;\n}\n\n.profile-launcher-target {\n    align-items: baseline;\n}\n\n.profile-launcher-target &gt; * {\n    flex: 0 0 auto;\n    margin-right: 8px;\n}\n\n.profile-launcher-view-content p {\n    color: grey;\n    margin-top: 1px;\n    margin-left: 22px;\n}\n\n.profile-launcher-view-content p [is=dt-checkbox] {\n    display: flex;\n}\n\n.profile-launcher-view-content button.running {\n    color: hsl(0, 100%, 58%);\n}\n\n.profile-launcher-view-content button.running:hover {\n    color: hsl(0, 100%, 42%);\n}\n\nbody.inactive .profile-launcher-view-content button.running:not(.toolbar-item) {\n    color: rgb(220, 130, 130);\n}\n\n.highlighted-row {\n    -webkit-animation: row_highlight 2s 0s;\n}\n\n@-webkit-keyframes row_highlight {\n    from {background-color: rgba(255, 255, 120, 1); }\n    to { background-color: rgba(255, 255, 120, 0); }\n}\n\n.profile-canvas-decoration span[is=dt-icon-label] {\n    margin-right: 4px;\n}\n\n.profile-canvas-decoration {\n    color: red;\n    margin: -14px 0 13px 22px;\n    padding-left: 14px;\n}\n\n.profile-canvas-decoration button {\n    margin: 0 0 0 10px !important;\n}\n\n.profile-launcher-button {\n    min-width: 120px;\n    height: 28px;\n    margin: 8px 16px 8px 0;\n}\n\n.cpu-profile-flame-chart-overview-container {\n    overflow: hidden;\n    position: absolute;\n    top: 0;\n    width: 100%;\n    height: 80px;\n}\n\n#cpu-profile-flame-chart-overview-container {\n    border-bottom: 1px solid rgba(0, 0, 0, 0.3);\n}\n\n.cpu-profile-flame-chart-overview-canvas {\n    position: absolute;\n    top: 20px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\n#cpu-profile-flame-chart-overview-grid .resources-dividers-label-bar {\n    pointer-events: auto;\n}\n\n.cpu-profile-flame-chart-overview-pane {\n    flex: 0 0 80px !important;\n}\n\n.profile-text-view {\n    padding: 10px;\n    overflow: auto;\n    margin: 0;\n    user-select: text;\n    cursor: text;\n}\n\n/*# sourceURL=profiler/profilesPanel.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["profiler/profilesSidebarTree.css"]="/*\n * Copyright 2016 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n/* Tree outline overrides */\n\n:host {\n    padding: 0;\n}\n\nol.tree-outline {\n    overflow: auto;\n    flex: auto;\n    padding: 0;\n    margin: 0;\n}\n\n.tree-outline li {\n    height: 36px;\n    padding-right: 5px;\n    margin-top: 1px;\n    line-height: 34px;\n    border-top: 1px solid transparent;\n}\n\n.tree-outline li:not(.parent)::before {\n    display: none;\n}\n\n:host-context(.some-expandable) .tree-outline li:not(.parent) {\n    margin-left: 10px;\n}\n\n.tree-outline li.profiles-tree-section {\n    height: 18px;\n    padding: 0 10px;\n    white-space: nowrap;\n    margin-top: 1px;\n    color: rgb(92, 110, 129);\n    text-shadow: rgba(255, 255, 255, 0.75) 0 1px 0;\n    line-height: 18px;\n}\n\n.tree-outline li.profiles-tree-section::before {\n    display: none;\n}\n\n.tree-outline ol {\n    overflow: hidden;\n}\n\n/* Generic items styling */\n\n.title-container &gt; .save-link {\n    text-decoration: underline;\n    margin-left: auto;\n    display: none;\n}\n\nli.selected .title-container &gt; .save-link {\n    display: block;\n    cursor: pointer;\n}\n\n.tree-outline &gt; .icon {\n    margin-left: 16px;\n}\n\nli .icon {\n    width: 32px;\n    height: 32px;\n    margin-top: 1px;\n    margin-right: 3px;\n    flex: none;\n}\n\nli.wait .icon {\n    content: none;\n}\n\nli.wait .icon::before {\n    display: block;\n    width: 24px;\n    height: 24px;\n    margin: 4px;\n    border: 3px solid grey;\n    border-radius: 12px;\n    clip: rect(0, 15px, 15px, 0);\n    content: \"\";\n    position: absolute;\n    -webkit-animation: spinner-animation 1s linear infinite;\n    box-sizing: border-box;\n}\n\nli.wait.small .icon::before {\n    width: 14px;\n    height: 14px;\n    margin: 1px;\n    clip: rect(0, 9px, 9px, 0);\n    border-width: 2px;\n}\n\nli.wait.selected .icon::before {\n    border-color: white;\n}\n\n@-webkit-keyframes spinner-animation {\n    from { transform: rotate(0); }\n    to { transform: rotate(360deg); }\n}\n\nli.small {\n    height: 20px;\n}\n\nli.small .icon {\n    width: 16px;\n    height: 16px;\n}\n\nli .titles {\n    display: flex;\n    flex-direction: column;\n    top: 5px;\n    line-height: 12px;\n    padding-bottom: 1px;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    flex: auto;\n}\n\nli .titles &gt; .title-container {\n    display: flex;\n}\n\nli.small .titles {\n    top: 2px;\n    line-height: normal;\n}\n\nli:not(.small) .title::after {\n    content: \"\\A\";\n    white-space: pre;\n}\n\nli .subtitle {\n    font-size: 80%;\n}\n\nli.small .subtitle {\n    display: none;\n}\n\n/* Heap profiles */\n\n.heap-snapshot-sidebar-tree-item .icon {\n    content: url(Images/profileIcon.png);\n}\n\n.heap-snapshot-sidebar-tree-item.small .icon {\n    content: url(Images/profileSmallIcon.png);\n}\n\n/* Launcher */\n\n.profile-launcher-view-tree-item {\n    margin-left: 0 !important;\n}\n\n.profile-launcher-view-tree-item &gt; .icon {\n    width: 8px !important;\n    visibility: hidden;\n}\n\n/* CPU profiles */\n\n.profile-sidebar-tree-item .icon {\n    content: url(Images/profileIcon.png);\n}\n\n.profile-sidebar-tree-item.small .icon {\n    content: url(Images/profileSmallIcon.png);\n}\n\n.profile-group-sidebar-tree-item .icon {\n    content: url(Images/profileGroupIcon.png);\n}\n\n/*# sourceURL=profiler/profilesSidebarTree.css */";</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:04:04 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
