<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/win-unpacked/resources/inspector/sources_test_runner/sources_test_runner_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/win-unpacked/resources/inspector/sources_test_runner</a> sources_test_runner_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/758</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/248</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/146</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/121</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpNavigatorView=<span class="fstat-no" title="function not covered" >fu</span>nction(navigatorView,dumpIcons){<span class="cstat-no" title="statement not covered" >dumpNavigatorTreeOutline(navigatorView._scriptsTree);f</span>unction <span class="fstat-no" title="function not covered" >dumpNavigatorTreeElement(</span>prefix,treeElement){let titleText=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(treeElement._leadingIconsElement&amp;&amp;dumpIcons){let icons=<span class="cstat-no" title="statement not covered" >treeElement._leadingIconsElement.querySelectorAll('[is=ui-icon]');<span class="cstat-no" title="statement not covered" ></span>icons=Array.prototype.slice.call(icons);c</span>onst iconTypes=<span class="cstat-no" title="statement not covered" >icons.map(<span class="fstat-no" title="function not covered" >ic</span>on=&gt;<span class="cstat-no" title="statement not covered" >icon._iconType)</span>;<span class="cstat-no" title="statement not covered" ></span>if(iconTypes.length)</span></span></span>
<span class="cstat-no" title="statement not covered" >titleText=titleText+'['+iconTypes.join(', ')+'] ';}</span>
<span class="cstat-no" title="statement not covered" >titleText+=treeElement.title;<span class="cstat-no" title="statement not covered" >i</span>f(treeElement._nodeType===Sources.NavigatorView.Types.FileSystem||treeElement._nodeType===Sources.NavigatorView.Types.FileSystemFolder){const hasMappedFiles=<span class="cstat-no" title="statement not covered" >treeElement.listItemElement.classList.contains('has-mapped-files');<span class="cstat-no" title="statement not covered" ></span>if(!hasMappedFiles)</span></span>
<span class="cstat-no" title="statement not covered" >titleText+=' [dimmed]';}</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult(prefix+titleText);<span class="cstat-no" title="statement not covered" >t</span>reeElement.expand();c</span>onst children=<span class="cstat-no" title="statement not covered" >treeElement.children();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;children.length;++i)</span>
<span class="cstat-no" title="statement not covered" >dumpNavigatorTreeElement(prefix+'  ',children[i]);}</span>
function <span class="fstat-no" title="function not covered" >dumpNavigatorTreeOutline(</span>treeOutline){const children=<span class="cstat-no" title="statement not covered" >treeOutline.rootElement().children();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;children.length;++i)</span>
<span class="cstat-no" title="statement not covered" >dumpNavigatorTreeElement('',children[i]);}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpNavigatorViewInAllModes=<span class="fstat-no" title="function not covered" >fu</span>nction(view){<span class="cstat-no" title="statement not covered" >['frame','frame/domain','frame/domain/folder','domain','domain/folder'].forEach(SourcesTestRunner.dumpNavigatorViewInMode.bind(TestRunner,view));}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.dumpNavigatorViewInMode=<span class="fstat-no" title="function not covered" >fu</span>nction(view,mode){<span class="cstat-no" title="statement not covered" >TestRunner.addResult(view instanceof Sources.NetworkNavigatorView?'Sources:':'Content Scripts:');<span class="cstat-no" title="statement not covered" >v</span>iew._groupByFrame=mode.includes('frame');<span class="cstat-no" title="statement not covered" >v</span>iew._groupByDomain=mode.includes('domain');<span class="cstat-no" title="statement not covered" >v</span>iew._groupByFolder=mode.includes('folder');<span class="cstat-no" title="statement not covered" >v</span>iew._resetForTest();<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('-------- Setting mode: ['+mode+']');<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.dumpNavigatorView(view);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.addScriptUISourceCode=<span class="fstat-no" title="function not covered" >fu</span>nction(url,content,isContentScript,worldId){<span class="cstat-no" title="statement not covered" >content+='\n//# sourceURL='+url;<span class="cstat-no" title="statement not covered" >i</span>f(isContentScript)</span></span>
<span class="cstat-no" title="statement not covered" >content=`testRunner.evaluateScriptInIsolatedWorld(${worldId}, \`${content}\`)`;<span class="cstat-no" title="statement not covered" >T</span>estRunner.evaluateInPageAnonymously(content);<span class="cstat-no" title="statement not covered" >r</span>eturn TestRunner.waitForUISourceCode(url);}</span>;function <span class="fstat-no" title="function not covered" >testSourceMapping(</span>text1,text2,mapping,testToken){const originalPosition=<span class="cstat-no" title="statement not covered" >text1.indexOf(testToken);<span class="cstat-no" title="statement not covered" ></span>TestRunner.assertTrue(originalPosition!==-1);c</span>onst originalLocation=<span class="cstat-no" title="statement not covered" >Formatter.Formatter.positionToLocation(text1.computeLineEndings(),originalPosition);</span>const formattedLocation=<span class="cstat-no" title="statement not covered" >mapping.originalToFormatted(originalLocation[0],originalLocation[1]);</span>const formattedPosition=<span class="cstat-no" title="statement not covered" >Formatter.Formatter.locationToPosition(text2.computeLineEndings(),formattedLocation[0],formattedLocation[1]);</span>const expectedFormattedPosition=<span class="cstat-no" title="statement not covered" >text2.indexOf(testToken);<span class="cstat-no" title="statement not covered" ></span>if(expectedFormattedPosition===formattedPosition)</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult(String.sprintf('Correct mapping for &lt;%s&gt;',testToken));e</span>lse
<span class="cstat-no" title="statement not covered" >TestRunner.addResult(String.sprintf('ERROR: Wrong mapping for &lt;%s&gt;',testToken));}</span>
<span class="cstat-no" title="statement not covered" >SourcesTestRunner.testPrettyPrint=<span class="fstat-no" title="function not covered" >fu</span>nction(mimeType,text,mappingQueries,next){<span class="cstat-no" title="statement not covered" >new Formatter.ScriptFormatter(mimeType,text,didFormatContent);f</span>unction <span class="fstat-no" title="function not covered" >didFormatContent(</span>formattedSource,mapping){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('====== 8&lt; ------');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(formattedSource);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('------ &gt;8 ======');<span class="cstat-no" title="statement not covered" >w</span>hile(mappingQueries&amp;&amp;mappingQueries.length)</span></span>
<span class="cstat-no" title="statement not covered" >testSourceMapping(text,formattedSource,mapping,mappingQueries.shift());<span class="cstat-no" title="statement not covered" >n</span>ext();}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.testJavascriptOutline=<span class="fstat-no" title="function not covered" >fu</span>nction(text){let fulfill;const promise=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >x=</span>&gt;<span class="cstat-no" title="statement not covered" >fulfill=x)</span>;<span class="cstat-no" title="statement not covered" ></span>Formatter.formatterWorkerPool().javaScriptOutline(text,onChunk);c</span>onst items=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return promise;f</span>unction <span class="fstat-no" title="function not covered" >onChunk(</span>isLastChunk,outlineItems){<span class="cstat-no" title="statement not covered" >items.pushAll(outlineItems);<span class="cstat-no" title="statement not covered" >i</span>f(!isLastChunk)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Text:');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(text.split('\n').map(<span class="fstat-no" title="function not covered" >li</span>ne=&gt;<span class="cstat-no" title="statement not covered" >'    '+line)</span>.join('\n'));<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Outline:');<span class="cstat-no" title="statement not covered" >f</span>or(const item of items)</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('    '+item.name+(item.arguments||'')+':'+item.line+':'+item.column);<span class="cstat-no" title="statement not covered" >f</span>ulfill();}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpSwatchPositions=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,bookmarkType){const textEditor=<span class="cstat-no" title="statement not covered" >sourceFrame.textEditor;</span>const markers=<span class="cstat-no" title="statement not covered" >textEditor.bookmarks(textEditor.fullRange(),bookmarkType);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;markers.length;i++){const position=<span class="cstat-no" title="statement not covered" >markers[i].position();</span>const text=<span class="cstat-no" title="statement not covered" >markers[i]._marker.widgetNode.firstChild.textContent;<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('Line '+position.startLine+', Column '+position.startColumn+': '+text);}</span>}</span>;;<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner.startDebuggerTest=<span class="fstat-no" title="function not covered" >fu</span>nction(callback,quiet){<span class="cstat-no" title="statement not covered" >console.assert(TestRunner.debuggerModel.debuggerEnabled(),'Debugger has to be enabled');<span class="cstat-no" title="statement not covered" >i</span>f(quiet!==undefined)</span></span>
<span class="cstat-no" title="statement not covered" >SourcesTestRunner._quiet=quiet;<span class="cstat-no" title="statement not covered" >U</span>I.viewManager.showView('sources');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(SDK.DebuggerModel.prototype,'_pausedScript',SourcesTestRunner._pausedScript,true);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(SDK.DebuggerModel.prototype,'_resumedScript',SourcesTestRunner._resumedScript,true);<span class="cstat-no" title="statement not covered" >T</span>estRunner.safeWrap(callback)();}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.startDebuggerTestPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(quiet){let cb;const p=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >fu</span>llfill=&gt;<span class="cstat-no" title="statement not covered" >cb=fullfill)</span>;<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner.startDebuggerTest(cb,quiet);<span class="cstat-no" title="statement not covered" >r</span>eturn p;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.completeDebuggerTest=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Common.moduleSetting('breakpointsActive').set(true);<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.resumeExecution(TestRunner.completeTest.bind(TestRunner));}</span>;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(){const origThen=<span class="cstat-no" title="statement not covered" >Promise.prototype.then;</span>const origCatch=<span class="cstat-no" title="statement not covered" >Promise.prototype.catch;<span class="cstat-no" title="statement not covered" ></span>Promise.prototype.then=<span class="fstat-no" title="function not covered" >fu</span>nction(){const result=<span class="cstat-no" title="statement not covered" >origThen.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>origThen.call(result,undefined,onUncaughtPromiseReject.bind(null,new Error().stack));<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>;<span class="cstat-no" title="statement not covered" >P</span>romise.prototype.catch=<span class="fstat-no" title="function not covered" >fu</span>nction(){const result=<span class="cstat-no" title="statement not covered" >origCatch.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>origThen.call(result,undefined,onUncaughtPromiseReject.bind(null,new Error().stack));<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>;f</span>unction <span class="fstat-no" title="function not covered" >onUncaughtPromiseReject(</span>stack,e){const message=<span class="cstat-no" title="statement not covered" >typeof e==='object'&amp;&amp;e.stack||e;<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('FAIL: Uncaught exception in promise: '+message+' '+stack);<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.completeDebuggerTest();}</span>})();<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.runDebuggerTestSuite=<span class="fstat-no" title="function not covered" >fu</span>nction(testSuite){const testSuiteTests=<span class="cstat-no" title="statement not covered" >testSuite.slice();</span>function <span class="fstat-no" title="function not covered" >runner(</span>){<span class="cstat-no" title="statement not covered" >if(!testSuiteTests.length){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.completeDebuggerTest();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
const nextTest=<span class="cstat-no" title="statement not covered" >testSuiteTests.shift();<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Running: '+/function\s([^(]*)/.exec(nextTest)[1]);<span class="cstat-no" title="statement not covered" >T</span>estRunner.safeWrap(nextTest)(runner,runner);}</span>
<span class="cstat-no" title="statement not covered" >SourcesTestRunner.startDebuggerTest(runner);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.runTestFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >TestRunner.evaluateInPageAnonymously('scheduleTestFunction()');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Set timer for test function.');}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.runTestFunctionAndWaitUntilPaused=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.runTestFunction();<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilPaused(callback);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.runTestFunctionAndWaitUntilPausedPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Promise(SourcesTestRunner.runTestFunctionAndWaitUntilPaused);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.runAsyncCallStacksTest=<span class="fstat-no" title="function not covered" >fu</span>nction(totalDebuggerStatements,maxAsyncCallStackDepth){const defaultMaxAsyncCallStackDepth=<span class="cstat-no" title="statement not covered" >32;<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner.setQuiet(true);<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.startDebuggerTest(step1);a</span>sync function <span class="fstat-no" title="function not covered" >step1(</span>){<span class="cstat-no" title="statement not covered" >await TestRunner.DebuggerAgent.setAsyncCallStackDepth(maxAsyncCallStackDepth||defaultMaxAsyncCallStackDepth);<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.runTestFunctionAndWaitUntilPaused(didPause);}</span></span>
let step=<span class="cstat-no" title="statement not covered" >0;</span>const callStacksOutput=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >didPause(</span>callFrames,reason,breakpointIds,asyncStackTrace){<span class="cstat-no" title="statement not covered" >++step;<span class="cstat-no" title="statement not covered" >c</span>allStacksOutput.push(SourcesTestRunner.captureStackTraceIntoString(callFrames,asyncStackTrace)+'\n');<span class="cstat-no" title="statement not covered" >i</span>f(step&lt;totalDebuggerStatements){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.resumeExecution(SourcesTestRunner.waitUntilPaused.bind(SourcesTestRunner,didPause));}</span>else{<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Captured call stacks in no particular order:');<span class="cstat-no" title="statement not covered" >c</span>allStacksOutput.sort();<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResults(callStacksOutput);<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.completeDebuggerTest();}</span>}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpSourceFrameMessages=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,dumpFullURL){const messages=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const bucket of sourceFrame._rowMessageBuckets.values()){<span class="cstat-no" title="statement not covered" >for(const rowMessage of bucket._messages){const message=<span class="cstat-no" title="statement not covered" >rowMessage.message();<span class="cstat-no" title="statement not covered" ></span>messages.push(String.sprintf('  %d:%d [%s] %s',message.lineNumber(),message.columnNumber(),message.level(),message.text()));}</span>}</span></span></span>
const name=(<span class="cstat-no" title="statement not covered" >dumpFullURL?sourceFrame.uiSourceCode().url():sourceFrame.uiSourceCode().displayName())</span>;<span class="cstat-no" title="statement not covered" >TestRunner.addResult('SourceFrame '+name+': '+messages.length+' message(s)');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(messages.join('\n'));}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilPausedNextTime=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >SourcesTestRunner._waitUntilPausedCallback=TestRunner.safeWrap(callback);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilPaused=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);<span class="cstat-no" title="statement not covered" >i</span>f(SourcesTestRunner._pausedScriptArguments)</span></span>
<span class="cstat-no" title="statement not covered" >callback.apply(callback,SourcesTestRunner._pausedScriptArguments);e</span>lse
<span class="cstat-no" title="statement not covered" >SourcesTestRunner._waitUntilPausedCallback=callback;}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilPausedPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilPaused(resolve))</span>;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilResumedNextTime=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >SourcesTestRunner._waitUntilResumedCallback=TestRunner.safeWrap(callback);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilResumed=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);<span class="cstat-no" title="statement not covered" >i</span>f(!SourcesTestRunner._pausedScriptArguments)</span></span>
<span class="cstat-no" title="statement not covered" >callback();e</span>lse
<span class="cstat-no" title="statement not covered" >SourcesTestRunner._waitUntilResumedCallback=callback;}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilResumedPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilResumed(resolve))</span>;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.resumeExecution=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >if(UI.panels.sources.paused())</span></span>
<span class="cstat-no" title="statement not covered" >UI.panels.sources._togglePause();<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilResumed(callback);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilPausedAndDumpStackAndResume=<span class="fstat-no" title="function not covered" >fu</span>nction(callback,options){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilPaused(paused);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(Sources.SourcesPanel.prototype,'_updateDebuggerButtonsAndStatusForTest',setStatus);l</span>et caption;let callFrames;let asyncStackTrace;function <span class="fstat-no" title="function not covered" >setStatus(</span>){const statusElement=<span class="cstat-no" title="statement not covered" >this.element.querySelector('.paused-message');<span class="cstat-no" title="statement not covered" ></span>caption=statusElement.deepTextContent();<span class="cstat-no" title="statement not covered" >i</span>f(callFrames)</span></span>
<span class="cstat-no" title="statement not covered" >step1();}</span>
function <span class="fstat-no" title="function not covered" >paused(</span>frames,reason,breakpointIds,async){<span class="cstat-no" title="statement not covered" >callFrames=frames;<span class="cstat-no" title="statement not covered" >a</span>syncStackTrace=async;<span class="cstat-no" title="statement not covered" >i</span>f(typeof caption==='string')</span>
<span class="cstat-no" title="statement not covered" >step1();}</span>
function <span class="fstat-no" title="function not covered" >step1(</span>){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.captureStackTrace(callFrames,asyncStackTrace,options);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(TestRunner.clearSpecificInfoFromStackFrames(caption));<span class="cstat-no" title="statement not covered" >T</span>estRunner.deprecatedRunAfterPendingDispatches(step2);}</span>
function <span class="fstat-no" title="function not covered" >step2(</span>){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.resumeExecution(TestRunner.safeWrap(callback));}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.stepOver=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Promise.resolve().then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >UI.panels.sources._stepOver();}</span>);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.stepInto=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Promise.resolve().then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >UI.panels.sources._stepInto();}</span>);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.stepIntoAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Promise.resolve().then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >UI.panels.sources._stepIntoAsync();}</span>);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.stepOut=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Promise.resolve().then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >UI.panels.sources._stepOut();}</span>);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.togglePause=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Promise.resolve().then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >UI.panels.sources._togglePause();}</span>);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilPausedAndPerformSteppingActions=<span class="fstat-no" title="function not covered" >fu</span>nction(actions,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilPaused(didPause);f</span>unction <span class="fstat-no" title="function not covered" >didPause(</span>callFrames,reason,breakpointIds,asyncStackTrace){let action=<span class="cstat-no" title="statement not covered" >actions.shift();<span class="cstat-no" title="statement not covered" ></span>if(action==='Print'){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.captureStackTrace(callFrames,asyncStackTrace);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('');<span class="cstat-no" title="statement not covered" >w</span>hile(action==='Print')</span></span></span>
<span class="cstat-no" title="statement not covered" >action=actions.shift();}</span>
<span class="cstat-no" title="statement not covered" >if(!action){<span class="cstat-no" title="statement not covered" >callback();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Executing '+action+'...');<span class="cstat-no" title="statement not covered" >s</span>witch(action){case'StepInto':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.stepInto();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'StepOver':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.stepOver();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'StepOut':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.stepOut();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'Resume':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.togglePause();<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >TestRunner.addResult('FAIL: Unknown action: '+action);<span class="cstat-no" title="statement not covered" >c</span>allback();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitUntilResumed((actions.length?SourcesTestRunner.waitUntilPaused.bind(SourcesTestRunner,didPause):callback));}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.captureStackTrace=<span class="fstat-no" title="function not covered" >fu</span>nction(callFrames,asyncStackTrace,options){<span class="cstat-no" title="statement not covered" >TestRunner.addResult(SourcesTestRunner.captureStackTraceIntoString(callFrames,asyncStackTrace,options));}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.captureStackTraceIntoString=<span class="fstat-no" title="function not covered" >fu</span>nction(callFrames,asyncStackTrace,options){const results=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>options=options||{};f</span>unction <span class="fstat-no" title="function not covered" >printCallFrames(</span>callFrames,locationFunction,returnValueFunction){let printed=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;callFrames.length;i++){const frame=<span class="cstat-no" title="statement not covered" >callFrames[i];</span>const location=<span class="cstat-no" title="statement not covered" >locationFunction.call(frame);</span>const script=<span class="cstat-no" title="statement not covered" >location.script();</span>const uiLocation=<span class="cstat-no" title="statement not covered" >Bindings.debuggerWorkspaceBinding.rawLocationToUILocation(location);</span>const isFramework=<span class="cstat-no" title="statement not covered" >uiLocation?Bindings.blackboxManager.isBlackboxedUISourceCode(uiLocation.uiSourceCode):false;<span class="cstat-no" title="statement not covered" ></span>if(options.dropFrameworkCallFrames&amp;&amp;isFramework)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et url;let lineNumber;<span class="cstat-no" title="statement not covered" >if(uiLocation&amp;&amp;uiLocation.uiSourceCode.project().type()!==Workspace.projectTypes.Debugger){<span class="cstat-no" title="statement not covered" >url=uiLocation.uiSourceCode.name();<span class="cstat-no" title="statement not covered" >l</span>ineNumber=uiLocation.lineNumber+1;}</span>else{<span class="cstat-no" title="statement not covered" >url=Bindings.displayNameForURL(script.sourceURL);<span class="cstat-no" title="statement not covered" >l</span>ineNumber=location.lineNumber+1;}</span></span>
let s=<span class="cstat-no" title="statement not covered" >((isFramework?'  * ':'    '))+printed++ +') '+frame.functionName+' ('+url+</span>
((options.dropLineNumbers?'':':'+lineNumber))+')';<span class="cstat-no" title="statement not covered" >s=s.replace(/scheduleTestFunction.+$/,'scheduleTestFunction &lt;omitted&gt;');<span class="cstat-no" title="statement not covered" >r</span>esults.push(s);<span class="cstat-no" title="statement not covered" >i</span>f(options.printReturnValue&amp;&amp;returnValueFunction&amp;&amp;returnValueFunction.call(frame))</span>
<span class="cstat-no" title="statement not covered" >results.push('       &lt;return&gt;: '+returnValueFunction.call(frame).description);<span class="cstat-no" title="statement not covered" >i</span>f(frame.functionName==='scheduleTestFunction'){const remainingFrames=<span class="cstat-no" title="statement not covered" >callFrames.length-1-i;<span class="cstat-no" title="statement not covered" ></span>if(remainingFrames)</span></span>
<span class="cstat-no" title="statement not covered" >results.push('    &lt;... skipped remaining frames ...&gt;');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}
<span class="cstat-no" title="statement not covered" >return printed;}</span>
function <span class="fstat-no" title="function not covered" >runtimeCallFramePosition(</span>){<span class="cstat-no" title="statement not covered" >return new SDK.DebuggerModel.Location(TestRunner.debuggerModel,this.scriptId,this.lineNumber,this.columnNumber);}</span>
<span class="cstat-no" title="statement not covered" >results.push('Call stack:');<span class="cstat-no" title="statement not covered" >p</span>rintCallFrames(callFrames,SDK.DebuggerModel.CallFrame.prototype.location,SDK.DebuggerModel.CallFrame.prototype.returnValue);<span class="cstat-no" title="statement not covered" >w</span>hile(asyncStackTrace){<span class="cstat-no" title="statement not covered" >results.push('    ['+(asyncStackTrace.description||'Async Call')+']');c</span>onst printed=<span class="cstat-no" title="statement not covered" >printCallFrames(asyncStackTrace.callFrames,runtimeCallFramePosition);<span class="cstat-no" title="statement not covered" ></span>if(!printed)</span></span>
<span class="cstat-no" title="statement not covered" >results.pop();<span class="cstat-no" title="statement not covered" >a</span>syncStackTrace=asyncStackTrace.parent;}</span>
<span class="cstat-no" title="statement not covered" >return results.join('\n');}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpSourceFrameContents=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('==Source frame contents start==');c</span>onst textEditor=<span class="cstat-no" title="statement not covered" >sourceFrame._textEditor;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;textEditor.linesCount;++i)</span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult(textEditor.line(i));<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('==Source frame contents end==');}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner._pausedScript=<span class="fstat-no" title="function not covered" >fu</span>nction(callFrames,reason,auxData,breakpointIds,asyncStackTrace){<span class="cstat-no" title="statement not covered" >if(!SourcesTestRunner._quiet)</span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Script execution paused.');c</span>onst debuggerModel=<span class="cstat-no" title="statement not covered" >this.target().model(SDK.DebuggerModel);<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner._pausedScriptArguments=[SDK.DebuggerModel.CallFrame.fromPayloadArray(debuggerModel,callFrames),reason,breakpointIds,asyncStackTrace,auxData];<span class="cstat-no" title="statement not covered" >i</span>f(SourcesTestRunner._waitUntilPausedCallback){const callback=<span class="cstat-no" title="statement not covered" >SourcesTestRunner._waitUntilPausedCallback;<span class="cstat-no" title="statement not covered" ></span>delete SourcesTestRunner._waitUntilPausedCallback;<span class="cstat-no" title="statement not covered" >s</span>etTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >callback.apply(callback,SourcesTestRunner._pausedScriptArguments))</span>;}</span>}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner._resumedScript=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!SourcesTestRunner._quiet)</span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Script execution resumed.');<span class="cstat-no" title="statement not covered" >d</span>elete SourcesTestRunner._pausedScriptArguments;<span class="cstat-no" title="statement not covered" >i</span>f(SourcesTestRunner._waitUntilResumedCallback){const callback=<span class="cstat-no" title="statement not covered" >SourcesTestRunner._waitUntilResumedCallback;<span class="cstat-no" title="statement not covered" ></span>delete SourcesTestRunner._waitUntilResumedCallback;<span class="cstat-no" title="statement not covered" >c</span>allback();}</span>}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.showUISourceCode=<span class="fstat-no" title="function not covered" >fu</span>nction(uiSourceCode,callback){const panel=<span class="cstat-no" title="statement not covered" >UI.panels.sources;<span class="cstat-no" title="statement not covered" ></span>panel.showUISourceCode(uiSourceCode);c</span>onst sourceFrame=<span class="cstat-no" title="statement not covered" >panel.visibleView;<span class="cstat-no" title="statement not covered" ></span>if(sourceFrame.loaded)</span></span>
<span class="cstat-no" title="statement not covered" >callback(sourceFrame);e</span>lse
<span class="cstat-no" title="statement not covered" >TestRunner.addSniffer(sourceFrame,'setContent',callback&amp;&amp;callback.bind(null,sourceFrame));}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.showUISourceCodePromise=<span class="fstat-no" title="function not covered" >fu</span>nction(uiSourceCode){let fulfill;const promise=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >x=</span>&gt;<span class="cstat-no" title="statement not covered" >fulfill=x)</span>;<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner.showUISourceCode(uiSourceCode,fulfill);<span class="cstat-no" title="statement not covered" >r</span>eturn promise;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.showScriptSource=<span class="fstat-no" title="function not covered" >fu</span>nction(scriptName,callback){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitForScriptSource(scriptName,onScriptSource);f</span>unction <span class="fstat-no" title="function not covered" >onScriptSource(</span>uiSourceCode){<span class="cstat-no" title="statement not covered" >SourcesTestRunner.showUISourceCode(uiSourceCode,callback);}</span>};<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.showScriptSourcePromise=<span class="fstat-no" title="function not covered" >fu</span>nction(scriptName){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.showScriptSource(scriptName,resolve))</span>;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitForScriptSource=<span class="fstat-no" title="function not covered" >fu</span>nction(scriptName,callback){const panel=<span class="cstat-no" title="statement not covered" >UI.panels.sources;</span>const uiSourceCodes=<span class="cstat-no" title="statement not covered" >panel._workspace.uiSourceCodes();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;uiSourceCodes.length;++i){<span class="cstat-no" title="statement not covered" >if(uiSourceCodes[i].project().type()===Workspace.projectTypes.Service)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(uiSourceCodes[i].name()===scriptName){<span class="cstat-no" title="statement not covered" >callback(uiSourceCodes[i]);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addSniffer(Sources.SourcesView.prototype,'_addUISourceCode',SourcesTestRunner.waitForScriptSource.bind(SourcesTestRunner,scriptName,callback));}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.objectForPopover=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,lineNumber,columnNumber){const debuggerPlugin=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.debuggerPlugin(sourceFrame);</span>const{x,y}=<span class="cstat-no" title="statement not covered" >debuggerPlugin._textEditor.cursorPositionToCoordinates(lineNumber,columnNumber);</span>const promise=<span class="cstat-no" title="statement not covered" >TestRunner.addSnifferPromise(ObjectUI.ObjectPopoverHelper,'buildObjectPopover');<span class="cstat-no" title="statement not covered" ></span>debuggerPlugin._getPopoverRequest({x,y}).show(new UI.GlassPane());<span class="cstat-no" title="statement not covered" >r</span>eturn promise;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.setBreakpoint=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,lineNumber,condition,enabled){const debuggerPlugin=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.debuggerPlugin(sourceFrame);<span class="cstat-no" title="statement not covered" ></span>if(!debuggerPlugin._muted)</span></span>
<span class="cstat-no" title="statement not covered" >debuggerPlugin._setBreakpoint(lineNumber,0,condition,enabled);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.removeBreakpoint=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,lineNumber){const debuggerPlugin=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.debuggerPlugin(sourceFrame);</span>const breakpointLocations=<span class="cstat-no" title="statement not covered" >debuggerPlugin._breakpointManager.allBreakpointLocations();</span>const breakpointLocation=<span class="cstat-no" title="statement not covered" >breakpointLocations.find(<span class="fstat-no" title="function not covered" >br</span>eakpointLocation=&gt;<span class="cstat-no" title="statement not covered" >breakpointLocation.uiLocation.uiSourceCode===sourceFrame._uiSourceCode&amp;&amp;breakpointLocation.uiLocation.lineNumber===lineNumber)</span>;<span class="cstat-no" title="statement not covered" ></span>breakpointLocation.breakpoint.remove();}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.createNewBreakpoint=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,lineNumber,condition,enabled){const debuggerPlugin=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.debuggerPlugin(sourceFrame);</span>const promise=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >TestRunner.addSniffer(debuggerPlugin.__proto__,'_breakpointWasSetForTest',resolve))</span>;<span class="cstat-no" title="statement not covered" ></span>debuggerPlugin._createNewBreakpoint(lineNumber,condition,enabled);<span class="cstat-no" title="statement not covered" >r</span>eturn promise;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.toggleBreakpoint=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,lineNumber,disableOnly){const debuggerPlugin=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.debuggerPlugin(sourceFrame);<span class="cstat-no" title="statement not covered" ></span>if(!debuggerPlugin._muted)</span></span>
<span class="cstat-no" title="statement not covered" >debuggerPlugin._toggleBreakpoint(lineNumber,disableOnly);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitBreakpointSidebarPane=<span class="fstat-no" title="function not covered" >fu</span>nction(waitUntilResolved){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >TestRunner.addSniffer(Sources.JavaScriptBreakpointsSidebarPane.prototype,'_didUpdateForTest',resolve))</span>.then(checkIfReady);f</span>unction <span class="fstat-no" title="function not covered" >checkIfReady(</span>){<span class="cstat-no" title="statement not covered" >if(!waitUntilResolved)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const{breakpoint}of Bindings.breakpointManager.allBreakpointLocations()){<span class="cstat-no" title="statement not covered" >if(breakpoint._uiLocations.size===0&amp;&amp;breakpoint.enabled())</span></span>
<span class="cstat-no" title="statement not covered" >return SourcesTestRunner.waitBreakpointSidebarPane();}</span>}};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.breakpointsSidebarPaneContent=<span class="fstat-no" title="function not covered" >fu</span>nction(){const paneElement=<span class="cstat-no" title="statement not covered" >self.runtime.sharedInstance(Sources.JavaScriptBreakpointsSidebarPane).contentElement;</span>const empty=<span class="cstat-no" title="statement not covered" >paneElement.querySelector('.gray-info-message');<span class="cstat-no" title="statement not covered" ></span>if(empty)</span></span>
<span class="cstat-no" title="statement not covered" >return TestRunner.textContentWithLineBreaks(empty);c</span>onst entries=<span class="cstat-no" title="statement not covered" >Array.from(paneElement.querySelectorAll('.breakpoint-entry'));<span class="cstat-no" title="statement not covered" ></span>return entries.map(TestRunner.textContentWithLineBreaks).join('\n');}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpBreakpointSidebarPane=<span class="fstat-no" title="function not covered" >fu</span>nction(title){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Breakpoint sidebar pane '+(title||''));<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(SourcesTestRunner.breakpointsSidebarPaneContent());}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.dumpScopeVariablesSidebarPane=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Scope variables sidebar pane:');c</span>onst sections=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.scopeChainSections();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;sections.length;++i){const textContent=<span class="cstat-no" title="statement not covered" >TestRunner.textContentWithLineBreaks(sections[i].element);</span>const text=<span class="cstat-no" title="statement not covered" >TestRunner.clearSpecificInfoFromStackFrames(textContent);<span class="cstat-no" title="statement not covered" ></span>if(text.length&gt;0)</span></span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult(text);<span class="cstat-no" title="statement not covered" >i</span>f(!sections[i].objectTreeElement().expanded)</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('    &lt;section collapsed&gt;');}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.scopeChainSections=<span class="fstat-no" title="function not covered" >fu</span>nction(){const children=<span class="cstat-no" title="statement not covered" >self.runtime.sharedInstance(Sources.ScopeChainSidebarPane).contentElement.children;</span>const sections=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;children.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >sections.push(children[i]._section);<span class="cstat-no" title="statement not covered" >r</span>eturn sections;}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.expandScopeVariablesSidebarPane=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){const sections=<span class="cstat-no" title="statement not covered" >SourcesTestRunner.scopeChainSections();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;sections.length-1;++i)</span></span>
<span class="cstat-no" title="statement not covered" >sections[i].expand();<span class="cstat-no" title="statement not covered" >T</span>estRunner.deprecatedRunAfterPendingDispatches(callback);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.expandProperties=<span class="fstat-no" title="function not covered" >fu</span>nction(properties,callback){let index=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >expandNextPath(</span>){<span class="cstat-no" title="statement not covered" >if(index===properties.length){<span class="cstat-no" title="statement not covered" >TestRunner.safeWrap(callback)();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
const parentTreeElement=<span class="cstat-no" title="statement not covered" >properties[index++];</span>const path=<span class="cstat-no" title="statement not covered" >properties[index++];<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner._expandProperty(parentTreeElement,path,0,expandNextPath);}</span>
<span class="cstat-no" title="statement not covered" >TestRunner.deprecatedRunAfterPendingDispatches(expandNextPath);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner._expandProperty=<span class="fstat-no" title="function not covered" >fu</span>nction(parentTreeElement,path,pathIndex,callback){<span class="cstat-no" title="statement not covered" >if(pathIndex===path.length){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Expanded property: '+path.join('.'));<span class="cstat-no" title="statement not covered" >c</span>allback();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
const name=<span class="cstat-no" title="statement not covered" >path[pathIndex++];</span>const propertyTreeElement=<span class="cstat-no" title="statement not covered" >SourcesTestRunner._findChildPropertyTreeElement(parentTreeElement,name);<span class="cstat-no" title="statement not covered" ></span>if(!propertyTreeElement){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Failed to expand property: '+path.slice(0,pathIndex).join('.'));<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.completeDebuggerTest();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >propertyTreeElement.expand();<span class="cstat-no" title="statement not covered" >T</span>estRunner.deprecatedRunAfterPendingDispatches(SourcesTestRunner._expandProperty.bind(SourcesTestRunner,propertyTreeElement,path,pathIndex,callback));}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner._findChildPropertyTreeElement=<span class="fstat-no" title="function not covered" >fu</span>nction(parent,childName){const children=<span class="cstat-no" title="statement not covered" >parent.children();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;children.length;i++){const treeElement=<span class="cstat-no" title="statement not covered" >children[i];</span>const property=<span class="cstat-no" title="statement not covered" >treeElement.property;<span class="cstat-no" title="statement not covered" ></span>if(property.name===childName)</span></span></span>
<span class="cstat-no" title="statement not covered" >return treeElement;}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.setQuiet=<span class="fstat-no" title="function not covered" >fu</span>nction(quiet){<span class="cstat-no" title="statement not covered" >SourcesTestRunner._quiet=quiet;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.queryScripts=<span class="fstat-no" title="function not covered" >fu</span>nction(filter){const scripts=<span class="cstat-no" title="statement not covered" >TestRunner.debuggerModel.scripts();<span class="cstat-no" title="statement not covered" ></span>return(filter?scripts.filter(filter):scripts);}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.createScriptMock=<span class="fstat-no" title="function not covered" >fu</span>nction(url,startLine,startColumn,isContentScript,source,target,preRegisterCallback){<span class="cstat-no" title="statement not covered" >target=target||SDK.targetManager.mainTarget();c</span>onst debuggerModel=<span class="cstat-no" title="statement not covered" >target.model(SDK.DebuggerModel);</span>const scriptId=<span class="cstat-no" title="statement not covered" >++SourcesTestRunner._lastScriptId+'';</span>const lineCount=<span class="cstat-no" title="statement not covered" >source.computeLineEndings().length;</span>const endLine=<span class="cstat-no" title="statement not covered" >startLine+lineCount-1;</span>const endColumn=(<span class="cstat-no" title="statement not covered" >lineCount===1?startColumn+source.length:source.length-source.computeLineEndings()[lineCount-2])</span>;const hasSourceURL=<span class="cstat-no" title="statement not covered" >!!source.match(/\/\/#\ssourceURL=\s*(\S*?)\s*$/m)||!!source.match(/\/\/@\ssourceURL=\s*(\S*?)\s*$/m);</span>const script=<span class="cstat-no" title="statement not covered" >new SDK.Script(debuggerModel,scriptId,url,startLine,startColumn,endLine,endColumn,0,'',isContentScript,false,undefined,hasSourceURL,source.length);<span class="cstat-no" title="statement not covered" ></span>script.requestContent=<span class="fstat-no" title="function not covered" >fu</span>nction(){const trimmedSource=<span class="cstat-no" title="statement not covered" >SDK.Script._trimSourceURLComment(source);<span class="cstat-no" title="statement not covered" ></span>return Promise.resolve(trimmedSource);}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(preRegisterCallback)</span></span>
<span class="cstat-no" title="statement not covered" >preRegisterCallback(script);<span class="cstat-no" title="statement not covered" >d</span>ebuggerModel._registerScript(script);<span class="cstat-no" title="statement not covered" >r</span>eturn script;}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner._lastScriptId=0;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.checkRawLocation=<span class="fstat-no" title="function not covered" >fu</span>nction(script,lineNumber,columnNumber,location){<span class="cstat-no" title="statement not covered" >TestRunner.assertEquals(script.scriptId,location.scriptId,'Incorrect scriptId');<span class="cstat-no" title="statement not covered" >T</span>estRunner.assertEquals(lineNumber,location.lineNumber,'Incorrect lineNumber');<span class="cstat-no" title="statement not covered" >T</span>estRunner.assertEquals(columnNumber,location.columnNumber,'Incorrect columnNumber');}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.checkUILocation=<span class="fstat-no" title="function not covered" >fu</span>nction(uiSourceCode,lineNumber,columnNumber,location){<span class="cstat-no" title="statement not covered" >TestRunner.assertEquals(uiSourceCode,location.uiSourceCode,'Incorrect uiSourceCode, expected \''+((uiSourceCode?uiSourceCode.url():null))+'\','+' but got \''+((location.uiSourceCode?location.uiSourceCode.url():null))+'\'');<span class="cstat-no" title="statement not covered" >T</span>estRunner.assertEquals(lineNumber,location.lineNumber,'Incorrect lineNumber, expected \''+lineNumber+'\', but got \''+location.lineNumber+'\'');<span class="cstat-no" title="statement not covered" >T</span>estRunner.assertEquals(columnNumber,location.columnNumber,'Incorrect columnNumber, expected \''+columnNumber+'\', but got \''+location.columnNumber+'\'');}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.scriptFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return self.runtime.allInstances(Sources.SourcesView.EditorAction).then(<span class="fstat-no" title="function not covered" >fu</span>nction(editorActions){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;editorActions.length;++i){<span class="cstat-no" title="statement not covered" >if(editorActions[i]instanceof Sources.ScriptFormatterEditorAction)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return editorActions[i];}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>);};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.waitForExecutionContextInTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(target,callback){const runtimeModel=<span class="cstat-no" title="statement not covered" >target.model(SDK.RuntimeModel);<span class="cstat-no" title="statement not covered" ></span>if(runtimeModel.executionContexts().length){<span class="cstat-no" title="statement not covered" >callback(runtimeModel.executionContexts()[0]);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
<span class="cstat-no" title="statement not covered" >runtimeModel.addEventListener(SDK.RuntimeModel.Events.ExecutionContextCreated,contextCreated);f</span>unction <span class="fstat-no" title="function not covered" >contextCreated(</span>){<span class="cstat-no" title="statement not covered" >runtimeModel.removeEventListener(SDK.RuntimeModel.Events.ExecutionContextCreated,contextCreated);<span class="cstat-no" title="statement not covered" >c</span>allback(runtimeModel.executionContexts()[0]);}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.selectThread=<span class="fstat-no" title="function not covered" >fu</span>nction(target){const threadsPane=<span class="cstat-no" title="statement not covered" >self.runtime.sharedInstance(Sources.ThreadsSidebarPane);<span class="cstat-no" title="statement not covered" ></span>threadsPane._list.selectItem(target.model(SDK.DebuggerModel));}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.evaluateOnCurrentCallFrame=<span class="fstat-no" title="function not covered" >fu</span>nction(code){<span class="cstat-no" title="statement not covered" >return TestRunner.debuggerModel.evaluateOnSelectedCallFrame({expression:code,objectGroup:'console'});}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitDebuggerPluginDecorations=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){<span class="cstat-no" title="statement not covered" >return TestRunner.addSnifferPromise(Sources.DebuggerPlugin.prototype,'_breakpointDecorationsUpdatedForTest');}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitDebuggerPluginBreakpoints=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){<span class="cstat-no" title="statement not covered" >return SourcesTestRunner.waitDebuggerPluginDecorations().then(checkIfReady);f</span>unction <span class="fstat-no" title="function not covered" >checkIfReady(</span>){<span class="cstat-no" title="statement not covered" >for(const{breakpoint}of Bindings.breakpointManager.allBreakpointLocations()){<span class="cstat-no" title="statement not covered" >if(breakpoint._uiLocations.size===0&amp;&amp;breakpoint.enabled())</span></span></span>
<span class="cstat-no" title="statement not covered" >return SourcesTestRunner.waitDebuggerPluginDecorations().then(checkIfReady);}</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpDebuggerPluginBreakpoints=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){const textEditor=<span class="cstat-no" title="statement not covered" >sourceFrame._textEditor;<span class="cstat-no" title="statement not covered" ></span>for(let lineNumber=0;lineNumber&lt;textEditor.linesCount;++lineNumber){<span class="cstat-no" title="statement not covered" >if(!textEditor.hasLineClass(lineNumber,'cm-breakpoint'))</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst disabled=<span class="cstat-no" title="statement not covered" >textEditor.hasLineClass(lineNumber,'cm-breakpoint-disabled');</span>const conditional=<span class="cstat-no" title="statement not covered" >textEditor.hasLineClass(lineNumber,'cm-breakpoint-conditional');<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('breakpoint at '+lineNumber+((disabled?' disabled':''))+((conditional?' conditional':'')));c</span>onst range=<span class="cstat-no" title="statement not covered" >new TextUtils.TextRange(lineNumber,0,lineNumber,textEditor.line(lineNumber).length);</span>let bookmarks=<span class="cstat-no" title="statement not covered" >textEditor.bookmarks(range,Sources.DebuggerPlugin.BreakpointDecoration._bookmarkSymbol);<span class="cstat-no" title="statement not covered" ></span>bookmarks=bookmarks.filter(<span class="fstat-no" title="function not covered" >bo</span>okmark=&gt;<span class="cstat-no" title="statement not covered" >!!bookmark.position())</span>;<span class="cstat-no" title="statement not covered" >b</span>ookmarks.sort(<span class="fstat-no" title="function not covered" >(b</span>ookmark1,bookmark2)=&gt;<span class="cstat-no" title="statement not covered" >bookmark1.position().startColumn-bookmark2.position().startColumn)</span>;<span class="cstat-no" title="statement not covered" >f</span>or(const bookmark of bookmarks){const position=<span class="cstat-no" title="statement not covered" >bookmark.position();</span>const element=<span class="cstat-no" title="statement not covered" >bookmark[Sources.DebuggerPlugin.BreakpointDecoration._elementSymbolForTest];</span>const disabled=<span class="cstat-no" title="statement not covered" >element.classList.contains('cm-inline-disabled');</span>const conditional=<span class="cstat-no" title="statement not covered" >element.classList.contains('cm-inline-conditional');<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('  inline breakpoint at ('+position.startLine+', '+position.startColumn+')'+</span></span>
((disabled?' disabled':''))+((conditional?' conditional':'')));}}};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.clickDebuggerPluginBreakpoint=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,lineNumber,index,next){const textEditor=<span class="cstat-no" title="statement not covered" >sourceFrame._textEditor;</span>const lineLength=<span class="cstat-no" title="statement not covered" >textEditor.line(lineNumber).length;</span>const lineRange=<span class="cstat-no" title="statement not covered" >new TextUtils.TextRange(lineNumber,0,lineNumber,lineLength);</span>const bookmarks=<span class="cstat-no" title="statement not covered" >textEditor.bookmarks(lineRange,Sources.DebuggerPlugin.BreakpointDecoration._bookmarkSymbol);<span class="cstat-no" title="statement not covered" ></span>bookmarks.sort(<span class="fstat-no" title="function not covered" >(b</span>ookmark1,bookmark2)=&gt;<span class="cstat-no" title="statement not covered" >bookmark1.position().startColumn-bookmark2.position().startColumn)</span>;c</span>onst bookmark=<span class="cstat-no" title="statement not covered" >bookmarks[index];<span class="cstat-no" title="statement not covered" ></span>if(bookmark){<span class="cstat-no" title="statement not covered" >bookmark[Sources.DebuggerPlugin.BreakpointDecoration._elementSymbolForTest].click();}</span>else{<span class="cstat-no" title="statement not covered" >TestRunner.addResult(`Could not click on Javascript breakpoint - lineNumber: ${lineNumber}, index: ${index}`);<span class="cstat-no" title="statement not covered" >n</span>ext();}</span>}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.debuggerPlugin=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){<span class="cstat-no" title="statement not covered" >return sourceFrame._plugins.find(<span class="fstat-no" title="function not covered" >pl</span>ugin=&gt;<span class="cstat-no" title="statement not covered" >plugin instanceof Sources.DebuggerPlugin)</span>;}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.waitUntilDebuggerPluginLoaded=<span class="fstat-no" title="function not covered" >as</span>ync function(sourceFrame){<span class="cstat-no" title="statement not covered" >while(!SourcesTestRunner.debuggerPlugin(sourceFrame))</span></span>
<span class="cstat-no" title="statement not covered" >await TestRunner.addSnifferPromise(sourceFrame,'_ensurePluginsLoaded');<span class="cstat-no" title="statement not covered" >r</span>eturn SourcesTestRunner.debuggerPlugin(sourceFrame);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.setEventListenerBreakpoint=<span class="fstat-no" title="function not covered" >fu</span>nction(id,enabled,targetName){const pane=<span class="cstat-no" title="statement not covered" >self.runtime.sharedInstance(BrowserDebugger.EventListenerBreakpointsSidebarPane);</span>const auxData=<span class="cstat-no" title="statement not covered" >{'eventName':id};<span class="cstat-no" title="statement not covered" ></span>if(targetName)</span></span>
<span class="cstat-no" title="statement not covered" >auxData.targetName=targetName;c</span>onst breakpoint=<span class="cstat-no" title="statement not covered" >SDK.domDebuggerManager.resolveEventListenerBreakpoint(auxData);<span class="cstat-no" title="statement not covered" ></span>if(breakpoint.enabled()!==enabled){<span class="cstat-no" title="statement not covered" >pane._breakpoints.get(breakpoint).checkbox.checked=enabled;<span class="cstat-no" title="statement not covered" >p</span>ane._breakpointCheckboxClicked(breakpoint);}</span>}</span>;<span class="cstat-no" title="statement not covered" >TestRunner.deprecatedInitAsync(`</span>
  function scheduleTestFunction() {
    setTimeout(testFunction, 0);
  }
`);;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.replaceInSource=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,string,replacement){<span class="cstat-no" title="statement not covered" >sourceFrame._textEditor.setReadOnly(false);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;sourceFrame._textEditor.linesCount;++i){const line=<span class="cstat-no" title="statement not covered" >sourceFrame._textEditor.line(i);</span>const column=<span class="cstat-no" title="statement not covered" >line.indexOf(string);<span class="cstat-no" title="statement not covered" ></span>if(column===-1)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst range=<span class="cstat-no" title="statement not covered" >new TextUtils.TextRange(i,column,i,column+string.length);<span class="cstat-no" title="statement not covered" ></span>sourceFrame._textEditor.editRange(range,replacement);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.commitSource=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){<span class="cstat-no" title="statement not covered" >sourceFrame.commitEditing();}</span>;<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.undoSourceEditing=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame){<span class="cstat-no" title="statement not covered" >sourceFrame._textEditor.undo();}</span>;;<span class="cstat-no" title="statement not covered" ></span>SourcesTestRunner.dumpSearchResults=<span class="fstat-no" title="function not covered" >fu</span>nction(searchResults){function <span class="fstat-no" title="function not covered" >comparator(</span>a,b){<span class="cstat-no" title="statement not covered" >a.url.localeCompare(b.url);}</span></span>
<span class="cstat-no" title="statement not covered" >searchResults.sort(comparator);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Search results: ');<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;searchResults.length;i++){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('url: '+searchResults[i].url.replace(/VM\d+/,'VMXX')+', matchesCount: '+searchResults[i].matchesCount);}</span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('');}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpSearchMatches=<span class="fstat-no" title="function not covered" >fu</span>nction(searchMatches){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Search matches: ');<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;searchMatches.length;i++){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('lineNumber: '+searchMatches[i].lineNumber+', line: \''+searchMatches[i].lineContent+'\'');}</span></span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('');}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.runSearchAndDumpResults=<span class="fstat-no" title="function not covered" >fu</span>nction(scope,searchConfig,callback){const searchResults=<span class="cstat-no" title="statement not covered" >[];</span>const progress=<span class="cstat-no" title="statement not covered" >new Common.Progress();<span class="cstat-no" title="statement not covered" ></span>scope.performSearch(searchConfig,progress,searchResultCallback,searchFinishedCallback);f</span>unction <span class="fstat-no" title="function not covered" >searchResultCallback(</span>searchResult){<span class="cstat-no" title="statement not covered" >searchResults.push(searchResult);}</span></span>
function <span class="fstat-no" title="function not covered" >searchFinishedCallback(</span>){function <span class="fstat-no" title="function not covered" >comparator(</span>searchResultA,searchResultB){<span class="cstat-no" title="statement not covered" >return searchResultA._uiSourceCode.url().compareTo(searchResultB._uiSourceCode.url());}</span>
<span class="cstat-no" title="statement not covered" >searchResults.sort(comparator);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;searchResults.length;++i){const searchResult=<span class="cstat-no" title="statement not covered" >searchResults[i];</span>const uiSourceCode=<span class="cstat-no" title="statement not covered" >searchResult._uiSourceCode;</span>const searchMatches=<span class="cstat-no" title="statement not covered" >searchResult._searchMatches;<span class="cstat-no" title="statement not covered" ></span>if(!searchMatches.length)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Search result #'+(i+1)+': uiSourceCode.url = '+uiSourceCode.url().replace(/VM\d+/,'VMXX'));<span class="cstat-no" title="statement not covered" >f</span>or(let j=0;j&lt;searchMatches.length;++j){const lineNumber=<span class="cstat-no" title="statement not covered" >searchMatches[j].lineNumber;</span>const lineContent=<span class="cstat-no" title="statement not covered" >searchMatches[j].lineContent;<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('  search match #'+(j+1)+': lineNumber = '+lineNumber+', lineContent = \''+lineContent+'\'');}</span>}</span>
<span class="cstat-no" title="statement not covered" >callback();}</span>};<span class="cstat-no" title="statement not covered" >SourcesTestRunner.replaceAndDumpChange=<span class="fstat-no" title="function not covered" >fu</span>nction(sourceFrame,searchConfig,replacement,replaceAll){const modifiers=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(searchConfig.isRegex)</span></span>
<span class="cstat-no" title="statement not covered" >modifiers.push('regex');<span class="cstat-no" title="statement not covered" >i</span>f(searchConfig.caseSensitive)</span>
<span class="cstat-no" title="statement not covered" >modifiers.push('caseSensitive');<span class="cstat-no" title="statement not covered" >i</span>f(replaceAll)</span>
<span class="cstat-no" title="statement not covered" >modifiers.push('replaceAll');c</span>onst modifiersString=(<span class="cstat-no" title="statement not covered" >modifiers.length?' ('+modifiers.join(', ')+')':'')</span>;<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Running replace test for /'+searchConfig.query+'/'+replacement+'/ '+modifiersString+':');<span class="cstat-no" title="statement not covered" >e</span>ditor=sourceFrame._textEditor;c</span>onst oldLines=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;editor.linesCount;++i)</span>
<span class="cstat-no" title="statement not covered" >oldLines.push(editor.line(i));c</span>onst searchableView=<span class="cstat-no" title="statement not covered" >UI.panels.sources.sourcesView().searchableView();<span class="cstat-no" title="statement not covered" ></span>searchableView.showSearchField();<span class="cstat-no" title="statement not covered" >s</span>earchableView._caseSensitiveButton.setToggled(searchConfig.caseSensitive);<span class="cstat-no" title="statement not covered" >s</span>earchableView._regexButton.setToggled(searchConfig.isRegex);<span class="cstat-no" title="statement not covered" >s</span>earchableView._searchInputElement.value=searchConfig.query;<span class="cstat-no" title="statement not covered" >s</span>earchableView._replaceToggleButton.setToggled(true);<span class="cstat-no" title="statement not covered" >s</span>earchableView._updateSecondRowVisibility();<span class="cstat-no" title="statement not covered" >s</span>earchableView._replaceInputElement.value=replacement;<span class="cstat-no" title="statement not covered" >s</span>earchableView._performSearch(true,true);<span class="cstat-no" title="statement not covered" >i</span>f(replaceAll)</span>
<span class="cstat-no" title="statement not covered" >searchableView._replaceAll();e</span>lse
<span class="cstat-no" title="statement not covered" >searchableView._replace();c</span>onst newLines=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;editor.linesCount;++i)</span>
<span class="cstat-no" title="statement not covered" >newLines.push(editor.line(i));<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;newLines.length;++i){<span class="cstat-no" title="statement not covered" >if(oldLines[i]===newLines[i])</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst oldLine=<span class="cstat-no" title="statement not covered" >oldLines[i];</span>const newLine=<span class="cstat-no" title="statement not covered" >newLines[i];</span>let prefixLength=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let j=0;j&lt;oldLine.length&amp;&amp;j&lt;newLine.length&amp;&amp;newLine[j]===oldLine[j];++j)</span>
<span class="cstat-no" title="statement not covered" >++prefixLength;l</span>et postfixLength=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let j=0;j&lt;oldLine.length&amp;&amp;j&lt;newLine.length&amp;&amp;newLine[newLine.length-j-1]===oldLine[oldLine.length-j-1];++j)</span>
<span class="cstat-no" title="statement not covered" >++postfixLength;c</span>onst prefix=<span class="cstat-no" title="statement not covered" >oldLine.substring(0,prefixLength);</span>const removed=<span class="cstat-no" title="statement not covered" >oldLine.substring(prefixLength,oldLine.length-postfixLength);</span>const added=<span class="cstat-no" title="statement not covered" >newLine.substring(prefixLength,newLine.length-postfixLength);</span>const postfix=<span class="cstat-no" title="statement not covered" >oldLine.substring(oldLine.length-postfixLength);<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('  - '+prefix+'#'+removed+'#'+added+'#'+postfix);}</span>};<span class="cstat-no" title="statement not covered" >TestRunner.deprecatedInitAsync(`</span>
  if (window.GCController)
    GCController.collect();
`);;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.createTestEditor=<span class="fstat-no" title="function not covered" >fu</span>nction(clientHeight,textEditorDelegate){const textEditor=<span class="cstat-no" title="statement not covered" >new SourceFrame.SourcesTextEditor(textEditorDelegate||new SourceFrame.SourcesTextEditorDelegate());<span class="cstat-no" title="statement not covered" ></span>clientHeight=clientHeight||100;<span class="cstat-no" title="statement not covered" >t</span>extEditor.element.style.height=clientHeight+'px';<span class="cstat-no" title="statement not covered" >t</span>extEditor.element.style.flex='none';<span class="cstat-no" title="statement not covered" >t</span>extEditor.show(UI.inspectorView.element);<span class="cstat-no" title="statement not covered" >r</span>eturn textEditor;}</span>;f</span>unction <span class="fstat-no" title="function not covered" >textWithSelection(</span>text,selections){<span class="cstat-no" title="statement not covered" >if(!selections.length)</span>
<span class="cstat-no" title="statement not covered" >return text;f</span>unction <span class="fstat-no" title="function not covered" >lineWithCursor(</span>line,column,cursorChar){<span class="cstat-no" title="statement not covered" >return line.substring(0,column)+cursorChar+line.substring(column);}</span>
const lines=<span class="cstat-no" title="statement not covered" >text.split('\n');<span class="cstat-no" title="statement not covered" ></span>selections.sort(TextUtils.TextRange.comparator);<span class="cstat-no" title="statement not covered" >f</span>or(let i=selections.length-1;i&gt;=0;--i){let selection=<span class="cstat-no" title="statement not covered" >selections[i];<span class="cstat-no" title="statement not covered" ></span>selection=selection.normalize();c</span>onst endCursorChar=(<span class="cstat-no" title="statement not covered" >selection.isEmpty()?'|':'&lt;')</span>;<span class="cstat-no" title="statement not covered" >lines[selection.endLine]=lineWithCursor(lines[selection.endLine],selection.endColumn,endCursorChar);<span class="cstat-no" title="statement not covered" >i</span>f(!selection.isEmpty())</span></span>
<span class="cstat-no" title="statement not covered" >lines[selection.startLine]=lineWithCursor(lines[selection.startLine],selection.startColumn,'&gt;');}</span>
<span class="cstat-no" title="statement not covered" >return lines.join('\n');}</span>
<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpTextWithSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(textEditor,dumpWhiteSpaces){let text=<span class="cstat-no" title="statement not covered" >textWithSelection(textEditor.text(),textEditor.selections());<span class="cstat-no" title="statement not covered" ></span>if(dumpWhiteSpaces)</span></span>
<span class="cstat-no" title="statement not covered" >text=text.replace(/ /g,'.');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(text);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.setLineSelections=<span class="fstat-no" title="function not covered" >fu</span>nction(editor,selections){const coords=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;selections.length;++i){const selection=<span class="cstat-no" title="statement not covered" >selections[i];<span class="cstat-no" title="statement not covered" ></span>if(typeof selection.column==='number'){<span class="cstat-no" title="statement not covered" >selection.from=selection.column;<span class="cstat-no" title="statement not covered" >s</span>election.to=selection.column;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >coords.push(new TextUtils.TextRange(selection.line,selection.from,selection.line,selection.to));}</span>
<span class="cstat-no" title="statement not covered" >editor.setSelections(coords);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.typeIn=<span class="fstat-no" title="function not covered" >fu</span>nction(editor,typeText,callback){<span class="cstat-no" title="statement not covered" >callback=callback||new Function();c</span>onst noop=<span class="cstat-no" title="statement not covered" >new Function();<span class="cstat-no" title="statement not covered" ></span>for(let charIndex=0;charIndex&lt;typeText.length;++charIndex){const iterationCallback=(<span class="cstat-no" title="statement not covered" >charIndex+1===typeText.length?callback:noop)</span>;<span class="cstat-no" title="statement not covered" >switch(typeText[charIndex]){case'\n':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent(editor,'Enter',null,iterationCallback);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'L':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent(editor,'ArrowLeft',null,iterationCallback);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'R':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent(editor,'ArrowRight',null,iterationCallback);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'U':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent(editor,'ArrowUp',null,iterationCallback);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'D':<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent(editor,'ArrowDown',null,iterationCallback);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent(editor,typeText[charIndex],null,iterationCallback);}</span>}</span>}</span>;c</span>onst eventCodes=<span class="cstat-no" title="statement not covered" >{Enter:13,Home:36,ArrowLeft:37,ArrowUp:38,ArrowRight:39,ArrowDown:40};</span>function <span class="fstat-no" title="function not covered" >createCodeMirrorFakeEvent(</span>editor,eventType,code,charCode,modifiers){function <span class="fstat-no" title="function not covered" >eventPreventDefault(</span>){<span class="cstat-no" title="statement not covered" >this._handled=true;}</span>
const event=<span class="cstat-no" title="statement not covered" >{_handled:false,type:eventType,keyCode:code,charCode:charCode,preventDefault:eventPreventDefault,stopPropagation:<span class="fstat-no" title="function not covered" >fu</span>nction(){},target:editor._codeMirror.display.input.textarea};<span class="cstat-no" title="statement not covered" ></span>if(modifiers){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;modifiers.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >event[modifiers[i]]=true;}</span>
<span class="cstat-no" title="statement not covered" >return event;}</span>
function <span class="fstat-no" title="function not covered" >fakeCodeMirrorKeyEvent(</span>editor,eventType,code,charCode,modifiers){const event=<span class="cstat-no" title="statement not covered" >createCodeMirrorFakeEvent(editor,eventType,code,charCode,modifiers);<span class="cstat-no" title="statement not covered" ></span>switch(eventType){case'keydown':<span class="cstat-no" title="statement not covered" >editor._codeMirror.triggerOnKeyDown(event);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'keypress':<span class="cstat-no" title="statement not covered" >editor._codeMirror.triggerOnKeyPress(event);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'keyup':<span class="cstat-no" title="statement not covered" >editor._codeMirror.triggerOnKeyUp(event);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Unknown KeyEvent type');}</span></span>
<span class="cstat-no" title="statement not covered" >return event._handled;}</span>
function <span class="fstat-no" title="function not covered" >fakeCodeMirrorInputEvent(</span>editor,character){<span class="cstat-no" title="statement not covered" >if(typeof character!=='string')</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst input=<span class="cstat-no" title="statement not covered" >editor._codeMirror.display.input;</span>const value=<span class="cstat-no" title="statement not covered" >input.textarea.value;</span>const newValue=<span class="cstat-no" title="statement not covered" >value.substring(0,input.textarea.selectionStart)+character+value.substring(input.textarea.selectionEnd);</span>const caretPosition=<span class="cstat-no" title="statement not covered" >input.textarea.selectionStart+character.length;<span class="cstat-no" title="statement not covered" ></span>input.textarea.value=newValue;<span class="cstat-no" title="statement not covered" >i</span>nput.textarea.setSelectionRange(caretPosition,caretPosition);<span class="cstat-no" title="statement not covered" >i</span>nput.poll();}</span>
<span class="cstat-no" title="statement not covered" >SourcesTestRunner.fakeKeyEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(editor,originalCode,modifiers,callback){<span class="cstat-no" title="statement not covered" >modifiers=modifiers||[];l</span>et code;let charCode;<span class="cstat-no" title="statement not covered" >if(originalCode==='\''){<span class="cstat-no" title="statement not covered" >code=222;<span class="cstat-no" title="statement not covered" >c</span>harCode=0;}</span>else <span class="cstat-no" title="statement not covered" >if(originalCode==='"'){<span class="cstat-no" title="statement not covered" >code=222;<span class="cstat-no" title="statement not covered" >m</span>odifiers.push('shiftKey');<span class="cstat-no" title="statement not covered" >c</span>harCode=34;}</span>else <span class="cstat-no" title="statement not covered" >if(originalCode==='('){<span class="cstat-no" title="statement not covered" >code='9'.charCodeAt(0);<span class="cstat-no" title="statement not covered" >m</span>odifiers.push('shiftKey');<span class="cstat-no" title="statement not covered" >c</span>harCode=originalCode.charCodeAt(0);}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >code=code||eventCodes[originalCode]||originalCode;<span class="cstat-no" title="statement not covered" >i</span>f(typeof code==='string')</span>
<span class="cstat-no" title="statement not covered" >code=code.charCodeAt(0);<span class="cstat-no" title="statement not covered" >i</span>f(fakeCodeMirrorKeyEvent(editor,'keydown',code,charCode,modifiers)){<span class="cstat-no" title="statement not covered" >callback();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(fakeCodeMirrorKeyEvent(editor,'keypress',code,charCode,modifiers)){<span class="cstat-no" title="statement not covered" >callback();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const inputReadPromise=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >x=</span>&gt;<span class="cstat-no" title="statement not covered" >editor._codeMirror.on('inputRead',x))</span>;<span class="cstat-no" title="statement not covered" ></span>fakeCodeMirrorInputEvent(editor,originalCode);<span class="cstat-no" title="statement not covered" >f</span>akeCodeMirrorKeyEvent(editor,'keyup',code,charCode,modifiers);<span class="cstat-no" title="statement not covered" >i</span>nputReadPromise.then(callback);}</span>;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpSelectionStats=<span class="fstat-no" title="function not covered" >fu</span>nction(textEditor){const listHashMap=<span class="cstat-no" title="statement not covered" >{};</span>const sortedKeys=<span class="cstat-no" title="statement not covered" >[];</span>const selections=<span class="cstat-no" title="statement not covered" >textEditor.selections();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;selections.length;++i){const selection=<span class="cstat-no" title="statement not covered" >selections[i];</span>const text=<span class="cstat-no" title="statement not covered" >textEditor.text(selection);<span class="cstat-no" title="statement not covered" ></span>if(!listHashMap[text]){<span class="cstat-no" title="statement not covered" >listHashMap[text]=1;<span class="cstat-no" title="statement not covered" >s</span>ortedKeys.push(text);}</span>else{<span class="cstat-no" title="statement not covered" >++listHashMap[text];}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;sortedKeys.length;++i){let keyName=<span class="cstat-no" title="statement not covered" >sortedKeys[i];<span class="cstat-no" title="statement not covered" ></span>if(!keyName.length)</span></span>
<span class="cstat-no" title="statement not covered" >keyName='&lt;Empty string&gt;';e</span>lse
<span class="cstat-no" title="statement not covered" >keyName='\''+keyName+'\'';<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult(keyName+': '+listHashMap[sortedKeys[i]]);}</span>};;<span class="cstat-no" title="statement not covered" >SourcesTestRunner.dumpSuggestions=<span class="fstat-no" title="function not covered" >fu</span>nction(textEditor,lines){let resolve;const promise=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfill=&gt;<span class="cstat-no" title="statement not covered" >resolve=fulfill)</span>;</span>let lineNumber=<span class="cstat-no" title="statement not covered" >-1;</span>let columnNumber;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;lines.length;++i){<span class="cstat-no" title="statement not covered" >columnNumber=lines[i].indexOf('|');<span class="cstat-no" title="statement not covered" >i</span>f(columnNumber!==-1){<span class="cstat-no" title="statement not covered" >lineNumber=i;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(lineNumber===-1)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Test case is invalid: cursor position is not marked with \'|\' symbol.');<span class="cstat-no" title="statement not covered" >t</span>extEditor.setText(lines.join('\n').replace('|',''));<span class="cstat-no" title="statement not covered" >t</span>extEditor.setSelection(TextUtils.TextRange.createFromLocation(lineNumber,columnNumber));<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(TextEditor.TextEditorAutocompleteController.prototype,'_onSuggestionsShownForTest',suggestionsShown);<span class="cstat-no" title="statement not covered" >t</span>extEditor._autocompleteController.autocomplete();f</span>unction <span class="fstat-no" title="function not covered" >suggestionsShown(</span>words){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('========= Selection In Editor =========');<span class="cstat-no" title="statement not covered" >S</span>ourcesTestRunner.dumpTextWithSelection(textEditor);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('======= Autocomplete Suggestions =======');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('['+words.map(<span class="fstat-no" title="function not covered" >it</span>em=&gt;<span class="cstat-no" title="statement not covered" >item.text)</span>.join(', ')+']');<span class="cstat-no" title="statement not covered" >r</span>esolve();}</span>
<span class="cstat-no" title="statement not covered" >return promise;}</span>;;</pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:04:04 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
