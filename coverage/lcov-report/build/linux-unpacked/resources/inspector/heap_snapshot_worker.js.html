<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/linux-unpacked/resources/inspector/heap_snapshot_worker.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../index.html">All files</a> / <a href="index.html">build/linux-unpacked/resources/inspector</a> heap_snapshot_worker.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/4354</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/1830</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/824</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/1265</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a>
<a name='L559'></a><a href='#L559'>559</a>
<a name='L560'></a><a href='#L560'>560</a>
<a name='L561'></a><a href='#L561'>561</a>
<a name='L562'></a><a href='#L562'>562</a>
<a name='L563'></a><a href='#L563'>563</a>
<a name='L564'></a><a href='#L564'>564</a>
<a name='L565'></a><a href='#L565'>565</a>
<a name='L566'></a><a href='#L566'>566</a>
<a name='L567'></a><a href='#L567'>567</a>
<a name='L568'></a><a href='#L568'>568</a>
<a name='L569'></a><a href='#L569'>569</a>
<a name='L570'></a><a href='#L570'>570</a>
<a name='L571'></a><a href='#L571'>571</a>
<a name='L572'></a><a href='#L572'>572</a>
<a name='L573'></a><a href='#L573'>573</a>
<a name='L574'></a><a href='#L574'>574</a>
<a name='L575'></a><a href='#L575'>575</a>
<a name='L576'></a><a href='#L576'>576</a>
<a name='L577'></a><a href='#L577'>577</a>
<a name='L578'></a><a href='#L578'>578</a>
<a name='L579'></a><a href='#L579'>579</a>
<a name='L580'></a><a href='#L580'>580</a>
<a name='L581'></a><a href='#L581'>581</a>
<a name='L582'></a><a href='#L582'>582</a>
<a name='L583'></a><a href='#L583'>583</a>
<a name='L584'></a><a href='#L584'>584</a>
<a name='L585'></a><a href='#L585'>585</a>
<a name='L586'></a><a href='#L586'>586</a>
<a name='L587'></a><a href='#L587'>587</a>
<a name='L588'></a><a href='#L588'>588</a>
<a name='L589'></a><a href='#L589'>589</a>
<a name='L590'></a><a href='#L590'>590</a>
<a name='L591'></a><a href='#L591'>591</a>
<a name='L592'></a><a href='#L592'>592</a>
<a name='L593'></a><a href='#L593'>593</a>
<a name='L594'></a><a href='#L594'>594</a>
<a name='L595'></a><a href='#L595'>595</a>
<a name='L596'></a><a href='#L596'>596</a>
<a name='L597'></a><a href='#L597'>597</a>
<a name='L598'></a><a href='#L598'>598</a>
<a name='L599'></a><a href='#L599'>599</a>
<a name='L600'></a><a href='#L600'>600</a>
<a name='L601'></a><a href='#L601'>601</a>
<a name='L602'></a><a href='#L602'>602</a>
<a name='L603'></a><a href='#L603'>603</a>
<a name='L604'></a><a href='#L604'>604</a>
<a name='L605'></a><a href='#L605'>605</a>
<a name='L606'></a><a href='#L606'>606</a>
<a name='L607'></a><a href='#L607'>607</a>
<a name='L608'></a><a href='#L608'>608</a>
<a name='L609'></a><a href='#L609'>609</a>
<a name='L610'></a><a href='#L610'>610</a>
<a name='L611'></a><a href='#L611'>611</a>
<a name='L612'></a><a href='#L612'>612</a>
<a name='L613'></a><a href='#L613'>613</a>
<a name='L614'></a><a href='#L614'>614</a>
<a name='L615'></a><a href='#L615'>615</a>
<a name='L616'></a><a href='#L616'>616</a>
<a name='L617'></a><a href='#L617'>617</a>
<a name='L618'></a><a href='#L618'>618</a>
<a name='L619'></a><a href='#L619'>619</a>
<a name='L620'></a><a href='#L620'>620</a>
<a name='L621'></a><a href='#L621'>621</a>
<a name='L622'></a><a href='#L622'>622</a>
<a name='L623'></a><a href='#L623'>623</a>
<a name='L624'></a><a href='#L624'>624</a>
<a name='L625'></a><a href='#L625'>625</a>
<a name='L626'></a><a href='#L626'>626</a>
<a name='L627'></a><a href='#L627'>627</a>
<a name='L628'></a><a href='#L628'>628</a>
<a name='L629'></a><a href='#L629'>629</a>
<a name='L630'></a><a href='#L630'>630</a>
<a name='L631'></a><a href='#L631'>631</a>
<a name='L632'></a><a href='#L632'>632</a>
<a name='L633'></a><a href='#L633'>633</a>
<a name='L634'></a><a href='#L634'>634</a>
<a name='L635'></a><a href='#L635'>635</a>
<a name='L636'></a><a href='#L636'>636</a>
<a name='L637'></a><a href='#L637'>637</a>
<a name='L638'></a><a href='#L638'>638</a>
<a name='L639'></a><a href='#L639'>639</a>
<a name='L640'></a><a href='#L640'>640</a>
<a name='L641'></a><a href='#L641'>641</a>
<a name='L642'></a><a href='#L642'>642</a>
<a name='L643'></a><a href='#L643'>643</a>
<a name='L644'></a><a href='#L644'>644</a>
<a name='L645'></a><a href='#L645'>645</a>
<a name='L646'></a><a href='#L646'>646</a>
<a name='L647'></a><a href='#L647'>647</a>
<a name='L648'></a><a href='#L648'>648</a>
<a name='L649'></a><a href='#L649'>649</a>
<a name='L650'></a><a href='#L650'>650</a>
<a name='L651'></a><a href='#L651'>651</a>
<a name='L652'></a><a href='#L652'>652</a>
<a name='L653'></a><a href='#L653'>653</a>
<a name='L654'></a><a href='#L654'>654</a>
<a name='L655'></a><a href='#L655'>655</a>
<a name='L656'></a><a href='#L656'>656</a>
<a name='L657'></a><a href='#L657'>657</a>
<a name='L658'></a><a href='#L658'>658</a>
<a name='L659'></a><a href='#L659'>659</a>
<a name='L660'></a><a href='#L660'>660</a>
<a name='L661'></a><a href='#L661'>661</a>
<a name='L662'></a><a href='#L662'>662</a>
<a name='L663'></a><a href='#L663'>663</a>
<a name='L664'></a><a href='#L664'>664</a>
<a name='L665'></a><a href='#L665'>665</a>
<a name='L666'></a><a href='#L666'>666</a>
<a name='L667'></a><a href='#L667'>667</a>
<a name='L668'></a><a href='#L668'>668</a>
<a name='L669'></a><a href='#L669'>669</a>
<a name='L670'></a><a href='#L670'>670</a>
<a name='L671'></a><a href='#L671'>671</a>
<a name='L672'></a><a href='#L672'>672</a>
<a name='L673'></a><a href='#L673'>673</a>
<a name='L674'></a><a href='#L674'>674</a>
<a name='L675'></a><a href='#L675'>675</a>
<a name='L676'></a><a href='#L676'>676</a>
<a name='L677'></a><a href='#L677'>677</a>
<a name='L678'></a><a href='#L678'>678</a>
<a name='L679'></a><a href='#L679'>679</a>
<a name='L680'></a><a href='#L680'>680</a>
<a name='L681'></a><a href='#L681'>681</a>
<a name='L682'></a><a href='#L682'>682</a>
<a name='L683'></a><a href='#L683'>683</a>
<a name='L684'></a><a href='#L684'>684</a>
<a name='L685'></a><a href='#L685'>685</a>
<a name='L686'></a><a href='#L686'>686</a>
<a name='L687'></a><a href='#L687'>687</a>
<a name='L688'></a><a href='#L688'>688</a>
<a name='L689'></a><a href='#L689'>689</a>
<a name='L690'></a><a href='#L690'>690</a>
<a name='L691'></a><a href='#L691'>691</a>
<a name='L692'></a><a href='#L692'>692</a>
<a name='L693'></a><a href='#L693'>693</a>
<a name='L694'></a><a href='#L694'>694</a>
<a name='L695'></a><a href='#L695'>695</a>
<a name='L696'></a><a href='#L696'>696</a>
<a name='L697'></a><a href='#L697'>697</a>
<a name='L698'></a><a href='#L698'>698</a>
<a name='L699'></a><a href='#L699'>699</a>
<a name='L700'></a><a href='#L700'>700</a>
<a name='L701'></a><a href='#L701'>701</a>
<a name='L702'></a><a href='#L702'>702</a>
<a name='L703'></a><a href='#L703'>703</a>
<a name='L704'></a><a href='#L704'>704</a>
<a name='L705'></a><a href='#L705'>705</a>
<a name='L706'></a><a href='#L706'>706</a>
<a name='L707'></a><a href='#L707'>707</a>
<a name='L708'></a><a href='#L708'>708</a>
<a name='L709'></a><a href='#L709'>709</a>
<a name='L710'></a><a href='#L710'>710</a>
<a name='L711'></a><a href='#L711'>711</a>
<a name='L712'></a><a href='#L712'>712</a>
<a name='L713'></a><a href='#L713'>713</a>
<a name='L714'></a><a href='#L714'>714</a>
<a name='L715'></a><a href='#L715'>715</a>
<a name='L716'></a><a href='#L716'>716</a>
<a name='L717'></a><a href='#L717'>717</a>
<a name='L718'></a><a href='#L718'>718</a>
<a name='L719'></a><a href='#L719'>719</a>
<a name='L720'></a><a href='#L720'>720</a>
<a name='L721'></a><a href='#L721'>721</a>
<a name='L722'></a><a href='#L722'>722</a>
<a name='L723'></a><a href='#L723'>723</a>
<a name='L724'></a><a href='#L724'>724</a>
<a name='L725'></a><a href='#L725'>725</a>
<a name='L726'></a><a href='#L726'>726</a>
<a name='L727'></a><a href='#L727'>727</a>
<a name='L728'></a><a href='#L728'>728</a>
<a name='L729'></a><a href='#L729'>729</a>
<a name='L730'></a><a href='#L730'>730</a>
<a name='L731'></a><a href='#L731'>731</a>
<a name='L732'></a><a href='#L732'>732</a>
<a name='L733'></a><a href='#L733'>733</a>
<a name='L734'></a><a href='#L734'>734</a>
<a name='L735'></a><a href='#L735'>735</a>
<a name='L736'></a><a href='#L736'>736</a>
<a name='L737'></a><a href='#L737'>737</a>
<a name='L738'></a><a href='#L738'>738</a>
<a name='L739'></a><a href='#L739'>739</a>
<a name='L740'></a><a href='#L740'>740</a>
<a name='L741'></a><a href='#L741'>741</a>
<a name='L742'></a><a href='#L742'>742</a>
<a name='L743'></a><a href='#L743'>743</a>
<a name='L744'></a><a href='#L744'>744</a>
<a name='L745'></a><a href='#L745'>745</a>
<a name='L746'></a><a href='#L746'>746</a>
<a name='L747'></a><a href='#L747'>747</a>
<a name='L748'></a><a href='#L748'>748</a>
<a name='L749'></a><a href='#L749'>749</a>
<a name='L750'></a><a href='#L750'>750</a>
<a name='L751'></a><a href='#L751'>751</a>
<a name='L752'></a><a href='#L752'>752</a>
<a name='L753'></a><a href='#L753'>753</a>
<a name='L754'></a><a href='#L754'>754</a>
<a name='L755'></a><a href='#L755'>755</a>
<a name='L756'></a><a href='#L756'>756</a>
<a name='L757'></a><a href='#L757'>757</a>
<a name='L758'></a><a href='#L758'>758</a>
<a name='L759'></a><a href='#L759'>759</a>
<a name='L760'></a><a href='#L760'>760</a>
<a name='L761'></a><a href='#L761'>761</a>
<a name='L762'></a><a href='#L762'>762</a>
<a name='L763'></a><a href='#L763'>763</a>
<a name='L764'></a><a href='#L764'>764</a>
<a name='L765'></a><a href='#L765'>765</a>
<a name='L766'></a><a href='#L766'>766</a>
<a name='L767'></a><a href='#L767'>767</a>
<a name='L768'></a><a href='#L768'>768</a>
<a name='L769'></a><a href='#L769'>769</a>
<a name='L770'></a><a href='#L770'>770</a>
<a name='L771'></a><a href='#L771'>771</a>
<a name='L772'></a><a href='#L772'>772</a>
<a name='L773'></a><a href='#L773'>773</a>
<a name='L774'></a><a href='#L774'>774</a>
<a name='L775'></a><a href='#L775'>775</a>
<a name='L776'></a><a href='#L776'>776</a>
<a name='L777'></a><a href='#L777'>777</a>
<a name='L778'></a><a href='#L778'>778</a>
<a name='L779'></a><a href='#L779'>779</a>
<a name='L780'></a><a href='#L780'>780</a>
<a name='L781'></a><a href='#L781'>781</a>
<a name='L782'></a><a href='#L782'>782</a>
<a name='L783'></a><a href='#L783'>783</a>
<a name='L784'></a><a href='#L784'>784</a>
<a name='L785'></a><a href='#L785'>785</a>
<a name='L786'></a><a href='#L786'>786</a>
<a name='L787'></a><a href='#L787'>787</a>
<a name='L788'></a><a href='#L788'>788</a>
<a name='L789'></a><a href='#L789'>789</a>
<a name='L790'></a><a href='#L790'>790</a>
<a name='L791'></a><a href='#L791'>791</a>
<a name='L792'></a><a href='#L792'>792</a>
<a name='L793'></a><a href='#L793'>793</a>
<a name='L794'></a><a href='#L794'>794</a>
<a name='L795'></a><a href='#L795'>795</a>
<a name='L796'></a><a href='#L796'>796</a>
<a name='L797'></a><a href='#L797'>797</a>
<a name='L798'></a><a href='#L798'>798</a>
<a name='L799'></a><a href='#L799'>799</a>
<a name='L800'></a><a href='#L800'>800</a>
<a name='L801'></a><a href='#L801'>801</a>
<a name='L802'></a><a href='#L802'>802</a>
<a name='L803'></a><a href='#L803'>803</a>
<a name='L804'></a><a href='#L804'>804</a>
<a name='L805'></a><a href='#L805'>805</a>
<a name='L806'></a><a href='#L806'>806</a>
<a name='L807'></a><a href='#L807'>807</a>
<a name='L808'></a><a href='#L808'>808</a>
<a name='L809'></a><a href='#L809'>809</a>
<a name='L810'></a><a href='#L810'>810</a>
<a name='L811'></a><a href='#L811'>811</a>
<a name='L812'></a><a href='#L812'>812</a>
<a name='L813'></a><a href='#L813'>813</a>
<a name='L814'></a><a href='#L814'>814</a>
<a name='L815'></a><a href='#L815'>815</a>
<a name='L816'></a><a href='#L816'>816</a>
<a name='L817'></a><a href='#L817'>817</a>
<a name='L818'></a><a href='#L818'>818</a>
<a name='L819'></a><a href='#L819'>819</a>
<a name='L820'></a><a href='#L820'>820</a>
<a name='L821'></a><a href='#L821'>821</a>
<a name='L822'></a><a href='#L822'>822</a>
<a name='L823'></a><a href='#L823'>823</a>
<a name='L824'></a><a href='#L824'>824</a>
<a name='L825'></a><a href='#L825'>825</a>
<a name='L826'></a><a href='#L826'>826</a>
<a name='L827'></a><a href='#L827'>827</a>
<a name='L828'></a><a href='#L828'>828</a>
<a name='L829'></a><a href='#L829'>829</a>
<a name='L830'></a><a href='#L830'>830</a>
<a name='L831'></a><a href='#L831'>831</a>
<a name='L832'></a><a href='#L832'>832</a>
<a name='L833'></a><a href='#L833'>833</a>
<a name='L834'></a><a href='#L834'>834</a>
<a name='L835'></a><a href='#L835'>835</a>
<a name='L836'></a><a href='#L836'>836</a>
<a name='L837'></a><a href='#L837'>837</a>
<a name='L838'></a><a href='#L838'>838</a>
<a name='L839'></a><a href='#L839'>839</a>
<a name='L840'></a><a href='#L840'>840</a>
<a name='L841'></a><a href='#L841'>841</a>
<a name='L842'></a><a href='#L842'>842</a>
<a name='L843'></a><a href='#L843'>843</a>
<a name='L844'></a><a href='#L844'>844</a>
<a name='L845'></a><a href='#L845'>845</a>
<a name='L846'></a><a href='#L846'>846</a>
<a name='L847'></a><a href='#L847'>847</a>
<a name='L848'></a><a href='#L848'>848</a>
<a name='L849'></a><a href='#L849'>849</a>
<a name='L850'></a><a href='#L850'>850</a>
<a name='L851'></a><a href='#L851'>851</a>
<a name='L852'></a><a href='#L852'>852</a>
<a name='L853'></a><a href='#L853'>853</a>
<a name='L854'></a><a href='#L854'>854</a>
<a name='L855'></a><a href='#L855'>855</a>
<a name='L856'></a><a href='#L856'>856</a>
<a name='L857'></a><a href='#L857'>857</a>
<a name='L858'></a><a href='#L858'>858</a>
<a name='L859'></a><a href='#L859'>859</a>
<a name='L860'></a><a href='#L860'>860</a>
<a name='L861'></a><a href='#L861'>861</a>
<a name='L862'></a><a href='#L862'>862</a>
<a name='L863'></a><a href='#L863'>863</a>
<a name='L864'></a><a href='#L864'>864</a>
<a name='L865'></a><a href='#L865'>865</a>
<a name='L866'></a><a href='#L866'>866</a>
<a name='L867'></a><a href='#L867'>867</a>
<a name='L868'></a><a href='#L868'>868</a>
<a name='L869'></a><a href='#L869'>869</a>
<a name='L870'></a><a href='#L870'>870</a>
<a name='L871'></a><a href='#L871'>871</a>
<a name='L872'></a><a href='#L872'>872</a>
<a name='L873'></a><a href='#L873'>873</a>
<a name='L874'></a><a href='#L874'>874</a>
<a name='L875'></a><a href='#L875'>875</a>
<a name='L876'></a><a href='#L876'>876</a>
<a name='L877'></a><a href='#L877'>877</a>
<a name='L878'></a><a href='#L878'>878</a>
<a name='L879'></a><a href='#L879'>879</a>
<a name='L880'></a><a href='#L880'>880</a>
<a name='L881'></a><a href='#L881'>881</a>
<a name='L882'></a><a href='#L882'>882</a>
<a name='L883'></a><a href='#L883'>883</a>
<a name='L884'></a><a href='#L884'>884</a>
<a name='L885'></a><a href='#L885'>885</a>
<a name='L886'></a><a href='#L886'>886</a>
<a name='L887'></a><a href='#L887'>887</a>
<a name='L888'></a><a href='#L888'>888</a>
<a name='L889'></a><a href='#L889'>889</a>
<a name='L890'></a><a href='#L890'>890</a>
<a name='L891'></a><a href='#L891'>891</a>
<a name='L892'></a><a href='#L892'>892</a>
<a name='L893'></a><a href='#L893'>893</a>
<a name='L894'></a><a href='#L894'>894</a>
<a name='L895'></a><a href='#L895'>895</a>
<a name='L896'></a><a href='#L896'>896</a>
<a name='L897'></a><a href='#L897'>897</a>
<a name='L898'></a><a href='#L898'>898</a>
<a name='L899'></a><a href='#L899'>899</a>
<a name='L900'></a><a href='#L900'>900</a>
<a name='L901'></a><a href='#L901'>901</a>
<a name='L902'></a><a href='#L902'>902</a>
<a name='L903'></a><a href='#L903'>903</a>
<a name='L904'></a><a href='#L904'>904</a>
<a name='L905'></a><a href='#L905'>905</a>
<a name='L906'></a><a href='#L906'>906</a>
<a name='L907'></a><a href='#L907'>907</a>
<a name='L908'></a><a href='#L908'>908</a>
<a name='L909'></a><a href='#L909'>909</a>
<a name='L910'></a><a href='#L910'>910</a>
<a name='L911'></a><a href='#L911'>911</a>
<a name='L912'></a><a href='#L912'>912</a>
<a name='L913'></a><a href='#L913'>913</a>
<a name='L914'></a><a href='#L914'>914</a>
<a name='L915'></a><a href='#L915'>915</a>
<a name='L916'></a><a href='#L916'>916</a>
<a name='L917'></a><a href='#L917'>917</a>
<a name='L918'></a><a href='#L918'>918</a>
<a name='L919'></a><a href='#L919'>919</a>
<a name='L920'></a><a href='#L920'>920</a>
<a name='L921'></a><a href='#L921'>921</a>
<a name='L922'></a><a href='#L922'>922</a>
<a name='L923'></a><a href='#L923'>923</a>
<a name='L924'></a><a href='#L924'>924</a>
<a name='L925'></a><a href='#L925'>925</a>
<a name='L926'></a><a href='#L926'>926</a>
<a name='L927'></a><a href='#L927'>927</a>
<a name='L928'></a><a href='#L928'>928</a>
<a name='L929'></a><a href='#L929'>929</a>
<a name='L930'></a><a href='#L930'>930</a>
<a name='L931'></a><a href='#L931'>931</a>
<a name='L932'></a><a href='#L932'>932</a>
<a name='L933'></a><a href='#L933'>933</a>
<a name='L934'></a><a href='#L934'>934</a>
<a name='L935'></a><a href='#L935'>935</a>
<a name='L936'></a><a href='#L936'>936</a>
<a name='L937'></a><a href='#L937'>937</a>
<a name='L938'></a><a href='#L938'>938</a>
<a name='L939'></a><a href='#L939'>939</a>
<a name='L940'></a><a href='#L940'>940</a>
<a name='L941'></a><a href='#L941'>941</a>
<a name='L942'></a><a href='#L942'>942</a>
<a name='L943'></a><a href='#L943'>943</a>
<a name='L944'></a><a href='#L944'>944</a>
<a name='L945'></a><a href='#L945'>945</a>
<a name='L946'></a><a href='#L946'>946</a>
<a name='L947'></a><a href='#L947'>947</a>
<a name='L948'></a><a href='#L948'>948</a>
<a name='L949'></a><a href='#L949'>949</a>
<a name='L950'></a><a href='#L950'>950</a>
<a name='L951'></a><a href='#L951'>951</a>
<a name='L952'></a><a href='#L952'>952</a>
<a name='L953'></a><a href='#L953'>953</a>
<a name='L954'></a><a href='#L954'>954</a>
<a name='L955'></a><a href='#L955'>955</a>
<a name='L956'></a><a href='#L956'>956</a>
<a name='L957'></a><a href='#L957'>957</a>
<a name='L958'></a><a href='#L958'>958</a>
<a name='L959'></a><a href='#L959'>959</a>
<a name='L960'></a><a href='#L960'>960</a>
<a name='L961'></a><a href='#L961'>961</a>
<a name='L962'></a><a href='#L962'>962</a>
<a name='L963'></a><a href='#L963'>963</a>
<a name='L964'></a><a href='#L964'>964</a>
<a name='L965'></a><a href='#L965'>965</a>
<a name='L966'></a><a href='#L966'>966</a>
<a name='L967'></a><a href='#L967'>967</a>
<a name='L968'></a><a href='#L968'>968</a>
<a name='L969'></a><a href='#L969'>969</a>
<a name='L970'></a><a href='#L970'>970</a>
<a name='L971'></a><a href='#L971'>971</a>
<a name='L972'></a><a href='#L972'>972</a>
<a name='L973'></a><a href='#L973'>973</a>
<a name='L974'></a><a href='#L974'>974</a>
<a name='L975'></a><a href='#L975'>975</a>
<a name='L976'></a><a href='#L976'>976</a>
<a name='L977'></a><a href='#L977'>977</a>
<a name='L978'></a><a href='#L978'>978</a>
<a name='L979'></a><a href='#L979'>979</a>
<a name='L980'></a><a href='#L980'>980</a>
<a name='L981'></a><a href='#L981'>981</a>
<a name='L982'></a><a href='#L982'>982</a>
<a name='L983'></a><a href='#L983'>983</a>
<a name='L984'></a><a href='#L984'>984</a>
<a name='L985'></a><a href='#L985'>985</a>
<a name='L986'></a><a href='#L986'>986</a>
<a name='L987'></a><a href='#L987'>987</a>
<a name='L988'></a><a href='#L988'>988</a>
<a name='L989'></a><a href='#L989'>989</a>
<a name='L990'></a><a href='#L990'>990</a>
<a name='L991'></a><a href='#L991'>991</a>
<a name='L992'></a><a href='#L992'>992</a>
<a name='L993'></a><a href='#L993'>993</a>
<a name='L994'></a><a href='#L994'>994</a>
<a name='L995'></a><a href='#L995'>995</a>
<a name='L996'></a><a href='#L996'>996</a>
<a name='L997'></a><a href='#L997'>997</a>
<a name='L998'></a><a href='#L998'>998</a>
<a name='L999'></a><a href='#L999'>999</a>
<a name='L1000'></a><a href='#L1000'>1000</a>
<a name='L1001'></a><a href='#L1001'>1001</a>
<a name='L1002'></a><a href='#L1002'>1002</a>
<a name='L1003'></a><a href='#L1003'>1003</a>
<a name='L1004'></a><a href='#L1004'>1004</a>
<a name='L1005'></a><a href='#L1005'>1005</a>
<a name='L1006'></a><a href='#L1006'>1006</a>
<a name='L1007'></a><a href='#L1007'>1007</a>
<a name='L1008'></a><a href='#L1008'>1008</a>
<a name='L1009'></a><a href='#L1009'>1009</a>
<a name='L1010'></a><a href='#L1010'>1010</a>
<a name='L1011'></a><a href='#L1011'>1011</a>
<a name='L1012'></a><a href='#L1012'>1012</a>
<a name='L1013'></a><a href='#L1013'>1013</a>
<a name='L1014'></a><a href='#L1014'>1014</a>
<a name='L1015'></a><a href='#L1015'>1015</a>
<a name='L1016'></a><a href='#L1016'>1016</a>
<a name='L1017'></a><a href='#L1017'>1017</a>
<a name='L1018'></a><a href='#L1018'>1018</a>
<a name='L1019'></a><a href='#L1019'>1019</a>
<a name='L1020'></a><a href='#L1020'>1020</a>
<a name='L1021'></a><a href='#L1021'>1021</a>
<a name='L1022'></a><a href='#L1022'>1022</a>
<a name='L1023'></a><a href='#L1023'>1023</a>
<a name='L1024'></a><a href='#L1024'>1024</a>
<a name='L1025'></a><a href='#L1025'>1025</a>
<a name='L1026'></a><a href='#L1026'>1026</a>
<a name='L1027'></a><a href='#L1027'>1027</a>
<a name='L1028'></a><a href='#L1028'>1028</a>
<a name='L1029'></a><a href='#L1029'>1029</a>
<a name='L1030'></a><a href='#L1030'>1030</a>
<a name='L1031'></a><a href='#L1031'>1031</a>
<a name='L1032'></a><a href='#L1032'>1032</a>
<a name='L1033'></a><a href='#L1033'>1033</a>
<a name='L1034'></a><a href='#L1034'>1034</a>
<a name='L1035'></a><a href='#L1035'>1035</a>
<a name='L1036'></a><a href='#L1036'>1036</a>
<a name='L1037'></a><a href='#L1037'>1037</a>
<a name='L1038'></a><a href='#L1038'>1038</a>
<a name='L1039'></a><a href='#L1039'>1039</a>
<a name='L1040'></a><a href='#L1040'>1040</a>
<a name='L1041'></a><a href='#L1041'>1041</a>
<a name='L1042'></a><a href='#L1042'>1042</a>
<a name='L1043'></a><a href='#L1043'>1043</a>
<a name='L1044'></a><a href='#L1044'>1044</a>
<a name='L1045'></a><a href='#L1045'>1045</a>
<a name='L1046'></a><a href='#L1046'>1046</a>
<a name='L1047'></a><a href='#L1047'>1047</a>
<a name='L1048'></a><a href='#L1048'>1048</a>
<a name='L1049'></a><a href='#L1049'>1049</a>
<a name='L1050'></a><a href='#L1050'>1050</a>
<a name='L1051'></a><a href='#L1051'>1051</a>
<a name='L1052'></a><a href='#L1052'>1052</a>
<a name='L1053'></a><a href='#L1053'>1053</a>
<a name='L1054'></a><a href='#L1054'>1054</a>
<a name='L1055'></a><a href='#L1055'>1055</a>
<a name='L1056'></a><a href='#L1056'>1056</a>
<a name='L1057'></a><a href='#L1057'>1057</a>
<a name='L1058'></a><a href='#L1058'>1058</a>
<a name='L1059'></a><a href='#L1059'>1059</a>
<a name='L1060'></a><a href='#L1060'>1060</a>
<a name='L1061'></a><a href='#L1061'>1061</a>
<a name='L1062'></a><a href='#L1062'>1062</a>
<a name='L1063'></a><a href='#L1063'>1063</a>
<a name='L1064'></a><a href='#L1064'>1064</a>
<a name='L1065'></a><a href='#L1065'>1065</a>
<a name='L1066'></a><a href='#L1066'>1066</a>
<a name='L1067'></a><a href='#L1067'>1067</a>
<a name='L1068'></a><a href='#L1068'>1068</a>
<a name='L1069'></a><a href='#L1069'>1069</a>
<a name='L1070'></a><a href='#L1070'>1070</a>
<a name='L1071'></a><a href='#L1071'>1071</a>
<a name='L1072'></a><a href='#L1072'>1072</a>
<a name='L1073'></a><a href='#L1073'>1073</a>
<a name='L1074'></a><a href='#L1074'>1074</a>
<a name='L1075'></a><a href='#L1075'>1075</a>
<a name='L1076'></a><a href='#L1076'>1076</a>
<a name='L1077'></a><a href='#L1077'>1077</a>
<a name='L1078'></a><a href='#L1078'>1078</a>
<a name='L1079'></a><a href='#L1079'>1079</a>
<a name='L1080'></a><a href='#L1080'>1080</a>
<a name='L1081'></a><a href='#L1081'>1081</a>
<a name='L1082'></a><a href='#L1082'>1082</a>
<a name='L1083'></a><a href='#L1083'>1083</a>
<a name='L1084'></a><a href='#L1084'>1084</a>
<a name='L1085'></a><a href='#L1085'>1085</a>
<a name='L1086'></a><a href='#L1086'>1086</a>
<a name='L1087'></a><a href='#L1087'>1087</a>
<a name='L1088'></a><a href='#L1088'>1088</a>
<a name='L1089'></a><a href='#L1089'>1089</a>
<a name='L1090'></a><a href='#L1090'>1090</a>
<a name='L1091'></a><a href='#L1091'>1091</a>
<a name='L1092'></a><a href='#L1092'>1092</a>
<a name='L1093'></a><a href='#L1093'>1093</a>
<a name='L1094'></a><a href='#L1094'>1094</a>
<a name='L1095'></a><a href='#L1095'>1095</a>
<a name='L1096'></a><a href='#L1096'>1096</a>
<a name='L1097'></a><a href='#L1097'>1097</a>
<a name='L1098'></a><a href='#L1098'>1098</a>
<a name='L1099'></a><a href='#L1099'>1099</a>
<a name='L1100'></a><a href='#L1100'>1100</a>
<a name='L1101'></a><a href='#L1101'>1101</a>
<a name='L1102'></a><a href='#L1102'>1102</a>
<a name='L1103'></a><a href='#L1103'>1103</a>
<a name='L1104'></a><a href='#L1104'>1104</a>
<a name='L1105'></a><a href='#L1105'>1105</a>
<a name='L1106'></a><a href='#L1106'>1106</a>
<a name='L1107'></a><a href='#L1107'>1107</a>
<a name='L1108'></a><a href='#L1108'>1108</a>
<a name='L1109'></a><a href='#L1109'>1109</a>
<a name='L1110'></a><a href='#L1110'>1110</a>
<a name='L1111'></a><a href='#L1111'>1111</a>
<a name='L1112'></a><a href='#L1112'>1112</a>
<a name='L1113'></a><a href='#L1113'>1113</a>
<a name='L1114'></a><a href='#L1114'>1114</a>
<a name='L1115'></a><a href='#L1115'>1115</a>
<a name='L1116'></a><a href='#L1116'>1116</a>
<a name='L1117'></a><a href='#L1117'>1117</a>
<a name='L1118'></a><a href='#L1118'>1118</a>
<a name='L1119'></a><a href='#L1119'>1119</a>
<a name='L1120'></a><a href='#L1120'>1120</a>
<a name='L1121'></a><a href='#L1121'>1121</a>
<a name='L1122'></a><a href='#L1122'>1122</a>
<a name='L1123'></a><a href='#L1123'>1123</a>
<a name='L1124'></a><a href='#L1124'>1124</a>
<a name='L1125'></a><a href='#L1125'>1125</a>
<a name='L1126'></a><a href='#L1126'>1126</a>
<a name='L1127'></a><a href='#L1127'>1127</a>
<a name='L1128'></a><a href='#L1128'>1128</a>
<a name='L1129'></a><a href='#L1129'>1129</a>
<a name='L1130'></a><a href='#L1130'>1130</a>
<a name='L1131'></a><a href='#L1131'>1131</a>
<a name='L1132'></a><a href='#L1132'>1132</a>
<a name='L1133'></a><a href='#L1133'>1133</a>
<a name='L1134'></a><a href='#L1134'>1134</a>
<a name='L1135'></a><a href='#L1135'>1135</a>
<a name='L1136'></a><a href='#L1136'>1136</a>
<a name='L1137'></a><a href='#L1137'>1137</a>
<a name='L1138'></a><a href='#L1138'>1138</a>
<a name='L1139'></a><a href='#L1139'>1139</a>
<a name='L1140'></a><a href='#L1140'>1140</a>
<a name='L1141'></a><a href='#L1141'>1141</a>
<a name='L1142'></a><a href='#L1142'>1142</a>
<a name='L1143'></a><a href='#L1143'>1143</a>
<a name='L1144'></a><a href='#L1144'>1144</a>
<a name='L1145'></a><a href='#L1145'>1145</a>
<a name='L1146'></a><a href='#L1146'>1146</a>
<a name='L1147'></a><a href='#L1147'>1147</a>
<a name='L1148'></a><a href='#L1148'>1148</a>
<a name='L1149'></a><a href='#L1149'>1149</a>
<a name='L1150'></a><a href='#L1150'>1150</a>
<a name='L1151'></a><a href='#L1151'>1151</a>
<a name='L1152'></a><a href='#L1152'>1152</a>
<a name='L1153'></a><a href='#L1153'>1153</a>
<a name='L1154'></a><a href='#L1154'>1154</a>
<a name='L1155'></a><a href='#L1155'>1155</a>
<a name='L1156'></a><a href='#L1156'>1156</a>
<a name='L1157'></a><a href='#L1157'>1157</a>
<a name='L1158'></a><a href='#L1158'>1158</a>
<a name='L1159'></a><a href='#L1159'>1159</a>
<a name='L1160'></a><a href='#L1160'>1160</a>
<a name='L1161'></a><a href='#L1161'>1161</a>
<a name='L1162'></a><a href='#L1162'>1162</a>
<a name='L1163'></a><a href='#L1163'>1163</a>
<a name='L1164'></a><a href='#L1164'>1164</a>
<a name='L1165'></a><a href='#L1165'>1165</a>
<a name='L1166'></a><a href='#L1166'>1166</a>
<a name='L1167'></a><a href='#L1167'>1167</a>
<a name='L1168'></a><a href='#L1168'>1168</a>
<a name='L1169'></a><a href='#L1169'>1169</a>
<a name='L1170'></a><a href='#L1170'>1170</a>
<a name='L1171'></a><a href='#L1171'>1171</a>
<a name='L1172'></a><a href='#L1172'>1172</a>
<a name='L1173'></a><a href='#L1173'>1173</a>
<a name='L1174'></a><a href='#L1174'>1174</a>
<a name='L1175'></a><a href='#L1175'>1175</a>
<a name='L1176'></a><a href='#L1176'>1176</a>
<a name='L1177'></a><a href='#L1177'>1177</a>
<a name='L1178'></a><a href='#L1178'>1178</a>
<a name='L1179'></a><a href='#L1179'>1179</a>
<a name='L1180'></a><a href='#L1180'>1180</a>
<a name='L1181'></a><a href='#L1181'>1181</a>
<a name='L1182'></a><a href='#L1182'>1182</a>
<a name='L1183'></a><a href='#L1183'>1183</a>
<a name='L1184'></a><a href='#L1184'>1184</a>
<a name='L1185'></a><a href='#L1185'>1185</a>
<a name='L1186'></a><a href='#L1186'>1186</a>
<a name='L1187'></a><a href='#L1187'>1187</a>
<a name='L1188'></a><a href='#L1188'>1188</a>
<a name='L1189'></a><a href='#L1189'>1189</a>
<a name='L1190'></a><a href='#L1190'>1190</a>
<a name='L1191'></a><a href='#L1191'>1191</a>
<a name='L1192'></a><a href='#L1192'>1192</a>
<a name='L1193'></a><a href='#L1193'>1193</a>
<a name='L1194'></a><a href='#L1194'>1194</a>
<a name='L1195'></a><a href='#L1195'>1195</a>
<a name='L1196'></a><a href='#L1196'>1196</a>
<a name='L1197'></a><a href='#L1197'>1197</a>
<a name='L1198'></a><a href='#L1198'>1198</a>
<a name='L1199'></a><a href='#L1199'>1199</a>
<a name='L1200'></a><a href='#L1200'>1200</a>
<a name='L1201'></a><a href='#L1201'>1201</a>
<a name='L1202'></a><a href='#L1202'>1202</a>
<a name='L1203'></a><a href='#L1203'>1203</a>
<a name='L1204'></a><a href='#L1204'>1204</a>
<a name='L1205'></a><a href='#L1205'>1205</a>
<a name='L1206'></a><a href='#L1206'>1206</a>
<a name='L1207'></a><a href='#L1207'>1207</a>
<a name='L1208'></a><a href='#L1208'>1208</a>
<a name='L1209'></a><a href='#L1209'>1209</a>
<a name='L1210'></a><a href='#L1210'>1210</a>
<a name='L1211'></a><a href='#L1211'>1211</a>
<a name='L1212'></a><a href='#L1212'>1212</a>
<a name='L1213'></a><a href='#L1213'>1213</a>
<a name='L1214'></a><a href='#L1214'>1214</a>
<a name='L1215'></a><a href='#L1215'>1215</a>
<a name='L1216'></a><a href='#L1216'>1216</a>
<a name='L1217'></a><a href='#L1217'>1217</a>
<a name='L1218'></a><a href='#L1218'>1218</a>
<a name='L1219'></a><a href='#L1219'>1219</a>
<a name='L1220'></a><a href='#L1220'>1220</a>
<a name='L1221'></a><a href='#L1221'>1221</a>
<a name='L1222'></a><a href='#L1222'>1222</a>
<a name='L1223'></a><a href='#L1223'>1223</a>
<a name='L1224'></a><a href='#L1224'>1224</a>
<a name='L1225'></a><a href='#L1225'>1225</a>
<a name='L1226'></a><a href='#L1226'>1226</a>
<a name='L1227'></a><a href='#L1227'>1227</a>
<a name='L1228'></a><a href='#L1228'>1228</a>
<a name='L1229'></a><a href='#L1229'>1229</a>
<a name='L1230'></a><a href='#L1230'>1230</a>
<a name='L1231'></a><a href='#L1231'>1231</a>
<a name='L1232'></a><a href='#L1232'>1232</a>
<a name='L1233'></a><a href='#L1233'>1233</a>
<a name='L1234'></a><a href='#L1234'>1234</a>
<a name='L1235'></a><a href='#L1235'>1235</a>
<a name='L1236'></a><a href='#L1236'>1236</a>
<a name='L1237'></a><a href='#L1237'>1237</a>
<a name='L1238'></a><a href='#L1238'>1238</a>
<a name='L1239'></a><a href='#L1239'>1239</a>
<a name='L1240'></a><a href='#L1240'>1240</a>
<a name='L1241'></a><a href='#L1241'>1241</a>
<a name='L1242'></a><a href='#L1242'>1242</a>
<a name='L1243'></a><a href='#L1243'>1243</a>
<a name='L1244'></a><a href='#L1244'>1244</a>
<a name='L1245'></a><a href='#L1245'>1245</a>
<a name='L1246'></a><a href='#L1246'>1246</a>
<a name='L1247'></a><a href='#L1247'>1247</a>
<a name='L1248'></a><a href='#L1248'>1248</a>
<a name='L1249'></a><a href='#L1249'>1249</a>
<a name='L1250'></a><a href='#L1250'>1250</a>
<a name='L1251'></a><a href='#L1251'>1251</a>
<a name='L1252'></a><a href='#L1252'>1252</a>
<a name='L1253'></a><a href='#L1253'>1253</a>
<a name='L1254'></a><a href='#L1254'>1254</a>
<a name='L1255'></a><a href='#L1255'>1255</a>
<a name='L1256'></a><a href='#L1256'>1256</a>
<a name='L1257'></a><a href='#L1257'>1257</a>
<a name='L1258'></a><a href='#L1258'>1258</a>
<a name='L1259'></a><a href='#L1259'>1259</a>
<a name='L1260'></a><a href='#L1260'>1260</a>
<a name='L1261'></a><a href='#L1261'>1261</a>
<a name='L1262'></a><a href='#L1262'>1262</a>
<a name='L1263'></a><a href='#L1263'>1263</a>
<a name='L1264'></a><a href='#L1264'>1264</a>
<a name='L1265'></a><a href='#L1265'>1265</a>
<a name='L1266'></a><a href='#L1266'>1266</a>
<a name='L1267'></a><a href='#L1267'>1267</a>
<a name='L1268'></a><a href='#L1268'>1268</a>
<a name='L1269'></a><a href='#L1269'>1269</a>
<a name='L1270'></a><a href='#L1270'>1270</a>
<a name='L1271'></a><a href='#L1271'>1271</a>
<a name='L1272'></a><a href='#L1272'>1272</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">const allDescriptors=<span class="cstat-no" title="statement not covered" >[];</span>let applicationDescriptor;const _loadedScripts=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const k of[]){}</span>
<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){const baseUrl=<span class="cstat-no" title="statement not covered" >self.location?self.location.origin+self.location.pathname:'';<span class="cstat-no" title="statement not covered" ></span>self._importScriptPathPrefix=baseUrl.substring(0,baseUrl.lastIndexOf('/')+1);}</span>)();c</span>onst REMOTE_MODULE_FALLBACK_REVISION=<span class="cstat-no" title="statement not covered" >'@010ddcfda246975d194964ccf20038ebbdec6084';</span>var Runtime=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(descriptors){<span class="cstat-no" title="statement not covered" >this._modules=[];<span class="cstat-no" title="statement not covered" >t</span>his._modulesMap={};<span class="cstat-no" title="statement not covered" >t</span>his._extensions=[];<span class="cstat-no" title="statement not covered" >t</span>his._cachedTypeClasses={};<span class="cstat-no" title="statement not covered" >t</span>his._descriptorsMap={};<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;descriptors.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this._registerModule(descriptors[i]);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic loadResourcePromise(url){<span class="cstat-no" title="statement not covered" >return new Promise(load);f</span>unction <span class="fstat-no" title="function not covered" >load(</span>fulfill,reject){const xhr=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest();<span class="cstat-no" title="statement not covered" ></span>xhr.open('GET',url,true);<span class="cstat-no" title="statement not covered" >x</span>hr.onreadystatechange=onreadystatechange;f</span>unction <span class="fstat-no" title="function not covered" >onreadystatechange(</span>e){<span class="cstat-no" title="statement not covered" >if(xhr.readyState!==XMLHttpRequest.DONE)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst status=<span class="cstat-no" title="statement not covered" >/^HTTP\/1.1 404/.test(e.target.response)?404:xhr.status;<span class="cstat-no" title="statement not covered" ></span>if([0,200,304].indexOf(status)===-1)</span>
<span class="cstat-no" title="statement not covered" >reject(new Error('While loading from url '+url+' server responded with a status of '+status));e</span>lse
<span class="cstat-no" title="statement not covered" >fulfill(e.target.response);}</span>
<span class="cstat-no" title="statement not covered" >xhr.send(null);}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic loadResourcePromiseWithFallback(url){<span class="cstat-no" title="statement not covered" >return Runtime.loadResourcePromise(url).catch(<span class="fstat-no" title="function not covered" >er</span>r=&gt;{const urlWithFallbackVersion=<span class="cstat-no" title="statement not covered" >url.replace(/@[0-9a-f]{40}/,REMOTE_MODULE_FALLBACK_REVISION);<span class="cstat-no" title="statement not covered" ></span>if(urlWithFallbackVersion===url||!url.includes('audits2_worker_module'))</span></span>
<span class="cstat-no" title="statement not covered" >throw err;<span class="cstat-no" title="statement not covered" >r</span>eturn Runtime.loadResourcePromise(urlWithFallbackVersion);}</span>);}
<span class="fstat-no" title="function not covered" >st</span>atic normalizePath(path){<span class="cstat-no" title="statement not covered" >if(path.indexOf('..')===-1&amp;&amp;path.indexOf('.')===-1)</span>
<span class="cstat-no" title="statement not covered" >return path;c</span>onst normalizedSegments=<span class="cstat-no" title="statement not covered" >[];</span>const segments=<span class="cstat-no" title="statement not covered" >path.split('/');<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;segments.length;i++){const segment=<span class="cstat-no" title="statement not covered" >segments[i];<span class="cstat-no" title="statement not covered" ></span>if(segment==='.')</span></span>
<span class="cstat-no" title="statement not covered" >continue;e</span>lse <span class="cstat-no" title="statement not covered" >if(segment==='..')</span>
<span class="cstat-no" title="statement not covered" >normalizedSegments.pop();e</span>lse <span class="cstat-no" title="statement not covered" >if(segment)</span>
<span class="cstat-no" title="statement not covered" >normalizedSegments.push(segment);}</span>
let normalizedPath=<span class="cstat-no" title="statement not covered" >normalizedSegments.join('/');<span class="cstat-no" title="statement not covered" ></span>if(normalizedPath[normalizedPath.length-1]==='/')</span>
<span class="cstat-no" title="statement not covered" >return normalizedPath;<span class="cstat-no" title="statement not covered" >i</span>f(path[0]==='/'&amp;&amp;normalizedPath)</span>
<span class="cstat-no" title="statement not covered" >normalizedPath='/'+normalizedPath;<span class="cstat-no" title="statement not covered" >i</span>f((path[path.length-1]==='/')||(segments[segments.length-1]==='.')||(segments[segments.length-1]==='..'))</span>
<span class="cstat-no" title="statement not covered" >normalizedPath=normalizedPath+'/';<span class="cstat-no" title="statement not covered" >r</span>eturn normalizedPath;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _loadScriptsPromise(scriptNames,base){const promises=<span class="cstat-no" title="statement not covered" >[];</span>const urls=<span class="cstat-no" title="statement not covered" >[];</span>const sources=<span class="cstat-no" title="statement not covered" >new Array(scriptNames.length);</span>let scriptToEval=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;scriptNames.length;++i){const scriptName=<span class="cstat-no" title="statement not covered" >scriptNames[i];</span>let sourceURL=<span class="cstat-no" title="statement not covered" >(base||self._importScriptPathPrefix)+scriptName;</span>const schemaIndex=<span class="cstat-no" title="statement not covered" >sourceURL.indexOf('://')+3;</span>let pathIndex=<span class="cstat-no" title="statement not covered" >sourceURL.indexOf('/',schemaIndex);<span class="cstat-no" title="statement not covered" ></span>if(pathIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >pathIndex=sourceURL.length;<span class="cstat-no" title="statement not covered" >s</span>ourceURL=sourceURL.substring(0,pathIndex)+Runtime.normalizePath(sourceURL.substring(pathIndex));<span class="cstat-no" title="statement not covered" >i</span>f(_loadedScripts[sourceURL])</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >u</span>rls.push(sourceURL);c</span>onst loadResourcePromise=<span class="cstat-no" title="statement not covered" >base?Runtime.loadResourcePromiseWithFallback(sourceURL):Runtime.loadResourcePromise(sourceURL);<span class="cstat-no" title="statement not covered" ></span>promises.push(loadResourcePromise.then(scriptSourceLoaded.bind(null,i),scriptSourceLoaded.bind(null,i,undefined)));}</span>
<span class="cstat-no" title="statement not covered" >return Promise.all(promises).then(undefined);f</span>unction <span class="fstat-no" title="function not covered" >scriptSourceLoaded(</span>scriptNumber,scriptSource){<span class="cstat-no" title="statement not covered" >sources[scriptNumber]=scriptSource||'';<span class="cstat-no" title="statement not covered" >w</span>hile(typeof sources[scriptToEval]!=='undefined'){<span class="cstat-no" title="statement not covered" >evaluateScript(urls[scriptToEval],sources[scriptToEval]);<span class="cstat-no" title="statement not covered" >+</span>+scriptToEval;}</span>}</span>
function <span class="fstat-no" title="function not covered" >evaluateScript(</span>sourceURL,scriptSource){<span class="cstat-no" title="statement not covered" >_loadedScripts[sourceURL]=true;<span class="cstat-no" title="statement not covered" >i</span>f(!scriptSource){<span class="cstat-no" title="statement not covered" >console.error('Empty response arrived for script \''+sourceURL+'\'');<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >self.eval(scriptSource+'\n//# sourceURL='+sourceURL);}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic _loadResourceIntoCache(url,appendSourceURL){<span class="cstat-no" title="statement not covered" >return Runtime.loadResourcePromise(url).then(cacheResource.bind(this,url),cacheResource.bind(this,url,undefined));f</span>unction <span class="fstat-no" title="function not covered" >cacheResource(</span>path,content){<span class="cstat-no" title="statement not covered" >if(!content){<span class="cstat-no" title="statement not covered" >console.error('Failed to load resource: '+path);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const sourceURL=<span class="cstat-no" title="statement not covered" >appendSourceURL?Runtime.resolveSourceURL(path):'';<span class="cstat-no" title="statement not covered" ></span>Runtime.cachedResources[path]=content+sourceURL;}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic async appStarted(){<span class="cstat-no" title="statement not covered" >return Runtime._appStartedPromise;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic async startApplication(appName){<span class="cstat-no" title="statement not covered" >console.timeStamp('Runtime.startApplication');c</span>onst allDescriptorsByName=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;allDescriptors.length;++i){const d=<span class="cstat-no" title="statement not covered" >allDescriptors[i];<span class="cstat-no" title="statement not covered" ></span>allDescriptorsByName[d['name']]=d;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!applicationDescriptor){let data=<span class="cstat-no" title="statement not covered" >await Runtime.loadResourcePromise(appName+'.json');<span class="cstat-no" title="statement not covered" ></span>applicationDescriptor=JSON.parse(data);l</span>et descriptor=<span class="cstat-no" title="statement not covered" >applicationDescriptor;<span class="cstat-no" title="statement not covered" ></span>while(descriptor.extends){<span class="cstat-no" title="statement not covered" >data=await Runtime.loadResourcePromise(descriptor.extends+'.json');<span class="cstat-no" title="statement not covered" >d</span>escriptor=JSON.parse(data);<span class="cstat-no" title="statement not covered" >a</span>pplicationDescriptor.modules=descriptor.modules.concat(applicationDescriptor.modules);}</span>}</span></span>
const configuration=<span class="cstat-no" title="statement not covered" >applicationDescriptor.modules;</span>const moduleJSONPromises=<span class="cstat-no" title="statement not covered" >[];</span>const coreModuleNames=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;configuration.length;++i){const descriptor=<span class="cstat-no" title="statement not covered" >configuration[i];</span>const name=<span class="cstat-no" title="statement not covered" >descriptor['name'];</span>const moduleJSON=<span class="cstat-no" title="statement not covered" >allDescriptorsByName[name];<span class="cstat-no" title="statement not covered" ></span>if(moduleJSON)</span></span>
<span class="cstat-no" title="statement not covered" >moduleJSONPromises.push(Promise.resolve(moduleJSON));e</span>lse
<span class="cstat-no" title="statement not covered" >moduleJSONPromises.push(Runtime.loadResourcePromise(name+'/module.json').then(JSON.parse.bind(JSON)));<span class="cstat-no" title="statement not covered" >i</span>f(descriptor['type']==='autostart')</span>
<span class="cstat-no" title="statement not covered" >coreModuleNames.push(name);}</span>
const moduleDescriptors=<span class="cstat-no" title="statement not covered" >await Promise.all(moduleJSONPromises);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;moduleDescriptors.length;++i){<span class="cstat-no" title="statement not covered" >moduleDescriptors[i].name=configuration[i]['name'];<span class="cstat-no" title="statement not covered" >m</span>oduleDescriptors[i].condition=configuration[i]['condition'];<span class="cstat-no" title="statement not covered" >m</span>oduleDescriptors[i].remote=configuration[i]['type']==='remote';}</span></span>
<span class="cstat-no" title="statement not covered" >self.runtime=new Runtime(moduleDescriptors);<span class="cstat-no" title="statement not covered" >i</span>f(coreModuleNames)</span>
<span class="cstat-no" title="statement not covered" >await self.runtime._loadAutoStartModules(coreModuleNames);<span class="cstat-no" title="statement not covered" >R</span>untime._appStartedPromiseCallback();}</span>
<span class="fstat-no" title="function not covered" >st</span>atic startWorker(appName){<span class="cstat-no" title="statement not covered" >return Runtime.startApplication(appName).then(sendWorkerReady);f</span>unction <span class="fstat-no" title="function not covered" >sendWorkerReady(</span>){<span class="cstat-no" title="statement not covered" >self.postMessage('workerReady');}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic queryParam(name){<span class="cstat-no" title="statement not covered" >return Runtime._queryParamsObject.get(name);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic queryParamsString(){<span class="cstat-no" title="statement not covered" >return location.search;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _experimentsSetting(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return(JSON.parse(self.localStorage&amp;&amp;self.localStorage['experiments']?self.localStorage['experiments']:'{}'));}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.error('Failed to parse localStorage[\'experiments\']');<span class="cstat-no" title="statement not covered" >r</span>eturn{};}</span>}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _assert(value,message){<span class="cstat-no" title="statement not covered" >if(value)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >R</span>untime._originalAssert.call(Runtime._console,value,message+' '+new Error().stack);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic setPlatform(platform){<span class="cstat-no" title="statement not covered" >Runtime._platform=platform;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _isDescriptorEnabled(descriptor){const activatorExperiment=<span class="cstat-no" title="statement not covered" >descriptor['experiment'];<span class="cstat-no" title="statement not covered" ></span>if(activatorExperiment==='*')</span>
<span class="cstat-no" title="statement not covered" >return Runtime.experiments.supportEnabled();<span class="cstat-no" title="statement not covered" >i</span>f(activatorExperiment&amp;&amp;activatorExperiment.startsWith('!')&amp;&amp;Runtime.experiments.isEnabled(activatorExperiment.substring(1)))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(activatorExperiment&amp;&amp;!activatorExperiment.startsWith('!')&amp;&amp;!Runtime.experiments.isEnabled(activatorExperiment))</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst condition=<span class="cstat-no" title="statement not covered" >descriptor['condition'];<span class="cstat-no" title="statement not covered" ></span>if(condition&amp;&amp;!condition.startsWith('!')&amp;&amp;!Runtime.queryParam(condition))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(condition&amp;&amp;condition.startsWith('!')&amp;&amp;Runtime.queryParam(condition.substring(1)))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic resolveSourceURL(path){let sourceURL=<span class="cstat-no" title="statement not covered" >self.location.href;<span class="cstat-no" title="statement not covered" ></span>if(self.location.search)</span>
<span class="cstat-no" title="statement not covered" >sourceURL=sourceURL.replace(self.location.search,'');<span class="cstat-no" title="statement not covered" >s</span>ourceURL=sourceURL.substring(0,sourceURL.lastIndexOf('/')+1)+path;<span class="cstat-no" title="statement not covered" >r</span>eturn'\n/*# sourceURL='+sourceURL+' */';}</span>
<span class="fstat-no" title="function not covered" >us</span>eTestBase(){<span class="cstat-no" title="statement not covered" >Runtime._remoteBase='http://localhost:8000/inspector-sources/';<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.queryParam('debugFrontend'))</span>
<span class="cstat-no" title="statement not covered" >Runtime._remoteBase+='debug/';}</span>
<span class="fstat-no" title="function not covered" >_r</span>egisterModule(descriptor){const module=<span class="cstat-no" title="statement not covered" >new Runtime.Module(this,descriptor);<span class="cstat-no" title="statement not covered" ></span>this._modules.push(module);<span class="cstat-no" title="statement not covered" >t</span>his._modulesMap[descriptor['name']]=module;}</span>
<span class="fstat-no" title="function not covered" >lo</span>adModulePromise(moduleName){<span class="cstat-no" title="statement not covered" >return this._modulesMap[moduleName]._loadPromise();}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadAutoStartModules(moduleNames){const promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;moduleNames.length;++i)</span>
<span class="cstat-no" title="statement not covered" >promises.push(this.loadModulePromise(moduleNames[i]));<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.all(promises);}</span>
<span class="fstat-no" title="function not covered" >_c</span>heckExtensionApplicability(extension,predicate){<span class="cstat-no" title="statement not covered" >if(!predicate)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst contextTypes=<span class="cstat-no" title="statement not covered" >extension.descriptor().contextTypes;<span class="cstat-no" title="statement not covered" ></span>if(!contextTypes)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;contextTypes.length;++i){const contextType=<span class="cstat-no" title="statement not covered" >this._resolve(contextTypes[i]);</span>const isMatching=<span class="cstat-no" title="statement not covered" >!!contextType&amp;&amp;predicate(contextType);<span class="cstat-no" title="statement not covered" ></span>if(isMatching)</span></span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >is</span>ExtensionApplicableToContext(extension,context){<span class="cstat-no" title="statement not covered" >if(!context)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span>eturn this._checkExtensionApplicability(extension,isInstanceOf);f</span>unction <span class="fstat-no" title="function not covered" >isInstanceOf(</span>targetType){<span class="cstat-no" title="statement not covered" >return context instanceof targetType;}</span>}
<span class="fstat-no" title="function not covered" >is</span>ExtensionApplicableToContextTypes(extension,currentContextTypes){<span class="cstat-no" title="statement not covered" >if(!extension.descriptor().contextTypes)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span>eturn this._checkExtensionApplicability(extension,currentContextTypes?isContextTypeKnown:null);f</span>unction <span class="fstat-no" title="function not covered" >isContextTypeKnown(</span>targetType){<span class="cstat-no" title="statement not covered" >return currentContextTypes.has(targetType);}</span>}
<span class="fstat-no" title="function not covered" >ex</span>tensions(type,context,sortByTitle){<span class="cstat-no" title="statement not covered" >return this._extensions.filter(filter).sort(sortByTitle?titleComparator:orderComparator);f</span>unction <span class="fstat-no" title="function not covered" >filter(</span>extension){<span class="cstat-no" title="statement not covered" >if(extension._type!==type&amp;&amp;extension._typeClass()!==type)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(!extension.enabled())</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn!context||extension.isApplicable(context);}</span>
function <span class="fstat-no" title="function not covered" >orderComparator(</span>extension1,extension2){const order1=<span class="cstat-no" title="statement not covered" >extension1.descriptor()['order']||0;</span>const order2=<span class="cstat-no" title="statement not covered" >extension2.descriptor()['order']||0;<span class="cstat-no" title="statement not covered" ></span>return order1-order2;}</span>
function <span class="fstat-no" title="function not covered" >titleComparator(</span>extension1,extension2){const title1=<span class="cstat-no" title="statement not covered" >extension1.title()||'';</span>const title2=<span class="cstat-no" title="statement not covered" >extension2.title()||'';<span class="cstat-no" title="statement not covered" ></span>return title1.localeCompare(title2);}</span>}
<span class="fstat-no" title="function not covered" >ex</span>tension(type,context){<span class="cstat-no" title="statement not covered" >return this.extensions(type,context)[0]||null;}</span>
<span class="fstat-no" title="function not covered" >al</span>lInstances(type,context){<span class="cstat-no" title="statement not covered" >return Promise.all(this.extensions(type,context).map(<span class="fstat-no" title="function not covered" >ex</span>tension=&gt;<span class="cstat-no" title="statement not covered" >extension.instance())</span>);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esolve(typeName){<span class="cstat-no" title="statement not covered" >if(!this._cachedTypeClasses[typeName]){const path=<span class="cstat-no" title="statement not covered" >typeName.split('.');</span>let object=<span class="cstat-no" title="statement not covered" >self;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;object&amp;&amp;(i&lt;path.length);++i)</span></span>
<span class="cstat-no" title="statement not covered" >object=object[path[i]];<span class="cstat-no" title="statement not covered" >i</span>f(object)</span>
<span class="cstat-no" title="statement not covered" >this._cachedTypeClasses[typeName]=(object);}</span>
<span class="cstat-no" title="statement not covered" >return this._cachedTypeClasses[typeName]||null;}</span>
<span class="fstat-no" title="function not covered" >sh</span>aredInstance(constructorFunction){<span class="cstat-no" title="statement not covered" >if(Runtime._instanceSymbol in constructorFunction&amp;&amp;Object.getOwnPropertySymbols(constructorFunction).includes(Runtime._instanceSymbol))</span>
<span class="cstat-no" title="statement not covered" >return constructorFunction[Runtime._instanceSymbol];c</span>onst instance=<span class="cstat-no" title="statement not covered" >new constructorFunction();<span class="cstat-no" title="statement not covered" ></span>constructorFunction[Runtime._instanceSymbol]=instance;<span class="cstat-no" title="statement not covered" >r</span>eturn instance;}</span>};<span class="cstat-no" title="statement not covered" >Runtime._queryParamsObject=new URLSearchParams(Runtime.queryParamsString());<span class="cstat-no" title="statement not covered" >R</span>untime._instanceSymbol=Symbol('instance');<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources={__proto__:null};<span class="cstat-no" title="statement not covered" >R</span>untime._console=console;<span class="cstat-no" title="statement not covered" >R</span>untime._originalAssert=console.assert;<span class="cstat-no" title="statement not covered" >R</span>untime._platform='';<span class="cstat-no" title="statement not covered" >R</span>untime.ModuleDescriptor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.name;<span class="cstat-no" title="statement not covered" >t</span>his.extensions;<span class="cstat-no" title="statement not covered" >t</span>his.dependencies;<span class="cstat-no" title="statement not covered" >t</span>his.scripts;<span class="cstat-no" title="statement not covered" >t</span>his.condition;<span class="cstat-no" title="statement not covered" >t</span>his.remote;}</span>};<span class="cstat-no" title="statement not covered" >R</span>untime.ExtensionDescriptor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.type;<span class="cstat-no" title="statement not covered" >t</span>his.className;<span class="cstat-no" title="statement not covered" >t</span>his.factoryName;<span class="cstat-no" title="statement not covered" >t</span>his.contextTypes;}</span>};<span class="cstat-no" title="statement not covered" >R</span>untime.Module=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(manager,descriptor){<span class="cstat-no" title="statement not covered" >this._manager=manager;<span class="cstat-no" title="statement not covered" >t</span>his._descriptor=descriptor;<span class="cstat-no" title="statement not covered" >t</span>his._name=descriptor.name;<span class="cstat-no" title="statement not covered" >t</span>his._extensions=[];<span class="cstat-no" title="statement not covered" >t</span>his._extensionsByClassName=new Map();c</span>onst extensions=(<span class="cstat-no" title="statement not covered" >descriptor.extensions)</span>;<span class="cstat-no" title="statement not covered" >for(let i=0;extensions&amp;&amp;i&lt;extensions.length;++i){const extension=<span class="cstat-no" title="statement not covered" >new Runtime.Extension(this,extensions[i]);<span class="cstat-no" title="statement not covered" ></span>this._manager._extensions.push(extension);<span class="cstat-no" title="statement not covered" >t</span>his._extensions.push(extension);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._loadedForTest=false;}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >en</span>abled(){<span class="cstat-no" title="statement not covered" >return Runtime._isDescriptorEnabled(this._descriptor);}</span>
<span class="fstat-no" title="function not covered" >re</span>source(name){const fullName=<span class="cstat-no" title="statement not covered" >this._name+'/'+name;</span>const content=<span class="cstat-no" title="statement not covered" >Runtime.cachedResources[fullName];<span class="cstat-no" title="statement not covered" ></span>if(!content)</span>
<span class="cstat-no" title="statement not covered" >throw new Error(fullName+' not preloaded. Check module.json');<span class="cstat-no" title="statement not covered" >r</span>eturn content;}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadPromise(){<span class="cstat-no" title="statement not covered" >if(!this.enabled())</span>
<span class="cstat-no" title="statement not covered" >return Promise.reject(new Error('Module '+this._name+' is not enabled'));<span class="cstat-no" title="statement not covered" >i</span>f(this._pendingLoadPromise)</span>
<span class="cstat-no" title="statement not covered" >return this._pendingLoadPromise;c</span>onst dependencies=<span class="cstat-no" title="statement not covered" >this._descriptor.dependencies;</span>const dependencyPromises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;dependencies&amp;&amp;i&lt;dependencies.length;++i)</span>
<span class="cstat-no" title="statement not covered" >dependencyPromises.push(this._manager._modulesMap[dependencies[i]]._loadPromise());<span class="cstat-no" title="statement not covered" >t</span>his._pendingLoadPromise=Promise.all(dependencyPromises).then(this._loadResources.bind(this)).then(this._loadScripts.bind(this)).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._loadedForTest=true)</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this._pendingLoadPromise;}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadResources(){const resources=<span class="cstat-no" title="statement not covered" >this._descriptor['resources'];<span class="cstat-no" title="statement not covered" ></span>if(!resources||!resources.length)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();c</span>onst promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;resources.length;++i){const url=<span class="cstat-no" title="statement not covered" >this._modularizeURL(resources[i]);<span class="cstat-no" title="statement not covered" ></span>promises.push(Runtime._loadResourceIntoCache(url,true));}</span></span>
<span class="cstat-no" title="statement not covered" >return Promise.all(promises).then(undefined);}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadScripts(){<span class="cstat-no" title="statement not covered" >if(!this._descriptor.scripts||!this._descriptor.scripts.length)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();c</span>onst specialCases=<span class="cstat-no" title="statement not covered" >{'sdk':'SDK','js_sdk':'JSSDK','browser_sdk':'BrowserSDK','ui':'UI','object_ui':'ObjectUI','javascript_metadata':'JavaScriptMetadata','perf_ui':'PerfUI','har_importer':'HARImporter','sdk_test_runner':'SDKTestRunner','cpu_profiler_test_runner':'CPUProfilerTestRunner'};</span>const namespace=<span class="cstat-no" title="statement not covered" >specialCases[this._name]||this._name.split('_').map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a.substring(0,1).toUpperCase()+a.substring(1))</span>.join('');<span class="cstat-no" title="statement not covered" ></span>self[namespace]=self[namespace]||{};<span class="cstat-no" title="statement not covered" >r</span>eturn Runtime._loadScriptsPromise(this._descriptor.scripts.map(this._modularizeURL,this),this._remoteBase());}</span>
<span class="fstat-no" title="function not covered" >_m</span>odularizeURL(resourceName){<span class="cstat-no" title="statement not covered" >return Runtime.normalizePath(this._name+'/'+resourceName);}</span>
<span class="fstat-no" title="function not covered" >_r</span>emoteBase(){<span class="cstat-no" title="statement not covered" >return!Runtime.queryParam('debugFrontend')&amp;&amp;this._descriptor.remote&amp;&amp;Runtime._remoteBase||undefined;}</span>
<span class="fstat-no" title="function not covered" >su</span>bstituteURL(value){const base=<span class="cstat-no" title="statement not covered" >this._remoteBase()||'';<span class="cstat-no" title="statement not covered" ></span>return value.replace(/@url\(([^\)]*?)\)/g,convertURL.bind(this));f</span>unction <span class="fstat-no" title="function not covered" >convertURL(</span>match,url){<span class="cstat-no" title="statement not covered" >return base+this._modularizeURL(url);}</span>}};<span class="cstat-no" title="statement not covered" >Runtime.Extension=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(module,descriptor){<span class="cstat-no" title="statement not covered" >this._module=module;<span class="cstat-no" title="statement not covered" >t</span>his._descriptor=descriptor;<span class="cstat-no" title="statement not covered" >t</span>his._type=descriptor.type;<span class="cstat-no" title="statement not covered" >t</span>his._hasTypeClass=this._type.charAt(0)==='@';<span class="cstat-no" title="statement not covered" >t</span>his._className=descriptor.className||null;<span class="cstat-no" title="statement not covered" >t</span>his._factoryName=descriptor.factoryName||null;}</span></span>
<span class="fstat-no" title="function not covered" >de</span>scriptor(){<span class="cstat-no" title="statement not covered" >return this._descriptor;}</span>
<span class="fstat-no" title="function not covered" >mo</span>dule(){<span class="cstat-no" title="statement not covered" >return this._module;}</span>
<span class="fstat-no" title="function not covered" >en</span>abled(){<span class="cstat-no" title="statement not covered" >return this._module.enabled()&amp;&amp;Runtime._isDescriptorEnabled(this.descriptor());}</span>
<span class="fstat-no" title="function not covered" >_t</span>ypeClass(){<span class="cstat-no" title="statement not covered" >if(!this._hasTypeClass)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this._module._manager._resolve(this._type.substring(1));}</span>
<span class="fstat-no" title="function not covered" >is</span>Applicable(context){<span class="cstat-no" title="statement not covered" >return this._module._manager.isExtensionApplicableToContext(this,context);}</span>
<span class="fstat-no" title="function not covered" >in</span>stance(){<span class="cstat-no" title="statement not covered" >return this._module._loadPromise().then(this._createInstance.bind(this));}</span>
<span class="fstat-no" title="function not covered" >ca</span>nInstantiate(){<span class="cstat-no" title="statement not covered" >return!!(this._className||this._factoryName);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateInstance(){const className=<span class="cstat-no" title="statement not covered" >this._className||this._factoryName;<span class="cstat-no" title="statement not covered" ></span>if(!className)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Could not instantiate extension with no class');c</span>onst constructorFunction=<span class="cstat-no" title="statement not covered" >self.eval((className));<span class="cstat-no" title="statement not covered" ></span>if(!(constructorFunction instanceof Function))</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Could not instantiate: '+className);<span class="cstat-no" title="statement not covered" >i</span>f(this._className)</span>
<span class="cstat-no" title="statement not covered" >return this._module._manager.sharedInstance(constructorFunction);<span class="cstat-no" title="statement not covered" >r</span>eturn new constructorFunction(this);}</span>
<span class="fstat-no" title="function not covered" >ti</span>tle(){<span class="cstat-no" title="statement not covered" >return this._descriptor['title-'+Runtime._platform]||this._descriptor['title'];}</span>
<span class="fstat-no" title="function not covered" >ha</span>sContextType(contextType){const contextTypes=<span class="cstat-no" title="statement not covered" >this.descriptor().contextTypes;<span class="cstat-no" title="statement not covered" ></span>if(!contextTypes)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;contextTypes.length;++i){<span class="cstat-no" title="statement not covered" >if(contextType===this._module._manager._resolve(contextTypes[i]))</span></span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>};<span class="cstat-no" title="statement not covered" >Runtime.ExperimentsSupport=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._supportEnabled=Runtime.queryParam('experiments')!==null;<span class="cstat-no" title="statement not covered" >t</span>his._experiments=[];<span class="cstat-no" title="statement not covered" >t</span>his._experimentNames={};<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently={};}</span></span>
<span class="fstat-no" title="function not covered" >al</span>lConfigurableExperiments(){const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._experiments.length;i++){const experiment=<span class="cstat-no" title="statement not covered" >this._experiments[i];<span class="cstat-no" title="statement not covered" ></span>if(!this._enabledTransiently[experiment.name])</span></span>
<span class="cstat-no" title="statement not covered" >result.push(experiment);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportEnabled(){<span class="cstat-no" title="statement not covered" >return this._supportEnabled;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etExperimentsSetting(value){<span class="cstat-no" title="statement not covered" >if(!self.localStorage)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span>elf.localStorage['experiments']=JSON.stringify(value);}</span>
<span class="fstat-no" title="function not covered" >re</span>gister(experimentName,experimentTitle,hidden){<span class="cstat-no" title="statement not covered" >Runtime._assert(!this._experimentNames[experimentName],'Duplicate registration of experiment '+experimentName);<span class="cstat-no" title="statement not covered" >t</span>his._experimentNames[experimentName]=true;<span class="cstat-no" title="statement not covered" >t</span>his._experiments.push(new Runtime.Experiment(this,experimentName,experimentTitle,!!hidden));}</span>
<span class="fstat-no" title="function not covered" >is</span>Enabled(experimentName){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentName);<span class="cstat-no" title="statement not covered" >i</span>f(Runtime._experimentsSetting()[experimentName]===false)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(this._enabledTransiently[experimentName])</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span>f(!this.supportEnabled())</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn!!Runtime._experimentsSetting()[experimentName];}</span>
<span class="fstat-no" title="function not covered" >se</span>tEnabled(experimentName,enabled){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentName);c</span>onst experimentsSetting=<span class="cstat-no" title="statement not covered" >Runtime._experimentsSetting();<span class="cstat-no" title="statement not covered" ></span>experimentsSetting[experimentName]=enabled;<span class="cstat-no" title="statement not covered" >t</span>his._setExperimentsSetting(experimentsSetting);}</span>
<span class="fstat-no" title="function not covered" >se</span>tDefaultExperiments(experimentNames){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;experimentNames.length;++i){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentNames[i]);<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently[experimentNames[i]]=true;}</span>}</span>
<span class="fstat-no" title="function not covered" >en</span>ableForTest(experimentName){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentName);<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently[experimentName]=true;}</span>
<span class="fstat-no" title="function not covered" >cl</span>earForTest(){<span class="cstat-no" title="statement not covered" >this._experiments=[];<span class="cstat-no" title="statement not covered" >t</span>his._experimentNames={};<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently={};}</span>
<span class="fstat-no" title="function not covered" >cl</span>eanUpStaleExperiments(){const experimentsSetting=<span class="cstat-no" title="statement not covered" >Runtime._experimentsSetting();</span>const cleanedUpExperimentSetting=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._experiments.length;++i){const experimentName=<span class="cstat-no" title="statement not covered" >this._experiments[i].name;<span class="cstat-no" title="statement not covered" ></span>if(experimentsSetting[experimentName])</span></span>
<span class="cstat-no" title="statement not covered" >cleanedUpExperimentSetting[experimentName]=true;}</span>
<span class="cstat-no" title="statement not covered" >this._setExperimentsSetting(cleanedUpExperimentSetting);}</span>
<span class="fstat-no" title="function not covered" >_c</span>heckExperiment(experimentName){<span class="cstat-no" title="statement not covered" >Runtime._assert(this._experimentNames[experimentName],'Unknown experiment '+experimentName);}</span>};<span class="cstat-no" title="statement not covered" >Runtime.Experiment=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(experiments,name,title,hidden){<span class="cstat-no" title="statement not covered" >this.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.hidden=hidden;<span class="cstat-no" title="statement not covered" >t</span>his._experiments=experiments;}</span></span>
<span class="fstat-no" title="function not covered" >is</span>Enabled(){<span class="cstat-no" title="statement not covered" >return this._experiments.isEnabled(this.name);}</span>
<span class="fstat-no" title="function not covered" >se</span>tEnabled(enabled){<span class="cstat-no" title="statement not covered" >this._experiments.setEnabled(this.name,enabled);}</span>};<span class="cstat-no" title="statement not covered" >Runtime.experiments=new Runtime.ExperimentsSupport();<span class="cstat-no" title="statement not covered" >R</span>untime._appStartedPromiseCallback;<span class="cstat-no" title="statement not covered" >R</span>untime._appStartedPromise=new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfil=&gt;<span class="cstat-no" title="statement not covered" >Runtime._appStartedPromiseCallback=fulfil)</span>;<span class="cstat-no" title="statement not covered" >R</span>untime._remoteBase;<span class="cstat-no" title="statement not covered" >(</span>function <span class="fstat-no" title="function not covered" >validateRemoteBase(</span>){<span class="cstat-no" title="statement not covered" >if(location.href.startsWith('chrome-devtools://devtools/bundled/')&amp;&amp;Runtime.queryParam('remoteBase')){const versionMatch=<span class="cstat-no" title="statement not covered" >/\/serve_file\/(@[0-9a-zA-Z]+)\/?$/.exec(Runtime.queryParam('remoteBase'));<span class="cstat-no" title="statement not covered" ></span>if(versionMatch)</span></span></span>
<span class="cstat-no" title="statement not covered" >Runtime._remoteBase=`${location.origin}/remote/serve_file/${versionMatch[1]}/`;}</span>})();function <span class="fstat-no" title="function not covered" >ServicePort(</span>){}
<span class="cstat-no" title="statement not covered" >ServicePort.prototype={setHandlers(messageHandler,closeHandler){},send(message){},close(){}};v</span>ar runtime;<span class="cstat-no" title="statement not covered" >allDescriptors.push(...[{"dependencies":[],"name":"heap_snapshot_model"},{"dependencies":[],"name":"platform"},{"dependencies":["heap_snapshot_model","platform","common"],"name":"heap_snapshot_worker"},{"dependencies":["platform"],"name":"text_utils"},{"dependencies":["text_utils","platform"],"name":"common"}]);<span class="cstat-no" title="statement not covered" >a</span>pplicationDescriptor={"has_html":false,"modules":[{"type":"autostart","name":"heap_snapshot_model"},{"type":"autostart","name":"platform"},{"type":"autostart","name":"heap_snapshot_worker"},{"type":"autostart","name":"text_utils"},{"type":"autostart","name":"common"}]}</span>
<span class="cstat-no" title="statement not covered" >self['HeapSnapshotModel']=self['HeapSnapshotModel']||{};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.HeapSnapshotProgressEvent={Update:'ProgressUpdate',BrokenSnapshot:'BrokenSnapshot'};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.baseSystemDistance=100000000;<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.AllocationNodeCallers=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(nodesWithSingleCaller,branchingCallers){<span class="cstat-no" title="statement not covered" >this.nodesWithSingleCaller=nodesWithSingleCaller;<span class="cstat-no" title="statement not covered" >t</span>his.branchingCallers=branchingCallers;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.SerializedAllocationNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(nodeId,functionName,scriptName,scriptId,line,column,count,size,liveCount,liveSize,hasChildren){<span class="cstat-no" title="statement not covered" >this.id=nodeId;<span class="cstat-no" title="statement not covered" >t</span>his.name=functionName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptName=scriptName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptId=scriptId;<span class="cstat-no" title="statement not covered" >t</span>his.line=line;<span class="cstat-no" title="statement not covered" >t</span>his.column=column;<span class="cstat-no" title="statement not covered" >t</span>his.count=count;<span class="cstat-no" title="statement not covered" >t</span>his.size=size;<span class="cstat-no" title="statement not covered" >t</span>his.liveCount=liveCount;<span class="cstat-no" title="statement not covered" >t</span>his.liveSize=liveSize;<span class="cstat-no" title="statement not covered" >t</span>his.hasChildren=hasChildren;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.AllocationStackFrame=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(functionName,scriptName,scriptId,line,column){<span class="cstat-no" title="statement not covered" >this.functionName=functionName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptName=scriptName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptId=scriptId;<span class="cstat-no" title="statement not covered" >t</span>his.line=line;<span class="cstat-no" title="statement not covered" >t</span>his.column=column;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Node=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,name,distance,nodeIndex,retainedSize,selfSize,type){<span class="cstat-no" title="statement not covered" >this.id=id;<span class="cstat-no" title="statement not covered" >t</span>his.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.distance=distance;<span class="cstat-no" title="statement not covered" >t</span>his.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >t</span>his.retainedSize=retainedSize;<span class="cstat-no" title="statement not covered" >t</span>his.selfSize=selfSize;<span class="cstat-no" title="statement not covered" >t</span>his.type=type;<span class="cstat-no" title="statement not covered" >t</span>his.canBeQueried=false;<span class="cstat-no" title="statement not covered" >t</span>his.detachedDOMTreeNode=false;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Edge=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(name,node,type,edgeIndex){<span class="cstat-no" title="statement not covered" >this.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.node=node;<span class="cstat-no" title="statement not covered" >t</span>his.type=type;<span class="cstat-no" title="statement not covered" >t</span>his.edgeIndex=edgeIndex;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Aggregate=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.count;<span class="cstat-no" title="statement not covered" >t</span>his.distance;<span class="cstat-no" title="statement not covered" >t</span>his.self;<span class="cstat-no" title="statement not covered" >t</span>his.maxRet;<span class="cstat-no" title="statement not covered" >t</span>his.type;<span class="cstat-no" title="statement not covered" >t</span>his.name;<span class="cstat-no" title="statement not covered" >t</span>his.idxs;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.AggregateForDiff=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.indexes=[];<span class="cstat-no" title="statement not covered" >t</span>his.ids=[];<span class="cstat-no" title="statement not covered" >t</span>his.selfSizes=[];}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Diff=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.addedCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.removedCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.addedSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.removedSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.deletedIndexes=[];<span class="cstat-no" title="statement not covered" >t</span>his.addedIndexes=[];}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.DiffForClass=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.addedCount;<span class="cstat-no" title="statement not covered" >t</span>his.removedCount;<span class="cstat-no" title="statement not covered" >t</span>his.addedSize;<span class="cstat-no" title="statement not covered" >t</span>his.removedSize;<span class="cstat-no" title="statement not covered" >t</span>his.deletedIndexes;<span class="cstat-no" title="statement not covered" >t</span>his.addedIndexes;<span class="cstat-no" title="statement not covered" >t</span>his.countDelta;<span class="cstat-no" title="statement not covered" >t</span>his.sizeDelta;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.ComparatorConfig=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.fieldName1;<span class="cstat-no" title="statement not covered" >t</span>his.ascending1;<span class="cstat-no" title="statement not covered" >t</span>his.fieldName2;<span class="cstat-no" title="statement not covered" >t</span>his.ascending2;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.WorkerCommand=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.callId;<span class="cstat-no" title="statement not covered" >t</span>his.disposition;<span class="cstat-no" title="statement not covered" >t</span>his.objectId;<span class="cstat-no" title="statement not covered" >t</span>his.newObjectId;<span class="cstat-no" title="statement not covered" >t</span>his.methodName;<span class="cstat-no" title="statement not covered" >t</span>his.methodArguments;<span class="cstat-no" title="statement not covered" >t</span>his.source;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.ItemsRange=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(startPosition,endPosition,totalLength,items){<span class="cstat-no" title="statement not covered" >this.startPosition=startPosition;<span class="cstat-no" title="statement not covered" >t</span>his.endPosition=endPosition;<span class="cstat-no" title="statement not covered" >t</span>his.totalLength=totalLength;<span class="cstat-no" title="statement not covered" >t</span>his.items=items;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.StaticData=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(nodeCount,rootNodeIndex,totalSize,maxJSObjectId){<span class="cstat-no" title="statement not covered" >this.nodeCount=nodeCount;<span class="cstat-no" title="statement not covered" >t</span>his.rootNodeIndex=rootNodeIndex;<span class="cstat-no" title="statement not covered" >t</span>his.totalSize=totalSize;<span class="cstat-no" title="statement not covered" >t</span>his.maxJSObjectId=maxJSObjectId;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Statistics=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.total;<span class="cstat-no" title="statement not covered" >t</span>his.v8heap;<span class="cstat-no" title="statement not covered" >t</span>his.native;<span class="cstat-no" title="statement not covered" >t</span>his.code;<span class="cstat-no" title="statement not covered" >t</span>his.jsArrays;<span class="cstat-no" title="statement not covered" >t</span>his.strings;<span class="cstat-no" title="statement not covered" >t</span>his.system;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.NodeFilter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(minNodeId,maxNodeId){<span class="cstat-no" title="statement not covered" >this.minNodeId=minNodeId;<span class="cstat-no" title="statement not covered" >t</span>his.maxNodeId=maxNodeId;<span class="cstat-no" title="statement not covered" >t</span>his.allocationNodeId;}</span></span>
<span class="fstat-no" title="function not covered" >eq</span>uals(o){<span class="cstat-no" title="statement not covered" >return this.minNodeId===o.minNodeId&amp;&amp;this.maxNodeId===o.maxNodeId&amp;&amp;this.allocationNodeId===o.allocationNodeId;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotModel.SearchConfig=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(query,caseSensitive,isRegex,shouldJump,jumpBackward){<span class="cstat-no" title="statement not covered" >this.query=query;<span class="cstat-no" title="statement not covered" >t</span>his.caseSensitive=caseSensitive;<span class="cstat-no" title="statement not covered" >t</span>his.isRegex=isRegex;<span class="cstat-no" title="statement not covered" >t</span>his.shouldJump=shouldJump;<span class="cstat-no" title="statement not covered" >t</span>his.jumpBackward=jumpBackward;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Samples=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(timestamps,lastAssignedIds,sizes){<span class="cstat-no" title="statement not covered" >this.timestamps=timestamps;<span class="cstat-no" title="statement not covered" >t</span>his.lastAssignedIds=lastAssignedIds;<span class="cstat-no" title="statement not covered" >t</span>his.sizes=sizes;}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotModel.Location=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(scriptId,lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >this.scriptId=scriptId;<span class="cstat-no" title="statement not covered" >t</span>his.lineNumber=lineNumber;<span class="cstat-no" title="statement not covered" >t</span>his.columnNumber=columnNumber;}</span>};;<span class="cstat-no" title="statement not covered" ></span>self['Platform']=self['Platform']||{};l</span>et ArrayLike;function <span class="fstat-no" title="function not covered" >mod(</span>m,n){<span class="cstat-no" title="statement not covered" >return((m%n)+n)%n;}</span>
<span class="cstat-no" title="statement not covered" >String.prototype.findAll=<span class="fstat-no" title="function not covered" >fu</span>nction(string){const matches=<span class="cstat-no" title="statement not covered" >[];</span>let i=<span class="cstat-no" title="statement not covered" >this.indexOf(string);<span class="cstat-no" title="statement not covered" ></span>while(i!==-1){<span class="cstat-no" title="statement not covered" >matches.push(i);<span class="cstat-no" title="statement not covered" >i</span>=this.indexOf(string,i+string.length);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return matches;}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.reverse=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.split('').reverse().join('');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.replaceControlCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/[\u0000-\u0008\u000b\u000c\u000e-\u001f\u0080-\u009f]/g,'');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.isWhitespace=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return/^\s*$/.test(this);}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.computeLineEndings=<span class="fstat-no" title="function not covered" >fu</span>nction(){const endings=<span class="cstat-no" title="statement not covered" >this.findAll('\n');<span class="cstat-no" title="statement not covered" ></span>endings.push(this.length);<span class="cstat-no" title="statement not covered" >r</span>eturn endings;}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.escapeCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(chars){let foundChar=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;chars.length;++i){<span class="cstat-no" title="statement not covered" >if(this.indexOf(chars.charAt(i))!==-1){<span class="cstat-no" title="statement not covered" >foundChar=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!foundChar)</span>
<span class="cstat-no" title="statement not covered" >return String(this);l</span>et result=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this.length;++i){<span class="cstat-no" title="statement not covered" >if(chars.indexOf(this.charAt(i))!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >result+='\\';<span class="cstat-no" title="statement not covered" >r</span>esult+=this.charAt(i);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >String.regexSpecialCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'^[]{}()\\.^$*+?|-,';}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.escapeForRegExp=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.escapeCharacters(String.regexSpecialCharacters());}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.filterRegex=<span class="fstat-no" title="function not covered" >fu</span>nction(query){const toEscape=<span class="cstat-no" title="statement not covered" >String.regexSpecialCharacters();</span>let regexString=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;query.length;++i){let c=<span class="cstat-no" title="statement not covered" >query.charAt(i);<span class="cstat-no" title="statement not covered" ></span>if(toEscape.indexOf(c)!==-1)</span></span></span>
<span class="cstat-no" title="statement not covered" >c='\\'+c;<span class="cstat-no" title="statement not covered" >i</span>f(i)</span>
<span class="cstat-no" title="statement not covered" >regexString+='[^\\0'+c+']*';<span class="cstat-no" title="statement not covered" >r</span>egexString+=c;}</span>
<span class="cstat-no" title="statement not covered" >return new RegExp(regexString,'i');}</span>;<span class="cstat-no" title="statement not covered" >String.escapeInvalidUnicodeCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >if(!String._invalidCharactersRegExp){let invalidCharacters=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0xfffe;i&lt;=0x10ffff;i+=0x10000)</span></span></span>
<span class="cstat-no" title="statement not covered" >invalidCharacters+=String.fromCodePoint(i,i+1);<span class="cstat-no" title="statement not covered" >S</span>tring._invalidCharactersRegExp=new RegExp(`[${invalidCharacters}\uD800-\uDFFF\uFDD0-\uFDEF]`,'gu');}</span>
let result=<span class="cstat-no" title="statement not covered" >'';</span>let lastPos=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(true){const match=<span class="cstat-no" title="statement not covered" >String._invalidCharactersRegExp.exec(text);<span class="cstat-no" title="statement not covered" ></span>if(!match)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span>esult+=text.substring(lastPos,match.index)+'\\u'+text.charCodeAt(match.index).toString(16);<span class="cstat-no" title="statement not covered" >i</span>f(match.index+1&lt;String._invalidCharactersRegExp.lastIndex)</span>
<span class="cstat-no" title="statement not covered" >result+='\\u'+text.charCodeAt(match.index+1).toString(16);<span class="cstat-no" title="statement not covered" >l</span>astPos=String._invalidCharactersRegExp.lastIndex;}</span>
<span class="cstat-no" title="statement not covered" >return result+text.substring(lastPos);}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.escapeHTML=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/&amp;/g,'&amp;amp;').replace(/&lt;/g,'&amp;lt;').replace(/&gt;/g,'&amp;gt;').replace(/"/g,'&amp;quot;');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.unescapeHTML=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/&amp;lt;/g,'&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;#58;/g,':').replace(/&amp;quot;/g,'"').replace(/&amp;#60;/g,'&lt;').replace(/&amp;#62;/g,'&gt;').replace(/&amp;amp;/g,'&amp;');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.collapseWhitespace=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/[\s\xA0]+/g,' ');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.trimMiddle=<span class="fstat-no" title="function not covered" >fu</span>nction(maxLength){<span class="cstat-no" title="statement not covered" >if(this.length&lt;=maxLength)</span></span>
<span class="cstat-no" title="statement not covered" >return String(this);l</span>et leftHalf=<span class="cstat-no" title="statement not covered" >maxLength&gt;&gt;1;</span>let rightHalf=<span class="cstat-no" title="statement not covered" >maxLength-leftHalf-1;<span class="cstat-no" title="statement not covered" ></span>if(this.codePointAt(this.length-rightHalf-1)&gt;=0x10000){<span class="cstat-no" title="statement not covered" >--rightHalf;<span class="cstat-no" title="statement not covered" >+</span>+leftHalf;}</span></span>
<span class="cstat-no" title="statement not covered" >if(leftHalf&gt;0&amp;&amp;this.codePointAt(leftHalf-1)&gt;=0x10000)</span>
<span class="cstat-no" title="statement not covered" >--leftHalf;<span class="cstat-no" title="statement not covered" >r</span>eturn this.substr(0,leftHalf)+'\u2026'+this.substr(this.length-rightHalf,rightHalf);}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.trimEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(maxLength){<span class="cstat-no" title="statement not covered" >if(this.length&lt;=maxLength)</span></span>
<span class="cstat-no" title="statement not covered" >return String(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this.substr(0,maxLength-1)+'\u2026';}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.trimURL=<span class="fstat-no" title="function not covered" >fu</span>nction(baseURLDomain){let result=<span class="cstat-no" title="statement not covered" >this.replace(/^(https|http|file):\/\//i,'');<span class="cstat-no" title="statement not covered" ></span>if(baseURLDomain){<span class="cstat-no" title="statement not covered" >if(result.toLowerCase().startsWith(baseURLDomain.toLowerCase()))</span></span></span>
<span class="cstat-no" title="statement not covered" >result=result.substr(baseURLDomain.length);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.toTitleCase=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.substring(0,1).toUpperCase()+this.substring(1);}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.compareTo=<span class="fstat-no" title="function not covered" >fu</span>nction(other){<span class="cstat-no" title="statement not covered" >if(this&gt;other)</span></span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(this&lt;other)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.removeURLFragment=<span class="fstat-no" title="function not covered" >fu</span>nction(){let fragmentIndex=<span class="cstat-no" title="statement not covered" >this.indexOf('#');<span class="cstat-no" title="statement not covered" ></span>if(fragmentIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >fragmentIndex=this.length;<span class="cstat-no" title="statement not covered" >r</span>eturn this.substring(0,fragmentIndex);}</span>;<span class="cstat-no" title="statement not covered" >String.hashCode=<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >if(!string)</span></span>
<span class="cstat-no" title="statement not covered" >return 0;c</span>onst p=(<span class="cstat-no" title="statement not covered" >(1&lt;&lt;30)*4-5)</span>;const z=<span class="cstat-no" title="statement not covered" >0x5033d967;</span>const z2=<span class="cstat-no" title="statement not covered" >0x59d2f15d;</span>let s=<span class="cstat-no" title="statement not covered" >0;</span>let zi=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;string.length;i++){const xi=<span class="cstat-no" title="statement not covered" >string.charCodeAt(i)*z2;<span class="cstat-no" title="statement not covered" ></span>s=(s+zi*xi)%p;<span class="cstat-no" title="statement not covered" >z</span>i=(zi*z)%p;}</span></span>
<span class="cstat-no" title="statement not covered" >s=(s+zi*(p-1))%p;<span class="cstat-no" title="statement not covered" >r</span>eturn Math.abs(s|0);}</span>;<span class="cstat-no" title="statement not covered" >String.isDigitAt=<span class="fstat-no" title="function not covered" >fu</span>nction(string,index){const c=<span class="cstat-no" title="statement not covered" >string.charCodeAt(index);<span class="cstat-no" title="statement not covered" ></span>return(48&lt;=c&amp;&amp;c&lt;=57);}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.toBase64=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >encodeBits(</span>b){<span class="cstat-no" title="statement not covered" >return b&lt;26?b+65:b&lt;52?b+71:b&lt;62?b-4:b===62?43:b===63?47:65;}</span></span>
const encoder=<span class="cstat-no" title="statement not covered" >new TextEncoder();</span>const data=<span class="cstat-no" title="statement not covered" >encoder.encode(this.toString());</span>const n=<span class="cstat-no" title="statement not covered" >data.length;</span>let encoded=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(n===0)</span>
<span class="cstat-no" title="statement not covered" >return encoded;l</span>et shift;let v=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;n;i++){<span class="cstat-no" title="statement not covered" >shift=i%3;<span class="cstat-no" title="statement not covered" >v</span>|=data[i]&lt;&lt;(16&gt;&gt;&gt;shift&amp;24);<span class="cstat-no" title="statement not covered" >i</span>f(shift===2){<span class="cstat-no" title="statement not covered" >encoded+=String.fromCharCode(encodeBits(v&gt;&gt;&gt;18&amp;63),encodeBits(v&gt;&gt;&gt;12&amp;63),encodeBits(v&gt;&gt;&gt;6&amp;63),encodeBits(v&amp;63));<span class="cstat-no" title="statement not covered" >v</span>=0;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(shift===0)</span>
<span class="cstat-no" title="statement not covered" >encoded+=String.fromCharCode(encodeBits(v&gt;&gt;&gt;18&amp;63),encodeBits(v&gt;&gt;&gt;12&amp;63),61,61);e</span>lse <span class="cstat-no" title="statement not covered" >if(shift===1)</span>
<span class="cstat-no" title="statement not covered" >encoded+=String.fromCharCode(encodeBits(v&gt;&gt;&gt;18&amp;63),encodeBits(v&gt;&gt;&gt;12&amp;63),encodeBits(v&gt;&gt;&gt;6&amp;63),61);<span class="cstat-no" title="statement not covered" >r</span>eturn encoded;}</span>;<span class="cstat-no" title="statement not covered" >String.naturalOrderComparator=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){const chunk=<span class="cstat-no" title="statement not covered" >/^\d+|^\D+/;</span>let chunka,chunkb,anum,bnum;<span class="cstat-no" title="statement not covered" >while(1){<span class="cstat-no" title="statement not covered" >if(a){<span class="cstat-no" title="statement not covered" >if(!b)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return 1;}</span>else{<span class="cstat-no" title="statement not covered" >if(b)</span>
<span class="cstat-no" title="statement not covered" >return-1;e</span>lse
<span class="cstat-no" title="statement not covered" >return 0;}</span>
<span class="cstat-no" title="statement not covered" >chunka=a.match(chunk)[0];<span class="cstat-no" title="statement not covered" >c</span>hunkb=b.match(chunk)[0];<span class="cstat-no" title="statement not covered" >a</span>num=!isNaN(chunka);<span class="cstat-no" title="statement not covered" >b</span>num=!isNaN(chunkb);<span class="cstat-no" title="statement not covered" >i</span>f(anum&amp;&amp;!bnum)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(bnum&amp;&amp;!anum)</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(anum&amp;&amp;bnum){const diff=<span class="cstat-no" title="statement not covered" >chunka-chunkb;<span class="cstat-no" title="statement not covered" ></span>if(diff)</span></span>
<span class="cstat-no" title="statement not covered" >return diff;<span class="cstat-no" title="statement not covered" >i</span>f(chunka.length!==chunkb.length){<span class="cstat-no" title="statement not covered" >if(!+chunka&amp;&amp;!+chunkb)</span></span>
<span class="cstat-no" title="statement not covered" >return chunka.length-chunkb.length;e</span>lse
<span class="cstat-no" title="statement not covered" >return chunkb.length-chunka.length;}</span>}else <span class="cstat-no" title="statement not covered" >if(chunka!==chunkb){<span class="cstat-no" title="statement not covered" >return(chunka&lt;chunkb)?-1:1;}</span></span>
<span class="cstat-no" title="statement not covered" >a=a.substring(chunka.length);<span class="cstat-no" title="statement not covered" >b</span>=b.substring(chunkb.length);}</span>};<span class="cstat-no" title="statement not covered" >String.caseInsensetiveComparator=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >a=a.toUpperCase();<span class="cstat-no" title="statement not covered" >b</span>=b.toUpperCase();<span class="cstat-no" title="statement not covered" >i</span>f(a===b)</span></span>
<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >r</span>eturn a&gt;b?1:-1;}</span>;<span class="cstat-no" title="statement not covered" >Number.constrain=<span class="fstat-no" title="function not covered" >fu</span>nction(num,min,max){<span class="cstat-no" title="statement not covered" >if(num&lt;min)</span></span>
<span class="cstat-no" title="statement not covered" >num=min;e</span>lse <span class="cstat-no" title="statement not covered" >if(num&gt;max)</span>
<span class="cstat-no" title="statement not covered" >num=max;<span class="cstat-no" title="statement not covered" >r</span>eturn num;}</span>;<span class="cstat-no" title="statement not covered" >Number.gcd=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >if(b===0)</span></span>
<span class="cstat-no" title="statement not covered" >return a;e</span>lse
<span class="cstat-no" title="statement not covered" >return Number.gcd(b,a%b);}</span>;<span class="cstat-no" title="statement not covered" >Number.toFixedIfFloating=<span class="fstat-no" title="function not covered" >fu</span>nction(value){<span class="cstat-no" title="statement not covered" >if(!value||isNaN(value))</span></span>
<span class="cstat-no" title="statement not covered" >return value;c</span>onst number=<span class="cstat-no" title="statement not covered" >Number(value);<span class="cstat-no" title="statement not covered" ></span>return number%1?number.toFixed(3):String(number);}</span>;<span class="cstat-no" title="statement not covered" >Date.prototype.isValid=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!isNaN(this.getTime());}</span>;<span class="cstat-no" title="statement not covered" >D</span>ate.prototype.toISO8601Compact=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >leadZero(</span>x){<span class="cstat-no" title="statement not covered" >return(x&gt;9?'':'0')+x;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.getFullYear()+leadZero(this.getMonth()+1)+leadZero(this.getDate())+'T'+</span>
leadZero(this.getHours())+leadZero(this.getMinutes())+leadZero(this.getSeconds());};<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'remove',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(value,firstOnly){let index=<span class="cstat-no" title="statement not covered" >this.indexOf(value);<span class="cstat-no" title="statement not covered" ></span>if(index===-1)</span></span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(firstOnly){<span class="cstat-no" title="statement not covered" >this.splice(index,1);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >for(let i=index+1,n=this.length;i&lt;n;++i){<span class="cstat-no" title="statement not covered" >if(this[i]!==value)</span></span>
<span class="cstat-no" title="statement not covered" >this[index++]=this[i];}</span>
<span class="cstat-no" title="statement not covered" >this.length=index;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'pushAll',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(array){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;array.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this.push(array[i]);}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'rotate',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(index){const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=index;i&lt;index+this.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >result.push(this[i%this.length]);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'sortNumbers',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >numericComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a-b;}</span></span>
<span class="cstat-no" title="statement not covered" >this.sort(numericComparator);}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Uint32Array.prototype,'sort',{value:Array.prototype.sort});<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(){const partition=<span class="cstat-no" title="statement not covered" >{value:<span class="fstat-no" title="function not covered" >fu</span>nction(comparator,left,right,pivotIndex){function <span class="fstat-no" title="function not covered" >swap(</span>array,i1,i2){const temp=<span class="cstat-no" title="statement not covered" >array[i1];<span class="cstat-no" title="statement not covered" ></span>array[i1]=array[i2];<span class="cstat-no" title="statement not covered" >a</span>rray[i2]=temp;}</span></span></span>
const pivotValue=<span class="cstat-no" title="statement not covered" >this[pivotIndex];<span class="cstat-no" title="statement not covered" ></span>swap(this,right,pivotIndex);l</span>et storeIndex=<span class="cstat-no" title="statement not covered" >left;<span class="cstat-no" title="statement not covered" ></span>for(let i=left;i&lt;right;++i){<span class="cstat-no" title="statement not covered" >if(comparator(this[i],pivotValue)&lt;0){<span class="cstat-no" title="statement not covered" >swap(this,storeIndex,i);<span class="cstat-no" title="statement not covered" >+</span>+storeIndex;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >swap(this,right,storeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn storeIndex;}</span>};<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'partition',partition);<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Uint32Array.prototype,'partition',partition);c</span>onst sortRange=<span class="cstat-no" title="statement not covered" >{value:<span class="fstat-no" title="function not covered" >fu</span>nction(comparator,leftBound,rightBound,sortWindowLeft,sortWindowRight){function <span class="fstat-no" title="function not covered" >quickSortRange(</span>array,comparator,left,right,sortWindowLeft,sortWindowRight){<span class="cstat-no" title="statement not covered" >if(right&lt;=left)</span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst pivotIndex=<span class="cstat-no" title="statement not covered" >Math.floor(Math.random()*(right-left))+left;</span>const pivotNewIndex=<span class="cstat-no" title="statement not covered" >array.partition(comparator,left,right,pivotIndex);<span class="cstat-no" title="statement not covered" ></span>if(sortWindowLeft&lt;pivotNewIndex)</span>
<span class="cstat-no" title="statement not covered" >quickSortRange(array,comparator,left,pivotNewIndex-1,sortWindowLeft,sortWindowRight);<span class="cstat-no" title="statement not covered" >i</span>f(pivotNewIndex&lt;sortWindowRight)</span>
<span class="cstat-no" title="statement not covered" >quickSortRange(array,comparator,pivotNewIndex+1,right,sortWindowLeft,sortWindowRight);}</span>
<span class="cstat-no" title="statement not covered" >if(leftBound===0&amp;&amp;rightBound===(this.length-1)&amp;&amp;sortWindowLeft===0&amp;&amp;sortWindowRight&gt;=rightBound)</span>
<span class="cstat-no" title="statement not covered" >this.sort(comparator);e</span>lse
<span class="cstat-no" title="statement not covered" >quickSortRange(this,comparator,leftBound,rightBound,sortWindowLeft,sortWindowRight);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>};<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'sortRange',sortRange);<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Uint32Array.prototype,'sortRange',sortRange);}</span>)();<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'stableSort',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(comparator){function <span class="fstat-no" title="function not covered" >defaultComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a&lt;b?-1:(a&gt;b?1:0);}</span></span>
<span class="cstat-no" title="statement not covered" >comparator=comparator||defaultComparator;c</span>onst indices=<span class="cstat-no" title="statement not covered" >new Array(this.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this.length;++i)</span>
<span class="cstat-no" title="statement not covered" >indices[i]=i;c</span>onst self=<span class="cstat-no" title="statement not covered" >this;</span>function <span class="fstat-no" title="function not covered" >indexComparator(</span>a,b){const result=<span class="cstat-no" title="statement not covered" >comparator(self[a],self[b]);<span class="cstat-no" title="statement not covered" ></span>return result?result:a-b;}</span>
<span class="cstat-no" title="statement not covered" >indices.sort(indexComparator);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this.length;++i){<span class="cstat-no" title="statement not covered" >if(indices[i]&lt;0||i===indices[i])</span></span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et cyclical=<span class="cstat-no" title="statement not covered" >i;</span>const saved=<span class="cstat-no" title="statement not covered" >this[i];<span class="cstat-no" title="statement not covered" ></span>while(true){const next=<span class="cstat-no" title="statement not covered" >indices[cyclical];<span class="cstat-no" title="statement not covered" ></span>indices[cyclical]=-1;<span class="cstat-no" title="statement not covered" >i</span>f(next===i){<span class="cstat-no" title="statement not covered" >this[cyclical]=saved;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else{<span class="cstat-no" title="statement not covered" >this[cyclical]=this[next];<span class="cstat-no" title="statement not covered" >c</span>yclical=next;}</span>}</span>}</span>
<span class="cstat-no" title="statement not covered" >return this;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'qselect',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(k,comparator){<span class="cstat-no" title="statement not covered" >if(k&lt;0||k&gt;=this.length)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!comparator){<span class="cstat-no" title="statement not covered" >comparator=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return a-b;}</span>;}</span></span>
let low=<span class="cstat-no" title="statement not covered" >0;</span>let high=<span class="cstat-no" title="statement not covered" >this.length-1;<span class="cstat-no" title="statement not covered" ></span>for(;;){const pivotPosition=<span class="cstat-no" title="statement not covered" >this.partition(comparator,low,high,Math.floor((high+low)/2));<span class="cstat-no" title="statement not covered" ></span>if(pivotPosition===k)</span></span>
<span class="cstat-no" title="statement not covered" >return this[k];e</span>lse <span class="cstat-no" title="statement not covered" >if(pivotPosition&gt;k)</span>
<span class="cstat-no" title="statement not covered" >high=pivotPosition-1;e</span>lse
<span class="cstat-no" title="statement not covered" >low=pivotPosition+1;}</span>}});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'lowerBound',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(object,comparator,left,right){function <span class="fstat-no" title="function not covered" >defaultComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a&lt;b?-1:(a&gt;b?1:0);}</span></span>
<span class="cstat-no" title="statement not covered" >comparator=comparator||defaultComparator;l</span>et l=<span class="cstat-no" title="statement not covered" >left||0;</span>let r=<span class="cstat-no" title="statement not covered" >right!==undefined?right:this.length;<span class="cstat-no" title="statement not covered" ></span>while(l&lt;r){const m=<span class="cstat-no" title="statement not covered" >(l+r)&gt;&gt;1;<span class="cstat-no" title="statement not covered" ></span>if(comparator(object,this[m])&gt;0)</span></span>
<span class="cstat-no" title="statement not covered" >l=m+1;e</span>lse
<span class="cstat-no" title="statement not covered" >r=m;}</span>
<span class="cstat-no" title="statement not covered" >return r;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'upperBound',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(object,comparator,left,right){function <span class="fstat-no" title="function not covered" >defaultComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a&lt;b?-1:(a&gt;b?1:0);}</span></span>
<span class="cstat-no" title="statement not covered" >comparator=comparator||defaultComparator;l</span>et l=<span class="cstat-no" title="statement not covered" >left||0;</span>let r=<span class="cstat-no" title="statement not covered" >right!==undefined?right:this.length;<span class="cstat-no" title="statement not covered" ></span>while(l&lt;r){const m=<span class="cstat-no" title="statement not covered" >(l+r)&gt;&gt;1;<span class="cstat-no" title="statement not covered" ></span>if(comparator(object,this[m])&gt;=0)</span></span>
<span class="cstat-no" title="statement not covered" >l=m+1;e</span>lse
<span class="cstat-no" title="statement not covered" >r=m;}</span>
<span class="cstat-no" title="statement not covered" >return r;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Uint32Array.prototype,'lowerBound',{value:Array.prototype.lowerBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Uint32Array.prototype,'upperBound',{value:Array.prototype.upperBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Int32Array.prototype,'lowerBound',{value:Array.prototype.lowerBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Int32Array.prototype,'upperBound',{value:Array.prototype.upperBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Float64Array.prototype,'lowerBound',{value:Array.prototype.lowerBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Array.prototype,'binaryIndexOf',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(value,comparator){const index=<span class="cstat-no" title="statement not covered" >this.lowerBound(value,comparator);<span class="cstat-no" title="statement not covered" ></span>return index&lt;this.length&amp;&amp;comparator(value,this[index])===0?index:-1;}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Array.prototype,'select',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(field){const result=<span class="cstat-no" title="statement not covered" >new Array(this.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >result[i]=this[i][field];<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'peekLast',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this[this.length-1];}</span>});<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(){function <span class="fstat-no" title="function not covered" >mergeOrIntersect(</span>array1,array2,comparator,mergeNotIntersect){const result=<span class="cstat-no" title="statement not covered" >[];</span>let i=<span class="cstat-no" title="statement not covered" >0;</span>let j=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(i&lt;array1.length&amp;&amp;j&lt;array2.length){const compareValue=<span class="cstat-no" title="statement not covered" >comparator(array1[i],array2[j]);<span class="cstat-no" title="statement not covered" ></span>if(mergeNotIntersect||!compareValue)</span></span></span>
<span class="cstat-no" title="statement not covered" >result.push(compareValue&lt;=0?array1[i]:array2[j]);<span class="cstat-no" title="statement not covered" >i</span>f(compareValue&lt;=0)</span>
<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >i</span>f(compareValue&gt;=0)</span>
<span class="cstat-no" title="statement not covered" >j++;}</span>
<span class="cstat-no" title="statement not covered" >if(mergeNotIntersect){<span class="cstat-no" title="statement not covered" >while(i&lt;array1.length)</span></span>
<span class="cstat-no" title="statement not covered" >result.push(array1[i++]);<span class="cstat-no" title="statement not covered" >w</span>hile(j&lt;array2.length)</span>
<span class="cstat-no" title="statement not covered" >result.push(array2[j++]);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'intersectOrdered',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(array,comparator){<span class="cstat-no" title="statement not covered" >return mergeOrIntersect(this,array,comparator,false);}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Array.prototype,'mergeOrdered',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(array,comparator){<span class="cstat-no" title="statement not covered" >return mergeOrIntersect(this,array,comparator,true);}</span>});}</span>)();<span class="cstat-no" title="statement not covered" >String.sprintf=<span class="fstat-no" title="function not covered" >fu</span>nction(format,var_arg){<span class="cstat-no" title="statement not covered" >return String.vsprintf(format,Array.prototype.slice.call(arguments,1));}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.tokenizeFormatString=<span class="fstat-no" title="function not covered" >fu</span>nction(format,formatters){const tokens=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >addStringToken(</span>str){<span class="cstat-no" title="statement not covered" >if(!str)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(tokens.length&amp;&amp;tokens[tokens.length-1].type==='string')</span>
<span class="cstat-no" title="statement not covered" >tokens[tokens.length-1].value+=str;e</span>lse
<span class="cstat-no" title="statement not covered" >tokens.push({type:'string',value:str});}</span>
function <span class="fstat-no" title="function not covered" >addSpecifierToken(</span>specifier,precision,substitutionIndex){<span class="cstat-no" title="statement not covered" >tokens.push({type:'specifier',specifier:specifier,precision:precision,substitutionIndex:substitutionIndex});}</span>
function <span class="fstat-no" title="function not covered" >addAnsiColor(</span>code){const types=<span class="cstat-no" title="statement not covered" >{3:'color',9:'colorLight',4:'bgColor',10:'bgColorLight'};</span>const colorCodes=<span class="cstat-no" title="statement not covered" >['black','red','green','yellow','blue','magenta','cyan','lightGray','','default'];</span>const colorCodesLight=<span class="cstat-no" title="statement not covered" >['darkGray','lightRed','lightGreen','lightYellow','lightBlue','lightMagenta','lightCyan','white',''];</span>const colors=<span class="cstat-no" title="statement not covered" >{color:colorCodes,colorLight:colorCodesLight,bgColor:colorCodes,bgColorLight:colorCodesLight};</span>const type=<span class="cstat-no" title="statement not covered" >types[Math.floor(code/10)];<span class="cstat-no" title="statement not covered" ></span>if(!type)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst color=<span class="cstat-no" title="statement not covered" >colors[type][code%10];<span class="cstat-no" title="statement not covered" ></span>if(!color)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>okens.push({type:'specifier',specifier:'c',value:{description:(type.startsWith('bg')?'background : ':'color: ')+color}});}</span>
let textStart=<span class="cstat-no" title="statement not covered" >0;</span>let substitutionIndex=<span class="cstat-no" title="statement not covered" >0;</span>const re=<span class="cstat-no" title="statement not covered" >new RegExp(`%%|%(?:(\\d+)\\$)?(?:\\.(\\d*))?([${Object.keys(formatters).join('')}])|\\u001b\\[(\\d+)m`,'g');<span class="cstat-no" title="statement not covered" ></span>for(let match=re.exec(format);!!match;match=re.exec(format)){const matchStart=<span class="cstat-no" title="statement not covered" >match.index;<span class="cstat-no" title="statement not covered" ></span>if(matchStart&gt;textStart)</span></span>
<span class="cstat-no" title="statement not covered" >addStringToken(format.substring(textStart,matchStart));<span class="cstat-no" title="statement not covered" >i</span>f(match[0]==='%%'){<span class="cstat-no" title="statement not covered" >addStringToken('%');}</span>else <span class="cstat-no" title="statement not covered" >if(match[0].startsWith('%')){const[_,substitionString,precisionString,specifierString]=<span class="cstat-no" title="statement not covered" >match;<span class="cstat-no" title="statement not covered" ></span>if(substitionString&amp;&amp;Number(substitionString)&gt;0)</span></span></span>
<span class="cstat-no" title="statement not covered" >substitutionIndex=Number(substitionString)-1;c</span>onst precision=<span class="cstat-no" title="statement not covered" >precisionString?Number(precisionString):-1;<span class="cstat-no" title="statement not covered" ></span>addSpecifierToken(specifierString,precision,substitutionIndex);<span class="cstat-no" title="statement not covered" >+</span>+substitutionIndex;}</span>else{const code=<span class="cstat-no" title="statement not covered" >Number(match[4]);<span class="cstat-no" title="statement not covered" ></span>addAnsiColor(code);}</span>
<span class="cstat-no" title="statement not covered" >textStart=matchStart+match[0].length;}</span>
<span class="cstat-no" title="statement not covered" >addStringToken(format.substring(textStart));<span class="cstat-no" title="statement not covered" >r</span>eturn tokens;}</span>;<span class="cstat-no" title="statement not covered" >String.standardFormatters={d:<span class="fstat-no" title="function not covered" >fu</span>nction(substitution){<span class="cstat-no" title="statement not covered" >return!isNaN(substitution)?substitution:0;}</span>,f:<span class="fstat-no" title="function not covered" >fu</span>nction(substitution,token){<span class="cstat-no" title="statement not covered" >if(substitution&amp;&amp;token.precision&gt;-1)</span></span>
<span class="cstat-no" title="statement not covered" >substitution=substitution.toFixed(token.precision);<span class="cstat-no" title="statement not covered" >r</span>eturn!isNaN(substitution)?substitution:(token.precision&gt;-1?Number(0).toFixed(token.precision):0);}</span>,s:<span class="fstat-no" title="function not covered" >fu</span>nction(substitution){<span class="cstat-no" title="statement not covered" >return substitution;}</span>};<span class="cstat-no" title="statement not covered" >String.vsprintf=<span class="fstat-no" title="function not covered" >fu</span>nction(format,substitutions){<span class="cstat-no" title="statement not covered" >return String.format(format,substitutions,String.standardFormatters,'',<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return a+b;}</span>).formattedResult;}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.format=<span class="fstat-no" title="function not covered" >fu</span>nction(format,substitutions,formatters,initialValue,append,tokenizedFormat){<span class="cstat-no" title="statement not covered" >if(!format||((!substitutions||!substitutions.length)&amp;&amp;format.search(/\u001b\[(\d+)m/)===-1))</span></span>
<span class="cstat-no" title="statement not covered" >return{formattedResult:append(initialValue,format),unusedSubstitutions:substitutions};f</span>unction <span class="fstat-no" title="function not covered" >prettyFunctionName(</span>){<span class="cstat-no" title="statement not covered" >return'String.format("'+format+'", "'+Array.prototype.join.call(substitutions,'", "')+'")';}</span>
function <span class="fstat-no" title="function not covered" >warn(</span>msg){<span class="cstat-no" title="statement not covered" >console.warn(prettyFunctionName()+': '+msg);}</span>
function <span class="fstat-no" title="function not covered" >error(</span>msg){<span class="cstat-no" title="statement not covered" >console.error(prettyFunctionName()+': '+msg);}</span>
let result=<span class="cstat-no" title="statement not covered" >initialValue;</span>const tokens=<span class="cstat-no" title="statement not covered" >tokenizedFormat||String.tokenizeFormatString(format,formatters);</span>const usedSubstitutionIndexes=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;tokens.length;++i){const token=<span class="cstat-no" title="statement not covered" >tokens[i];<span class="cstat-no" title="statement not covered" ></span>if(token.type==='string'){<span class="cstat-no" title="statement not covered" >result=append(result,token.value);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(token.type!=='specifier'){<span class="cstat-no" title="statement not covered" >error('Unknown token type "'+token.type+'" found.');<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!token.value&amp;&amp;token.substitutionIndex&gt;=substitutions.length){<span class="cstat-no" title="statement not covered" >error('not enough substitution arguments. Had '+substitutions.length+' but needed '+</span></span>
(token.substitutionIndex+1)+', so substitution was skipped.');<span class="cstat-no" title="statement not covered" >result=append(result,'%'+(token.precision&gt;-1?token.precision:'')+token.specifier);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>
<span class="cstat-no" title="statement not covered" >if(!token.value)</span>
<span class="cstat-no" title="statement not covered" >usedSubstitutionIndexes[token.substitutionIndex]=true;<span class="cstat-no" title="statement not covered" >i</span>f(!(token.specifier in formatters)){<span class="cstat-no" title="statement not covered" >warn('unsupported format character \u201C'+token.specifier+'\u201D. Treating as a string.');<span class="cstat-no" title="statement not covered" >r</span>esult=append(result,token.value?'':substitutions[token.substitutionIndex]);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >result=append(result,formatters[token.specifier](token.value||substitutions[token.substitutionIndex],token));}</span>
const unusedSubstitutions=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;substitutions.length;++i){<span class="cstat-no" title="statement not covered" >if(i in usedSubstitutionIndexes)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >u</span>nusedSubstitutions.push(substitutions[i]);}</span>
<span class="cstat-no" title="statement not covered" >return{formattedResult:result,unusedSubstitutions:unusedSubstitutions};}</span>;function <span class="fstat-no" title="function not covered" >createSearchRegex(</span>query,caseSensitive,isRegex){const regexFlags=<span class="cstat-no" title="statement not covered" >caseSensitive?'g':'gi';</span>let regexObject;<span class="cstat-no" title="statement not covered" >if(isRegex){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >regexObject=new RegExp(query,regexFlags);}</span>catch(e){}}</span></span>
<span class="cstat-no" title="statement not covered" >if(!regexObject)</span>
<span class="cstat-no" title="statement not covered" >regexObject=createPlainTextSearchRegex(query,regexFlags);<span class="cstat-no" title="statement not covered" >r</span>eturn regexObject;}</span>
function <span class="fstat-no" title="function not covered" >createPlainTextSearchRegex(</span>query,flags){const regexSpecialCharacters=<span class="cstat-no" title="statement not covered" >String.regexSpecialCharacters();</span>let regex=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;query.length;++i){const c=<span class="cstat-no" title="statement not covered" >query.charAt(i);<span class="cstat-no" title="statement not covered" ></span>if(regexSpecialCharacters.indexOf(c)!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >regex+='\\';<span class="cstat-no" title="statement not covered" >r</span>egex+=c;}</span>
<span class="cstat-no" title="statement not covered" >return new RegExp(regex,flags||'');}</span>
function <span class="fstat-no" title="function not covered" >countRegexMatches(</span>regex,content){let text=<span class="cstat-no" title="statement not covered" >content;</span>let result=<span class="cstat-no" title="statement not covered" >0;</span>let match;<span class="cstat-no" title="statement not covered" >while(text&amp;&amp;(match=regex.exec(text))){<span class="cstat-no" title="statement not covered" >if(match[0].length&gt;0)</span></span>
<span class="cstat-no" title="statement not covered" >++result;<span class="cstat-no" title="statement not covered" >t</span>ext=text.substring(match.index+1);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
function <span class="fstat-no" title="function not covered" >spacesPadding(</span>spacesCount){<span class="cstat-no" title="statement not covered" >return'\u00a0'.repeat(spacesCount);}</span>
function <span class="fstat-no" title="function not covered" >numberToStringWithSpacesPadding(</span>value,symbolsCount){const numberString=<span class="cstat-no" title="statement not covered" >value.toString();</span>const paddingLength=<span class="cstat-no" title="statement not covered" >Math.max(0,symbolsCount-numberString.length);<span class="cstat-no" title="statement not covered" ></span>return spacesPadding(paddingLength)+numberString;}</span>
<span class="cstat-no" title="statement not covered" >Set.prototype.valuesArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Array.from(this.values());}</span>;<span class="cstat-no" title="statement not covered" >S</span>et.prototype.firstValue=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.size)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.values().next().value;}</span>;<span class="cstat-no" title="statement not covered" >Set.prototype.addAll=<span class="fstat-no" title="function not covered" >fu</span>nction(iterable){<span class="cstat-no" title="statement not covered" >for(const e of iterable)</span></span>
<span class="cstat-no" title="statement not covered" >this.add(e);}</span>;<span class="cstat-no" title="statement not covered" >Set.prototype.containsAll=<span class="fstat-no" title="function not covered" >fu</span>nction(iterable){<span class="cstat-no" title="statement not covered" >for(const e of iterable){<span class="cstat-no" title="statement not covered" >if(!this.has(e))</span></span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>;<span class="cstat-no" title="statement not covered" >Map.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(key){const value=<span class="cstat-no" title="statement not covered" >this.get(key);<span class="cstat-no" title="statement not covered" ></span>this.delete(key);<span class="cstat-no" title="statement not covered" >r</span>eturn value;}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.valuesArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Array.from(this.values());}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.keysArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Array.from(this.keys());}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.inverse=<span class="fstat-no" title="function not covered" >fu</span>nction(){const result=<span class="cstat-no" title="statement not covered" >new Multimap();<span class="cstat-no" title="statement not covered" ></span>for(const key of this.keys()){const value=<span class="cstat-no" title="statement not covered" >this.get(key);<span class="cstat-no" title="statement not covered" ></span>result.set(value,key);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;var Multimap=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._map=new Map();}</span>;<span class="cstat-no" title="statement not covered" ></span>Multimap.prototype={set:<span class="fstat-no" title="function not covered" >fu</span>nction(key,value){let set=<span class="cstat-no" title="statement not covered" >this._map.get(key);<span class="cstat-no" title="statement not covered" ></span>if(!set){<span class="cstat-no" title="statement not covered" >set=new Set();<span class="cstat-no" title="statement not covered" >t</span>his._map.set(key,set);}</span></span></span>
<span class="cstat-no" title="statement not covered" >set.add(value);}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >return this._map.get(key)||new Set();}</span>,has:<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >return this._map.has(key);}</span>,hasValue:<span class="fstat-no" title="function not covered" >fu</span>nction(key,value){const set=<span class="cstat-no" title="statement not covered" >this._map.get(key);<span class="cstat-no" title="statement not covered" ></span>if(!set)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn set.has(value);}</span>,get size(){<span class="cstat-no" title="statement not covered" >return this._map.size;}</span>,delete:<span class="fstat-no" title="function not covered" >fu</span>nction(key,value){const values=<span class="cstat-no" title="statement not covered" >this.get(key);<span class="cstat-no" title="statement not covered" ></span>if(!values)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst result=<span class="cstat-no" title="statement not covered" >values.delete(value);<span class="cstat-no" title="statement not covered" ></span>if(!values.size)</span>
<span class="cstat-no" title="statement not covered" >this._map.delete(key);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>,deleteAll:<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >this._map.delete(key);}</span>,keysArray:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._map.keysArray();}</span>,valuesArray:<span class="fstat-no" title="function not covered" >fu</span>nction(){const result=<span class="cstat-no" title="statement not covered" >[];</span>const keys=<span class="cstat-no" title="statement not covered" >this.keysArray();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;keys.length;++i)</span>
<span class="cstat-no" title="statement not covered" >result.pushAll(this.get(keys[i]).valuesArray());<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._map.clear();}</span>};function <span class="fstat-no" title="function not covered" >loadXHR(</span>url){<span class="cstat-no" title="statement not covered" >return new Promise(load);f</span>unction <span class="fstat-no" title="function not covered" >load(</span>successCallback,failureCallback){function <span class="fstat-no" title="function not covered" >onReadyStateChanged(</span>){<span class="cstat-no" title="statement not covered" >if(xhr.readyState!==XMLHttpRequest.DONE)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(xhr.status!==200){<span class="cstat-no" title="statement not covered" >xhr.onreadystatechange=null;<span class="cstat-no" title="statement not covered" >f</span>ailureCallback(new Error(xhr.status));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >xhr.onreadystatechange=null;<span class="cstat-no" title="statement not covered" >s</span>uccessCallback(xhr.responseText);}</span>
const xhr=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest();<span class="cstat-no" title="statement not covered" ></span>xhr.withCredentials=false;<span class="cstat-no" title="statement not covered" >x</span>hr.open('GET',url,true);<span class="cstat-no" title="statement not covered" >x</span>hr.onreadystatechange=onReadyStateChanged;<span class="cstat-no" title="statement not covered" >x</span>hr.send(null);}</span>}
function <span class="fstat-no" title="function not covered" >suppressUnused(</span>value){}
<span class="cstat-no" title="statement not covered" >self.setImmediate=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){const args=<span class="cstat-no" title="statement not covered" >[...arguments].slice(1);<span class="cstat-no" title="statement not covered" ></span>Promise.resolve().then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >callback(...args))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>;<span class="cstat-no" title="statement not covered" >P</span>romise.prototype.spread=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >return this.then(spreadPromise);f</span>unction <span class="fstat-no" title="function not covered" >spreadPromise(</span>arg){<span class="cstat-no" title="statement not covered" >return callback.apply(null,arg);}</span>};<span class="cstat-no" title="statement not covered" >P</span>romise.prototype.catchException=<span class="fstat-no" title="function not covered" >fu</span>nction(defaultValue){<span class="cstat-no" title="statement not covered" >return this.catch(<span class="fstat-no" title="function not covered" >fu</span>nction(error){<span class="cstat-no" title="statement not covered" >console.error(error);<span class="cstat-no" title="statement not covered" >r</span>eturn defaultValue;}</span>);}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.diff=<span class="fstat-no" title="function not covered" >fu</span>nction(other,isEqual){const leftKeys=<span class="cstat-no" title="statement not covered" >this.keysArray();</span>const rightKeys=<span class="cstat-no" title="statement not covered" >other.keysArray();<span class="cstat-no" title="statement not covered" ></span>leftKeys.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a-b)</span>;<span class="cstat-no" title="statement not covered" >r</span>ightKeys.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a-b)</span>;c</span>onst removed=<span class="cstat-no" title="statement not covered" >[];</span>const added=<span class="cstat-no" title="statement not covered" >[];</span>const equal=<span class="cstat-no" title="statement not covered" >[];</span>let leftIndex=<span class="cstat-no" title="statement not covered" >0;</span>let rightIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(leftIndex&lt;leftKeys.length&amp;&amp;rightIndex&lt;rightKeys.length){const leftKey=<span class="cstat-no" title="statement not covered" >leftKeys[leftIndex];</span>const rightKey=<span class="cstat-no" title="statement not covered" >rightKeys[rightIndex];<span class="cstat-no" title="statement not covered" ></span>if(leftKey===rightKey&amp;&amp;isEqual(this.get(leftKey),other.get(rightKey))){<span class="cstat-no" title="statement not covered" >equal.push(this.get(leftKey));<span class="cstat-no" title="statement not covered" >+</span>+leftIndex;<span class="cstat-no" title="statement not covered" >+</span>+rightIndex;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(leftKey&lt;=rightKey){<span class="cstat-no" title="statement not covered" >removed.push(this.get(leftKey));<span class="cstat-no" title="statement not covered" >+</span>+leftIndex;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >added.push(other.get(rightKey));<span class="cstat-no" title="statement not covered" >+</span>+rightIndex;}</span>
<span class="cstat-no" title="statement not covered" >while(leftIndex&lt;leftKeys.length){const leftKey=<span class="cstat-no" title="statement not covered" >leftKeys[leftIndex++];<span class="cstat-no" title="statement not covered" ></span>removed.push(this.get(leftKey));}</span></span>
<span class="cstat-no" title="statement not covered" >while(rightIndex&lt;rightKeys.length){const rightKey=<span class="cstat-no" title="statement not covered" >rightKeys[rightIndex++];<span class="cstat-no" title="statement not covered" ></span>added.push(other.get(rightKey));}</span></span>
<span class="cstat-no" title="statement not covered" >return{added:added,removed:removed,equal:equal};}</span>;function <span class="fstat-no" title="function not covered" >runOnWindowLoad(</span>callback){function <span class="fstat-no" title="function not covered" >windowLoaded(</span>){<span class="cstat-no" title="statement not covered" >self.removeEventListener('DOMContentLoaded',windowLoaded,false);<span class="cstat-no" title="statement not covered" >c</span>allback();}</span>
<span class="cstat-no" title="statement not covered" >if(document.readyState==='complete'||document.readyState==='interactive')</span>
<span class="cstat-no" title="statement not covered" >callback();e</span>lse
<span class="cstat-no" title="statement not covered" >self.addEventListener('DOMContentLoaded',windowLoaded,false);}</span>
const _singletonSymbol=<span class="cstat-no" title="statement not covered" >Symbol('singleton');</span>function <span class="fstat-no" title="function not covered" >singleton(</span>constructorFunction){<span class="cstat-no" title="statement not covered" >if(_singletonSymbol in constructorFunction)</span>
<span class="cstat-no" title="statement not covered" >return constructorFunction[_singletonSymbol];c</span>onst instance=<span class="cstat-no" title="statement not covered" >new constructorFunction();<span class="cstat-no" title="statement not covered" ></span>constructorFunction[_singletonSymbol]=instance;<span class="cstat-no" title="statement not covered" >r</span>eturn instance;}</span>;<span class="cstat-no" title="statement not covered" >self['TextUtils']=self['TextUtils']||{};<span class="cstat-no" title="statement not covered" >T</span>extUtils.Text=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(value){<span class="cstat-no" title="statement not covered" >this._value=value;}</span></span>
<span class="fstat-no" title="function not covered" >li</span>neEndings(){<span class="cstat-no" title="statement not covered" >if(!this._lineEndings)</span>
<span class="cstat-no" title="statement not covered" >this._lineEndings=this._value.computeLineEndings();<span class="cstat-no" title="statement not covered" >r</span>eturn this._lineEndings;}</span>
<span class="fstat-no" title="function not covered" >va</span>lue(){<span class="cstat-no" title="statement not covered" >return this._value;}</span>
<span class="fstat-no" title="function not covered" >li</span>neCount(){const lineEndings=<span class="cstat-no" title="statement not covered" >this.lineEndings();<span class="cstat-no" title="statement not covered" ></span>return lineEndings.length;}</span>
<span class="fstat-no" title="function not covered" >of</span>fsetFromPosition(lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >return(lineNumber?this.lineEndings()[lineNumber-1]+1:0)+columnNumber;}</span>
<span class="fstat-no" title="function not covered" >po</span>sitionFromOffset(offset){const lineEndings=<span class="cstat-no" title="statement not covered" >this.lineEndings();</span>const lineNumber=<span class="cstat-no" title="statement not covered" >lineEndings.lowerBound(offset);<span class="cstat-no" title="statement not covered" ></span>return{lineNumber:lineNumber,columnNumber:offset-(lineNumber&amp;&amp;(lineEndings[lineNumber-1]+1))};}</span>
<span class="fstat-no" title="function not covered" >li</span>neAt(lineNumber){const lineEndings=<span class="cstat-no" title="statement not covered" >this.lineEndings();</span>const lineStart=<span class="cstat-no" title="statement not covered" >lineNumber&gt;0?lineEndings[lineNumber-1]+1:0;</span>const lineEnd=<span class="cstat-no" title="statement not covered" >lineEndings[lineNumber];</span>let lineContent=<span class="cstat-no" title="statement not covered" >this._value.substring(lineStart,lineEnd);<span class="cstat-no" title="statement not covered" ></span>if(lineContent.length&gt;0&amp;&amp;lineContent.charAt(lineContent.length-1)==='\r')</span>
<span class="cstat-no" title="statement not covered" >lineContent=lineContent.substring(0,lineContent.length-1);<span class="cstat-no" title="statement not covered" >r</span>eturn lineContent;}</span>
<span class="fstat-no" title="function not covered" >to</span>SourceRange(range){const start=<span class="cstat-no" title="statement not covered" >this.offsetFromPosition(range.startLine,range.startColumn);</span>const end=<span class="cstat-no" title="statement not covered" >this.offsetFromPosition(range.endLine,range.endColumn);<span class="cstat-no" title="statement not covered" ></span>return new TextUtils.SourceRange(start,end-start);}</span>
<span class="fstat-no" title="function not covered" >to</span>TextRange(sourceRange){const cursor=<span class="cstat-no" title="statement not covered" >new TextUtils.TextCursor(this.lineEndings());</span>const result=<span class="cstat-no" title="statement not covered" >TextUtils.TextRange.createFromLocation(0,0);<span class="cstat-no" title="statement not covered" ></span>cursor.resetTo(sourceRange.offset);<span class="cstat-no" title="statement not covered" >r</span>esult.startLine=cursor.lineNumber();<span class="cstat-no" title="statement not covered" >r</span>esult.startColumn=cursor.columnNumber();<span class="cstat-no" title="statement not covered" >c</span>ursor.advance(sourceRange.offset+sourceRange.length);<span class="cstat-no" title="statement not covered" >r</span>esult.endLine=cursor.lineNumber();<span class="cstat-no" title="statement not covered" >r</span>esult.endColumn=cursor.columnNumber();<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >re</span>placeRange(range,replacement){const sourceRange=<span class="cstat-no" title="statement not covered" >this.toSourceRange(range);<span class="cstat-no" title="statement not covered" ></span>return this._value.substring(0,sourceRange.offset)+replacement+</span>
this._value.substring(sourceRange.offset+sourceRange.length);}
<span class="fstat-no" title="function not covered" >ex</span>tract(range){const sourceRange=<span class="cstat-no" title="statement not covered" >this.toSourceRange(range);<span class="cstat-no" title="statement not covered" ></span>return this._value.substr(sourceRange.offset,sourceRange.length);}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.Text.Position;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextCursor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(lineEndings){<span class="cstat-no" title="statement not covered" >this._lineEndings=lineEndings;<span class="cstat-no" title="statement not covered" >t</span>his._offset=0;<span class="cstat-no" title="statement not covered" >t</span>his._lineNumber=0;<span class="cstat-no" title="statement not covered" >t</span>his._columnNumber=0;}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>vance(offset){<span class="cstat-no" title="statement not covered" >this._offset=offset;<span class="cstat-no" title="statement not covered" >w</span>hile(this._lineNumber&lt;this._lineEndings.length&amp;&amp;this._lineEndings[this._lineNumber]&lt;this._offset)</span>
<span class="cstat-no" title="statement not covered" >++this._lineNumber;<span class="cstat-no" title="statement not covered" >t</span>his._columnNumber=this._lineNumber?this._offset-this._lineEndings[this._lineNumber-1]-1:this._offset;}</span>
<span class="fstat-no" title="function not covered" >of</span>fset(){<span class="cstat-no" title="statement not covered" >return this._offset;}</span>
<span class="fstat-no" title="function not covered" >re</span>setTo(offset){<span class="cstat-no" title="statement not covered" >this._offset=offset;<span class="cstat-no" title="statement not covered" >t</span>his._lineNumber=this._lineEndings.lowerBound(offset);<span class="cstat-no" title="statement not covered" >t</span>his._columnNumber=this._lineNumber?this._offset-this._lineEndings[this._lineNumber-1]-1:this._offset;}</span>
<span class="fstat-no" title="function not covered" >li</span>neNumber(){<span class="cstat-no" title="statement not covered" >return this._lineNumber;}</span>
<span class="fstat-no" title="function not covered" >co</span>lumnNumber(){<span class="cstat-no" title="statement not covered" >return this._columnNumber;}</span>};;<span class="cstat-no" title="statement not covered" >TextUtils.TextUtils={isStopChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return(char&gt;' '&amp;&amp;char&lt;'0')||(char&gt;'9'&amp;&amp;char&lt;'A')||(char&gt;'Z'&amp;&amp;char&lt;'_')||(char&gt;'_'&amp;&amp;char&lt;'a')||(char&gt;'z'&amp;&amp;char&lt;='~');}</span>,isWordChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return!TextUtils.TextUtils.isStopChar(char)&amp;&amp;!TextUtils.TextUtils.isSpaceChar(char);}</span>,isSpaceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return TextUtils.TextUtils._SpaceCharRegex.test(char);}</span>,isWord:<span class="fstat-no" title="function not covered" >fu</span>nction(word){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;word.length;++i){<span class="cstat-no" title="statement not covered" >if(!TextUtils.TextUtils.isWordChar(word.charAt(i)))</span></span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>,isOpeningBraceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return char==='('||char==='{';}</span>,isClosingBraceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return char===')'||char==='}';}</span>,isBraceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return TextUtils.TextUtils.isOpeningBraceChar(char)||TextUtils.TextUtils.isClosingBraceChar(char);}</span>,textToWords:<span class="fstat-no" title="function not covered" >fu</span>nction(text,isWordChar,wordCallback){let startWord=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;text.length;++i){<span class="cstat-no" title="statement not covered" >if(!isWordChar(text.charAt(i))){<span class="cstat-no" title="statement not covered" >if(startWord!==-1)</span></span></span>
<span class="cstat-no" title="statement not covered" >wordCallback(text.substring(startWord,i));<span class="cstat-no" title="statement not covered" >s</span>tartWord=-1;}</span>else <span class="cstat-no" title="statement not covered" >if(startWord===-1){<span class="cstat-no" title="statement not covered" >startWord=i;}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(startWord!==-1)</span>
<span class="cstat-no" title="statement not covered" >wordCallback(text.substring(startWord));}</span>,lineIndent:<span class="fstat-no" title="function not covered" >fu</span>nction(line){let indentation=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(indentation&lt;line.length&amp;&amp;TextUtils.TextUtils.isSpaceChar(line.charAt(indentation)))</span>
<span class="cstat-no" title="statement not covered" >++indentation;<span class="cstat-no" title="statement not covered" >r</span>eturn line.substr(0,indentation);}</span>,isUpperCase:<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >return text===text.toUpperCase();}</span>,isLowerCase:<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >return text===text.toLowerCase();}</span>,splitStringByRegexes(text,regexes){const matches=<span class="cstat-no" title="statement not covered" >[];</span>const globalRegexes=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;regexes.length;i++){const regex=<span class="cstat-no" title="statement not covered" >regexes[i];<span class="cstat-no" title="statement not covered" ></span>if(!regex.global)</span></span>
<span class="cstat-no" title="statement not covered" >globalRegexes.push(new RegExp(regex.source,regex.flags?regex.flags+'g':'g'));e</span>lse
<span class="cstat-no" title="statement not covered" >globalRegexes.push(regex);}</span>
<span class="cstat-no" title="statement not covered" >doSplit(text,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn matches;f</span>unction <span class="fstat-no" title="function not covered" >doSplit(</span>text,regexIndex,startIndex){<span class="cstat-no" title="statement not covered" >if(regexIndex&gt;=globalRegexes.length){<span class="cstat-no" title="statement not covered" >matches.push({value:text,position:startIndex,regexIndex:-1,captureGroups:[]});<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const regex=<span class="cstat-no" title="statement not covered" >globalRegexes[regexIndex];</span>let currentIndex=<span class="cstat-no" title="statement not covered" >0;</span>let result;<span class="cstat-no" title="statement not covered" >regex.lastIndex=0;<span class="cstat-no" title="statement not covered" >w</span>hile((result=regex.exec(text))!==null){const stringBeforeMatch=<span class="cstat-no" title="statement not covered" >text.substring(currentIndex,result.index);<span class="cstat-no" title="statement not covered" ></span>if(stringBeforeMatch)</span></span>
<span class="cstat-no" title="statement not covered" >doSplit(stringBeforeMatch,regexIndex+1,startIndex+currentIndex);c</span>onst match=<span class="cstat-no" title="statement not covered" >result[0];<span class="cstat-no" title="statement not covered" ></span>matches.push({value:match,position:startIndex+result.index,regexIndex:regexIndex,captureGroups:result.slice(1)});<span class="cstat-no" title="statement not covered" >c</span>urrentIndex=result.index+match.length;}</span>
const stringAfterMatches=<span class="cstat-no" title="statement not covered" >text.substring(currentIndex);<span class="cstat-no" title="statement not covered" ></span>if(stringAfterMatches)</span>
<span class="cstat-no" title="statement not covered" >doSplit(stringAfterMatches,regexIndex+1,startIndex+currentIndex);}</span>}};<span class="cstat-no" title="statement not covered" >TextUtils.FilterParser=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(keys){<span class="cstat-no" title="statement not covered" >this._keys=keys;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic cloneFilter(filter){<span class="cstat-no" title="statement not covered" >return{key:filter.key,text:filter.text,regex:filter.regex,negative:filter.negative};}</span>
<span class="fstat-no" title="function not covered" >pa</span>rse(query){const splitResult=<span class="cstat-no" title="statement not covered" >TextUtils.TextUtils.splitStringByRegexes(query,[TextUtils.TextUtils._keyValueFilterRegex,TextUtils.TextUtils._regexFilterRegex,TextUtils.TextUtils._textFilterRegex]);</span>const filters=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;splitResult.length;i++){const regexIndex=<span class="cstat-no" title="statement not covered" >splitResult[i].regexIndex;<span class="cstat-no" title="statement not covered" ></span>if(regexIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst result=<span class="cstat-no" title="statement not covered" >splitResult[i].captureGroups;<span class="cstat-no" title="statement not covered" ></span>if(regexIndex===0){<span class="cstat-no" title="statement not covered" >if(this._keys.indexOf((result[1]))!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >filters.push({key:result[1],text:result[2],negative:!!result[0]});e</span>lse
<span class="cstat-no" title="statement not covered" >filters.push({text:result[1]+':'+result[2],negative:!!result[0]});}</span>else <span class="cstat-no" title="statement not covered" >if(regexIndex===1){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >filters.push({regex:new RegExp(result[1],'i'),negative:!!result[0]});}</span>catch(e){<span class="cstat-no" title="statement not covered" >filters.push({text:'/'+result[1]+'/',negative:!!result[0]});}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(regexIndex===2){<span class="cstat-no" title="statement not covered" >filters.push({text:result[1],negative:!!result[0]});}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return filters;}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.FilterParser.ParsedFilter;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._keyValueFilterRegex=/(?:^|\s)(\-)?([\w\-]+):([^\s]+)/;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._regexFilterRegex=/(?:^|\s)(\-)?\/([^\s]+)\//;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._textFilterRegex=/(?:^|\s)(\-)?([^\s]+)/;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._SpaceCharRegex=/\s/;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils.Indent={TwoSpaces:'  ',FourSpaces:'    ',EightSpaces:'        ',TabCharacter:'\t'};<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils.BalancedJSONTokenizer=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(callback,findMultiple){<span class="cstat-no" title="statement not covered" >this._callback=callback;<span class="cstat-no" title="statement not covered" >t</span>his._index=0;<span class="cstat-no" title="statement not covered" >t</span>his._balance=0;<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';<span class="cstat-no" title="statement not covered" >t</span>his._findMultiple=findMultiple||false;<span class="cstat-no" title="statement not covered" >t</span>his._closingDoubleQuoteRegex=/[^\\](?:\\\\)*"/g;}</span></span>
<span class="fstat-no" title="function not covered" >wr</span>ite(chunk){<span class="cstat-no" title="statement not covered" >this._buffer+=chunk;c</span>onst lastIndex=<span class="cstat-no" title="statement not covered" >this._buffer.length;</span>const buffer=<span class="cstat-no" title="statement not covered" >this._buffer;</span>let index;<span class="cstat-no" title="statement not covered" >for(index=this._index;index&lt;lastIndex;++index){const character=<span class="cstat-no" title="statement not covered" >buffer[index];<span class="cstat-no" title="statement not covered" ></span>if(character==='"'){<span class="cstat-no" title="statement not covered" >this._closingDoubleQuoteRegex.lastIndex=index;<span class="cstat-no" title="statement not covered" >i</span>f(!this._closingDoubleQuoteRegex.test(buffer))</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>ndex=this._closingDoubleQuoteRegex.lastIndex-1;}</span>else <span class="cstat-no" title="statement not covered" >if(character==='{'){<span class="cstat-no" title="statement not covered" >++this._balance;}</span>else <span class="cstat-no" title="statement not covered" >if(character==='}'){<span class="cstat-no" title="statement not covered" >--this._balance;<span class="cstat-no" title="statement not covered" >i</span>f(this._balance&lt;0){<span class="cstat-no" title="statement not covered" >this._reportBalanced();<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(!this._balance){<span class="cstat-no" title="statement not covered" >this._lastBalancedIndex=index+1;<span class="cstat-no" title="statement not covered" >i</span>f(!this._findMultiple)</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>}else <span class="cstat-no" title="statement not covered" >if(character===']'&amp;&amp;!this._balance){<span class="cstat-no" title="statement not covered" >this._reportBalanced();<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>}</span>
<span class="cstat-no" title="statement not covered" >this._index=index;<span class="cstat-no" title="statement not covered" >t</span>his._reportBalanced();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_r</span>eportBalanced(){<span class="cstat-no" title="statement not covered" >if(!this._lastBalancedIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._callback(this._buffer.slice(0,this._lastBalancedIndex));<span class="cstat-no" title="statement not covered" >t</span>his._buffer=this._buffer.slice(this._lastBalancedIndex);<span class="cstat-no" title="statement not covered" >t</span>his._index-=this._lastBalancedIndex;<span class="cstat-no" title="statement not covered" >t</span>his._lastBalancedIndex=0;}</span>
<span class="fstat-no" title="function not covered" >re</span>mainder(){<span class="cstat-no" title="statement not covered" >return this._buffer;}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.TokenizerFactory=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >T</span>extUtils.TokenizerFactory.prototype={createTokenizer(mimeType){}};<span class="cstat-no" title="statement not covered" >T</span>extUtils.isMinified=<span class="fstat-no" title="function not covered" >fu</span>nction(text){const kMaxNonMinifiedLength=<span class="cstat-no" title="statement not covered" >500;</span>let linesToCheck=<span class="cstat-no" title="statement not covered" >10;</span>let lastPosition=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>do{let eolIndex=<span class="cstat-no" title="statement not covered" >text.indexOf('\n',lastPosition);<span class="cstat-no" title="statement not covered" ></span>if(eolIndex&lt;0)</span></span></span>
<span class="cstat-no" title="statement not covered" >eolIndex=text.length;<span class="cstat-no" title="statement not covered" >i</span>f(eolIndex-lastPosition&gt;kMaxNonMinifiedLength&amp;&amp;text.substr(lastPosition,3)!=='//#')</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >l</span>astPosition=eolIndex+1;}</span>while(--linesToCheck&gt;=0&amp;&amp;lastPosition&lt;text.length);<span class="cstat-no" title="statement not covered" >linesToCheck=10;<span class="cstat-no" title="statement not covered" >l</span>astPosition=text.length;<span class="cstat-no" title="statement not covered" >d</span>o{let eolIndex=<span class="cstat-no" title="statement not covered" >text.lastIndexOf('\n',lastPosition);<span class="cstat-no" title="statement not covered" ></span>if(eolIndex&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >eolIndex=0;<span class="cstat-no" title="statement not covered" >i</span>f(lastPosition-eolIndex&gt;kMaxNonMinifiedLength&amp;&amp;text.substr(lastPosition,3)!=='//#')</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >l</span>astPosition=eolIndex-1;}</span>while(--linesToCheck&gt;=0&amp;&amp;lastPosition&gt;0);<span class="cstat-no" title="statement not covered" >return false;}</span>;;<span class="cstat-no" title="statement not covered" >TextUtils.TextRange=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(startLine,startColumn,endLine,endColumn){<span class="cstat-no" title="statement not covered" >this.startLine=startLine;<span class="cstat-no" title="statement not covered" >t</span>his.startColumn=startColumn;<span class="cstat-no" title="statement not covered" >t</span>his.endLine=endLine;<span class="cstat-no" title="statement not covered" >t</span>his.endColumn=endColumn;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic createFromLocation(line,column){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(line,column,line,column);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromObject(serializedTextRange){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(serializedTextRange.startLine,serializedTextRange.startColumn,serializedTextRange.endLine,serializedTextRange.endColumn);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic comparator(range1,range2){<span class="cstat-no" title="statement not covered" >return range1.compareTo(range2);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromEdit(oldRange,newText){let endLine=<span class="cstat-no" title="statement not covered" >oldRange.startLine;</span>let endColumn=<span class="cstat-no" title="statement not covered" >oldRange.startColumn+newText.length;</span>const lineEndings=<span class="cstat-no" title="statement not covered" >newText.computeLineEndings();<span class="cstat-no" title="statement not covered" ></span>if(lineEndings.length&gt;1){<span class="cstat-no" title="statement not covered" >endLine=oldRange.startLine+lineEndings.length-1;c</span>onst len=<span class="cstat-no" title="statement not covered" >lineEndings.length;<span class="cstat-no" title="statement not covered" ></span>endColumn=lineEndings[len-1]-lineEndings[len-2]-1;}</span></span>
<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(oldRange.startLine,oldRange.startColumn,endLine,endColumn);}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this.startLine===this.endLine&amp;&amp;this.startColumn===this.endColumn;}</span>
<span class="fstat-no" title="function not covered" >im</span>mediatelyPrecedes(range){<span class="cstat-no" title="statement not covered" >if(!range)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn this.endLine===range.startLine&amp;&amp;this.endColumn===range.startColumn;}</span>
<span class="fstat-no" title="function not covered" >im</span>mediatelyFollows(range){<span class="cstat-no" title="statement not covered" >if(!range)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn range.immediatelyPrecedes(this);}</span>
<span class="fstat-no" title="function not covered" >fo</span>llows(range){<span class="cstat-no" title="statement not covered" >return(range.endLine===this.startLine&amp;&amp;range.endColumn&lt;=this.startColumn)||range.endLine&lt;this.startLine;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t linesCount(){<span class="cstat-no" title="statement not covered" >return this.endLine-this.startLine;}</span>
<span class="fstat-no" title="function not covered" >co</span>llapseToEnd(){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.endLine,this.endColumn,this.endLine,this.endColumn);}</span>
<span class="fstat-no" title="function not covered" >co</span>llapseToStart(){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.startLine,this.startColumn,this.startLine,this.startColumn);}</span>
<span class="fstat-no" title="function not covered" >no</span>rmalize(){<span class="cstat-no" title="statement not covered" >if(this.startLine&gt;this.endLine||(this.startLine===this.endLine&amp;&amp;this.startColumn&gt;this.endColumn))</span>
<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.endLine,this.endColumn,this.startLine,this.startColumn);e</span>lse
<span class="cstat-no" title="statement not covered" >return this.clone();}</span>
<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.startLine,this.startColumn,this.endLine,this.endColumn);}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeToObject(){const serializedTextRange=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>serializedTextRange.startLine=this.startLine;<span class="cstat-no" title="statement not covered" >s</span>erializedTextRange.startColumn=this.startColumn;<span class="cstat-no" title="statement not covered" >s</span>erializedTextRange.endLine=this.endLine;<span class="cstat-no" title="statement not covered" >s</span>erializedTextRange.endColumn=this.endColumn;<span class="cstat-no" title="statement not covered" >r</span>eturn serializedTextRange;}</span>
<span class="fstat-no" title="function not covered" >co</span>mpareTo(other){<span class="cstat-no" title="statement not covered" >if(this.startLine&gt;other.startLine)</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(this.startLine&lt;other.startLine)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(this.startColumn&gt;other.startColumn)</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(this.startColumn&lt;other.startColumn)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>
<span class="fstat-no" title="function not covered" >co</span>mpareToPosition(lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >if(lineNumber&lt;this.startLine||(lineNumber===this.startLine&amp;&amp;columnNumber&lt;this.startColumn))</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(lineNumber&gt;this.endLine||(lineNumber===this.endLine&amp;&amp;columnNumber&gt;this.endColumn))</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>
<span class="fstat-no" title="function not covered" >eq</span>ual(other){<span class="cstat-no" title="statement not covered" >return this.startLine===other.startLine&amp;&amp;this.endLine===other.endLine&amp;&amp;this.startColumn===other.startColumn&amp;&amp;this.endColumn===other.endColumn;}</span>
<span class="fstat-no" title="function not covered" >re</span>lativeTo(line,column){const relative=<span class="cstat-no" title="statement not covered" >this.clone();<span class="cstat-no" title="statement not covered" ></span>if(this.startLine===line)</span>
<span class="cstat-no" title="statement not covered" >relative.startColumn-=column;<span class="cstat-no" title="statement not covered" >i</span>f(this.endLine===line)</span>
<span class="cstat-no" title="statement not covered" >relative.endColumn-=column;<span class="cstat-no" title="statement not covered" >r</span>elative.startLine-=line;<span class="cstat-no" title="statement not covered" >r</span>elative.endLine-=line;<span class="cstat-no" title="statement not covered" >r</span>eturn relative;}</span>
<span class="fstat-no" title="function not covered" >re</span>lativeFrom(line,column){const relative=<span class="cstat-no" title="statement not covered" >this.clone();<span class="cstat-no" title="statement not covered" ></span>if(this.startLine===0)</span>
<span class="cstat-no" title="statement not covered" >relative.startColumn+=column;<span class="cstat-no" title="statement not covered" >i</span>f(this.endLine===0)</span>
<span class="cstat-no" title="statement not covered" >relative.endColumn+=column;<span class="cstat-no" title="statement not covered" >r</span>elative.startLine+=line;<span class="cstat-no" title="statement not covered" >r</span>elative.endLine+=line;<span class="cstat-no" title="statement not covered" >r</span>eturn relative;}</span>
<span class="fstat-no" title="function not covered" >re</span>baseAfterTextEdit(originalRange,editedRange){<span class="cstat-no" title="statement not covered" >console.assert(originalRange.startLine===editedRange.startLine);<span class="cstat-no" title="statement not covered" >c</span>onsole.assert(originalRange.startColumn===editedRange.startColumn);c</span>onst rebase=<span class="cstat-no" title="statement not covered" >this.clone();<span class="cstat-no" title="statement not covered" ></span>if(!this.follows(originalRange))</span>
<span class="cstat-no" title="statement not covered" >return rebase;c</span>onst lineDelta=<span class="cstat-no" title="statement not covered" >editedRange.endLine-originalRange.endLine;</span>const columnDelta=<span class="cstat-no" title="statement not covered" >editedRange.endColumn-originalRange.endColumn;<span class="cstat-no" title="statement not covered" ></span>rebase.startLine+=lineDelta;<span class="cstat-no" title="statement not covered" >r</span>ebase.endLine+=lineDelta;<span class="cstat-no" title="statement not covered" >i</span>f(rebase.startLine===editedRange.endLine)</span>
<span class="cstat-no" title="statement not covered" >rebase.startColumn+=columnDelta;<span class="cstat-no" title="statement not covered" >i</span>f(rebase.endLine===editedRange.endLine)</span>
<span class="cstat-no" title="statement not covered" >rebase.endColumn+=columnDelta;<span class="cstat-no" title="statement not covered" >r</span>eturn rebase;}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return JSON.stringify(this);}</span>
<span class="fstat-no" title="function not covered" >co</span>ntainsLocation(lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >if(this.startLine===this.endLine)</span>
<span class="cstat-no" title="statement not covered" >return this.startLine===lineNumber&amp;&amp;this.startColumn&lt;=columnNumber&amp;&amp;columnNumber&lt;=this.endColumn;<span class="cstat-no" title="statement not covered" >i</span>f(this.startLine===lineNumber)</span>
<span class="cstat-no" title="statement not covered" >return this.startColumn&lt;=columnNumber;<span class="cstat-no" title="statement not covered" >i</span>f(this.endLine===lineNumber)</span>
<span class="cstat-no" title="statement not covered" >return columnNumber&lt;=this.endColumn;<span class="cstat-no" title="statement not covered" >r</span>eturn this.startLine&lt;lineNumber&amp;&amp;lineNumber&lt;this.endLine;}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.SourceRange=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(offset,length){<span class="cstat-no" title="statement not covered" >this.offset=offset;<span class="cstat-no" title="statement not covered" >t</span>his.length=length;}</span>};<span class="cstat-no" title="statement not covered" >T</span>extUtils.SourceEdit=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(sourceURL,oldRange,newText){<span class="cstat-no" title="statement not covered" >this.sourceURL=sourceURL;<span class="cstat-no" title="statement not covered" >t</span>his.oldRange=oldRange;<span class="cstat-no" title="statement not covered" >t</span>his.newText=newText;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic comparator(edit1,edit2){<span class="cstat-no" title="statement not covered" >return TextUtils.TextRange.comparator(edit1.oldRange,edit2.oldRange);}</span>
<span class="fstat-no" title="function not covered" >ne</span>wRange(){<span class="cstat-no" title="statement not covered" >return TextUtils.TextRange.fromEdit(this.oldRange,this.newText);}</span>};;<span class="cstat-no" title="statement not covered" >self['Common']=self['Common']||{};<span class="cstat-no" title="statement not covered" >C</span>ommon.Worker=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(appName){let url=<span class="cstat-no" title="statement not covered" >appName+'.js';<span class="cstat-no" title="statement not covered" ></span>url+=Runtime.queryParamsString();<span class="cstat-no" title="statement not covered" >t</span>his._workerPromise=new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfill=&gt;{<span class="cstat-no" title="statement not covered" >this._worker=new Worker(url);<span class="cstat-no" title="statement not covered" >t</span>his._worker.onmessage=onMessage.bind(this);f</span>unction <span class="fstat-no" title="function not covered" >onMessage(</span>event){<span class="cstat-no" title="statement not covered" >console.assert(event.data==='workerReady');<span class="cstat-no" title="statement not covered" >t</span>his._worker.onmessage=null;<span class="cstat-no" title="statement not covered" >f</span>ulfill(this._worker);<span class="cstat-no" title="statement not covered" >t</span>his._worker=null;}</span>});}</span></span>
<span class="fstat-no" title="function not covered" >po</span>stMessage(message){<span class="cstat-no" title="statement not covered" >this._workerPromise.then(<span class="fstat-no" title="function not covered" >wo</span>rker=&gt;{<span class="cstat-no" title="statement not covered" >if(!this._disposed)</span></span>
<span class="cstat-no" title="statement not covered" >worker.postMessage(message);}</span>);}
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._disposed=true;<span class="cstat-no" title="statement not covered" >t</span>his._workerPromise.then(<span class="fstat-no" title="function not covered" >wo</span>rker=&gt;<span class="cstat-no" title="statement not covered" >worker.terminate())</span>;}</span>
<span class="fstat-no" title="function not covered" >te</span>rminate(){<span class="cstat-no" title="statement not covered" >this.dispose();}</span>
<span class="fstat-no" title="function not covered" >se</span>t onmessage(listener){<span class="cstat-no" title="statement not covered" >this._workerPromise.then(<span class="fstat-no" title="function not covered" >wo</span>rker=&gt;<span class="cstat-no" title="statement not covered" >worker.onmessage=listener)</span>;}</span>
<span class="fstat-no" title="function not covered" >se</span>t onerror(listener){<span class="cstat-no" title="statement not covered" >this._workerPromise.then(<span class="fstat-no" title="function not covered" >wo</span>rker=&gt;<span class="cstat-no" title="statement not covered" >worker.onerror=listener)</span>;}</span>};;<span class="cstat-no" title="statement not covered" >Common.TextDictionary=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._words=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._index=new Common.Trie();}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dWord(word){let count=<span class="cstat-no" title="statement not covered" >this._words.get(word)||0;<span class="cstat-no" title="statement not covered" ></span>++count;<span class="cstat-no" title="statement not covered" >t</span>his._words.set(word,count);<span class="cstat-no" title="statement not covered" >t</span>his._index.add(word);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveWord(word){let count=<span class="cstat-no" title="statement not covered" >this._words.get(word)||0;<span class="cstat-no" title="statement not covered" ></span>if(!count)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(count===1){<span class="cstat-no" title="statement not covered" >this._words.delete(word);<span class="cstat-no" title="statement not covered" >t</span>his._index.remove(word);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >--count;<span class="cstat-no" title="statement not covered" >t</span>his._words.set(word,count);}</span>
<span class="fstat-no" title="function not covered" >wo</span>rdsWithPrefix(prefix){<span class="cstat-no" title="statement not covered" >return this._index.words(prefix);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sWord(word){<span class="cstat-no" title="statement not covered" >return this._words.has(word);}</span>
<span class="fstat-no" title="function not covered" >wo</span>rdCount(word){<span class="cstat-no" title="statement not covered" >return this._words.get(word)||0;}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._words.clear();<span class="cstat-no" title="statement not covered" >t</span>his._index.clear();}</span>};;<span class="cstat-no" title="statement not covered" >Common.Object=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._listeners;}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dEventListener(eventType,listener,thisObject){<span class="cstat-no" title="statement not covered" >if(!listener)</span>
<span class="cstat-no" title="statement not covered" >console.assert(false);<span class="cstat-no" title="statement not covered" >i</span>f(!this._listeners)</span>
<span class="cstat-no" title="statement not covered" >this._listeners=new Map();<span class="cstat-no" title="statement not covered" >i</span>f(!this._listeners.has(eventType))</span>
<span class="cstat-no" title="statement not covered" >this._listeners.set(eventType,[]);<span class="cstat-no" title="statement not covered" >t</span>his._listeners.get(eventType).push({thisObject:thisObject,listener:listener});<span class="cstat-no" title="statement not covered" >r</span>eturn{eventTarget:this,eventType:eventType,thisObject:thisObject,listener:listener};}</span>
<span class="fstat-no" title="function not covered" >on</span>ce(eventType){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;{const descriptor=<span class="cstat-no" title="statement not covered" >this.addEventListener(eventType,<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;{<span class="cstat-no" title="statement not covered" >this.removeEventListener(eventType,descriptor.listener);<span class="cstat-no" title="statement not covered" >r</span>esolve(event.data);}</span>);</span>});}</span>
<span class="fstat-no" title="function not covered" >re</span>moveEventListener(eventType,listener,thisObject){<span class="cstat-no" title="statement not covered" >console.assert(listener);<span class="cstat-no" title="statement not covered" >i</span>f(!this._listeners||!this._listeners.has(eventType))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst listeners=<span class="cstat-no" title="statement not covered" >this._listeners.get(eventType);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;listeners.length;++i){<span class="cstat-no" title="statement not covered" >if(listeners[i].listener===listener&amp;&amp;listeners[i].thisObject===thisObject){<span class="cstat-no" title="statement not covered" >listeners[i].disposed=true;<span class="cstat-no" title="statement not covered" >l</span>isteners.splice(i--,1);}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(!listeners.length)</span>
<span class="cstat-no" title="statement not covered" >this._listeners.delete(eventType);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sEventListeners(eventType){<span class="cstat-no" title="statement not covered" >return!!(this._listeners&amp;&amp;this._listeners.has(eventType));}</span>
<span class="fstat-no" title="function not covered" >di</span>spatchEventToListeners(eventType,eventData){<span class="cstat-no" title="statement not covered" >if(!this._listeners||!this._listeners.has(eventType))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst event=(<span class="cstat-no" title="statement not covered" >{data:eventData})</span>;const listeners=<span class="cstat-no" title="statement not covered" >this._listeners.get(eventType).slice(0);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;listeners.length;++i){<span class="cstat-no" title="statement not covered" >if(!listeners[i].disposed)</span></span>
<span class="cstat-no" title="statement not covered" >listeners[i].listener.call(listeners[i].thisObject,event);}</span>}};<span class="cstat-no" title="statement not covered" >Common.Event;<span class="cstat-no" title="statement not covered" >C</span>ommon.Object._listenerCallbackTuple;<span class="cstat-no" title="statement not covered" >C</span>ommon.EventTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.EventTarget.EventDescriptor;<span class="cstat-no" title="statement not covered" >C</span>ommon.EventTarget.removeEventListeners=<span class="fstat-no" title="function not covered" >fu</span>nction(eventList){<span class="cstat-no" title="statement not covered" >for(const eventInfo of eventList)</span></span>
<span class="cstat-no" title="statement not covered" >eventInfo.eventTarget.removeEventListener(eventInfo.eventType,eventInfo.listener,eventInfo.thisObject);<span class="cstat-no" title="statement not covered" >e</span>ventList.splice(0);}</span>;<span class="cstat-no" title="statement not covered" >Common.EventTarget.prototype={addEventListener(eventType,listener,thisObject){},once(eventType){},removeEventListener(eventType,listener,thisObject){},hasEventListeners(eventType){},dispatchEventToListeners(eventType,eventData){},};;<span class="cstat-no" title="statement not covered" ></span>Common.Color=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(rgba,format,originalText){<span class="cstat-no" title="statement not covered" >this._rgba=rgba;<span class="cstat-no" title="statement not covered" >t</span>his._originalText=originalText||null;<span class="cstat-no" title="statement not covered" >t</span>his._originalTextIsValid=!!this._originalText;<span class="cstat-no" title="statement not covered" >t</span>his._format=format;<span class="cstat-no" title="statement not covered" >i</span>f(typeof this._rgba[3]==='undefined')</span></span>
<span class="cstat-no" title="statement not covered" >this._rgba[3]=1;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;4;++i){<span class="cstat-no" title="statement not covered" >if(this._rgba[i]&lt;0){<span class="cstat-no" title="statement not covered" >this._rgba[i]=0;<span class="cstat-no" title="statement not covered" >t</span>his._originalTextIsValid=false;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this._rgba[i]&gt;1){<span class="cstat-no" title="statement not covered" >this._rgba[i]=1;<span class="cstat-no" title="statement not covered" >t</span>his._originalTextIsValid=false;}</span>}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic parse(text){const value=<span class="cstat-no" title="statement not covered" >text.toLowerCase().replace(/\s+/g,'');</span>const simple=<span class="cstat-no" title="statement not covered" >/^(?:#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})|(\w+))$/i;</span>let match=<span class="cstat-no" title="statement not covered" >value.match(simple);<span class="cstat-no" title="statement not covered" ></span>if(match){<span class="cstat-no" title="statement not covered" >if(match[1]){let hex=<span class="cstat-no" title="statement not covered" >match[1].toLowerCase();</span>let format;<span class="cstat-no" title="statement not covered" >if(hex.length===3){<span class="cstat-no" title="statement not covered" >format=Common.Color.Format.ShortHEX;<span class="cstat-no" title="statement not covered" >h</span>ex=hex.charAt(0)+hex.charAt(0)+hex.charAt(1)+hex.charAt(1)+hex.charAt(2)+hex.charAt(2);}</span>else <span class="cstat-no" title="statement not covered" >if(hex.length===4){<span class="cstat-no" title="statement not covered" >format=Common.Color.Format.ShortHEXA;<span class="cstat-no" title="statement not covered" >h</span>ex=hex.charAt(0)+hex.charAt(0)+hex.charAt(1)+hex.charAt(1)+hex.charAt(2)+hex.charAt(2)+</span></span></span></span></span>
hex.charAt(3)+hex.charAt(3);}else <span class="cstat-no" title="statement not covered" >if(hex.length===6){<span class="cstat-no" title="statement not covered" >format=Common.Color.Format.HEX;}</span>else{<span class="cstat-no" title="statement not covered" >format=Common.Color.Format.HEXA;}</span></span>
const r=<span class="cstat-no" title="statement not covered" >parseInt(hex.substring(0,2),16);</span>const g=<span class="cstat-no" title="statement not covered" >parseInt(hex.substring(2,4),16);</span>const b=<span class="cstat-no" title="statement not covered" >parseInt(hex.substring(4,6),16);</span>let a=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(hex.length===8)</span>
<span class="cstat-no" title="statement not covered" >a=parseInt(hex.substring(6,8),16)/255;<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color([r/255,g/255,b/255,a],format,text);}</span>
<span class="cstat-no" title="statement not covered" >if(match[2]){const nickname=<span class="cstat-no" title="statement not covered" >match[2].toLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(nickname in Common.Color.Nicknames){const rgba=<span class="cstat-no" title="statement not covered" >Common.Color.Nicknames[nickname];</span>const color=<span class="cstat-no" title="statement not covered" >Common.Color.fromRGBA(rgba);<span class="cstat-no" title="statement not covered" ></span>color._format=Common.Color.Format.Nickname;<span class="cstat-no" title="statement not covered" >c</span>olor._originalText=text;<span class="cstat-no" title="statement not covered" >r</span>eturn color;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="cstat-no" title="statement not covered" >match=text.toLowerCase().match(/^\s*(?:(rgba?)|(hsla?))\((.*)\)\s*$/);<span class="cstat-no" title="statement not covered" >i</span>f(match){const components=<span class="cstat-no" title="statement not covered" >match[3].trim();</span>let values=<span class="cstat-no" title="statement not covered" >components.split(/\s*,\s*/);<span class="cstat-no" title="statement not covered" ></span>if(values.length===1){<span class="cstat-no" title="statement not covered" >values=components.split(/\s+/);<span class="cstat-no" title="statement not covered" >i</span>f(values[3]==='/'){<span class="cstat-no" title="statement not covered" >values.splice(3,1);<span class="cstat-no" title="statement not covered" >i</span>f(values.length!==4)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if((values.length&gt;2&amp;&amp;values[2].indexOf('/')!==-1)||(values.length&gt;3&amp;&amp;values[3].indexOf('/')!==-1)){const alpha=<span class="cstat-no" title="statement not covered" >values.slice(2,4).join('');<span class="cstat-no" title="statement not covered" ></span>values=values.slice(0,2).concat(alpha.split(/\//)).concat(values.slice(4));}</span>else <span class="cstat-no" title="statement not covered" >if(values.length&gt;=4){<span class="cstat-no" title="statement not covered" >return null;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(values.length!==3&amp;&amp;values.length!==4||values.indexOf('')&gt;-1)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst hasAlpha=(<span class="cstat-no" title="statement not covered" >values[3]!==undefined)</span>;<span class="cstat-no" title="statement not covered" >if(match[1]){const rgba=<span class="cstat-no" title="statement not covered" >[Common.Color._parseRgbNumeric(values[0]),Common.Color._parseRgbNumeric(values[1]),Common.Color._parseRgbNumeric(values[2]),hasAlpha?Common.Color._parseAlphaNumeric(values[3]):1];<span class="cstat-no" title="statement not covered" ></span>if(rgba.indexOf(null)&gt;-1)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color(rgba,hasAlpha?Common.Color.Format.RGBA:Common.Color.Format.RGB,text);}</span>
<span class="cstat-no" title="statement not covered" >if(match[2]){const hsla=<span class="cstat-no" title="statement not covered" >[Common.Color._parseHueNumeric(values[0]),Common.Color._parseSatLightNumeric(values[1]),Common.Color._parseSatLightNumeric(values[2]),hasAlpha?Common.Color._parseAlphaNumeric(values[3]):1];<span class="cstat-no" title="statement not covered" ></span>if(hsla.indexOf(null)&gt;-1)</span></span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst rgba=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>Common.Color.hsl2rgb(hsla,rgba);<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color(rgba,hasAlpha?Common.Color.Format.HSLA:Common.Color.Format.HSL,text);}</span>}
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromRGBA(rgba){<span class="cstat-no" title="statement not covered" >return new Common.Color([rgba[0]/255,rgba[1]/255,rgba[2]/255,rgba[3]],Common.Color.Format.RGBA);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromHSVA(hsva){const rgba=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>Common.Color.hsva2rgba(hsva,rgba);<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color(rgba,Common.Color.Format.HSLA);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _parsePercentOrNumber(value){<span class="cstat-no" title="statement not covered" >if(isNaN(value.replace('%','')))</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst parsed=<span class="cstat-no" title="statement not covered" >parseFloat(value);<span class="cstat-no" title="statement not covered" ></span>if(value.indexOf('%')!==-1){<span class="cstat-no" title="statement not covered" >if(value.indexOf('%')!==value.length-1)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn parsed/100;}</span>
<span class="cstat-no" title="statement not covered" >return parsed;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _parseRgbNumeric(value){const parsed=<span class="cstat-no" title="statement not covered" >Common.Color._parsePercentOrNumber(value);<span class="cstat-no" title="statement not covered" ></span>if(parsed===null)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span>f(value.indexOf('%')!==-1)</span>
<span class="cstat-no" title="statement not covered" >return parsed;<span class="cstat-no" title="statement not covered" >r</span>eturn parsed/255;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _parseHueNumeric(value){const angle=<span class="cstat-no" title="statement not covered" >value.replace(/(deg|g?rad|turn)$/,'');<span class="cstat-no" title="statement not covered" ></span>if(isNaN(angle)||value.match(/\s+(deg|g?rad|turn)/))</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst number=<span class="cstat-no" title="statement not covered" >parseFloat(angle);<span class="cstat-no" title="statement not covered" ></span>if(value.indexOf('turn')!==-1)</span>
<span class="cstat-no" title="statement not covered" >return number%1;e</span>lse <span class="cstat-no" title="statement not covered" >if(value.indexOf('grad')!==-1)</span>
<span class="cstat-no" title="statement not covered" >return(number/400)%1;e</span>lse <span class="cstat-no" title="statement not covered" >if(value.indexOf('rad')!==-1)</span>
<span class="cstat-no" title="statement not covered" >return(number/(2*Math.PI))%1;<span class="cstat-no" title="statement not covered" >r</span>eturn(number/360)%1;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _parseSatLightNumeric(value){<span class="cstat-no" title="statement not covered" >if(value.indexOf('%')!==value.length-1||isNaN(value.replace('%','')))</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst parsed=<span class="cstat-no" title="statement not covered" >parseFloat(value);<span class="cstat-no" title="statement not covered" ></span>return Math.min(1,parsed/100);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _parseAlphaNumeric(value){<span class="cstat-no" title="statement not covered" >return Common.Color._parsePercentOrNumber(value);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _hsva2hsla(hsva,out_hsla){const h=<span class="cstat-no" title="statement not covered" >hsva[0];</span>let s=<span class="cstat-no" title="statement not covered" >hsva[1];</span>const v=<span class="cstat-no" title="statement not covered" >hsva[2];</span>const t=<span class="cstat-no" title="statement not covered" >(2-s)*v;<span class="cstat-no" title="statement not covered" ></span>if(v===0||s===0)</span>
<span class="cstat-no" title="statement not covered" >s=0;e</span>lse
<span class="cstat-no" title="statement not covered" >s*=v/(t&lt;1?t:2-t);<span class="cstat-no" title="statement not covered" >o</span>ut_hsla[0]=h;<span class="cstat-no" title="statement not covered" >o</span>ut_hsla[1]=s;<span class="cstat-no" title="statement not covered" >o</span>ut_hsla[2]=t/2;<span class="cstat-no" title="statement not covered" >o</span>ut_hsla[3]=hsva[3];}</span>
<span class="fstat-no" title="function not covered" >st</span>atic hsl2rgb(hsl,out_rgb){const h=<span class="cstat-no" title="statement not covered" >hsl[0];</span>let s=<span class="cstat-no" title="statement not covered" >hsl[1];</span>const l=<span class="cstat-no" title="statement not covered" >hsl[2];</span>function <span class="fstat-no" title="function not covered" >hue2rgb(</span>p,q,h){<span class="cstat-no" title="statement not covered" >if(h&lt;0)</span>
<span class="cstat-no" title="statement not covered" >h+=1;e</span>lse <span class="cstat-no" title="statement not covered" >if(h&gt;1)</span>
<span class="cstat-no" title="statement not covered" >h-=1;<span class="cstat-no" title="statement not covered" >i</span>f((h*6)&lt;1)</span>
<span class="cstat-no" title="statement not covered" >return p+(q-p)*h*6;e</span>lse <span class="cstat-no" title="statement not covered" >if((h*2)&lt;1)</span>
<span class="cstat-no" title="statement not covered" >return q;e</span>lse <span class="cstat-no" title="statement not covered" >if((h*3)&lt;2)</span>
<span class="cstat-no" title="statement not covered" >return p+(q-p)*((2/3)-h)*6;e</span>lse
<span class="cstat-no" title="statement not covered" >return p;}</span>
<span class="cstat-no" title="statement not covered" >if(s&lt;0)</span>
<span class="cstat-no" title="statement not covered" >s=0;l</span>et q;<span class="cstat-no" title="statement not covered" >if(l&lt;=0.5)</span>
<span class="cstat-no" title="statement not covered" >q=l*(1+s);e</span>lse
<span class="cstat-no" title="statement not covered" >q=l+s-(l*s);c</span>onst p=<span class="cstat-no" title="statement not covered" >2*l-q;</span>const tr=<span class="cstat-no" title="statement not covered" >h+(1/3);</span>const tg=<span class="cstat-no" title="statement not covered" >h;</span>const tb=<span class="cstat-no" title="statement not covered" >h-(1/3);<span class="cstat-no" title="statement not covered" ></span>out_rgb[0]=hue2rgb(p,q,tr);<span class="cstat-no" title="statement not covered" >o</span>ut_rgb[1]=hue2rgb(p,q,tg);<span class="cstat-no" title="statement not covered" >o</span>ut_rgb[2]=hue2rgb(p,q,tb);<span class="cstat-no" title="statement not covered" >o</span>ut_rgb[3]=hsl[3];}</span>
<span class="fstat-no" title="function not covered" >st</span>atic hsva2rgba(hsva,out_rgba){<span class="cstat-no" title="statement not covered" >Common.Color._hsva2hsla(hsva,Common.Color.hsva2rgba._tmpHSLA);<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.hsl2rgb(Common.Color.hsva2rgba._tmpHSLA,out_rgba);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;Common.Color.hsva2rgba._tmpHSLA.length;i++)</span>
<span class="cstat-no" title="statement not covered" >Common.Color.hsva2rgba._tmpHSLA[i]=0;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic luminance(rgba){const rSRGB=<span class="cstat-no" title="statement not covered" >rgba[0];</span>const gSRGB=<span class="cstat-no" title="statement not covered" >rgba[1];</span>const bSRGB=<span class="cstat-no" title="statement not covered" >rgba[2];</span>const r=<span class="cstat-no" title="statement not covered" >rSRGB&lt;=0.03928?rSRGB/12.92:Math.pow(((rSRGB+0.055)/1.055),2.4);</span>const g=<span class="cstat-no" title="statement not covered" >gSRGB&lt;=0.03928?gSRGB/12.92:Math.pow(((gSRGB+0.055)/1.055),2.4);</span>const b=<span class="cstat-no" title="statement not covered" >bSRGB&lt;=0.03928?bSRGB/12.92:Math.pow(((bSRGB+0.055)/1.055),2.4);<span class="cstat-no" title="statement not covered" ></span>return 0.2126*r+0.7152*g+0.0722*b;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic blendColors(fgRGBA,bgRGBA,out_blended){const alpha=<span class="cstat-no" title="statement not covered" >fgRGBA[3];<span class="cstat-no" title="statement not covered" ></span>out_blended[0]=((1-alpha)*bgRGBA[0])+(alpha*fgRGBA[0]);<span class="cstat-no" title="statement not covered" >o</span>ut_blended[1]=((1-alpha)*bgRGBA[1])+(alpha*fgRGBA[1]);<span class="cstat-no" title="statement not covered" >o</span>ut_blended[2]=((1-alpha)*bgRGBA[2])+(alpha*fgRGBA[2]);<span class="cstat-no" title="statement not covered" >o</span>ut_blended[3]=alpha+(bgRGBA[3]*(1-alpha));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic calculateContrastRatio(fgRGBA,bgRGBA){<span class="cstat-no" title="statement not covered" >Common.Color.blendColors(fgRGBA,bgRGBA,Common.Color.calculateContrastRatio._blendedFg);c</span>onst fgLuminance=<span class="cstat-no" title="statement not covered" >Common.Color.luminance(Common.Color.calculateContrastRatio._blendedFg);</span>const bgLuminance=<span class="cstat-no" title="statement not covered" >Common.Color.luminance(bgRGBA);</span>const contrastRatio=<span class="cstat-no" title="statement not covered" >(Math.max(fgLuminance,bgLuminance)+0.05)/(Math.min(fgLuminance,bgLuminance)+0.05);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;Common.Color.calculateContrastRatio._blendedFg.length;i++)</span>
<span class="cstat-no" title="statement not covered" >Common.Color.calculateContrastRatio._blendedFg[i]=0;<span class="cstat-no" title="statement not covered" >r</span>eturn contrastRatio;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic desiredLuminance(luminance,contrast,lighter){function <span class="fstat-no" title="function not covered" >computeLuminance(</span>){<span class="cstat-no" title="statement not covered" >if(lighter)</span>
<span class="cstat-no" title="statement not covered" >return(luminance+0.05)*contrast-0.05;e</span>lse
<span class="cstat-no" title="statement not covered" >return(luminance+0.05)/contrast-0.05;}</span>
let desiredLuminance=<span class="cstat-no" title="statement not covered" >computeLuminance();<span class="cstat-no" title="statement not covered" ></span>if(desiredLuminance&lt;0||desiredLuminance&gt;1){<span class="cstat-no" title="statement not covered" >lighter=!lighter;<span class="cstat-no" title="statement not covered" >d</span>esiredLuminance=computeLuminance();}</span></span>
<span class="cstat-no" title="statement not covered" >return desiredLuminance;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic detectColorFormat(color){const cf=<span class="cstat-no" title="statement not covered" >Common.Color.Format;</span>let format;const formatSetting=<span class="cstat-no" title="statement not covered" >Common.moduleSetting('colorFormat').get();<span class="cstat-no" title="statement not covered" ></span>if(formatSetting===cf.Original)</span>
<span class="cstat-no" title="statement not covered" >format=cf.Original;e</span>lse <span class="cstat-no" title="statement not covered" >if(formatSetting===cf.RGB)</span>
<span class="cstat-no" title="statement not covered" >format=(color.hasAlpha()?cf.RGBA:cf.RGB);e</span>lse <span class="cstat-no" title="statement not covered" >if(formatSetting===cf.HSL)</span>
<span class="cstat-no" title="statement not covered" >format=(color.hasAlpha()?cf.HSLA:cf.HSL);e</span>lse <span class="cstat-no" title="statement not covered" >if(formatSetting===cf.HEX)</span>
<span class="cstat-no" title="statement not covered" >format=color.detectHEXFormat();e</span>lse
<span class="cstat-no" title="statement not covered" >format=cf.RGBA;<span class="cstat-no" title="statement not covered" >r</span>eturn format;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmat(){<span class="cstat-no" title="statement not covered" >return this._format;}</span>
<span class="fstat-no" title="function not covered" >hs</span>la(){<span class="cstat-no" title="statement not covered" >if(this._hsla)</span>
<span class="cstat-no" title="statement not covered" >return this._hsla;c</span>onst r=<span class="cstat-no" title="statement not covered" >this._rgba[0];</span>const g=<span class="cstat-no" title="statement not covered" >this._rgba[1];</span>const b=<span class="cstat-no" title="statement not covered" >this._rgba[2];</span>const max=<span class="cstat-no" title="statement not covered" >Math.max(r,g,b);</span>const min=<span class="cstat-no" title="statement not covered" >Math.min(r,g,b);</span>const diff=<span class="cstat-no" title="statement not covered" >max-min;</span>const add=<span class="cstat-no" title="statement not covered" >max+min;</span>let h;<span class="cstat-no" title="statement not covered" >if(min===max)</span>
<span class="cstat-no" title="statement not covered" >h=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(r===max)</span>
<span class="cstat-no" title="statement not covered" >h=((1/6*(g-b)/diff)+1)%1;e</span>lse <span class="cstat-no" title="statement not covered" >if(g===max)</span>
<span class="cstat-no" title="statement not covered" >h=(1/6*(b-r)/diff)+1/3;e</span>lse
<span class="cstat-no" title="statement not covered" >h=(1/6*(r-g)/diff)+2/3;c</span>onst l=<span class="cstat-no" title="statement not covered" >0.5*add;</span>let s;<span class="cstat-no" title="statement not covered" >if(l===0)</span>
<span class="cstat-no" title="statement not covered" >s=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(l===1)</span>
<span class="cstat-no" title="statement not covered" >s=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(l&lt;=0.5)</span>
<span class="cstat-no" title="statement not covered" >s=diff/add;e</span>lse
<span class="cstat-no" title="statement not covered" >s=diff/(2-add);<span class="cstat-no" title="statement not covered" >t</span>his._hsla=[h,s,l,this._rgba[3]];<span class="cstat-no" title="statement not covered" >r</span>eturn this._hsla;}</span>
<span class="fstat-no" title="function not covered" >ca</span>nonicalHSLA(){const hsla=<span class="cstat-no" title="statement not covered" >this.hsla();<span class="cstat-no" title="statement not covered" ></span>return[Math.round(hsla[0]*360),Math.round(hsla[1]*100),Math.round(hsla[2]*100),hsla[3]];}</span>
<span class="fstat-no" title="function not covered" >hs</span>va(){const hsla=<span class="cstat-no" title="statement not covered" >this.hsla();</span>const h=<span class="cstat-no" title="statement not covered" >hsla[0];</span>let s=<span class="cstat-no" title="statement not covered" >hsla[1];</span>const l=<span class="cstat-no" title="statement not covered" >hsla[2];<span class="cstat-no" title="statement not covered" ></span>s*=l&lt;0.5?l:1-l;<span class="cstat-no" title="statement not covered" >r</span>eturn[h,s!==0?2*s/(l+s):0,(l+s),hsla[3]];}</span>
<span class="fstat-no" title="function not covered" >ha</span>sAlpha(){<span class="cstat-no" title="statement not covered" >return this._rgba[3]!==1;}</span>
<span class="fstat-no" title="function not covered" >de</span>tectHEXFormat(){let canBeShort=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;4;++i){const c=<span class="cstat-no" title="statement not covered" >Math.round(this._rgba[i]*255);<span class="cstat-no" title="statement not covered" ></span>if(c%17){<span class="cstat-no" title="statement not covered" >canBeShort=false;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>
const hasAlpha=<span class="cstat-no" title="statement not covered" >this.hasAlpha();</span>const cf=<span class="cstat-no" title="statement not covered" >Common.Color.Format;<span class="cstat-no" title="statement not covered" ></span>if(canBeShort)</span>
<span class="cstat-no" title="statement not covered" >return hasAlpha?cf.ShortHEXA:cf.ShortHEX;<span class="cstat-no" title="statement not covered" >r</span>eturn hasAlpha?cf.HEXA:cf.HEX;}</span>
<span class="fstat-no" title="function not covered" >as</span>String(format){<span class="cstat-no" title="statement not covered" >if(format===this._format&amp;&amp;this._originalTextIsValid)</span>
<span class="cstat-no" title="statement not covered" >return this._originalText;<span class="cstat-no" title="statement not covered" >i</span>f(!format)</span>
<span class="cstat-no" title="statement not covered" >format=this._format;f</span>unction <span class="fstat-no" title="function not covered" >toRgbValue(</span>value){<span class="cstat-no" title="statement not covered" >return Math.round(value*255);}</span>
function <span class="fstat-no" title="function not covered" >toHexValue(</span>value){const hex=<span class="cstat-no" title="statement not covered" >Math.round(value*255).toString(16);<span class="cstat-no" title="statement not covered" ></span>return hex.length===1?'0'+hex:hex;}</span>
function <span class="fstat-no" title="function not covered" >toShortHexValue(</span>value){<span class="cstat-no" title="statement not covered" >return(Math.round(value*255)/17).toString(16);}</span>
<span class="cstat-no" title="statement not covered" >switch(format){case Common.Color.Format.Original:<span class="cstat-no" title="statement not covered" >return this._originalText;c</span>ase Common.Color.Format.RGB:<span class="cstat-no" title="statement not covered" >if(this.hasAlpha())</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn String.sprintf('rgb(%d, %d, %d)',toRgbValue(this._rgba[0]),toRgbValue(this._rgba[1]),toRgbValue(this._rgba[2]));c</span>ase Common.Color.Format.RGBA:<span class="cstat-no" title="statement not covered" >return String.sprintf('rgba(%d, %d, %d, %f)',toRgbValue(this._rgba[0]),toRgbValue(this._rgba[1]),toRgbValue(this._rgba[2]),this._rgba[3]);c</span>ase Common.Color.Format.HSL:<span class="cstat-no" title="statement not covered" >if(this.hasAlpha())</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst hsl=<span class="cstat-no" title="statement not covered" >this.hsla();<span class="cstat-no" title="statement not covered" ></span>return String.sprintf('hsl(%d, %d%, %d%)',Math.round(hsl[0]*360),Math.round(hsl[1]*100),Math.round(hsl[2]*100));c</span>ase Common.Color.Format.HSLA:const hsla=<span class="cstat-no" title="statement not covered" >this.hsla();<span class="cstat-no" title="statement not covered" ></span>return String.sprintf('hsla(%d, %d%, %d%, %f)',Math.round(hsla[0]*360),Math.round(hsla[1]*100),Math.round(hsla[2]*100),hsla[3]);c</span>ase Common.Color.Format.HEXA:<span class="cstat-no" title="statement not covered" >return String.sprintf('#%s%s%s%s',toHexValue(this._rgba[0]),toHexValue(this._rgba[1]),toHexValue(this._rgba[2]),toHexValue(this._rgba[3])).toLowerCase();c</span>ase Common.Color.Format.HEX:<span class="cstat-no" title="statement not covered" >if(this.hasAlpha())</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn String.sprintf('#%s%s%s',toHexValue(this._rgba[0]),toHexValue(this._rgba[1]),toHexValue(this._rgba[2])).toLowerCase();c</span>ase Common.Color.Format.ShortHEXA:const hexFormat=<span class="cstat-no" title="statement not covered" >this.detectHEXFormat();<span class="cstat-no" title="statement not covered" ></span>if(hexFormat!==Common.Color.Format.ShortHEXA&amp;&amp;hexFormat!==Common.Color.Format.ShortHEX)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn String.sprintf('#%s%s%s%s',toShortHexValue(this._rgba[0]),toShortHexValue(this._rgba[1]),toShortHexValue(this._rgba[2]),toShortHexValue(this._rgba[3])).toLowerCase();c</span>ase Common.Color.Format.ShortHEX:<span class="cstat-no" title="statement not covered" >if(this.hasAlpha())</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span>f(this.detectHEXFormat()!==Common.Color.Format.ShortHEX)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn String.sprintf('#%s%s%s',toShortHexValue(this._rgba[0]),toShortHexValue(this._rgba[1]),toShortHexValue(this._rgba[2])).toLowerCase();c</span>ase Common.Color.Format.Nickname:<span class="cstat-no" title="statement not covered" >return this.nickname();}</span>
<span class="cstat-no" title="statement not covered" >return this._originalText;}</span>
<span class="fstat-no" title="function not covered" >rg</span>ba(){<span class="cstat-no" title="statement not covered" >return this._rgba.slice();}</span>
<span class="fstat-no" title="function not covered" >ca</span>nonicalRGBA(){const rgba=<span class="cstat-no" title="statement not covered" >new Array(4);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;3;++i)</span>
<span class="cstat-no" title="statement not covered" >rgba[i]=Math.round(this._rgba[i]*255);<span class="cstat-no" title="statement not covered" >r</span>gba[3]=this._rgba[3];<span class="cstat-no" title="statement not covered" >r</span>eturn rgba;}</span>
<span class="fstat-no" title="function not covered" >ni</span>ckname(){<span class="cstat-no" title="statement not covered" >if(!Common.Color._rgbaToNickname){<span class="cstat-no" title="statement not covered" >Common.Color._rgbaToNickname={};<span class="cstat-no" title="statement not covered" >f</span>or(const nickname in Common.Color.Nicknames){let rgba=<span class="cstat-no" title="statement not covered" >Common.Color.Nicknames[nickname];<span class="cstat-no" title="statement not covered" ></span>if(rgba.length!==4)</span></span></span>
<span class="cstat-no" title="statement not covered" >rgba=rgba.concat(1);<span class="cstat-no" title="statement not covered" >C</span>ommon.Color._rgbaToNickname[rgba]=nickname;}</span>}
<span class="cstat-no" title="statement not covered" >return Common.Color._rgbaToNickname[this.canonicalRGBA()]||null;}</span>
<span class="fstat-no" title="function not covered" >to</span>ProtocolRGBA(){const rgba=<span class="cstat-no" title="statement not covered" >this.canonicalRGBA();</span>const result=<span class="cstat-no" title="statement not covered" >{r:rgba[0],g:rgba[1],b:rgba[2]};<span class="cstat-no" title="statement not covered" ></span>if(rgba[3]!==1)</span>
<span class="cstat-no" title="statement not covered" >result.a=rgba[3];<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >in</span>vert(){const rgba=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>rgba[0]=1-this._rgba[0];<span class="cstat-no" title="statement not covered" >r</span>gba[1]=1-this._rgba[1];<span class="cstat-no" title="statement not covered" >r</span>gba[2]=1-this._rgba[2];<span class="cstat-no" title="statement not covered" >r</span>gba[3]=this._rgba[3];<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color(rgba,Common.Color.Format.RGBA);}</span>
<span class="fstat-no" title="function not covered" >se</span>tAlpha(alpha){const rgba=<span class="cstat-no" title="statement not covered" >this._rgba.slice();<span class="cstat-no" title="statement not covered" ></span>rgba[3]=alpha;<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color(rgba,Common.Color.Format.RGBA);}</span>
<span class="fstat-no" title="function not covered" >bl</span>endWith(fgColor){const rgba=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>Common.Color.blendColors(fgColor._rgba,this._rgba,rgba);<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Color(rgba,Common.Color.Format.RGBA);}</span>};<span class="cstat-no" title="statement not covered" >Common.Color.Regex=/((?:rgb|hsl)a?\([^)]+\)|#[0-9a-fA-F]{8}|#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3,4}|\b[a-zA-Z]+\b(?!-))/g;<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.Format={Original:'original',Nickname:'nickname',HEX:'hex',ShortHEX:'shorthex',HEXA:'hexa',ShortHEXA:'shorthexa',RGB:'rgb',RGBA:'rgba',HSL:'hsl',HSLA:'hsla'};<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.hsva2rgba._tmpHSLA=[0,0,0,0];<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.calculateContrastRatio._blendedFg=[0,0,0,0];<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.Nicknames={'aliceblue':[240,248,255],'antiquewhite':[250,235,215],'aqua':[0,255,255],'aquamarine':[127,255,212],'azure':[240,255,255],'beige':[245,245,220],'bisque':[255,228,196],'black':[0,0,0],'blanchedalmond':[255,235,205],'blue':[0,0,255],'blueviolet':[138,43,226],'brown':[165,42,42],'burlywood':[222,184,135],'cadetblue':[95,158,160],'chartreuse':[127,255,0],'chocolate':[210,105,30],'coral':[255,127,80],'cornflowerblue':[100,149,237],'cornsilk':[255,248,220],'crimson':[237,20,61],'cyan':[0,255,255],'darkblue':[0,0,139],'darkcyan':[0,139,139],'darkgoldenrod':[184,134,11],'darkgray':[169,169,169],'darkgrey':[169,169,169],'darkgreen':[0,100,0],'darkkhaki':[189,183,107],'darkmagenta':[139,0,139],'darkolivegreen':[85,107,47],'darkorange':[255,140,0],'darkorchid':[153,50,204],'darkred':[139,0,0],'darksalmon':[233,150,122],'darkseagreen':[143,188,143],'darkslateblue':[72,61,139],'darkslategray':[47,79,79],'darkslategrey':[47,79,79],'darkturquoise':[0,206,209],'darkviolet':[148,0,211],'deeppink':[255,20,147],'deepskyblue':[0,191,255],'dimgray':[105,105,105],'dimgrey':[105,105,105],'dodgerblue':[30,144,255],'firebrick':[178,34,34],'floralwhite':[255,250,240],'forestgreen':[34,139,34],'fuchsia':[255,0,255],'gainsboro':[220,220,220],'ghostwhite':[248,248,255],'gold':[255,215,0],'goldenrod':[218,165,32],'gray':[128,128,128],'grey':[128,128,128],'green':[0,128,0],'greenyellow':[173,255,47],'honeydew':[240,255,240],'hotpink':[255,105,180],'indianred':[205,92,92],'indigo':[75,0,130],'ivory':[255,255,240],'khaki':[240,230,140],'lavender':[230,230,250],'lavenderblush':[255,240,245],'lawngreen':[124,252,0],'lemonchiffon':[255,250,205],'lightblue':[173,216,230],'lightcoral':[240,128,128],'lightcyan':[224,255,255],'lightgoldenrodyellow':[250,250,210],'lightgreen':[144,238,144],'lightgray':[211,211,211],'lightgrey':[211,211,211],'lightpink':[255,182,193],'lightsalmon':[255,160,122],'lightseagreen':[32,178,170],'lightskyblue':[135,206,250],'lightslategray':[119,136,153],'lightslategrey':[119,136,153],'lightsteelblue':[176,196,222],'lightyellow':[255,255,224],'lime':[0,255,0],'limegreen':[50,205,50],'linen':[250,240,230],'magenta':[255,0,255],'maroon':[128,0,0],'mediumaquamarine':[102,205,170],'mediumblue':[0,0,205],'mediumorchid':[186,85,211],'mediumpurple':[147,112,219],'mediumseagreen':[60,179,113],'mediumslateblue':[123,104,238],'mediumspringgreen':[0,250,154],'mediumturquoise':[72,209,204],'mediumvioletred':[199,21,133],'midnightblue':[25,25,112],'mintcream':[245,255,250],'mistyrose':[255,228,225],'moccasin':[255,228,181],'navajowhite':[255,222,173],'navy':[0,0,128],'oldlace':[253,245,230],'olive':[128,128,0],'olivedrab':[107,142,35],'orange':[255,165,0],'orangered':[255,69,0],'orchid':[218,112,214],'palegoldenrod':[238,232,170],'palegreen':[152,251,152],'paleturquoise':[175,238,238],'palevioletred':[219,112,147],'papayawhip':[255,239,213],'peachpuff':[255,218,185],'peru':[205,133,63],'pink':[255,192,203],'plum':[221,160,221],'powderblue':[176,224,230],'purple':[128,0,128],'rebeccapurple':[102,51,153],'red':[255,0,0],'rosybrown':[188,143,143],'royalblue':[65,105,225],'saddlebrown':[139,69,19],'salmon':[250,128,114],'sandybrown':[244,164,96],'seagreen':[46,139,87],'seashell':[255,245,238],'sienna':[160,82,45],'silver':[192,192,192],'skyblue':[135,206,235],'slateblue':[106,90,205],'slategray':[112,128,144],'slategrey':[112,128,144],'snow':[255,250,250],'springgreen':[0,255,127],'steelblue':[70,130,180],'tan':[210,180,140],'teal':[0,128,128],'thistle':[216,191,216],'tomato':[255,99,71],'turquoise':[64,224,208],'violet':[238,130,238],'wheat':[245,222,179],'white':[255,255,255],'whitesmoke':[245,245,245],'yellow':[255,255,0],'yellowgreen':[154,205,50],'transparent':[0,0,0,0],};<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.PageHighlight={Content:Common.Color.fromRGBA([111,168,220,.66]),ContentLight:Common.Color.fromRGBA([111,168,220,.5]),ContentOutline:Common.Color.fromRGBA([9,83,148]),Padding:Common.Color.fromRGBA([147,196,125,.55]),PaddingLight:Common.Color.fromRGBA([147,196,125,.4]),Border:Common.Color.fromRGBA([255,229,153,.66]),BorderLight:Common.Color.fromRGBA([255,229,153,.5]),Margin:Common.Color.fromRGBA([246,178,107,.66]),MarginLight:Common.Color.fromRGBA([246,178,107,.5]),EventTarget:Common.Color.fromRGBA([255,196,196,.66]),Shape:Common.Color.fromRGBA([96,82,177,0.8]),ShapeMargin:Common.Color.fromRGBA([96,82,127,.6]),CssGrid:Common.Color.fromRGBA([0x4b,0,0x82,1])};<span class="cstat-no" title="statement not covered" >C</span>ommon.Color.Generator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(hueSpace,satSpace,lightnessSpace,alphaSpace){<span class="cstat-no" title="statement not covered" >this._hueSpace=hueSpace||{min:0,max:360};<span class="cstat-no" title="statement not covered" >t</span>his._satSpace=satSpace||67;<span class="cstat-no" title="statement not covered" >t</span>his._lightnessSpace=lightnessSpace||80;<span class="cstat-no" title="statement not covered" >t</span>his._alphaSpace=alphaSpace||1;<span class="cstat-no" title="statement not covered" >t</span>his._colors=new Map();}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tColorForID(id,color){<span class="cstat-no" title="statement not covered" >this._colors.set(id,color);}</span>
<span class="fstat-no" title="function not covered" >co</span>lorForID(id){let color=<span class="cstat-no" title="statement not covered" >this._colors.get(id);<span class="cstat-no" title="statement not covered" ></span>if(!color){<span class="cstat-no" title="statement not covered" >color=this._generateColorForID(id);<span class="cstat-no" title="statement not covered" >t</span>his._colors.set(id,color);}</span></span>
<span class="cstat-no" title="statement not covered" >return color;}</span>
<span class="fstat-no" title="function not covered" >_g</span>enerateColorForID(id){const hash=<span class="cstat-no" title="statement not covered" >String.hashCode(id);</span>const h=<span class="cstat-no" title="statement not covered" >this._indexToValueInSpace(hash,this._hueSpace);</span>const s=<span class="cstat-no" title="statement not covered" >this._indexToValueInSpace(hash&gt;&gt;8,this._satSpace);</span>const l=<span class="cstat-no" title="statement not covered" >this._indexToValueInSpace(hash&gt;&gt;16,this._lightnessSpace);</span>const a=<span class="cstat-no" title="statement not covered" >this._indexToValueInSpace(hash&gt;&gt;24,this._alphaSpace);<span class="cstat-no" title="statement not covered" ></span>return`hsla(${h}, ${s}%, ${l}%, ${a})`;}</span>
<span class="fstat-no" title="function not covered" >_i</span>ndexToValueInSpace(index,space){<span class="cstat-no" title="statement not covered" >if(typeof space==='number')</span>
<span class="cstat-no" title="statement not covered" >return space;c</span>onst count=<span class="cstat-no" title="statement not covered" >space.count||space.max-space.min;<span class="cstat-no" title="statement not covered" ></span>index%=count;<span class="cstat-no" title="statement not covered" >r</span>eturn space.min+Math.floor(index/(count-1)*(space.max-space.min));}</span>};;<span class="cstat-no" title="statement not covered" >Common.Console=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._messages=[];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dMessage(text,level,show){const message=<span class="cstat-no" title="statement not covered" >new Common.Console.Message(text,level||Common.Console.MessageLevel.Info,Date.now(),show||false);<span class="cstat-no" title="statement not covered" ></span>this._messages.push(message);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Common.Console.Events.MessageAdded,message);}</span>
<span class="fstat-no" title="function not covered" >lo</span>g(text){<span class="cstat-no" title="statement not covered" >this.addMessage(text,Common.Console.MessageLevel.Info);}</span>
<span class="fstat-no" title="function not covered" >wa</span>rn(text){<span class="cstat-no" title="statement not covered" >this.addMessage(text,Common.Console.MessageLevel.Warning);}</span>
<span class="fstat-no" title="function not covered" >er</span>ror(text){<span class="cstat-no" title="statement not covered" >this.addMessage(text,Common.Console.MessageLevel.Error,true);}</span>
<span class="fstat-no" title="function not covered" >me</span>ssages(){<span class="cstat-no" title="statement not covered" >return this._messages;}</span>
<span class="fstat-no" title="function not covered" >sh</span>ow(){<span class="cstat-no" title="statement not covered" >this.showPromise();}</span>
<span class="fstat-no" title="function not covered" >sh</span>owPromise(){<span class="cstat-no" title="statement not covered" >return Common.Revealer.reveal(this);}</span>};<span class="cstat-no" title="statement not covered" >Common.Console.Events={MessageAdded:Symbol('messageAdded')};<span class="cstat-no" title="statement not covered" >C</span>ommon.Console.MessageLevel={Info:'info',Warning:'warning',Error:'error'};<span class="cstat-no" title="statement not covered" >C</span>ommon.Console.Message=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(text,level,timestamp,show){<span class="cstat-no" title="statement not covered" >this.text=text;<span class="cstat-no" title="statement not covered" >t</span>his.level=level;<span class="cstat-no" title="statement not covered" >t</span>his.timestamp=(typeof timestamp==='number')?timestamp:Date.now();<span class="cstat-no" title="statement not covered" >t</span>his.show=show;}</span>};<span class="cstat-no" title="statement not covered" >C</span>ommon.console=new Common.Console();;<span class="cstat-no" title="statement not covered" ></span>Common.ContentProvider=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.ContentProvider.prototype={contentURL(){},contentType(){},contentEncoded(){},requestContent(){},searchInContent(query,caseSensitive,isRegex){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.ContentProvider.SearchMatch=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(lineNumber,lineContent){<span class="cstat-no" title="statement not covered" >this.lineNumber=lineNumber;<span class="cstat-no" title="statement not covered" >t</span>his.lineContent=lineContent;}</span>};<span class="cstat-no" title="statement not covered" >C</span>ommon.ContentProvider.performSearchInContent=<span class="fstat-no" title="function not covered" >fu</span>nction(content,query,caseSensitive,isRegex){const regex=<span class="cstat-no" title="statement not covered" >createSearchRegex(query,caseSensitive,isRegex);</span>const text=<span class="cstat-no" title="statement not covered" >new TextUtils.Text(content);</span>const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;text.lineCount();++i){const lineContent=<span class="cstat-no" title="statement not covered" >text.lineAt(i);<span class="cstat-no" title="statement not covered" ></span>regex.lastIndex=0;<span class="cstat-no" title="statement not covered" >i</span>f(regex.exec(lineContent))</span></span></span>
<span class="cstat-no" title="statement not covered" >result.push(new Common.ContentProvider.SearchMatch(i,lineContent));}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >Common.ContentProvider.contentAsDataURL=<span class="fstat-no" title="function not covered" >fu</span>nction(content,mimeType,contentEncoded,charset){const maxDataUrlSize=<span class="cstat-no" title="statement not covered" >1024*1024;<span class="cstat-no" title="statement not covered" ></span>if(content===null||content.length&gt;maxDataUrlSize)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn'data:'+mimeType+(charset?';charset='+charset:'')+(contentEncoded?';base64':'')+','+</span>
content;};;<span class="cstat-no" title="statement not covered" >Common.ParsedURL=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(url){<span class="cstat-no" title="statement not covered" >this.isValid=false;<span class="cstat-no" title="statement not covered" >t</span>his.url=url;<span class="cstat-no" title="statement not covered" >t</span>his.scheme='';<span class="cstat-no" title="statement not covered" >t</span>his.user='';<span class="cstat-no" title="statement not covered" >t</span>his.host='';<span class="cstat-no" title="statement not covered" >t</span>his.port='';<span class="cstat-no" title="statement not covered" >t</span>his.path='';<span class="cstat-no" title="statement not covered" >t</span>his.queryParams='';<span class="cstat-no" title="statement not covered" >t</span>his.fragment='';<span class="cstat-no" title="statement not covered" >t</span>his.folderPathComponents='';<span class="cstat-no" title="statement not covered" >t</span>his.lastPathComponent='';c</span>onst match=<span class="cstat-no" title="statement not covered" >url.match(Common.ParsedURL._urlRegex());<span class="cstat-no" title="statement not covered" ></span>if(match){<span class="cstat-no" title="statement not covered" >this.isValid=true;<span class="cstat-no" title="statement not covered" >t</span>his.scheme=match[2].toLowerCase();<span class="cstat-no" title="statement not covered" >t</span>his.user=match[3];<span class="cstat-no" title="statement not covered" >t</span>his.host=match[4];<span class="cstat-no" title="statement not covered" >t</span>his.port=match[5];<span class="cstat-no" title="statement not covered" >t</span>his.path=match[6]||'/';<span class="cstat-no" title="statement not covered" >t</span>his.queryParams=match[7]||'';<span class="cstat-no" title="statement not covered" >t</span>his.fragment=match[8];}</span>else{<span class="cstat-no" title="statement not covered" >if(this.url.startsWith('data:')){<span class="cstat-no" title="statement not covered" >this.scheme='data';<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.url==='about:blank'){<span class="cstat-no" title="statement not covered" >this.scheme='about';<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this.path=this.url;}</span>
const lastSlashIndex=<span class="cstat-no" title="statement not covered" >this.path.lastIndexOf('/');<span class="cstat-no" title="statement not covered" ></span>if(lastSlashIndex!==-1){<span class="cstat-no" title="statement not covered" >this.folderPathComponents=this.path.substring(0,lastSlashIndex);<span class="cstat-no" title="statement not covered" >t</span>his.lastPathComponent=this.path.substring(lastSlashIndex+1);}</span>else{<span class="cstat-no" title="statement not covered" >this.lastPathComponent=this.path;}</span>}</span>
<span class="fstat-no" title="function not covered" >st</span>atic platformPathToURL(fileSystemPath){<span class="cstat-no" title="statement not covered" >fileSystemPath=fileSystemPath.replace(/\\/g,'/');<span class="cstat-no" title="statement not covered" >i</span>f(!fileSystemPath.startsWith('file://')){<span class="cstat-no" title="statement not covered" >if(fileSystemPath.startsWith('/'))</span></span>
<span class="cstat-no" title="statement not covered" >fileSystemPath='file://'+fileSystemPath;e</span>lse
<span class="cstat-no" title="statement not covered" >fileSystemPath='file:///'+fileSystemPath;}</span>
<span class="cstat-no" title="statement not covered" >return fileSystemPath;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic urlToPlatformPath(fileURL,isWindows){<span class="cstat-no" title="statement not covered" >console.assert(fileURL.startsWith('file://'),'This must be a file URL.');<span class="cstat-no" title="statement not covered" >i</span>f(isWindows)</span>
<span class="cstat-no" title="statement not covered" >return fileURL.substr('file:///'.length).replace(/\//g,'\\');<span class="cstat-no" title="statement not covered" >r</span>eturn fileURL.substr('file://'.length);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic urlWithoutHash(url){const hashIndex=<span class="cstat-no" title="statement not covered" >url.indexOf('#');<span class="cstat-no" title="statement not covered" ></span>if(hashIndex!==-1)</span>
<span class="cstat-no" title="statement not covered" >return url.substr(0,hashIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn url;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _urlRegex(){<span class="cstat-no" title="statement not covered" >if(Common.ParsedURL._urlRegexInstance)</span>
<span class="cstat-no" title="statement not covered" >return Common.ParsedURL._urlRegexInstance;c</span>onst schemeRegex=<span class="cstat-no" title="statement not covered" >/([A-Za-z][A-Za-z0-9+.-]*):\/\//;</span>const userRegex=<span class="cstat-no" title="statement not covered" >/(?:([A-Za-z0-9\-._~%!$&amp;'()*+,;=:]*)@)?/;</span>const hostRegex=<span class="cstat-no" title="statement not covered" >/((?:\[::\d?\])|(?:[^\s\/:]*))/;</span>const portRegex=<span class="cstat-no" title="statement not covered" >/(?::([\d]+))?/;</span>const pathRegex=<span class="cstat-no" title="statement not covered" >/(\/[^#?]*)?/;</span>const queryRegex=<span class="cstat-no" title="statement not covered" >/(?:\?([^#]*))?/;</span>const fragmentRegex=<span class="cstat-no" title="statement not covered" >/(?:#(.*))?/;<span class="cstat-no" title="statement not covered" ></span>Common.ParsedURL._urlRegexInstance=new RegExp('^('+schemeRegex.source+userRegex.source+hostRegex.source+portRegex.source+')'+pathRegex.source+</span>
queryRegex.source+fragmentRegex.source+'$');<span class="cstat-no" title="statement not covered" >return Common.ParsedURL._urlRegexInstance;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic extractPath(url){const parsedURL=<span class="cstat-no" title="statement not covered" >url.asParsedURL();<span class="cstat-no" title="statement not covered" ></span>return parsedURL?parsedURL.path:'';}</span>
<span class="fstat-no" title="function not covered" >st</span>atic extractOrigin(url){const parsedURL=<span class="cstat-no" title="statement not covered" >url.asParsedURL();<span class="cstat-no" title="statement not covered" ></span>return parsedURL?parsedURL.securityOrigin():'';}</span>
<span class="fstat-no" title="function not covered" >st</span>atic extractExtension(url){<span class="cstat-no" title="statement not covered" >url=Common.ParsedURL.urlWithoutHash(url);c</span>onst indexOfQuestionMark=<span class="cstat-no" title="statement not covered" >url.indexOf('?');<span class="cstat-no" title="statement not covered" ></span>if(indexOfQuestionMark!==-1)</span>
<span class="cstat-no" title="statement not covered" >url=url.substr(0,indexOfQuestionMark);c</span>onst lastIndexOfSlash=<span class="cstat-no" title="statement not covered" >url.lastIndexOf('/');<span class="cstat-no" title="statement not covered" ></span>if(lastIndexOfSlash!==-1)</span>
<span class="cstat-no" title="statement not covered" >url=url.substr(lastIndexOfSlash+1);c</span>onst lastIndexOfDot=<span class="cstat-no" title="statement not covered" >url.lastIndexOf('.');<span class="cstat-no" title="statement not covered" ></span>if(lastIndexOfDot!==-1){<span class="cstat-no" title="statement not covered" >url=url.substr(lastIndexOfDot+1);c</span>onst lastIndexOfPercent=<span class="cstat-no" title="statement not covered" >url.indexOf('%');<span class="cstat-no" title="statement not covered" ></span>if(lastIndexOfPercent!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >return url.substr(0,lastIndexOfPercent);<span class="cstat-no" title="statement not covered" >r</span>eturn url;}</span>
<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >st</span>atic extractName(url){let index=<span class="cstat-no" title="statement not covered" >url.lastIndexOf('/');</span>const pathAndQuery=<span class="cstat-no" title="statement not covered" >index!==-1?url.substr(index+1):url;<span class="cstat-no" title="statement not covered" ></span>index=pathAndQuery.indexOf('?');<span class="cstat-no" title="statement not covered" >r</span>eturn index&lt;0?pathAndQuery:pathAndQuery.substr(0,index);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic completeURL(baseURL,href){const trimmedHref=<span class="cstat-no" title="statement not covered" >href.trim();<span class="cstat-no" title="statement not covered" ></span>if(trimmedHref.startsWith('data:')||trimmedHref.startsWith('blob:')||trimmedHref.startsWith('javascript:'))</span>
<span class="cstat-no" title="statement not covered" >return href;c</span>onst parsedHref=<span class="cstat-no" title="statement not covered" >trimmedHref.asParsedURL();<span class="cstat-no" title="statement not covered" ></span>if(parsedHref&amp;&amp;parsedHref.scheme)</span>
<span class="cstat-no" title="statement not covered" >return trimmedHref;c</span>onst parsedURL=<span class="cstat-no" title="statement not covered" >baseURL.asParsedURL();<span class="cstat-no" title="statement not covered" ></span>if(!parsedURL)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span>f(parsedURL.isDataURL())</span>
<span class="cstat-no" title="statement not covered" >return href;<span class="cstat-no" title="statement not covered" >i</span>f(href.length&gt;1&amp;&amp;href.charAt(0)==='/'&amp;&amp;href.charAt(1)==='/'){<span class="cstat-no" title="statement not covered" >return parsedURL.scheme+':'+href;}</span></span>
const securityOrigin=<span class="cstat-no" title="statement not covered" >parsedURL.securityOrigin();</span>const pathText=<span class="cstat-no" title="statement not covered" >parsedURL.path;</span>const queryText=<span class="cstat-no" title="statement not covered" >parsedURL.queryParams?'?'+parsedURL.queryParams:'';<span class="cstat-no" title="statement not covered" ></span>if(!href.length)</span>
<span class="cstat-no" title="statement not covered" >return securityOrigin+pathText+queryText;<span class="cstat-no" title="statement not covered" >i</span>f(href.charAt(0)==='#')</span>
<span class="cstat-no" title="statement not covered" >return securityOrigin+pathText+queryText+href;<span class="cstat-no" title="statement not covered" >i</span>f(href.charAt(0)==='?')</span>
<span class="cstat-no" title="statement not covered" >return securityOrigin+pathText+href;l</span>et hrefPath=<span class="cstat-no" title="statement not covered" >href.match(/^[^#?]*/)[0];</span>const hrefSuffix=<span class="cstat-no" title="statement not covered" >href.substring(hrefPath.length);<span class="cstat-no" title="statement not covered" ></span>if(hrefPath.charAt(0)!=='/')</span>
<span class="cstat-no" title="statement not covered" >hrefPath=parsedURL.folderPathComponents+'/'+hrefPath;<span class="cstat-no" title="statement not covered" >r</span>eturn securityOrigin+Runtime.normalizePath(hrefPath)+hrefSuffix;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic splitLineAndColumn(string){const beforePathMatch=<span class="cstat-no" title="statement not covered" >string.match(Common.ParsedURL._urlRegex());</span>let beforePath=<span class="cstat-no" title="statement not covered" >'';</span>let pathAndAfter=<span class="cstat-no" title="statement not covered" >string;<span class="cstat-no" title="statement not covered" ></span>if(beforePathMatch){<span class="cstat-no" title="statement not covered" >beforePath=beforePathMatch[1];<span class="cstat-no" title="statement not covered" >p</span>athAndAfter=string.substring(beforePathMatch[1].length);}</span></span>
const lineColumnRegEx=<span class="cstat-no" title="statement not covered" >/(?::(\d+))?(?::(\d+))?$/;</span>const lineColumnMatch=<span class="cstat-no" title="statement not covered" >lineColumnRegEx.exec(pathAndAfter);</span>let lineNumber;let columnNumber;<span class="cstat-no" title="statement not covered" >console.assert(lineColumnMatch);<span class="cstat-no" title="statement not covered" >i</span>f(typeof(lineColumnMatch[1])==='string'){<span class="cstat-no" title="statement not covered" >lineNumber=parseInt(lineColumnMatch[1],10);<span class="cstat-no" title="statement not covered" >l</span>ineNumber=isNaN(lineNumber)?undefined:lineNumber-1;}</span></span>
<span class="cstat-no" title="statement not covered" >if(typeof(lineColumnMatch[2])==='string'){<span class="cstat-no" title="statement not covered" >columnNumber=parseInt(lineColumnMatch[2],10);<span class="cstat-no" title="statement not covered" >c</span>olumnNumber=isNaN(columnNumber)?undefined:columnNumber-1;}</span></span>
<span class="cstat-no" title="statement not covered" >return{url:beforePath+pathAndAfter.substring(0,pathAndAfter.length-lineColumnMatch[0].length),lineNumber:lineNumber,columnNumber:columnNumber};}</span>
<span class="fstat-no" title="function not covered" >st</span>atic isRelativeURL(url){<span class="cstat-no" title="statement not covered" >return!(/^[A-Za-z][A-Za-z0-9+.-]*:/.test(url));}</span>
<span class="fstat-no" title="function not covered" >ge</span>t displayName(){<span class="cstat-no" title="statement not covered" >if(this._displayName)</span>
<span class="cstat-no" title="statement not covered" >return this._displayName;<span class="cstat-no" title="statement not covered" >i</span>f(this.isDataURL())</span>
<span class="cstat-no" title="statement not covered" >return this.dataURLDisplayName();<span class="cstat-no" title="statement not covered" >i</span>f(this.isAboutBlank())</span>
<span class="cstat-no" title="statement not covered" >return this.url;<span class="cstat-no" title="statement not covered" >t</span>his._displayName=this.lastPathComponent;<span class="cstat-no" title="statement not covered" >i</span>f(!this._displayName)</span>
<span class="cstat-no" title="statement not covered" >this._displayName=(this.host||'')+'/';<span class="cstat-no" title="statement not covered" >i</span>f(this._displayName==='/')</span>
<span class="cstat-no" title="statement not covered" >this._displayName=this.url;<span class="cstat-no" title="statement not covered" >r</span>eturn this._displayName;}</span>
<span class="fstat-no" title="function not covered" >da</span>taURLDisplayName(){<span class="cstat-no" title="statement not covered" >if(this._dataURLDisplayName)</span>
<span class="cstat-no" title="statement not covered" >return this._dataURLDisplayName;<span class="cstat-no" title="statement not covered" >i</span>f(!this.isDataURL())</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >t</span>his._dataURLDisplayName=this.url.trimEnd(20);<span class="cstat-no" title="statement not covered" >r</span>eturn this._dataURLDisplayName;}</span>
<span class="fstat-no" title="function not covered" >is</span>AboutBlank(){<span class="cstat-no" title="statement not covered" >return this.url==='about:blank';}</span>
<span class="fstat-no" title="function not covered" >is</span>DataURL(){<span class="cstat-no" title="statement not covered" >return this.scheme==='data';}</span>
<span class="fstat-no" title="function not covered" >la</span>stPathComponentWithFragment(){<span class="cstat-no" title="statement not covered" >return this.lastPathComponent+(this.fragment?'#'+this.fragment:'');}</span>
<span class="fstat-no" title="function not covered" >do</span>main(){<span class="cstat-no" title="statement not covered" >if(this.isDataURL())</span>
<span class="cstat-no" title="statement not covered" >return'data:';<span class="cstat-no" title="statement not covered" >r</span>eturn this.host+(this.port?':'+this.port:'');}</span>
<span class="fstat-no" title="function not covered" >se</span>curityOrigin(){<span class="cstat-no" title="statement not covered" >if(this.isDataURL())</span>
<span class="cstat-no" title="statement not covered" >return'data:';<span class="cstat-no" title="statement not covered" >r</span>eturn this.scheme+'://'+this.domain();}</span>
<span class="fstat-no" title="function not covered" >ur</span>lWithoutScheme(){<span class="cstat-no" title="statement not covered" >if(this.scheme&amp;&amp;this.url.startsWith(this.scheme+'://'))</span>
<span class="cstat-no" title="statement not covered" >return this.url.substring(this.scheme.length+3);<span class="cstat-no" title="statement not covered" >r</span>eturn this.url;}</span>};<span class="cstat-no" title="statement not covered" >String.prototype.asParsedURL=<span class="fstat-no" title="function not covered" >fu</span>nction(){const parsedURL=<span class="cstat-no" title="statement not covered" >new Common.ParsedURL(this.toString());<span class="cstat-no" title="statement not covered" ></span>if(parsedURL.isValid)</span></span>
<span class="cstat-no" title="statement not covered" >return parsedURL;<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>;;<span class="cstat-no" title="statement not covered" >Common.Progress=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.Progress.prototype={setTotalWork(totalWork){},setTitle(title){},setWorked(worked,title){},worked(worked){},done(){},isCanceled(){<span class="cstat-no" title="statement not covered" >return false;}</span>,};<span class="cstat-no" title="statement not covered" >C</span>ommon.CompositeProgress=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(parent){<span class="cstat-no" title="statement not covered" >this._parent=parent;<span class="cstat-no" title="statement not covered" >t</span>his._children=[];<span class="cstat-no" title="statement not covered" >t</span>his._childrenDone=0;<span class="cstat-no" title="statement not covered" >t</span>his._parent.setTotalWork(1);<span class="cstat-no" title="statement not covered" >t</span>his._parent.setWorked(0);}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>hildDone(){<span class="cstat-no" title="statement not covered" >if(++this._childrenDone!==this._children.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._parent.done();}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSubProgress(weight){const child=<span class="cstat-no" title="statement not covered" >new Common.SubProgress(this,weight);<span class="cstat-no" title="statement not covered" ></span>this._children.push(child);<span class="cstat-no" title="statement not covered" >r</span>eturn child;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){let totalWeights=<span class="cstat-no" title="statement not covered" >0;</span>let done=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._children.length;++i){const child=<span class="cstat-no" title="statement not covered" >this._children[i];<span class="cstat-no" title="statement not covered" ></span>if(child._totalWork)</span></span>
<span class="cstat-no" title="statement not covered" >done+=child._weight*child._worked/child._totalWork;<span class="cstat-no" title="statement not covered" >t</span>otalWeights+=child._weight;}</span>
<span class="cstat-no" title="statement not covered" >this._parent.setWorked(done/totalWeights);}</span>};<span class="cstat-no" title="statement not covered" >Common.SubProgress=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(composite,weight){<span class="cstat-no" title="statement not covered" >this._composite=composite;<span class="cstat-no" title="statement not covered" >t</span>his._weight=weight||1;<span class="cstat-no" title="statement not covered" >t</span>his._worked=0;}</span></span>
<span class="fstat-no" title="function not covered" >is</span>Canceled(){<span class="cstat-no" title="statement not covered" >return this._composite._parent.isCanceled();}</span>
<span class="fstat-no" title="function not covered" >se</span>tTitle(title){<span class="cstat-no" title="statement not covered" >this._composite._parent.setTitle(title);}</span>
<span class="fstat-no" title="function not covered" >do</span>ne(){<span class="cstat-no" title="statement not covered" >this.setWorked(this._totalWork);<span class="cstat-no" title="statement not covered" >t</span>his._composite._childDone();}</span>
<span class="fstat-no" title="function not covered" >se</span>tTotalWork(totalWork){<span class="cstat-no" title="statement not covered" >this._totalWork=totalWork;<span class="cstat-no" title="statement not covered" >t</span>his._composite._update();}</span>
<span class="fstat-no" title="function not covered" >se</span>tWorked(worked,title){<span class="cstat-no" title="statement not covered" >this._worked=worked;<span class="cstat-no" title="statement not covered" >i</span>f(typeof title!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >this.setTitle(title);<span class="cstat-no" title="statement not covered" >t</span>his._composite._update();}</span>
<span class="fstat-no" title="function not covered" >wo</span>rked(worked){<span class="cstat-no" title="statement not covered" >this.setWorked(this._worked+(worked||1));}</span>};<span class="cstat-no" title="statement not covered" >Common.ProgressProxy=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(delegate,doneCallback){<span class="cstat-no" title="statement not covered" >this._delegate=delegate;<span class="cstat-no" title="statement not covered" >t</span>his._doneCallback=doneCallback;}</span></span>
<span class="fstat-no" title="function not covered" >is</span>Canceled(){<span class="cstat-no" title="statement not covered" >return this._delegate?this._delegate.isCanceled():false;}</span>
<span class="fstat-no" title="function not covered" >se</span>tTitle(title){<span class="cstat-no" title="statement not covered" >if(this._delegate)</span>
<span class="cstat-no" title="statement not covered" >this._delegate.setTitle(title);}</span>
<span class="fstat-no" title="function not covered" >do</span>ne(){<span class="cstat-no" title="statement not covered" >if(this._delegate)</span>
<span class="cstat-no" title="statement not covered" >this._delegate.done();<span class="cstat-no" title="statement not covered" >i</span>f(this._doneCallback)</span>
<span class="cstat-no" title="statement not covered" >this._doneCallback();}</span>
<span class="fstat-no" title="function not covered" >se</span>tTotalWork(totalWork){<span class="cstat-no" title="statement not covered" >if(this._delegate)</span>
<span class="cstat-no" title="statement not covered" >this._delegate.setTotalWork(totalWork);}</span>
<span class="fstat-no" title="function not covered" >se</span>tWorked(worked,title){<span class="cstat-no" title="statement not covered" >if(this._delegate)</span>
<span class="cstat-no" title="statement not covered" >this._delegate.setWorked(worked,title);}</span>
<span class="fstat-no" title="function not covered" >wo</span>rked(worked){<span class="cstat-no" title="statement not covered" >if(this._delegate)</span>
<span class="cstat-no" title="statement not covered" >this._delegate.worked(worked);}</span>};;<span class="cstat-no" title="statement not covered" >Common.ResourceType=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(name,title,category,isTextType){<span class="cstat-no" title="statement not covered" >this._name=name;<span class="cstat-no" title="statement not covered" >t</span>his._title=title;<span class="cstat-no" title="statement not covered" >t</span>his._category=category;<span class="cstat-no" title="statement not covered" >t</span>his._isTextType=isTextType;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic fromMimeType(mimeType){<span class="cstat-no" title="statement not covered" >if(mimeType.startsWith('text/html'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Document;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.startsWith('text/css'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Stylesheet;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.startsWith('image/'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Image;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.startsWith('text/'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Script;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.includes('font'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Font;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.includes('script'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Script;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.includes('octet'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Other;<span class="cstat-no" title="statement not covered" >i</span>f(mimeType.includes('application'))</span>
<span class="cstat-no" title="statement not covered" >return Common.resourceTypes.Script;<span class="cstat-no" title="statement not covered" >r</span>eturn Common.resourceTypes.Other;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromURL(url){<span class="cstat-no" title="statement not covered" >return Common.ResourceType._resourceTypeByExtension.get(Common.ParsedURL.extractExtension(url))||null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromName(name){<span class="cstat-no" title="statement not covered" >for(const resourceTypeId in Common.resourceTypes){const resourceType=<span class="cstat-no" title="statement not covered" >Common.resourceTypes[resourceTypeId];<span class="cstat-no" title="statement not covered" ></span>if(resourceType.name()===name)</span></span>
<span class="cstat-no" title="statement not covered" >return resourceType;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic mimeFromURL(url){const name=<span class="cstat-no" title="statement not covered" >Common.ParsedURL.extractName(url);<span class="cstat-no" title="statement not covered" ></span>if(Common.ResourceType._mimeTypeByName.has(name))</span>
<span class="cstat-no" title="statement not covered" >return Common.ResourceType._mimeTypeByName.get(name);c</span>onst ext=<span class="cstat-no" title="statement not covered" >Common.ParsedURL.extractExtension(url).toLowerCase();<span class="cstat-no" title="statement not covered" ></span>return Common.ResourceType._mimeTypeByExtension.get(ext);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic mimeFromExtension(ext){<span class="cstat-no" title="statement not covered" >return Common.ResourceType._mimeTypeByExtension.get(ext);}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >ti</span>tle(){<span class="cstat-no" title="statement not covered" >return this._title;}</span>
<span class="fstat-no" title="function not covered" >ca</span>tegory(){<span class="cstat-no" title="statement not covered" >return this._category;}</span>
<span class="fstat-no" title="function not covered" >is</span>TextType(){<span class="cstat-no" title="statement not covered" >return this._isTextType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Script(){<span class="cstat-no" title="statement not covered" >return this._name==='script'||this._name==='sm-script';}</span>
<span class="fstat-no" title="function not covered" >ha</span>sScripts(){<span class="cstat-no" title="statement not covered" >return this.isScript()||this.isDocument();}</span>
<span class="fstat-no" title="function not covered" >is</span>StyleSheet(){<span class="cstat-no" title="statement not covered" >return this._name==='stylesheet'||this._name==='sm-stylesheet';}</span>
<span class="fstat-no" title="function not covered" >is</span>Document(){<span class="cstat-no" title="statement not covered" >return this._name==='document';}</span>
<span class="fstat-no" title="function not covered" >is</span>DocumentOrScriptOrStyleSheet(){<span class="cstat-no" title="statement not covered" >return this.isDocument()||this.isScript()||this.isStyleSheet();}</span>
<span class="fstat-no" title="function not covered" >is</span>FromSourceMap(){<span class="cstat-no" title="statement not covered" >return this._name.startsWith('sm-');}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >ca</span>nonicalMimeType(){<span class="cstat-no" title="statement not covered" >if(this.isDocument())</span>
<span class="cstat-no" title="statement not covered" >return'text/html';<span class="cstat-no" title="statement not covered" >i</span>f(this.isScript())</span>
<span class="cstat-no" title="statement not covered" >return'text/javascript';<span class="cstat-no" title="statement not covered" >i</span>f(this.isStyleSheet())</span>
<span class="cstat-no" title="statement not covered" >return'text/css';<span class="cstat-no" title="statement not covered" >r</span>eturn'';}</span>};<span class="cstat-no" title="statement not covered" >Common.ResourceCategory=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(title,shortTitle){<span class="cstat-no" title="statement not covered" >this.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.shortTitle=shortTitle;}</span>};<span class="cstat-no" title="statement not covered" >C</span>ommon.resourceCategories={XHR:new Common.ResourceCategory('XHR and Fetch','XHR'),Script:new Common.ResourceCategory('Scripts','JS'),Stylesheet:new Common.ResourceCategory('Stylesheets','CSS'),Image:new Common.ResourceCategory('Images','Img'),Media:new Common.ResourceCategory('Media','Media'),Font:new Common.ResourceCategory('Fonts','Font'),Document:new Common.ResourceCategory('Documents','Doc'),WebSocket:new Common.ResourceCategory('WebSockets','WS'),Manifest:new Common.ResourceCategory('Manifest','Manifest'),Other:new Common.ResourceCategory('Other','Other')};<span class="cstat-no" title="statement not covered" >C</span>ommon.resourceTypes={XHR:new Common.ResourceType('xhr','XHR',Common.resourceCategories.XHR,true),Fetch:new Common.ResourceType('fetch','Fetch',Common.resourceCategories.XHR,true),EventSource:new Common.ResourceType('eventsource','EventSource',Common.resourceCategories.XHR,true),Script:new Common.ResourceType('script','Script',Common.resourceCategories.Script,true),Stylesheet:new Common.ResourceType('stylesheet','Stylesheet',Common.resourceCategories.Stylesheet,true),Image:new Common.ResourceType('image','Image',Common.resourceCategories.Image,false),Media:new Common.ResourceType('media','Media',Common.resourceCategories.Media,false),Font:new Common.ResourceType('font','Font',Common.resourceCategories.Font,false),Document:new Common.ResourceType('document','Document',Common.resourceCategories.Document,true),TextTrack:new Common.ResourceType('texttrack','TextTrack',Common.resourceCategories.Other,true),WebSocket:new Common.ResourceType('websocket','WebSocket',Common.resourceCategories.WebSocket,false),Other:new Common.ResourceType('other','Other',Common.resourceCategories.Other,false),SourceMapScript:new Common.ResourceType('sm-script','Script',Common.resourceCategories.Script,true),SourceMapStyleSheet:new Common.ResourceType('sm-stylesheet','Stylesheet',Common.resourceCategories.Stylesheet,true),Manifest:new Common.ResourceType('manifest','Manifest',Common.resourceCategories.Manifest,true),SignedExchange:new Common.ResourceType('signed-exchange','SignedExchange',Common.resourceCategories.Other,false),};<span class="cstat-no" title="statement not covered" >C</span>ommon.ResourceType._mimeTypeByName=new Map([['Cakefile','text/x-coffeescript']]);<span class="cstat-no" title="statement not covered" >C</span>ommon.ResourceType._resourceTypeByExtension=new Map([['js',Common.resourceTypes.Script],['mjs',Common.resourceTypes.Script],['css',Common.resourceTypes.Stylesheet],['xsl',Common.resourceTypes.Stylesheet],['jpeg',Common.resourceTypes.Image],['jpg',Common.resourceTypes.Image],['svg',Common.resourceTypes.Image],['gif',Common.resourceTypes.Image],['png',Common.resourceTypes.Image],['ico',Common.resourceTypes.Image],['tiff',Common.resourceTypes.Image],['tif',Common.resourceTypes.Image],['bmp',Common.resourceTypes.Image],['webp',Common.resourceTypes.Media],['ttf',Common.resourceTypes.Font],['otf',Common.resourceTypes.Font],['ttc',Common.resourceTypes.Font],['woff',Common.resourceTypes.Font]]);<span class="cstat-no" title="statement not covered" >C</span>ommon.ResourceType._mimeTypeByExtension=new Map([['js','text/javascript'],['mjs','text/javascript'],['css','text/css'],['html','text/html'],['htm','text/html'],['xml','application/xml'],['xsl','application/xml'],['asp','application/x-aspx'],['aspx','application/x-aspx'],['jsp','application/x-jsp'],['c','text/x-c++src'],['cc','text/x-c++src'],['cpp','text/x-c++src'],['h','text/x-c++src'],['m','text/x-c++src'],['mm','text/x-c++src'],['coffee','text/x-coffeescript'],['dart','text/javascript'],['ts','text/typescript'],['tsx','text/typescript-jsx'],['json','application/json'],['gyp','application/json'],['gypi','application/json'],['cs','text/x-csharp'],['java','text/x-java'],['less','text/x-less'],['php','text/x-php'],['phtml','application/x-httpd-php'],['py','text/x-python'],['sh','text/x-sh'],['scss','text/x-scss'],['vtt','text/vtt'],['ls','text/x-livescript'],['md','text/markdown'],['cljs','text/x-clojure'],['cljc','text/x-clojure'],['cljx','text/x-clojure'],['styl','text/x-styl'],['jsx','text/jsx'],['jpeg','image/jpeg'],['jpg','image/jpeg'],['svg','image/svg+xml'],['gif','image/gif'],['webp','image/webp'],['png','image/png'],['ico','image/ico'],['tiff','image/tiff'],['tif','image/tif'],['bmp','image/bmp'],['ttf','font/opentype'],['otf','font/opentype'],['ttc','font/opentype'],['woff','application/font-woff']]);;<span class="cstat-no" title="statement not covered" ></span>Common.Settings=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(globalStorage,localStorage){<span class="cstat-no" title="statement not covered" >this._globalStorage=globalStorage;<span class="cstat-no" title="statement not covered" >t</span>his._localStorage=localStorage;<span class="cstat-no" title="statement not covered" >t</span>his._sessionStorage=new Common.SettingsStorage({});<span class="cstat-no" title="statement not covered" >t</span>his._eventSupport=new Common.Object();<span class="cstat-no" title="statement not covered" >t</span>his._registry=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._moduleSettings=new Map();<span class="cstat-no" title="statement not covered" >s</span>elf.runtime.extensions('setting').forEach(this._registerModuleSetting.bind(this));}</span></span>
<span class="fstat-no" title="function not covered" >_r</span>egisterModuleSetting(extension){const descriptor=<span class="cstat-no" title="statement not covered" >extension.descriptor();</span>const settingName=<span class="cstat-no" title="statement not covered" >descriptor['settingName'];</span>const isRegex=<span class="cstat-no" title="statement not covered" >descriptor['settingType']==='regex';</span>const defaultValue=<span class="cstat-no" title="statement not covered" >descriptor['defaultValue'];</span>let storageType;<span class="cstat-no" title="statement not covered" >switch(descriptor['storageType']){case('local'):<span class="cstat-no" title="statement not covered" >storageType=Common.SettingStorageType.Local;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase('session'):<span class="cstat-no" title="statement not covered" >storageType=Common.SettingStorageType.Session;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase('global'):<span class="cstat-no" title="statement not covered" >storageType=Common.SettingStorageType.Global;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >storageType=Common.SettingStorageType.Global;}</span></span>
const setting=<span class="cstat-no" title="statement not covered" >isRegex?this.createRegExpSetting(settingName,defaultValue,undefined,storageType):this.createSetting(settingName,defaultValue,storageType);<span class="cstat-no" title="statement not covered" ></span>if(descriptor['title'])</span>
<span class="cstat-no" title="statement not covered" >setting.setTitle(descriptor['title']);<span class="cstat-no" title="statement not covered" >i</span>f(descriptor['userActionCondition'])</span>
<span class="cstat-no" title="statement not covered" >setting.setRequiresUserAction(!!Runtime.queryParam(descriptor['userActionCondition']));<span class="cstat-no" title="statement not covered" >s</span>etting._extension=extension;<span class="cstat-no" title="statement not covered" >t</span>his._moduleSettings.set(settingName,setting);}</span>
<span class="fstat-no" title="function not covered" >mo</span>duleSetting(settingName){const setting=<span class="cstat-no" title="statement not covered" >this._moduleSettings.get(settingName);<span class="cstat-no" title="statement not covered" ></span>if(!setting)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('No setting registered: '+settingName);<span class="cstat-no" title="statement not covered" >r</span>eturn setting;}</span>
<span class="fstat-no" title="function not covered" >se</span>ttingForTest(settingName){const setting=<span class="cstat-no" title="statement not covered" >this._registry.get(settingName);<span class="cstat-no" title="statement not covered" ></span>if(!setting)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('No setting registered: '+settingName);<span class="cstat-no" title="statement not covered" >r</span>eturn setting;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSetting(key,defaultValue,storageType){const storage=<span class="cstat-no" title="statement not covered" >this._storageFromType(storageType);<span class="cstat-no" title="statement not covered" ></span>if(!this._registry.get(key))</span>
<span class="cstat-no" title="statement not covered" >this._registry.set(key,new Common.Setting(this,key,defaultValue,this._eventSupport,storage));<span class="cstat-no" title="statement not covered" >r</span>eturn(this._registry.get(key));}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateLocalSetting(key,defaultValue){<span class="cstat-no" title="statement not covered" >return this.createSetting(key,defaultValue,Common.SettingStorageType.Local);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRegExpSetting(key,defaultValue,regexFlags,storageType){<span class="cstat-no" title="statement not covered" >if(!this._registry.get(key)){<span class="cstat-no" title="statement not covered" >this._registry.set(key,new Common.RegExpSetting(this,key,defaultValue,this._eventSupport,this._storageFromType(storageType),regexFlags));}</span></span>
<span class="cstat-no" title="statement not covered" >return(this._registry.get(key));}</span>
<span class="fstat-no" title="function not covered" >cl</span>earAll(){<span class="cstat-no" title="statement not covered" >this._globalStorage.removeAll();<span class="cstat-no" title="statement not covered" >t</span>his._localStorage.removeAll();c</span>onst versionSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(Common.VersionController._currentVersionName,0);<span class="cstat-no" title="statement not covered" ></span>versionSetting.set(Common.VersionController.currentVersion);}</span>
<span class="fstat-no" title="function not covered" >_s</span>torageFromType(storageType){<span class="cstat-no" title="statement not covered" >switch(storageType){case(Common.SettingStorageType.Local):<span class="cstat-no" title="statement not covered" >return this._localStorage;c</span>ase(Common.SettingStorageType.Session):<span class="cstat-no" title="statement not covered" >return this._sessionStorage;c</span>ase(Common.SettingStorageType.Global):<span class="cstat-no" title="statement not covered" >return this._globalStorage;}</span></span>
<span class="cstat-no" title="statement not covered" >return this._globalStorage;}</span>};<span class="cstat-no" title="statement not covered" >Common.SettingsStorage=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(object,setCallback,removeCallback,removeAllCallback,storagePrefix){<span class="cstat-no" title="statement not covered" >this._object=object;<span class="cstat-no" title="statement not covered" >t</span>his._setCallback=setCallback||<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >t</span>his._removeCallback=removeCallback||<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >t</span>his._removeAllCallback=removeAllCallback||<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >t</span>his._storagePrefix=storagePrefix||'';}</span></span>
<span class="fstat-no" title="function not covered" >se</span>t(name,value){<span class="cstat-no" title="statement not covered" >name=this._storagePrefix+name;<span class="cstat-no" title="statement not covered" >t</span>his._object[name]=value;<span class="cstat-no" title="statement not covered" >t</span>his._setCallback(name,value);}</span>
<span class="fstat-no" title="function not covered" >ha</span>s(name){<span class="cstat-no" title="statement not covered" >name=this._storagePrefix+name;<span class="cstat-no" title="statement not covered" >r</span>eturn name in this._object;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t(name){<span class="cstat-no" title="statement not covered" >name=this._storagePrefix+name;<span class="cstat-no" title="statement not covered" >r</span>eturn this._object[name];}</span>
<span class="fstat-no" title="function not covered" >re</span>move(name){<span class="cstat-no" title="statement not covered" >name=this._storagePrefix+name;<span class="cstat-no" title="statement not covered" >d</span>elete this._object[name];<span class="cstat-no" title="statement not covered" >t</span>his._removeCallback(name);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveAll(){<span class="cstat-no" title="statement not covered" >this._object={};<span class="cstat-no" title="statement not covered" >t</span>his._removeAllCallback();}</span>
<span class="fstat-no" title="function not covered" >_d</span>umpSizes(){<span class="cstat-no" title="statement not covered" >Common.console.log('Ten largest settings: ');c</span>onst sizes=<span class="cstat-no" title="statement not covered" >{__proto__:null};<span class="cstat-no" title="statement not covered" ></span>for(const key in this._object)</span>
<span class="cstat-no" title="statement not covered" >sizes[key]=this._object[key].length;c</span>onst keys=<span class="cstat-no" title="statement not covered" >Object.keys(sizes);</span>function <span class="fstat-no" title="function not covered" >comparator(</span>key1,key2){<span class="cstat-no" title="statement not covered" >return sizes[key2]-sizes[key1];}</span>
<span class="cstat-no" title="statement not covered" >keys.sort(comparator);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;10&amp;&amp;i&lt;keys.length;++i)</span>
<span class="cstat-no" title="statement not covered" >Common.console.log('Setting: \''+keys[i]+'\', size: '+sizes[keys[i]]);}</span>};<span class="cstat-no" title="statement not covered" >Common.Setting=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(settings,name,defaultValue,eventSupport,storage){<span class="cstat-no" title="statement not covered" >this._settings=settings;<span class="cstat-no" title="statement not covered" >t</span>his._name=name;<span class="cstat-no" title="statement not covered" >t</span>his._defaultValue=defaultValue;<span class="cstat-no" title="statement not covered" >t</span>his._eventSupport=eventSupport;<span class="cstat-no" title="statement not covered" >t</span>his._storage=storage;<span class="cstat-no" title="statement not covered" >t</span>his._title='';<span class="cstat-no" title="statement not covered" >t</span>his._extension=null;}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dChangeListener(listener,thisObject){<span class="cstat-no" title="statement not covered" >this._eventSupport.addEventListener(this._name,listener,thisObject);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveChangeListener(listener,thisObject){<span class="cstat-no" title="statement not covered" >this._eventSupport.removeEventListener(this._name,listener,thisObject);}</span>
<span class="fstat-no" title="function not covered" >ge</span>t name(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >ti</span>tle(){<span class="cstat-no" title="statement not covered" >return this._title;}</span>
<span class="fstat-no" title="function not covered" >se</span>tTitle(title){<span class="cstat-no" title="statement not covered" >this._title=title;}</span>
<span class="fstat-no" title="function not covered" >se</span>tRequiresUserAction(requiresUserAction){<span class="cstat-no" title="statement not covered" >this._requiresUserAction=requiresUserAction;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >if(this._requiresUserAction&amp;&amp;!this._hadUserAction)</span>
<span class="cstat-no" title="statement not covered" >return this._defaultValue;<span class="cstat-no" title="statement not covered" >i</span>f(typeof this._value!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >return this._value;<span class="cstat-no" title="statement not covered" >t</span>his._value=this._defaultValue;<span class="cstat-no" title="statement not covered" >i</span>f(this._storage.has(this._name)){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this._value=JSON.parse(this._storage.get(this._name));}</span>catch(e){<span class="cstat-no" title="statement not covered" >this._storage.remove(this._name);}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return this._value;}</span>
<span class="fstat-no" title="function not covered" >se</span>t(value){<span class="cstat-no" title="statement not covered" >this._hadUserAction=true;<span class="cstat-no" title="statement not covered" >t</span>his._value=value;<span class="cstat-no" title="statement not covered" >t</span>ry{const settingString=<span class="cstat-no" title="statement not covered" >JSON.stringify(value);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >this._storage.set(this._name,settingString);}</span>catch(e){<span class="cstat-no" title="statement not covered" >this._printSettingsSavingError(e.message,this._name,settingString);}</span>}</span>catch(e){<span class="cstat-no" title="statement not covered" >Common.console.error('Cannot stringify setting with name: '+this._name+', error: '+e.message);}</span></span>
<span class="cstat-no" title="statement not covered" >this._eventSupport.dispatchEventToListeners(this._name,value);}</span>
<span class="fstat-no" title="function not covered" >re</span>move(){<span class="cstat-no" title="statement not covered" >this._settings._registry.delete(this._name);<span class="cstat-no" title="statement not covered" >t</span>his._settings._moduleSettings.delete(this._name);<span class="cstat-no" title="statement not covered" >t</span>his._storage.remove(this._name);}</span>
<span class="fstat-no" title="function not covered" >ex</span>tension(){<span class="cstat-no" title="statement not covered" >return this._extension;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rintSettingsSavingError(message,name,value){const errorMessage=<span class="cstat-no" title="statement not covered" >'Error saving setting with name: '+this._name+', value length: '+value.length+'. Error: '+message;<span class="cstat-no" title="statement not covered" ></span>console.error(errorMessage);<span class="cstat-no" title="statement not covered" >C</span>ommon.console.error(errorMessage);<span class="cstat-no" title="statement not covered" >t</span>his._storage._dumpSizes();}</span>};<span class="cstat-no" title="statement not covered" >Common.RegExpSetting=class extends Common.Setting{<span class="fstat-no" title="function not covered" >co</span>nstructor(settings,name,defaultValue,eventSupport,storage,regexFlags){<span class="cstat-no" title="statement not covered" >super(settings,name,defaultValue?[{pattern:defaultValue}]:[],eventSupport,storage);<span class="cstat-no" title="statement not covered" >t</span>his._regexFlags=regexFlags;}</span></span>
<span class="fstat-no" title="function not covered" >ge</span>t(){const result=<span class="cstat-no" title="statement not covered" >[];</span>const items=<span class="cstat-no" title="statement not covered" >this.getAsArray();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;items.length;++i){const item=<span class="cstat-no" title="statement not covered" >items[i];<span class="cstat-no" title="statement not covered" ></span>if(item.pattern&amp;&amp;!item.disabled)</span></span>
<span class="cstat-no" title="statement not covered" >result.push(item.pattern);}</span>
<span class="cstat-no" title="statement not covered" >return result.join('|');}</span>
<span class="fstat-no" title="function not covered" >ge</span>tAsArray(){<span class="cstat-no" title="statement not covered" >return super.get();}</span>
<span class="fstat-no" title="function not covered" >se</span>t(value){<span class="cstat-no" title="statement not covered" >this.setAsArray([{pattern:value}]);}</span>
<span class="fstat-no" title="function not covered" >se</span>tAsArray(value){<span class="cstat-no" title="statement not covered" >delete this._regex;<span class="cstat-no" title="statement not covered" >s</span>uper.set(value);}</span>
<span class="fstat-no" title="function not covered" >as</span>RegExp(){<span class="cstat-no" title="statement not covered" >if(typeof this._regex!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >return this._regex;<span class="cstat-no" title="statement not covered" >t</span>his._regex=null;<span class="cstat-no" title="statement not covered" >t</span>ry{const pattern=<span class="cstat-no" title="statement not covered" >this.get();<span class="cstat-no" title="statement not covered" ></span>if(pattern)</span></span>
<span class="cstat-no" title="statement not covered" >this._regex=new RegExp(pattern,this._regexFlags||'');}</span>catch(e){}
<span class="cstat-no" title="statement not covered" >return this._regex;}</span>};<span class="cstat-no" title="statement not covered" >Common.VersionController=class{<span class="fstat-no" title="function not covered" >up</span>dateVersion(){const localStorageVersion=<span class="cstat-no" title="statement not covered" >window.localStorage?window.localStorage[Common.VersionController._currentVersionName]:0;</span>const versionSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(Common.VersionController._currentVersionName,0);</span>const currentVersion=<span class="cstat-no" title="statement not covered" >Common.VersionController.currentVersion;</span>const oldVersion=<span class="cstat-no" title="statement not covered" >versionSetting.get()||parseInt(localStorageVersion||'0',10);<span class="cstat-no" title="statement not covered" ></span>if(oldVersion===0){<span class="cstat-no" title="statement not covered" >versionSetting.set(currentVersion);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
const methodsToRun=<span class="cstat-no" title="statement not covered" >this._methodsToRunToUpdateVersion(oldVersion,currentVersion);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;methodsToRun.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this[methodsToRun[i]].call(this);<span class="cstat-no" title="statement not covered" >v</span>ersionSetting.set(currentVersion);}</span>
<span class="fstat-no" title="function not covered" >_m</span>ethodsToRunToUpdateVersion(oldVersion,currentVersion){const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=oldVersion;i&lt;currentVersion;++i)</span>
<span class="cstat-no" title="statement not covered" >result.push('_updateVersionFrom'+i+'To'+(i+1));<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom0To1(){<span class="cstat-no" title="statement not covered" >this._clearBreakpointsWhenTooMany(Common.settings.createLocalSetting('breakpoints',[]),500000);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom1To2(){<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('previouslyViewedFiles',[]).set([]);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom2To3(){<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('fileSystemMapping',{}).set({});<span class="cstat-no" title="statement not covered" >C</span>ommon.settings.createSetting('fileMappingEntries',[]).remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom3To4(){const advancedMode=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('showHeaSnapshotObjectsHiddenProperties',false);<span class="cstat-no" title="statement not covered" ></span>Common.moduleSetting('showAdvancedHeapSnapshotProperties').set(advancedMode.get());<span class="cstat-no" title="statement not covered" >a</span>dvancedMode.remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom4To5(){const settingNames=<span class="cstat-no" title="statement not covered" >{'FileSystemViewSidebarWidth':'fileSystemViewSplitViewState','elementsSidebarWidth':'elementsPanelSplitViewState','StylesPaneSplitRatio':'stylesPaneSplitViewState','heapSnapshotRetainersViewSize':'heapSnapshotSplitViewState','InspectorView.splitView':'InspectorView.splitViewState','InspectorView.screencastSplitView':'InspectorView.screencastSplitViewState','Inspector.drawerSplitView':'Inspector.drawerSplitViewState','layerDetailsSplitView':'layerDetailsSplitViewState','networkSidebarWidth':'networkPanelSplitViewState','sourcesSidebarWidth':'sourcesPanelSplitViewState','scriptsPanelNavigatorSidebarWidth':'sourcesPanelNavigatorSplitViewState','sourcesPanelSplitSidebarRatio':'sourcesPanelDebuggerSidebarSplitViewState','timeline-details':'timelinePanelDetailsSplitViewState','timeline-split':'timelinePanelRecorsSplitViewState','timeline-view':'timelinePanelTimelineStackSplitViewState','auditsSidebarWidth':'auditsPanelSplitViewState','layersSidebarWidth':'layersPanelSplitViewState','profilesSidebarWidth':'profilesPanelSplitViewState','resourcesSidebarWidth':'resourcesPanelSplitViewState'};</span>const empty=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const oldName in settingNames){const newName=<span class="cstat-no" title="statement not covered" >settingNames[oldName];</span>const oldNameH=<span class="cstat-no" title="statement not covered" >oldName+'H';</span>let newValue=<span class="cstat-no" title="statement not covered" >null;</span>const oldSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(oldName,empty);<span class="cstat-no" title="statement not covered" ></span>if(oldSetting.get()!==empty){<span class="cstat-no" title="statement not covered" >newValue=newValue||{};<span class="cstat-no" title="statement not covered" >n</span>ewValue.vertical={};<span class="cstat-no" title="statement not covered" >n</span>ewValue.vertical.size=oldSetting.get();<span class="cstat-no" title="statement not covered" >o</span>ldSetting.remove();}</span></span></span>
const oldSettingH=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(oldNameH,empty);<span class="cstat-no" title="statement not covered" ></span>if(oldSettingH.get()!==empty){<span class="cstat-no" title="statement not covered" >newValue=newValue||{};<span class="cstat-no" title="statement not covered" >n</span>ewValue.horizontal={};<span class="cstat-no" title="statement not covered" >n</span>ewValue.horizontal.size=oldSettingH.get();<span class="cstat-no" title="statement not covered" >o</span>ldSettingH.remove();}</span></span>
<span class="cstat-no" title="statement not covered" >if(newValue)</span>
<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(newName,{}).set(newValue);}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom5To6(){const settingNames=<span class="cstat-no" title="statement not covered" >{'debuggerSidebarHidden':'sourcesPanelSplitViewState','navigatorHidden':'sourcesPanelNavigatorSplitViewState','WebInspector.Drawer.showOnLoad':'Inspector.drawerSplitViewState'};<span class="cstat-no" title="statement not covered" ></span>for(const oldName in settingNames){const oldSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(oldName,null);<span class="cstat-no" title="statement not covered" ></span>if(oldSetting.get()===null){<span class="cstat-no" title="statement not covered" >oldSetting.remove();<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
const newName=<span class="cstat-no" title="statement not covered" >settingNames[oldName];</span>const invert=<span class="cstat-no" title="statement not covered" >oldName==='WebInspector.Drawer.showOnLoad';</span>const hidden=<span class="cstat-no" title="statement not covered" >oldSetting.get()!==invert;<span class="cstat-no" title="statement not covered" ></span>oldSetting.remove();c</span>onst showMode=<span class="cstat-no" title="statement not covered" >hidden?'OnlyMain':'Both';</span>const newSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(newName,{});</span>const newValue=<span class="cstat-no" title="statement not covered" >newSetting.get()||{};<span class="cstat-no" title="statement not covered" ></span>newValue.vertical=newValue.vertical||{};<span class="cstat-no" title="statement not covered" >n</span>ewValue.vertical.showMode=showMode;<span class="cstat-no" title="statement not covered" >n</span>ewValue.horizontal=newValue.horizontal||{};<span class="cstat-no" title="statement not covered" >n</span>ewValue.horizontal.showMode=showMode;<span class="cstat-no" title="statement not covered" >n</span>ewSetting.set(newValue);}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom6To7(){const settingNames=<span class="cstat-no" title="statement not covered" >{'sourcesPanelNavigatorSplitViewState':'sourcesPanelNavigatorSplitViewState','elementsPanelSplitViewState':'elementsPanelSplitViewState','stylesPaneSplitViewState':'stylesPaneSplitViewState','sourcesPanelDebuggerSidebarSplitViewState':'sourcesPanelDebuggerSidebarSplitViewState'};</span>const empty=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const name in settingNames){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(name,empty);</span>const value=<span class="cstat-no" title="statement not covered" >setting.get();<span class="cstat-no" title="statement not covered" ></span>if(value===empty)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(value.vertical&amp;&amp;value.vertical.size&amp;&amp;value.vertical.size&lt;1)</span>
<span class="cstat-no" title="statement not covered" >value.vertical.size=0;<span class="cstat-no" title="statement not covered" >i</span>f(value.horizontal&amp;&amp;value.horizontal.size&amp;&amp;value.horizontal.size&lt;1)</span>
<span class="cstat-no" title="statement not covered" >value.horizontal.size=0;<span class="cstat-no" title="statement not covered" >s</span>etting.set(value);}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom7To8(){}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom8To9(){const settingNames=<span class="cstat-no" title="statement not covered" >['skipStackFramesPattern','workspaceFolderExcludePattern'];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;settingNames.length;++i){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(settingNames[i],'');</span>let value=<span class="cstat-no" title="statement not covered" >setting.get();<span class="cstat-no" title="statement not covered" ></span>if(!value)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(typeof value==='string')</span>
<span class="cstat-no" title="statement not covered" >value=[value];<span class="cstat-no" title="statement not covered" >f</span>or(let j=0;j&lt;value.length;++j){<span class="cstat-no" title="statement not covered" >if(typeof value[j]==='string')</span></span>
<span class="cstat-no" title="statement not covered" >value[j]={pattern:value[j]};}</span>
<span class="cstat-no" title="statement not covered" >setting.set(value);}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom9To10(){<span class="cstat-no" title="statement not covered" >if(!window.localStorage)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const key in window.localStorage){<span class="cstat-no" title="statement not covered" >if(key.startsWith('revision-history'))</span></span>
<span class="cstat-no" title="statement not covered" >window.localStorage.removeItem(key);}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom10To11(){const oldSettingName=<span class="cstat-no" title="statement not covered" >'customDevicePresets';</span>const newSettingName=<span class="cstat-no" title="statement not covered" >'customEmulatedDeviceList';</span>const oldSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(oldSettingName,undefined);</span>const list=<span class="cstat-no" title="statement not covered" >oldSetting.get();<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(list))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst newList=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;list.length;++i){const value=<span class="cstat-no" title="statement not covered" >list[i];</span>const device=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>device['title']=value['title'];<span class="cstat-no" title="statement not covered" >d</span>evice['type']='unknown';<span class="cstat-no" title="statement not covered" >d</span>evice['user-agent']=value['userAgent'];<span class="cstat-no" title="statement not covered" >d</span>evice['capabilities']=[];<span class="cstat-no" title="statement not covered" >i</span>f(value['touch'])</span></span>
<span class="cstat-no" title="statement not covered" >device['capabilities'].push('touch');<span class="cstat-no" title="statement not covered" >i</span>f(value['mobile'])</span>
<span class="cstat-no" title="statement not covered" >device['capabilities'].push('mobile');<span class="cstat-no" title="statement not covered" >d</span>evice['screen']={};<span class="cstat-no" title="statement not covered" >d</span>evice['screen']['vertical']={width:value['width'],height:value['height']};<span class="cstat-no" title="statement not covered" >d</span>evice['screen']['horizontal']={width:value['height'],height:value['width']};<span class="cstat-no" title="statement not covered" >d</span>evice['screen']['device-pixel-ratio']=value['deviceScaleFactor'];<span class="cstat-no" title="statement not covered" >d</span>evice['modes']=[];<span class="cstat-no" title="statement not covered" >d</span>evice['show-by-default']=true;<span class="cstat-no" title="statement not covered" >d</span>evice['show']='Default';<span class="cstat-no" title="statement not covered" >n</span>ewList.push(device);}</span>
<span class="cstat-no" title="statement not covered" >if(newList.length)</span>
<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(newSettingName,[]).set(newList);<span class="cstat-no" title="statement not covered" >o</span>ldSetting.remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom11To12(){<span class="cstat-no" title="statement not covered" >this._migrateSettingsFromLocalStorage();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom12To13(){<span class="cstat-no" title="statement not covered" >this._migrateSettingsFromLocalStorage();<span class="cstat-no" title="statement not covered" >C</span>ommon.settings.createSetting('timelineOverviewMode','').remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom13To14(){const defaultValue=<span class="cstat-no" title="statement not covered" >{'throughput':-1,'latency':0};<span class="cstat-no" title="statement not covered" ></span>Common.settings.createSetting('networkConditions',defaultValue).set(defaultValue);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom14To15(){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createLocalSetting('workspaceExcludedFolders',{});</span>const oldValue=<span class="cstat-no" title="statement not covered" >setting.get();</span>const newValue=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const fileSystemPath in oldValue){<span class="cstat-no" title="statement not covered" >newValue[fileSystemPath]=[];<span class="cstat-no" title="statement not covered" >f</span>or(const entry of oldValue[fileSystemPath])</span></span>
<span class="cstat-no" title="statement not covered" >newValue[fileSystemPath].push(entry.path);}</span>
<span class="cstat-no" title="statement not covered" >setting.set(newValue);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom15To16(){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('InspectorView.panelOrder',{});</span>const tabOrders=<span class="cstat-no" title="statement not covered" >setting.get();<span class="cstat-no" title="statement not covered" ></span>for(const key of Object.keys(tabOrders))</span>
<span class="cstat-no" title="statement not covered" >tabOrders[key]=(tabOrders[key]+1)*10;<span class="cstat-no" title="statement not covered" >s</span>etting.set(tabOrders);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom16To17(){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('networkConditionsCustomProfiles',[]);</span>const oldValue=<span class="cstat-no" title="statement not covered" >setting.get();</span>const newValue=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(oldValue)){<span class="cstat-no" title="statement not covered" >for(const preset of oldValue){<span class="cstat-no" title="statement not covered" >if(typeof preset.title==='string'&amp;&amp;typeof preset.value==='object'&amp;&amp;typeof preset.value.throughput==='number'&amp;&amp;typeof preset.value.latency==='number'){<span class="cstat-no" title="statement not covered" >newValue.push({title:preset.title,value:{download:preset.value.throughput,upload:preset.value.throughput,latency:preset.value.latency}});}</span>}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >setting.set(newValue);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom17To18(){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createLocalSetting('workspaceExcludedFolders',{});</span>const oldValue=<span class="cstat-no" title="statement not covered" >setting.get();</span>const newValue=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const oldKey in oldValue){let newKey=<span class="cstat-no" title="statement not covered" >oldKey.replace(/\\/g,'/');<span class="cstat-no" title="statement not covered" ></span>if(!newKey.startsWith('file://')){<span class="cstat-no" title="statement not covered" >if(newKey.startsWith('/'))</span></span></span>
<span class="cstat-no" title="statement not covered" >newKey='file://'+newKey;e</span>lse
<span class="cstat-no" title="statement not covered" >newKey='file:///'+newKey;}</span>
<span class="cstat-no" title="statement not covered" >newValue[newKey]=oldValue[oldKey];}</span>
<span class="cstat-no" title="statement not covered" >setting.set(newValue);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom18To19(){const defaultColumns=<span class="cstat-no" title="statement not covered" >{status:true,type:true,initiator:true,size:true,time:true};</span>const visibleColumnSettings=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('networkLogColumnsVisibility',defaultColumns);</span>const visibleColumns=<span class="cstat-no" title="statement not covered" >visibleColumnSettings.get();<span class="cstat-no" title="statement not covered" ></span>visibleColumns.name=true;<span class="cstat-no" title="statement not covered" >v</span>isibleColumns.timeline=true;c</span>onst configs=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const columnId in visibleColumns){<span class="cstat-no" title="statement not covered" >if(!visibleColumns.hasOwnProperty(columnId))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >c</span>onfigs[columnId.toLowerCase()]={visible:visibleColumns[columnId]};}</span>
const newSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('networkLogColumns',{});<span class="cstat-no" title="statement not covered" ></span>newSetting.set(configs);<span class="cstat-no" title="statement not covered" >v</span>isibleColumnSettings.remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom19To20(){const oldSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('InspectorView.panelOrder',{});</span>const newSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('panel-tabOrder',{});<span class="cstat-no" title="statement not covered" ></span>newSetting.set(oldSetting.get());<span class="cstat-no" title="statement not covered" >o</span>ldSetting.remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom20To21(){const networkColumns=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('networkLogColumns',{});</span>const columns=(<span class="cstat-no" title="statement not covered" >networkColumns.get())</span>;<span class="cstat-no" title="statement not covered" >delete columns['timeline'];<span class="cstat-no" title="statement not covered" >d</span>elete columns['waterfall'];<span class="cstat-no" title="statement not covered" >n</span>etworkColumns.set(columns);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom21To22(){const breakpointsSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createLocalSetting('breakpoints',[]);</span>const breakpoints=<span class="cstat-no" title="statement not covered" >breakpointsSetting.get();<span class="cstat-no" title="statement not covered" ></span>for(const breakpoint of breakpoints){<span class="cstat-no" title="statement not covered" >breakpoint['url']=breakpoint['sourceFileId'];<span class="cstat-no" title="statement not covered" >d</span>elete breakpoint['sourceFileId'];}</span></span>
<span class="cstat-no" title="statement not covered" >breakpointsSetting.set(breakpoints);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom22To23(){}
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom23To24(){const oldSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('searchInContentScripts',false);</span>const newSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('searchInAnonymousAndContentScripts',false);<span class="cstat-no" title="statement not covered" ></span>newSetting.set(oldSetting.get());<span class="cstat-no" title="statement not covered" >o</span>ldSetting.remove();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom24To25(){const defaultColumns=<span class="cstat-no" title="statement not covered" >{status:true,type:true,initiator:true,size:true,time:true};</span>const networkLogColumnsSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('networkLogColumns',defaultColumns);</span>const columns=<span class="cstat-no" title="statement not covered" >networkLogColumnsSetting.get();<span class="cstat-no" title="statement not covered" ></span>delete columns.product;<span class="cstat-no" title="statement not covered" >n</span>etworkLogColumnsSetting.set(columns);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateVersionFrom25To26(){const oldSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('messageURLFilters',{});</span>const urls=<span class="cstat-no" title="statement not covered" >Object.keys(oldSetting.get());</span>const textFilter=<span class="cstat-no" title="statement not covered" >urls.map(<span class="fstat-no" title="function not covered" >ur</span>l=&gt;<span class="cstat-no" title="statement not covered" >`-url:${url}`)</span>.join(' ');<span class="cstat-no" title="statement not covered" ></span>if(textFilter){const textFilterSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('console.textFilter','');</span>const suffix=<span class="cstat-no" title="statement not covered" >textFilterSetting.get()?` ${textFilterSetting.get()}`:'';<span class="cstat-no" title="statement not covered" ></span>textFilterSetting.set(`${textFilter}${suffix}`);}</span></span>
<span class="cstat-no" title="statement not covered" >oldSetting.remove();}</span>
<span class="fstat-no" title="function not covered" >_m</span>igrateSettingsFromLocalStorage(){const localSettings=<span class="cstat-no" title="statement not covered" >new Set(['advancedSearchConfig','breakpoints','consoleHistory','domBreakpoints','eventListenerBreakpoints','fileSystemMapping','lastSelectedSourcesSidebarPaneTab','previouslyViewedFiles','savedURLs','watchExpressions','workspaceExcludedFolders','xhrBreakpoints']);<span class="cstat-no" title="statement not covered" ></span>if(!window.localStorage)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const key in window.localStorage){<span class="cstat-no" title="statement not covered" >if(localSettings.has(key))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst value=<span class="cstat-no" title="statement not covered" >window.localStorage[key];<span class="cstat-no" title="statement not covered" ></span>window.localStorage.removeItem(key);<span class="cstat-no" title="statement not covered" >C</span>ommon.settings._globalStorage[key]=value;}</span>}
<span class="fstat-no" title="function not covered" >_c</span>learBreakpointsWhenTooMany(breakpointsSetting,maxBreakpointsCount){<span class="cstat-no" title="statement not covered" >if(breakpointsSetting.get().length&gt;maxBreakpointsCount)</span>
<span class="cstat-no" title="statement not covered" >breakpointsSetting.set([]);}</span>};<span class="cstat-no" title="statement not covered" >Common.VersionController._currentVersionName='inspectorVersion';<span class="cstat-no" title="statement not covered" >C</span>ommon.VersionController.currentVersion=26;<span class="cstat-no" title="statement not covered" >C</span>ommon.settings;<span class="cstat-no" title="statement not covered" >C</span>ommon.SettingStorageType={Global:Symbol('Global'),Local:Symbol('Local'),Session:Symbol('Session')};<span class="cstat-no" title="statement not covered" >C</span>ommon.moduleSetting=<span class="fstat-no" title="function not covered" >fu</span>nction(settingName){<span class="cstat-no" title="statement not covered" >return Common.settings.moduleSetting(settingName);}</span>;<span class="cstat-no" title="statement not covered" >C</span>ommon.settingForTest=<span class="fstat-no" title="function not covered" >fu</span>nction(settingName){<span class="cstat-no" title="statement not covered" >return Common.settings.settingForTest(settingName);}</span>;;<span class="cstat-no" title="statement not covered" ></span>Common.StaticContentProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(contentURL,contentType,lazyContent){<span class="cstat-no" title="statement not covered" >this._contentURL=contentURL;<span class="cstat-no" title="statement not covered" >t</span>his._contentType=contentType;<span class="cstat-no" title="statement not covered" >t</span>his._lazyContent=lazyContent;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic fromString(contentURL,contentType,content){const lazyContent=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve(content);<span class="cstat-no" title="statement not covered" ></span></span>return new Common.StaticContentProvider(contentURL,contentType,lazyContent);}</span>
<span class="fstat-no" title="function not covered" >co</span>ntentURL(){<span class="cstat-no" title="statement not covered" >return this._contentURL;}</span>
<span class="fstat-no" title="function not covered" >co</span>ntentType(){<span class="cstat-no" title="statement not covered" >return this._contentType;}</span>
<span class="fstat-no" title="function not covered" >co</span>ntentEncoded(){<span class="cstat-no" title="statement not covered" >return Promise.resolve(false);}</span>
<span class="fstat-no" title="function not covered" >re</span>questContent(){<span class="cstat-no" title="statement not covered" >return this._lazyContent();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync searchInContent(query,caseSensitive,isRegex){const content=<span class="cstat-no" title="statement not covered" >await this._lazyContent();<span class="cstat-no" title="statement not covered" ></span>return content?Common.ContentProvider.performSearchInContent(content,query,caseSensitive,isRegex):[];}</span>};;<span class="cstat-no" title="statement not covered" >Common.OutputStream=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.OutputStream.prototype={write(data){},close(){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.StringOutputStream=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._data='';}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync write(chunk){<span class="cstat-no" title="statement not covered" >this._data+=chunk;}</span>
<span class="fstat-no" title="function not covered" >cl</span>ose(){}
<span class="fstat-no" title="function not covered" >da</span>ta(){<span class="cstat-no" title="statement not covered" >return this._data;}</span>};;<span class="cstat-no" title="statement not covered" >Common.Segment=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(begin,end,data){<span class="cstat-no" title="statement not covered" >if(begin&gt;end)</span></span>
<span class="cstat-no" title="statement not covered" >console.assert(false,'Invalid segment');<span class="cstat-no" title="statement not covered" >t</span>his.begin=begin;<span class="cstat-no" title="statement not covered" >t</span>his.end=end;<span class="cstat-no" title="statement not covered" >t</span>his.data=data;}</span>
<span class="fstat-no" title="function not covered" >in</span>tersects(that){<span class="cstat-no" title="statement not covered" >return this.begin&lt;that.end&amp;&amp;that.begin&lt;this.end;}</span>};<span class="cstat-no" title="statement not covered" >Common.SegmentedRange=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(mergeCallback){<span class="cstat-no" title="statement not covered" >this._segments=[];<span class="cstat-no" title="statement not covered" >t</span>his._mergeCallback=mergeCallback;}</span></span>
<span class="fstat-no" title="function not covered" >ap</span>pend(newSegment){let startIndex=<span class="cstat-no" title="statement not covered" >this._segments.lowerBound(newSegment,<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a.begin-b.begin)</span>;</span>let endIndex=<span class="cstat-no" title="statement not covered" >startIndex;</span>let merged=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(startIndex&gt;0){const precedingSegment=<span class="cstat-no" title="statement not covered" >this._segments[startIndex-1];<span class="cstat-no" title="statement not covered" ></span>merged=this._tryMerge(precedingSegment,newSegment);<span class="cstat-no" title="statement not covered" >i</span>f(merged){<span class="cstat-no" title="statement not covered" >--startIndex;<span class="cstat-no" title="statement not covered" >n</span>ewSegment=merged;}</span>else <span class="cstat-no" title="statement not covered" >if(this._segments[startIndex-1].end&gt;=newSegment.begin){<span class="cstat-no" title="statement not covered" >if(newSegment.end&lt;precedingSegment.end){<span class="cstat-no" title="statement not covered" >this._segments.splice(startIndex,0,new Common.Segment(newSegment.end,precedingSegment.end,precedingSegment.data));}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >precedingSegment.end=newSegment.begin;}</span>}
<span class="cstat-no" title="statement not covered" >while(endIndex&lt;this._segments.length&amp;&amp;this._segments[endIndex].end&lt;=newSegment.end)</span>
<span class="cstat-no" title="statement not covered" >++endIndex;<span class="cstat-no" title="statement not covered" >i</span>f(endIndex&lt;this._segments.length){<span class="cstat-no" title="statement not covered" >merged=this._tryMerge(newSegment,this._segments[endIndex]);<span class="cstat-no" title="statement not covered" >i</span>f(merged){<span class="cstat-no" title="statement not covered" >endIndex++;<span class="cstat-no" title="statement not covered" >n</span>ewSegment=merged;}</span>else <span class="cstat-no" title="statement not covered" >if(newSegment.intersects(this._segments[endIndex])){<span class="cstat-no" title="statement not covered" >this._segments[endIndex].begin=newSegment.end;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._segments.splice(startIndex,endIndex-startIndex,newSegment);}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendRange(that){<span class="cstat-no" title="statement not covered" >that.segments().forEach(<span class="fstat-no" title="function not covered" >se</span>gment=&gt;<span class="cstat-no" title="statement not covered" >this.append(segment))</span>;}</span>
<span class="fstat-no" title="function not covered" >se</span>gments(){<span class="cstat-no" title="statement not covered" >return this._segments;}</span>
<span class="fstat-no" title="function not covered" >_t</span>ryMerge(first,second){const merged=<span class="cstat-no" title="statement not covered" >this._mergeCallback&amp;&amp;this._mergeCallback(first,second);<span class="cstat-no" title="statement not covered" ></span>if(!merged)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >m</span>erged.begin=first.begin;<span class="cstat-no" title="statement not covered" >m</span>erged.end=Math.max(first.end,second.end);<span class="cstat-no" title="statement not covered" >r</span>eturn merged;}</span>};;<span class="cstat-no" title="statement not covered" >Common.Throttler=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(timeout){<span class="cstat-no" title="statement not covered" >this._timeout=timeout;<span class="cstat-no" title="statement not covered" >t</span>his._isRunningProcess=false;<span class="cstat-no" title="statement not covered" >t</span>his._asSoonAsPossible=false;<span class="cstat-no" title="statement not covered" >t</span>his._process=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastCompleteTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._schedulePromise=new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfill=&gt;{<span class="cstat-no" title="statement not covered" >this._scheduleResolve=fulfill;}</span>);}</span></span>
<span class="fstat-no" title="function not covered" >_p</span>rocessCompleted(){<span class="cstat-no" title="statement not covered" >this._lastCompleteTime=this._getTime();<span class="cstat-no" title="statement not covered" >t</span>his._isRunningProcess=false;<span class="cstat-no" title="statement not covered" >i</span>f(this._process)</span>
<span class="cstat-no" title="statement not covered" >this._innerSchedule(false);<span class="cstat-no" title="statement not covered" >t</span>his._processCompletedForTests();}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessCompletedForTests(){}
<span class="fstat-no" title="function not covered" >_o</span>nTimeout(){<span class="cstat-no" title="statement not covered" >delete this._processTimeout;<span class="cstat-no" title="statement not covered" >t</span>his._asSoonAsPossible=false;<span class="cstat-no" title="statement not covered" >t</span>his._isRunningProcess=true;<span class="cstat-no" title="statement not covered" >P</span>romise.resolve().then(this._process).catch(console.error.bind(console)).then(this._processCompleted.bind(this)).then(this._scheduleResolve);<span class="cstat-no" title="statement not covered" >t</span>his._schedulePromise=new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfill=&gt;{<span class="cstat-no" title="statement not covered" >this._scheduleResolve=fulfill;}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._process=null;}</span>
<span class="fstat-no" title="function not covered" >sc</span>hedule(process,asSoonAsPossible){<span class="cstat-no" title="statement not covered" >this._process=process;c</span>onst hasScheduledTasks=<span class="cstat-no" title="statement not covered" >!!this._processTimeout||this._isRunningProcess;</span>const okToFire=<span class="cstat-no" title="statement not covered" >this._getTime()-this._lastCompleteTime&gt;this._timeout;<span class="cstat-no" title="statement not covered" ></span>asSoonAsPossible=!!asSoonAsPossible||(!hasScheduledTasks&amp;&amp;okToFire);c</span>onst forceTimerUpdate=<span class="cstat-no" title="statement not covered" >asSoonAsPossible&amp;&amp;!this._asSoonAsPossible;<span class="cstat-no" title="statement not covered" ></span>this._asSoonAsPossible=this._asSoonAsPossible||asSoonAsPossible;<span class="cstat-no" title="statement not covered" >t</span>his._innerSchedule(forceTimerUpdate);<span class="cstat-no" title="statement not covered" >r</span>eturn this._schedulePromise;}</span>
<span class="fstat-no" title="function not covered" >_i</span>nnerSchedule(forceTimerUpdate){<span class="cstat-no" title="statement not covered" >if(this._isRunningProcess)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._processTimeout&amp;&amp;!forceTimerUpdate)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._processTimeout)</span>
<span class="cstat-no" title="statement not covered" >this._clearTimeout(this._processTimeout);c</span>onst timeout=<span class="cstat-no" title="statement not covered" >this._asSoonAsPossible?0:this._timeout;<span class="cstat-no" title="statement not covered" ></span>this._processTimeout=this._setTimeout(this._onTimeout.bind(this),timeout);}</span>
<span class="fstat-no" title="function not covered" >_c</span>learTimeout(timeoutId){<span class="cstat-no" title="statement not covered" >clearTimeout(timeoutId);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etTimeout(operation,timeout){<span class="cstat-no" title="statement not covered" >return setTimeout(operation,timeout);}</span>
<span class="fstat-no" title="function not covered" >_g</span>etTime(){<span class="cstat-no" title="statement not covered" >return window.performance.now();}</span>};<span class="cstat-no" title="statement not covered" >Common.Throttler.FinishCallback;;<span class="cstat-no" title="statement not covered" ></span>Common.Trie=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.clear();}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>d(word){let node=<span class="cstat-no" title="statement not covered" >this._root;<span class="cstat-no" title="statement not covered" ></span>++this._wordsInSubtree[this._root];<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;word.length;++i){const edge=<span class="cstat-no" title="statement not covered" >word[i];</span>let next=<span class="cstat-no" title="statement not covered" >this._edges[node][edge];<span class="cstat-no" title="statement not covered" ></span>if(!next){<span class="cstat-no" title="statement not covered" >if(this._freeNodes.length){<span class="cstat-no" title="statement not covered" >next=this._freeNodes.pop();}</span>else{<span class="cstat-no" title="statement not covered" >next=this._size++;<span class="cstat-no" title="statement not covered" >t</span>his._isWord.push(false);<span class="cstat-no" title="statement not covered" >t</span>his._wordsInSubtree.push(0);<span class="cstat-no" title="statement not covered" >t</span>his._edges.push({__proto__:null});}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this._edges[node][edge]=next;}</span>
<span class="cstat-no" title="statement not covered" >++this._wordsInSubtree[next];<span class="cstat-no" title="statement not covered" >n</span>ode=next;}</span>
<span class="cstat-no" title="statement not covered" >this._isWord[node]=true;}</span>
<span class="fstat-no" title="function not covered" >re</span>move(word){<span class="cstat-no" title="statement not covered" >if(!this.has(word))</span>
<span class="cstat-no" title="statement not covered" >return false;l</span>et node=<span class="cstat-no" title="statement not covered" >this._root;<span class="cstat-no" title="statement not covered" ></span>--this._wordsInSubtree[this._root];<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;word.length;++i){const edge=<span class="cstat-no" title="statement not covered" >word[i];</span>const next=<span class="cstat-no" title="statement not covered" >this._edges[node][edge];<span class="cstat-no" title="statement not covered" ></span>if(!--this._wordsInSubtree[next]){<span class="cstat-no" title="statement not covered" >delete this._edges[node][edge];<span class="cstat-no" title="statement not covered" >t</span>his._freeNodes.push(next);}</span></span></span>
<span class="cstat-no" title="statement not covered" >node=next;}</span>
<span class="cstat-no" title="statement not covered" >this._isWord[node]=false;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >ha</span>s(word){let node=<span class="cstat-no" title="statement not covered" >this._root;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;word.length;++i){<span class="cstat-no" title="statement not covered" >node=this._edges[node][word[i]];<span class="cstat-no" title="statement not covered" >i</span>f(!node)</span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return this._isWord[node];}</span>
<span class="fstat-no" title="function not covered" >wo</span>rds(prefix){<span class="cstat-no" title="statement not covered" >prefix=prefix||'';l</span>et node=<span class="cstat-no" title="statement not covered" >this._root;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;prefix.length;++i){<span class="cstat-no" title="statement not covered" >node=this._edges[node][prefix[i]];<span class="cstat-no" title="statement not covered" >i</span>f(!node)</span></span>
<span class="cstat-no" title="statement not covered" >return[];}</span>
const results=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>this._dfs(node,prefix,results);<span class="cstat-no" title="statement not covered" >r</span>eturn results;}</span>
<span class="fstat-no" title="function not covered" >_d</span>fs(node,prefix,results){<span class="cstat-no" title="statement not covered" >if(this._isWord[node])</span>
<span class="cstat-no" title="statement not covered" >results.push(prefix);c</span>onst edges=<span class="cstat-no" title="statement not covered" >this._edges[node];<span class="cstat-no" title="statement not covered" ></span>for(const edge in edges)</span>
<span class="cstat-no" title="statement not covered" >this._dfs(edges[edge],prefix+edge,results);}</span>
<span class="fstat-no" title="function not covered" >lo</span>ngestPrefix(word,fullWordOnly){let node=<span class="cstat-no" title="statement not covered" >this._root;</span>let wordIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;word.length;++i){<span class="cstat-no" title="statement not covered" >node=this._edges[node][word[i]];<span class="cstat-no" title="statement not covered" >i</span>f(!node)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(!fullWordOnly||this._isWord[node])</span>
<span class="cstat-no" title="statement not covered" >wordIndex=i+1;}</span>
<span class="cstat-no" title="statement not covered" >return word.substring(0,wordIndex);}</span>
<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >this._size=1;<span class="cstat-no" title="statement not covered" >t</span>his._root=0;<span class="cstat-no" title="statement not covered" >t</span>his._edges=[{__proto__:null}];<span class="cstat-no" title="statement not covered" >t</span>his._isWord=[false];<span class="cstat-no" title="statement not covered" >t</span>his._wordsInSubtree=[0];<span class="cstat-no" title="statement not covered" >t</span>his._freeNodes=[];}</span>};;<span class="cstat-no" title="statement not covered" >self['Common']=self['Common']||{};<span class="cstat-no" title="statement not covered" >C</span>ommon.UIString=<span class="fstat-no" title="function not covered" >fu</span>nction(string,vararg){<span class="cstat-no" title="statement not covered" >return String.vsprintf(Common.localize(string),Array.prototype.slice.call(arguments,1));}</span>;<span class="cstat-no" title="statement not covered" >C</span>ommon.localize=<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string;}</span>;<span class="cstat-no" title="statement not covered" >C</span>ommon.UIStringFormat=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(format){<span class="cstat-no" title="statement not covered" >this._localizedFormat=Common.localize(format);<span class="cstat-no" title="statement not covered" >t</span>his._tokenizedFormat=String.tokenizeFormatString(this._localizedFormat,String.standardFormatters);}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _append(a,b){<span class="cstat-no" title="statement not covered" >return a+b;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmat(vararg){<span class="cstat-no" title="statement not covered" >return String.format(this._localizedFormat,arguments,String.standardFormatters,'',Common.UIStringFormat._append,this._tokenizedFormat).formattedResult;}</span>};<span class="cstat-no" title="statement not covered" >self.ls=<span class="fstat-no" title="function not covered" >fu</span>nction(strings,vararg){<span class="cstat-no" title="statement not covered" >if(typeof strings==='string')</span></span>
<span class="cstat-no" title="statement not covered" >return strings;c</span>onst values=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments,1);<span class="cstat-no" title="statement not covered" ></span>if(!values.length)</span>
<span class="cstat-no" title="statement not covered" >return strings[0];l</span>et result=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;values.length;i++){<span class="cstat-no" title="statement not covered" >result+=strings[i];<span class="cstat-no" title="statement not covered" >r</span>esult+=''+values[i];}</span></span>
<span class="cstat-no" title="statement not covered" >return result+strings[values.length];}</span>;;<span class="cstat-no" title="statement not covered" >Common.Revealer=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.Revealer.reveal=<span class="fstat-no" title="function not covered" >fu</span>nction(revealable,omitFocus){<span class="cstat-no" title="statement not covered" >if(!revealable)</span></span>
<span class="cstat-no" title="statement not covered" >return Promise.reject(new Error('Can\'t reveal '+revealable));<span class="cstat-no" title="statement not covered" >r</span>eturn self.runtime.allInstances(Common.Revealer,revealable).then(reveal);f</span>unction <span class="fstat-no" title="function not covered" >reveal(</span>revealers){const promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;revealers.length;++i)</span>
<span class="cstat-no" title="statement not covered" >promises.push(revealers[i].reveal((revealable),omitFocus));<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.race(promises);}</span>};<span class="cstat-no" title="statement not covered" >Common.Revealer.revealDestination=<span class="fstat-no" title="function not covered" >fu</span>nction(revealable){const extension=<span class="cstat-no" title="statement not covered" >self.runtime.extension(Common.Revealer,revealable);<span class="cstat-no" title="statement not covered" ></span>if(!extension)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn extension.descriptor()['destination'];}</span>;<span class="cstat-no" title="statement not covered" >Common.Revealer.prototype={reveal(object,omitFocus){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.App=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.App.prototype={presentUI(document){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.AppProvider=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.AppProvider.prototype={createApp(){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.QueryParamHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.QueryParamHandler.prototype={handleQueryParam(value){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.Runnable=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.Runnable.prototype={run(){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.Linkifier=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.Linkifier.prototype={linkify(object,options){}};<span class="cstat-no" title="statement not covered" >C</span>ommon.Linkifier.linkify=<span class="fstat-no" title="function not covered" >fu</span>nction(object,options){<span class="cstat-no" title="statement not covered" >if(!object)</span></span>
<span class="cstat-no" title="statement not covered" >return Promise.reject(new Error('Can\'t linkify '+object));<span class="cstat-no" title="statement not covered" >r</span>eturn self.runtime.extension(Common.Linkifier,object).instance().then(<span class="fstat-no" title="function not covered" >li</span>nkifier=&gt;<span class="cstat-no" title="statement not covered" >linkifier.linkify(object,options))</span>;}</span>;<span class="cstat-no" title="statement not covered" >Common.Linkifier.Options;<span class="cstat-no" title="statement not covered" >C</span>ommon.JavaScriptMetadata=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >C</span>ommon.JavaScriptMetadata.prototype={signaturesForNativeFunction(name){},signaturesForInstanceMethod(name,receiverClassName){},signaturesForStaticMethod(name,receiverConstructorName){}};;<span class="cstat-no" title="statement not covered" ></span>Common.CharacterIdMap=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._elementToCharacter=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._characterToElement=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._charCode=33;}</span></span>
<span class="fstat-no" title="function not covered" >to</span>Char(object){let character=<span class="cstat-no" title="statement not covered" >this._elementToCharacter.get(object);<span class="cstat-no" title="statement not covered" ></span>if(!character){<span class="cstat-no" title="statement not covered" >if(this._charCode&gt;=0xFFFF)</span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('CharacterIdMap ran out of capacity!');<span class="cstat-no" title="statement not covered" >c</span>haracter=String.fromCharCode(this._charCode++);<span class="cstat-no" title="statement not covered" >t</span>his._elementToCharacter.set(object,character);<span class="cstat-no" title="statement not covered" >t</span>his._characterToElement.set(character,object);}</span>
<span class="cstat-no" title="statement not covered" >return character;}</span>
<span class="fstat-no" title="function not covered" >fr</span>omChar(character){const object=<span class="cstat-no" title="statement not covered" >this._characterToElement.get(character);<span class="cstat-no" title="statement not covered" ></span>if(object===undefined)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn object;}</span>};;<span class="cstat-no" title="statement not covered" >self['HeapSnapshotWorker']=self['HeapSnapshotWorker']||{};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.AllocationProfile=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,liveObjectStats){<span class="cstat-no" title="statement not covered" >this._strings=profile.strings;<span class="cstat-no" title="statement not covered" >t</span>his._liveObjectStats=liveObjectStats;<span class="cstat-no" title="statement not covered" >t</span>his._nextNodeId=1;<span class="cstat-no" title="statement not covered" >t</span>his._functionInfos=[];<span class="cstat-no" title="statement not covered" >t</span>his._idToNode={};<span class="cstat-no" title="statement not covered" >t</span>his._idToTopDownNode={};<span class="cstat-no" title="statement not covered" >t</span>his._collapsedTopNodeIdToFunctionInfo={};<span class="cstat-no" title="statement not covered" >t</span>his._traceTops=null;<span class="cstat-no" title="statement not covered" >t</span>his._buildFunctionAllocationInfos(profile);<span class="cstat-no" title="statement not covered" >t</span>his._traceTree=this._buildAllocationTree(profile,liveObjectStats);}</span></span>
<span class="fstat-no" title="function not covered" >_b</span>uildFunctionAllocationInfos(profile){const strings=<span class="cstat-no" title="statement not covered" >this._strings;</span>const functionInfoFields=<span class="cstat-no" title="statement not covered" >profile.snapshot.meta.trace_function_info_fields;</span>const functionNameOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('name');</span>const scriptNameOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('script_name');</span>const scriptIdOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('script_id');</span>const lineOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('line');</span>const columnOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('column');</span>const functionInfoFieldCount=<span class="cstat-no" title="statement not covered" >functionInfoFields.length;</span>const rawInfos=<span class="cstat-no" title="statement not covered" >profile.trace_function_infos;</span>const infoLength=<span class="cstat-no" title="statement not covered" >rawInfos.length;</span>const functionInfos=<span class="cstat-no" title="statement not covered" >this._functionInfos=new Array(infoLength/functionInfoFieldCount);</span>let index=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;infoLength;i+=functionInfoFieldCount){<span class="cstat-no" title="statement not covered" >functionInfos[index++]=new HeapSnapshotWorker.FunctionAllocationInfo(strings[rawInfos[i+functionNameOffset]],strings[rawInfos[i+scriptNameOffset]],rawInfos[i+scriptIdOffset],rawInfos[i+lineOffset],rawInfos[i+columnOffset]);}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildAllocationTree(profile,liveObjectStats){const traceTreeRaw=<span class="cstat-no" title="statement not covered" >profile.trace_tree;</span>const functionInfos=<span class="cstat-no" title="statement not covered" >this._functionInfos;</span>const idToTopDownNode=<span class="cstat-no" title="statement not covered" >this._idToTopDownNode;</span>const traceNodeFields=<span class="cstat-no" title="statement not covered" >profile.snapshot.meta.trace_node_fields;</span>const nodeIdOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('id');</span>const functionInfoIndexOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('function_info_index');</span>const allocationCountOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('count');</span>const allocationSizeOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('size');</span>const childrenOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('children');</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >traceNodeFields.length;</span>function <span class="fstat-no" title="function not covered" >traverseNode(</span>rawNodeArray,nodeOffset,parent){const functionInfo=<span class="cstat-no" title="statement not covered" >functionInfos[rawNodeArray[nodeOffset+functionInfoIndexOffset]];</span>const id=<span class="cstat-no" title="statement not covered" >rawNodeArray[nodeOffset+nodeIdOffset];</span>const stats=<span class="cstat-no" title="statement not covered" >liveObjectStats[id];</span>const liveCount=<span class="cstat-no" title="statement not covered" >stats?stats.count:0;</span>const liveSize=<span class="cstat-no" title="statement not covered" >stats?stats.size:0;</span>const result=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.TopDownAllocationNode(id,functionInfo,rawNodeArray[nodeOffset+allocationCountOffset],rawNodeArray[nodeOffset+allocationSizeOffset],liveCount,liveSize,parent);<span class="cstat-no" title="statement not covered" ></span>idToTopDownNode[id]=result;<span class="cstat-no" title="statement not covered" >f</span>unctionInfo.addTraceTopNode(result);c</span>onst rawChildren=<span class="cstat-no" title="statement not covered" >rawNodeArray[nodeOffset+childrenOffset];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;rawChildren.length;i+=nodeFieldCount)</span>
<span class="cstat-no" title="statement not covered" >result.children.push(traverseNode(rawChildren,i,result));<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="cstat-no" title="statement not covered" >return traverseNode(traceTreeRaw,0,null);}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeTraceTops(){<span class="cstat-no" title="statement not covered" >if(this._traceTops)</span>
<span class="cstat-no" title="statement not covered" >return this._traceTops;c</span>onst result=<span class="cstat-no" title="statement not covered" >this._traceTops=[];</span>const functionInfos=<span class="cstat-no" title="statement not covered" >this._functionInfos;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;functionInfos.length;i++){const info=<span class="cstat-no" title="statement not covered" >functionInfos[i];<span class="cstat-no" title="statement not covered" ></span>if(info.totalCount===0)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst nodeId=<span class="cstat-no" title="statement not covered" >this._nextNodeId++;</span>const isRoot=<span class="cstat-no" title="statement not covered" >i===0;<span class="cstat-no" title="statement not covered" ></span>result.push(this._serializeNode(nodeId,info,info.totalCount,info.totalSize,info.totalLiveCount,info.totalLiveSize,!isRoot));<span class="cstat-no" title="statement not covered" >t</span>his._collapsedTopNodeIdToFunctionInfo[nodeId]=info;}</span>
<span class="cstat-no" title="statement not covered" >result.sort(<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return b.size-a.size;}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeCallers(nodeId){let node=<span class="cstat-no" title="statement not covered" >this._ensureBottomUpNode(nodeId);</span>const nodesWithSingleCaller=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>while(node.callers().length===1){<span class="cstat-no" title="statement not covered" >node=node.callers()[0];<span class="cstat-no" title="statement not covered" >n</span>odesWithSingleCaller.push(this._serializeCaller(node));}</span></span>
const branchingCallers=<span class="cstat-no" title="statement not covered" >[];</span>const callers=<span class="cstat-no" title="statement not covered" >node.callers();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;callers.length;i++)</span>
<span class="cstat-no" title="statement not covered" >branchingCallers.push(this._serializeCaller(callers[i]));<span class="cstat-no" title="statement not covered" >r</span>eturn new HeapSnapshotModel.AllocationNodeCallers(nodesWithSingleCaller,branchingCallers);}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeAllocationStack(traceNodeId){let node=<span class="cstat-no" title="statement not covered" >this._idToTopDownNode[traceNodeId];</span>const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>while(node){const functionInfo=<span class="cstat-no" title="statement not covered" >node.functionInfo;<span class="cstat-no" title="statement not covered" ></span>result.push(new HeapSnapshotModel.AllocationStackFrame(functionInfo.functionName,functionInfo.scriptName,functionInfo.scriptId,functionInfo.line,functionInfo.column));<span class="cstat-no" title="statement not covered" >n</span>ode=node.parent;}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >tr</span>aceIds(allocationNodeId){<span class="cstat-no" title="statement not covered" >return this._ensureBottomUpNode(allocationNodeId).traceTopIds;}</span>
<span class="fstat-no" title="function not covered" >_e</span>nsureBottomUpNode(nodeId){let node=<span class="cstat-no" title="statement not covered" >this._idToNode[nodeId];<span class="cstat-no" title="statement not covered" ></span>if(!node){const functionInfo=<span class="cstat-no" title="statement not covered" >this._collapsedTopNodeIdToFunctionInfo[nodeId];<span class="cstat-no" title="statement not covered" ></span>node=functionInfo.bottomUpRoot();<span class="cstat-no" title="statement not covered" >d</span>elete this._collapsedTopNodeIdToFunctionInfo[nodeId];<span class="cstat-no" title="statement not covered" >t</span>his._idToNode[nodeId]=node;}</span></span>
<span class="cstat-no" title="statement not covered" >return node;}</span>
<span class="fstat-no" title="function not covered" >_s</span>erializeCaller(node){const callerId=<span class="cstat-no" title="statement not covered" >this._nextNodeId++;<span class="cstat-no" title="statement not covered" ></span>this._idToNode[callerId]=node;<span class="cstat-no" title="statement not covered" >r</span>eturn this._serializeNode(callerId,node.functionInfo,node.allocationCount,node.allocationSize,node.liveCount,node.liveSize,node.hasCallers());}</span>
<span class="fstat-no" title="function not covered" >_s</span>erializeNode(nodeId,functionInfo,count,size,liveCount,liveSize,hasChildren){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.SerializedAllocationNode(nodeId,functionInfo.functionName,functionInfo.scriptName,functionInfo.scriptId,functionInfo.line,functionInfo.column,count,size,liveCount,liveSize,hasChildren);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.TopDownAllocationNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,functionInfo,count,size,liveCount,liveSize,parent){<span class="cstat-no" title="statement not covered" >this.id=id;<span class="cstat-no" title="statement not covered" >t</span>his.functionInfo=functionInfo;<span class="cstat-no" title="statement not covered" >t</span>his.allocationCount=count;<span class="cstat-no" title="statement not covered" >t</span>his.allocationSize=size;<span class="cstat-no" title="statement not covered" >t</span>his.liveCount=liveCount;<span class="cstat-no" title="statement not covered" >t</span>his.liveSize=liveSize;<span class="cstat-no" title="statement not covered" >t</span>his.parent=parent;<span class="cstat-no" title="statement not covered" >t</span>his.children=[];}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.BottomUpAllocationNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(functionInfo){<span class="cstat-no" title="statement not covered" >this.functionInfo=functionInfo;<span class="cstat-no" title="statement not covered" >t</span>his.allocationCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.allocationSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.liveCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.liveSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.traceTopIds=[];<span class="cstat-no" title="statement not covered" >t</span>his._callers=[];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dCaller(traceNode){const functionInfo=<span class="cstat-no" title="statement not covered" >traceNode.functionInfo;</span>let result;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._callers.length;i++){const caller=<span class="cstat-no" title="statement not covered" >this._callers[i];<span class="cstat-no" title="statement not covered" ></span>if(caller.functionInfo===functionInfo){<span class="cstat-no" title="statement not covered" >result=caller;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(!result){<span class="cstat-no" title="statement not covered" >result=new HeapSnapshotWorker.BottomUpAllocationNode(functionInfo);<span class="cstat-no" title="statement not covered" >t</span>his._callers.push(result);}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >ca</span>llers(){<span class="cstat-no" title="statement not covered" >return this._callers;}</span>
<span class="fstat-no" title="function not covered" >ha</span>sCallers(){<span class="cstat-no" title="statement not covered" >return this._callers.length&gt;0;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.FunctionAllocationInfo=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(functionName,scriptName,scriptId,line,column){<span class="cstat-no" title="statement not covered" >this.functionName=functionName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptName=scriptName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptId=scriptId;<span class="cstat-no" title="statement not covered" >t</span>his.line=line;<span class="cstat-no" title="statement not covered" >t</span>his.column=column;<span class="cstat-no" title="statement not covered" >t</span>his.totalCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.totalSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveSize=0;<span class="cstat-no" title="statement not covered" >t</span>his._traceTops=[];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dTraceTopNode(node){<span class="cstat-no" title="statement not covered" >if(node.allocationCount===0)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._traceTops.push(node);<span class="cstat-no" title="statement not covered" >t</span>his.totalCount+=node.allocationCount;<span class="cstat-no" title="statement not covered" >t</span>his.totalSize+=node.allocationSize;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveCount+=node.liveCount;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveSize+=node.liveSize;}</span>
<span class="fstat-no" title="function not covered" >bo</span>ttomUpRoot(){<span class="cstat-no" title="statement not covered" >if(!this._traceTops.length)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span>f(!this._bottomUpTree)</span>
<span class="cstat-no" title="statement not covered" >this._buildAllocationTraceTree();<span class="cstat-no" title="statement not covered" >r</span>eturn this._bottomUpTree;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildAllocationTraceTree(){<span class="cstat-no" title="statement not covered" >this._bottomUpTree=new HeapSnapshotWorker.BottomUpAllocationNode(this);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._traceTops.length;i++){let node=<span class="cstat-no" title="statement not covered" >this._traceTops[i];</span>let bottomUpNode=<span class="cstat-no" title="statement not covered" >this._bottomUpTree;</span>const count=<span class="cstat-no" title="statement not covered" >node.allocationCount;</span>const size=<span class="cstat-no" title="statement not covered" >node.allocationSize;</span>const liveCount=<span class="cstat-no" title="statement not covered" >node.liveCount;</span>const liveSize=<span class="cstat-no" title="statement not covered" >node.liveSize;</span>const traceId=<span class="cstat-no" title="statement not covered" >node.id;<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >bottomUpNode.allocationCount+=count;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.allocationSize+=size;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.liveCount+=liveCount;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.liveSize+=liveSize;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.traceTopIds.push(traceId);<span class="cstat-no" title="statement not covered" >n</span>ode=node.parent;<span class="cstat-no" title="statement not covered" >i</span>f(node===null)</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode=bottomUpNode.addCaller(node);}</span>}}};;<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotItem=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItem.prototype={itemIndex(){},serialize(){}};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotEdge=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,edgeIndex){<span class="cstat-no" title="statement not covered" >this._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._edges=snapshot.containmentEdges;<span class="cstat-no" title="statement not covered" >t</span>his.edgeIndex=edgeIndex||0;}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotEdge(this._snapshot,this.edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sStringName(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >no</span>de(){<span class="cstat-no" title="statement not covered" >return this._snapshot.createNode(this.nodeIndex());}</span>
<span class="fstat-no" title="function not covered" >no</span>deIndex(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeToNodeOffset];}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return'HeapSnapshotEdge: '+this.name();}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._snapshot._edgeTypes[this.rawType()];}</span>
<span class="fstat-no" title="function not covered" >it</span>emIndex(){<span class="cstat-no" title="statement not covered" >return this.edgeIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this.edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ra</span>wType(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset];}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotItemIterator=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItemIterator.prototype={hasNext(){},item(){},next(){}};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItemIndexProvider=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItemIndexProvider.prototype={itemForIndex(newIndex){},};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotNodeIndexProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot){<span class="cstat-no" title="statement not covered" >this._node=snapshot.createNode();}</span></span>
<span class="fstat-no" title="function not covered" >it</span>emForIndex(index){<span class="cstat-no" title="statement not covered" >this._node.nodeIndex=index;<span class="cstat-no" title="statement not covered" >r</span>eturn this._node;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotEdgeIndexProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot){<span class="cstat-no" title="statement not covered" >this._edge=snapshot.createEdge(0);}</span></span>
<span class="fstat-no" title="function not covered" >it</span>emForIndex(index){<span class="cstat-no" title="statement not covered" >this._edge.edgeIndex=index;<span class="cstat-no" title="statement not covered" >r</span>eturn this._edge;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotRetainerEdgeIndexProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot){<span class="cstat-no" title="statement not covered" >this._retainerEdge=snapshot.createRetainingEdge(0);}</span></span>
<span class="fstat-no" title="function not covered" >it</span>emForIndex(index){<span class="cstat-no" title="statement not covered" >this._retainerEdge.setRetainerIndex(index);<span class="cstat-no" title="statement not covered" >r</span>eturn this._retainerEdge;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotEdgeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(node){<span class="cstat-no" title="statement not covered" >this._sourceNode=node;<span class="cstat-no" title="statement not covered" >t</span>his.edge=node._snapshot.createEdge(node.edgeIndexesStart());}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this.edge.edgeIndex&lt;this._sourceNode.edgeIndexesEnd();}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this.edge;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this.edge.edgeIndex+=this.edge._snapshot._edgeFieldsCount;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotRetainerEdge=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,retainerIndex){<span class="cstat-no" title="statement not covered" >this._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his.setRetainerIndex(retainerIndex);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotRetainerEdge(this._snapshot,this.retainerIndex());}</span>
<span class="fstat-no" title="function not covered" >ha</span>sStringName(){<span class="cstat-no" title="statement not covered" >return this._edge().hasStringName();}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._edge().name();}</span>
<span class="fstat-no" title="function not covered" >no</span>de(){<span class="cstat-no" title="statement not covered" >return this._node();}</span>
<span class="fstat-no" title="function not covered" >no</span>deIndex(){<span class="cstat-no" title="statement not covered" >return this._retainingNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >re</span>tainerIndex(){<span class="cstat-no" title="statement not covered" >return this._retainerIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>tRetainerIndex(retainerIndex){<span class="cstat-no" title="statement not covered" >if(retainerIndex===this._retainerIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._retainerIndex=retainerIndex;<span class="cstat-no" title="statement not covered" >t</span>his._globalEdgeIndex=this._snapshot._retainingEdges[retainerIndex];<span class="cstat-no" title="statement not covered" >t</span>his._retainingNodeIndex=this._snapshot._retainingNodes[retainerIndex];<span class="cstat-no" title="statement not covered" >t</span>his._edgeInstance=null;<span class="cstat-no" title="statement not covered" >t</span>his._nodeInstance=null;}</span>
<span class="fstat-no" title="function not covered" >se</span>t edgeIndex(edgeIndex){<span class="cstat-no" title="statement not covered" >this.setRetainerIndex(edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >_n</span>ode(){<span class="cstat-no" title="statement not covered" >if(!this._nodeInstance)</span>
<span class="cstat-no" title="statement not covered" >this._nodeInstance=this._snapshot.createNode(this._retainingNodeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn this._nodeInstance;}</span>
<span class="fstat-no" title="function not covered" >_e</span>dge(){<span class="cstat-no" title="statement not covered" >if(!this._edgeInstance)</span>
<span class="cstat-no" title="statement not covered" >this._edgeInstance=this._snapshot.createEdge(this._globalEdgeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn this._edgeInstance;}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return this._edge().toString();}</span>
<span class="fstat-no" title="function not covered" >it</span>emIndex(){<span class="cstat-no" title="statement not covered" >return this._retainerIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this._globalEdgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._edge().type();}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotRetainerEdgeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(retainedNode){const snapshot=<span class="cstat-no" title="statement not covered" >retainedNode._snapshot;</span>const retainedNodeOrdinal=<span class="cstat-no" title="statement not covered" >retainedNode.ordinal();</span>const retainerIndex=<span class="cstat-no" title="statement not covered" >snapshot._firstRetainerIndex[retainedNodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>this._retainersEnd=snapshot._firstRetainerIndex[retainedNodeOrdinal+1];<span class="cstat-no" title="statement not covered" >t</span>his.retainer=snapshot.createRetainingEdge(retainerIndex);}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this.retainer.retainerIndex()&lt;this._retainersEnd;}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this.retainer;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this.retainer.setRetainerIndex(this.retainer.retainerIndex()+1);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,nodeIndex){<span class="cstat-no" title="statement not covered" >this._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his.nodeIndex=nodeIndex||0;}</span></span>
<span class="fstat-no" title="function not covered" >di</span>stance(){<span class="cstat-no" title="statement not covered" >return this._snapshot._nodeDistances[this.nodeIndex/this._snapshot._nodeFieldCount];}</span>
<span class="fstat-no" title="function not covered" >cl</span>assName(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >cl</span>assIndex(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >do</span>minatorIndex(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._snapshot._nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>return this._snapshot._dominatorsTree[this.nodeIndex/this._snapshot._nodeFieldCount]*nodeFieldCount;}</span>
<span class="fstat-no" title="function not covered" >ed</span>ges(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotEdgeIterator(this);}</span>
<span class="fstat-no" title="function not covered" >ed</span>gesCount(){<span class="cstat-no" title="statement not covered" >return(this.edgeIndexesEnd()-this.edgeIndexesStart())/this._snapshot._edgeFieldsCount;}</span>
<span class="fstat-no" title="function not covered" >id</span>(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >is</span>Root(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex===this._snapshot._rootNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._snapshot.strings[this._name()];}</span>
<span class="fstat-no" title="function not covered" >re</span>tainedSize(){<span class="cstat-no" title="statement not covered" >return this._snapshot._retainedSizes[this.ordinal()];}</span>
<span class="fstat-no" title="function not covered" >re</span>tainers(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotRetainerEdgeIterator(this);}</span>
<span class="fstat-no" title="function not covered" >re</span>tainersCount(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>const ordinal=<span class="cstat-no" title="statement not covered" >this.ordinal();<span class="cstat-no" title="statement not covered" ></span>return snapshot._firstRetainerIndex[ordinal+1]-snapshot._firstRetainerIndex[ordinal];}</span>
<span class="fstat-no" title="function not covered" >se</span>lfSize(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeSelfSizeOffset];}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._snapshot._nodeTypes[this.rawType()];}</span>
<span class="fstat-no" title="function not covered" >tr</span>aceNodeId(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeTraceNodeIdOffset];}</span>
<span class="fstat-no" title="function not covered" >it</span>emIndex(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.Node(this.id(),this.name(),this.distance(),this.nodeIndex,this.retainedSize(),this.selfSize(),this.type());}</span>
<span class="fstat-no" title="function not covered" >_n</span>ame(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeNameOffset];}</span>
<span class="fstat-no" title="function not covered" >ed</span>geIndexesStart(){<span class="cstat-no" title="statement not covered" >return this._snapshot._firstEdgeIndexes[this.ordinal()];}</span>
<span class="fstat-no" title="function not covered" >ed</span>geIndexesEnd(){<span class="cstat-no" title="statement not covered" >return this._snapshot._firstEdgeIndexes[this.ordinal()+1];}</span>
<span class="fstat-no" title="function not covered" >or</span>dinal(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex/this._snapshot._nodeFieldCount;}</span>
<span class="fstat-no" title="function not covered" >_n</span>extNodeIndex(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex+this._snapshot._nodeFieldCount;}</span>
<span class="fstat-no" title="function not covered" >ra</span>wType(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeTypeOffset];}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotNodeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(node){<span class="cstat-no" title="statement not covered" >this.node=node;<span class="cstat-no" title="statement not covered" >t</span>his._nodesLength=node._snapshot.nodes.length;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this.node.nodeIndex&lt;this._nodesLength;}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this.node;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this.node.nodeIndex=this.node._nextNodeIndex();}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotIndexRangeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(itemProvider,indexes){<span class="cstat-no" title="statement not covered" >this._itemProvider=itemProvider;<span class="cstat-no" title="statement not covered" >t</span>his._indexes=indexes;<span class="cstat-no" title="statement not covered" >t</span>his._position=0;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this._position&lt;this._indexes.length;}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){const index=<span class="cstat-no" title="statement not covered" >this._indexes[this._position];<span class="cstat-no" title="statement not covered" ></span>return this._itemProvider.itemForIndex(index);}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >++this._position;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotFilteredIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(iterator,filter){<span class="cstat-no" title="statement not covered" >this._iterator=iterator;<span class="cstat-no" title="statement not covered" >t</span>his._filter=filter;<span class="cstat-no" title="statement not covered" >t</span>his._skipFilteredItems();}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this._iterator.hasNext();}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this._iterator.item();}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this._iterator.next();<span class="cstat-no" title="statement not covered" >t</span>his._skipFilteredItems();}</span>
<span class="fstat-no" title="function not covered" >_s</span>kipFilteredItems(){<span class="cstat-no" title="statement not covered" >while(this._iterator.hasNext()&amp;&amp;!this._filter(this._iterator.item()))</span>
<span class="cstat-no" title="statement not covered" >this._iterator.next();}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotProgress=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(dispatcher){<span class="cstat-no" title="statement not covered" >this._dispatcher=dispatcher;}</span></span>
<span class="fstat-no" title="function not covered" >up</span>dateStatus(status){<span class="cstat-no" title="statement not covered" >this._sendUpdateEvent(Common.UIString(status));}</span>
<span class="fstat-no" title="function not covered" >up</span>dateProgress(title,value,total){const percentValue=<span class="cstat-no" title="statement not covered" >((total?(value/total):0)*100).toFixed(0);<span class="cstat-no" title="statement not covered" ></span>this._sendUpdateEvent(Common.UIString(title,percentValue));}</span>
<span class="fstat-no" title="function not covered" >re</span>portProblem(error){<span class="cstat-no" title="statement not covered" >if(this._dispatcher)</span>
<span class="cstat-no" title="statement not covered" >this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot,error);}</span>
<span class="fstat-no" title="function not covered" >_s</span>endUpdateEvent(text){<span class="cstat-no" title="statement not covered" >if(this._dispatcher)</span>
<span class="cstat-no" title="statement not covered" >this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotProgressEvent.Update,text);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotProblemReport=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(title){<span class="cstat-no" title="statement not covered" >this._errors=[title];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dError(error){<span class="cstat-no" title="statement not covered" >if(this._errors.length&gt;100)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._errors.push(error);}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return this._errors.join('\n  ');}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshot=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,progress){<span class="cstat-no" title="statement not covered" >this.nodes=profile.nodes;<span class="cstat-no" title="statement not covered" >t</span>his.containmentEdges=profile.edges;<span class="cstat-no" title="statement not covered" >t</span>his._metaNode=profile.snapshot.meta;<span class="cstat-no" title="statement not covered" >t</span>his._rawSamples=profile.samples;<span class="cstat-no" title="statement not covered" >t</span>his._samples=null;<span class="cstat-no" title="statement not covered" >t</span>his.strings=profile.strings;<span class="cstat-no" title="statement not covered" >t</span>his._locations=profile.locations;<span class="cstat-no" title="statement not covered" >t</span>his._progress=progress;<span class="cstat-no" title="statement not covered" >t</span>his._noDistance=-5;<span class="cstat-no" title="statement not covered" >t</span>his._rootNodeIndex=0;<span class="cstat-no" title="statement not covered" >i</span>f(profile.snapshot.root_index)</span></span>
<span class="cstat-no" title="statement not covered" >this._rootNodeIndex=profile.snapshot.root_index;<span class="cstat-no" title="statement not covered" >t</span>his._snapshotDiffs={};<span class="cstat-no" title="statement not covered" >t</span>his._aggregatesForDiff=null;<span class="cstat-no" title="statement not covered" >t</span>his._aggregates={};<span class="cstat-no" title="statement not covered" >t</span>his._aggregatesSortedFlags={};<span class="cstat-no" title="statement not covered" >t</span>his._profile=profile;}</span>
<span class="fstat-no" title="function not covered" >in</span>itialize(){const meta=<span class="cstat-no" title="statement not covered" >this._metaNode;<span class="cstat-no" title="statement not covered" ></span>this._nodeTypeOffset=meta.node_fields.indexOf('type');<span class="cstat-no" title="statement not covered" >t</span>his._nodeNameOffset=meta.node_fields.indexOf('name');<span class="cstat-no" title="statement not covered" >t</span>his._nodeIdOffset=meta.node_fields.indexOf('id');<span class="cstat-no" title="statement not covered" >t</span>his._nodeSelfSizeOffset=meta.node_fields.indexOf('self_size');<span class="cstat-no" title="statement not covered" >t</span>his._nodeEdgeCountOffset=meta.node_fields.indexOf('edge_count');<span class="cstat-no" title="statement not covered" >t</span>his._nodeTraceNodeIdOffset=meta.node_fields.indexOf('trace_node_id');<span class="cstat-no" title="statement not covered" >t</span>his._nodeFieldCount=meta.node_fields.length;<span class="cstat-no" title="statement not covered" >t</span>his._nodeTypes=meta.node_types[this._nodeTypeOffset];<span class="cstat-no" title="statement not covered" >t</span>his._nodeArrayType=this._nodeTypes.indexOf('array');<span class="cstat-no" title="statement not covered" >t</span>his._nodeHiddenType=this._nodeTypes.indexOf('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._nodeObjectType=this._nodeTypes.indexOf('object');<span class="cstat-no" title="statement not covered" >t</span>his._nodeNativeType=this._nodeTypes.indexOf('native');<span class="cstat-no" title="statement not covered" >t</span>his._nodeConsStringType=this._nodeTypes.indexOf('concatenated string');<span class="cstat-no" title="statement not covered" >t</span>his._nodeSlicedStringType=this._nodeTypes.indexOf('sliced string');<span class="cstat-no" title="statement not covered" >t</span>his._nodeCodeType=this._nodeTypes.indexOf('code');<span class="cstat-no" title="statement not covered" >t</span>his._nodeSyntheticType=this._nodeTypes.indexOf('synthetic');<span class="cstat-no" title="statement not covered" >t</span>his._edgeFieldsCount=meta.edge_fields.length;<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypeOffset=meta.edge_fields.indexOf('type');<span class="cstat-no" title="statement not covered" >t</span>his._edgeNameOffset=meta.edge_fields.indexOf('name_or_index');<span class="cstat-no" title="statement not covered" >t</span>his._edgeToNodeOffset=meta.edge_fields.indexOf('to_node');<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypes=meta.edge_types[this._edgeTypeOffset];<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypes.push('invisible');<span class="cstat-no" title="statement not covered" >t</span>his._edgeElementType=this._edgeTypes.indexOf('element');<span class="cstat-no" title="statement not covered" >t</span>his._edgeHiddenType=this._edgeTypes.indexOf('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._edgeInternalType=this._edgeTypes.indexOf('internal');<span class="cstat-no" title="statement not covered" >t</span>his._edgeShortcutType=this._edgeTypes.indexOf('shortcut');<span class="cstat-no" title="statement not covered" >t</span>his._edgeWeakType=this._edgeTypes.indexOf('weak');<span class="cstat-no" title="statement not covered" >t</span>his._edgeInvisibleType=this._edgeTypes.indexOf('invisible');c</span>onst location_fields=<span class="cstat-no" title="statement not covered" >meta.location_fields||[];<span class="cstat-no" title="statement not covered" ></span>this._locationIndexOffset=location_fields.indexOf('object_index');<span class="cstat-no" title="statement not covered" >t</span>his._locationScriptIdOffset=location_fields.indexOf('script_id');<span class="cstat-no" title="statement not covered" >t</span>his._locationLineOffset=location_fields.indexOf('line');<span class="cstat-no" title="statement not covered" >t</span>his._locationColumnOffset=location_fields.indexOf('column');<span class="cstat-no" title="statement not covered" >t</span>his._locationFieldCount=location_fields.length;<span class="cstat-no" title="statement not covered" >t</span>his.nodeCount=this.nodes.length/this._nodeFieldCount;<span class="cstat-no" title="statement not covered" >t</span>his._edgeCount=this.containmentEdges.length/this._edgeFieldsCount;<span class="cstat-no" title="statement not covered" >t</span>his._retainedSizes=new Float64Array(this.nodeCount);<span class="cstat-no" title="statement not covered" >t</span>his._firstEdgeIndexes=new Uint32Array(this.nodeCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._retainingNodes=new Uint32Array(this._edgeCount);<span class="cstat-no" title="statement not covered" >t</span>his._retainingEdges=new Uint32Array(this._edgeCount);<span class="cstat-no" title="statement not covered" >t</span>his._firstRetainerIndex=new Uint32Array(this.nodeCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._nodeDistances=new Int32Array(this.nodeCount);<span class="cstat-no" title="statement not covered" >t</span>his._firstDominatedNodeIndex=new Uint32Array(this.nodeCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._dominatedNodes=new Uint32Array(this.nodeCount-1);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building edge indexes\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildEdgeIndexes();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building retainers\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildRetainers();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating node flags\u2026');<span class="cstat-no" title="statement not covered" >t</span>his.calculateFlags();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating distances\u2026');<span class="cstat-no" title="statement not covered" >t</span>his.calculateDistances();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building postorder index\u2026');c</span>onst result=<span class="cstat-no" title="statement not covered" >this._buildPostOrderIndex();<span class="cstat-no" title="statement not covered" ></span>this._progress.updateStatus('Building dominator tree\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._dominatorsTree=this._buildDominatorTree(result.postOrderIndex2NodeOrdinal,result.nodeOrdinal2PostOrderIndex);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating retained sizes\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._calculateRetainedSizes(result.postOrderIndex2NodeOrdinal);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building dominated nodes\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildDominatedNodes();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating statistics\u2026');<span class="cstat-no" title="statement not covered" >t</span>his.calculateStatistics();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating samples\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildSamples();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building locations\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildLocationMap();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Finished processing.');<span class="cstat-no" title="statement not covered" >i</span>f(this._profile.snapshot.trace_function_count){<span class="cstat-no" title="statement not covered" >this._progress.updateStatus('Building allocation statistics\u2026');c</span>onst nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();</span>const liveObjects=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;c</span>onst traceNodeId=<span class="cstat-no" title="statement not covered" >node.traceNodeId();</span>let stats=<span class="cstat-no" title="statement not covered" >liveObjects[traceNodeId];<span class="cstat-no" title="statement not covered" ></span>if(!stats)</span></span></span>
<span class="cstat-no" title="statement not covered" >liveObjects[traceNodeId]=stats={count:0,size:0,ids:[]};<span class="cstat-no" title="statement not covered" >s</span>tats.count++;<span class="cstat-no" title="statement not covered" >s</span>tats.size+=node.selfSize();<span class="cstat-no" title="statement not covered" >s</span>tats.ids.push(node.id());}</span>
<span class="cstat-no" title="statement not covered" >this._allocationProfile=new HeapSnapshotWorker.AllocationProfile(this._profile,liveObjects);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Done');}</span>}
<span class="fstat-no" title="function not covered" >_b</span>uildEdgeIndexes(){const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const nodeEdgeCountOffset=<span class="cstat-no" title="statement not covered" >this._nodeEdgeCountOffset;<span class="cstat-no" title="statement not covered" ></span>firstEdgeIndexes[nodeCount]=this.containmentEdges.length;<span class="cstat-no" title="statement not covered" >f</span>or(let nodeOrdinal=0,edgeIndex=0;nodeOrdinal&lt;nodeCount;++nodeOrdinal){<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal]=edgeIndex;<span class="cstat-no" title="statement not covered" >e</span>dgeIndex+=nodes[nodeOrdinal*nodeFieldCount+nodeEdgeCountOffset]*edgeFieldsCount;}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildRetainers(){const retainingNodes=<span class="cstat-no" title="statement not covered" >this._retainingNodes;</span>const retainingEdges=<span class="cstat-no" title="statement not covered" >this._retainingEdges;</span>const firstRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;<span class="cstat-no" title="statement not covered" ></span>for(let toNodeFieldIndex=edgeToNodeOffset,l=containmentEdges.length;toNodeFieldIndex&lt;l;toNodeFieldIndex+=edgeFieldsCount){const toNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[toNodeFieldIndex];<span class="cstat-no" title="statement not covered" ></span>if(toNodeIndex%nodeFieldCount)</span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('Invalid toNodeIndex '+toNodeIndex);<span class="cstat-no" title="statement not covered" >+</span>+firstRetainerIndex[toNodeIndex/nodeFieldCount];}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0,firstUnusedRetainerSlot=0;i&lt;nodeCount;i++){const retainersCount=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[i];<span class="cstat-no" title="statement not covered" ></span>firstRetainerIndex[i]=firstUnusedRetainerSlot;<span class="cstat-no" title="statement not covered" >r</span>etainingNodes[firstUnusedRetainerSlot]=retainersCount;<span class="cstat-no" title="statement not covered" >f</span>irstUnusedRetainerSlot+=retainersCount;}</span></span>
<span class="cstat-no" title="statement not covered" >firstRetainerIndex[nodeCount]=retainingNodes.length;l</span>et nextNodeFirstEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[0];<span class="cstat-no" title="statement not covered" ></span>for(let srcNodeOrdinal=0;srcNodeOrdinal&lt;nodeCount;++srcNodeOrdinal){const firstEdgeIndex=<span class="cstat-no" title="statement not covered" >nextNodeFirstEdgeIndex;<span class="cstat-no" title="statement not covered" ></span>nextNodeFirstEdgeIndex=firstEdgeIndexes[srcNodeOrdinal+1];c</span>onst srcNodeIndex=<span class="cstat-no" title="statement not covered" >srcNodeOrdinal*nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=firstEdgeIndex;edgeIndex&lt;nextNodeFirstEdgeIndex;edgeIndex+=edgeFieldsCount){const toNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];<span class="cstat-no" title="statement not covered" ></span>if(toNodeIndex%nodeFieldCount)</span></span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('Invalid toNodeIndex '+toNodeIndex);c</span>onst firstRetainerSlotIndex=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[toNodeIndex/nodeFieldCount];</span>const nextUnusedRetainerSlotIndex=<span class="cstat-no" title="statement not covered" >firstRetainerSlotIndex+(--retainingNodes[firstRetainerSlotIndex]);<span class="cstat-no" title="statement not covered" ></span>retainingNodes[nextUnusedRetainerSlotIndex]=srcNodeIndex;<span class="cstat-no" title="statement not covered" >r</span>etainingEdges[nextUnusedRetainerSlotIndex]=edgeIndex;}</span>}}
<span class="fstat-no" title="function not covered" >cr</span>eateNode(nodeIndex){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdge(edgeIndex){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdge(retainerIndex){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >_a</span>llNodes(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotNodeIterator(this.rootNode());}</span>
<span class="fstat-no" title="function not covered" >ro</span>otNode(){<span class="cstat-no" title="statement not covered" >return this.createNode(this._rootNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >ge</span>t rootNodeIndex(){<span class="cstat-no" title="statement not covered" >return this._rootNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t totalSize(){<span class="cstat-no" title="statement not covered" >return this.rootNode().retainedSize();}</span>
<span class="fstat-no" title="function not covered" >_g</span>etDominatedIndex(nodeIndex){<span class="cstat-no" title="statement not covered" >if(nodeIndex%this._nodeFieldCount)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Invalid nodeIndex: '+nodeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn this._firstDominatedNodeIndex[nodeIndex/this._nodeFieldCount];}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateFilter(nodeFilter){const minNodeId=<span class="cstat-no" title="statement not covered" >nodeFilter.minNodeId;</span>const maxNodeId=<span class="cstat-no" title="statement not covered" >nodeFilter.maxNodeId;</span>const allocationNodeId=<span class="cstat-no" title="statement not covered" >nodeFilter.allocationNodeId;</span>let filter;<span class="cstat-no" title="statement not covered" >if(typeof allocationNodeId==='number'){<span class="cstat-no" title="statement not covered" >filter=this._createAllocationStackFilter(allocationNodeId);<span class="cstat-no" title="statement not covered" >f</span>ilter.key='AllocationNodeId: '+allocationNodeId;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof minNodeId==='number'&amp;&amp;typeof maxNodeId==='number'){<span class="cstat-no" title="statement not covered" >filter=this._createNodeIdFilter(minNodeId,maxNodeId);<span class="cstat-no" title="statement not covered" >f</span>ilter.key='NodeIdRange: '+minNodeId+'..'+maxNodeId;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return filter;}</span>
<span class="fstat-no" title="function not covered" >se</span>arch(searchConfig,nodeFilter){const query=<span class="cstat-no" title="statement not covered" >searchConfig.query;</span>function <span class="fstat-no" title="function not covered" >filterString(</span>matchedStringIndexes,string,index){<span class="cstat-no" title="statement not covered" >if(string.indexOf(query)!==-1)</span>
<span class="cstat-no" title="statement not covered" >matchedStringIndexes.add(index);<span class="cstat-no" title="statement not covered" >r</span>eturn matchedStringIndexes;}</span>
const regexp=<span class="cstat-no" title="statement not covered" >searchConfig.isRegex?new RegExp(query):createPlainTextSearchRegex(query,'i');</span>function <span class="fstat-no" title="function not covered" >filterRegexp(</span>matchedStringIndexes,string,index){<span class="cstat-no" title="statement not covered" >if(regexp.test(string))</span>
<span class="cstat-no" title="statement not covered" >matchedStringIndexes.add(index);<span class="cstat-no" title="statement not covered" >r</span>eturn matchedStringIndexes;}</span>
const stringFilter=<span class="cstat-no" title="statement not covered" >(searchConfig.isRegex||!searchConfig.caseSensitive)?filterRegexp:filterString;</span>const stringIndexes=<span class="cstat-no" title="statement not covered" >this.strings.reduce(stringFilter,new Set());<span class="cstat-no" title="statement not covered" ></span>if(!stringIndexes.size)</span>
<span class="cstat-no" title="statement not covered" >return[];c</span>onst filter=<span class="cstat-no" title="statement not covered" >this._createFilter(nodeFilter);</span>const nodeIds=<span class="cstat-no" title="statement not covered" >[];</span>const nodesLength=<span class="cstat-no" title="statement not covered" >this.nodes.length;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodeNameOffset=<span class="cstat-no" title="statement not covered" >this._nodeNameOffset;</span>const nodeIdOffset=<span class="cstat-no" title="statement not covered" >this._nodeIdOffset;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(node))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(stringIndexes.has(nodes[nodeIndex+nodeNameOffset]))</span>
<span class="cstat-no" title="statement not covered" >nodeIds.push(nodes[nodeIndex+nodeIdOffset]);}</span>
<span class="cstat-no" title="statement not covered" >return nodeIds;}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregatesWithFilter(nodeFilter){const filter=<span class="cstat-no" title="statement not covered" >this._createFilter(nodeFilter);</span>const key=<span class="cstat-no" title="statement not covered" >filter?filter.key:'allObjects';<span class="cstat-no" title="statement not covered" ></span>return this.aggregates(false,key,filter);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateNodeIdFilter(minNodeId,maxNodeId){function <span class="fstat-no" title="function not covered" >nodeIdFilter(</span>node){const id=<span class="cstat-no" title="statement not covered" >node.id();<span class="cstat-no" title="statement not covered" ></span>return id&gt;minNodeId&amp;&amp;id&lt;=maxNodeId;}</span>
<span class="cstat-no" title="statement not covered" >return nodeIdFilter;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateAllocationStackFilter(bottomUpAllocationNodeId){const traceIds=<span class="cstat-no" title="statement not covered" >this._allocationProfile.traceIds(bottomUpAllocationNodeId);<span class="cstat-no" title="statement not covered" ></span>if(!traceIds.length)</span>
<span class="cstat-no" title="statement not covered" >return undefined;c</span>onst set=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;traceIds.length;i++)</span>
<span class="cstat-no" title="statement not covered" >set[traceIds[i]]=true;f</span>unction <span class="fstat-no" title="function not covered" >traceIdFilter(</span>node){<span class="cstat-no" title="statement not covered" >return!!set[node.traceNodeId()];}</span>
<span class="cstat-no" title="statement not covered" >return traceIdFilter;}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregates(sortedIndexes,key,filter){let aggregatesByClassName=<span class="cstat-no" title="statement not covered" >key&amp;&amp;this._aggregates[key];<span class="cstat-no" title="statement not covered" ></span>if(!aggregatesByClassName){const aggregates=<span class="cstat-no" title="statement not covered" >this._buildAggregates(filter);<span class="cstat-no" title="statement not covered" ></span>this._calculateClassesRetainedSize(aggregates.aggregatesByClassIndex,filter);<span class="cstat-no" title="statement not covered" >a</span>ggregatesByClassName=aggregates.aggregatesByClassName;<span class="cstat-no" title="statement not covered" >i</span>f(key)</span></span>
<span class="cstat-no" title="statement not covered" >this._aggregates[key]=aggregatesByClassName;}</span>
<span class="cstat-no" title="statement not covered" >if(sortedIndexes&amp;&amp;(!key||!this._aggregatesSortedFlags[key])){<span class="cstat-no" title="statement not covered" >this._sortAggregateIndexes(aggregatesByClassName);<span class="cstat-no" title="statement not covered" >i</span>f(key)</span></span>
<span class="cstat-no" title="statement not covered" >this._aggregatesSortedFlags[key]=sortedIndexes;}</span>
<span class="cstat-no" title="statement not covered" >return aggregatesByClassName;}</span>
<span class="fstat-no" title="function not covered" >al</span>locationTracesTops(){<span class="cstat-no" title="statement not covered" >return this._allocationProfile.serializeTraceTops();}</span>
<span class="fstat-no" title="function not covered" >al</span>locationNodeCallers(nodeId){<span class="cstat-no" title="statement not covered" >return this._allocationProfile.serializeCallers(nodeId);}</span>
<span class="fstat-no" title="function not covered" >al</span>locationStack(nodeIndex){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const allocationNodeId=<span class="cstat-no" title="statement not covered" >node.traceNodeId();<span class="cstat-no" title="statement not covered" ></span>if(!allocationNodeId)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this._allocationProfile.serializeAllocationStack(allocationNodeId);}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregatesForDiff(){<span class="cstat-no" title="statement not covered" >if(this._aggregatesForDiff)</span>
<span class="cstat-no" title="statement not covered" >return this._aggregatesForDiff;c</span>onst aggregatesByClassName=<span class="cstat-no" title="statement not covered" >this.aggregates(true,'allObjects');<span class="cstat-no" title="statement not covered" ></span>this._aggregatesForDiff={};c</span>onst node=<span class="cstat-no" title="statement not covered" >this.createNode();<span class="cstat-no" title="statement not covered" ></span>for(const className in aggregatesByClassName){const aggregate=<span class="cstat-no" title="statement not covered" >aggregatesByClassName[className];</span>const indexes=<span class="cstat-no" title="statement not covered" >aggregate.idxs;</span>const ids=<span class="cstat-no" title="statement not covered" >new Array(indexes.length);</span>const selfSizes=<span class="cstat-no" title="statement not covered" >new Array(indexes.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;indexes.length;i++){<span class="cstat-no" title="statement not covered" >node.nodeIndex=indexes[i];<span class="cstat-no" title="statement not covered" >i</span>ds[i]=node.id();<span class="cstat-no" title="statement not covered" >s</span>elfSizes[i]=node.selfSize();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._aggregatesForDiff[className]={indexes:indexes,ids:ids,selfSizes:selfSizes};}</span>
<span class="cstat-no" title="statement not covered" >return this._aggregatesForDiff;}</span>
<span class="fstat-no" title="function not covered" >is</span>UserRoot(node){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateDistances(filter){const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const distances=<span class="cstat-no" title="statement not covered" >this._nodeDistances;</span>const noDistance=<span class="cstat-no" title="statement not covered" >this._noDistance;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;nodeCount;++i)</span>
<span class="cstat-no" title="statement not covered" >distances[i]=noDistance;c</span>onst nodesToVisit=<span class="cstat-no" title="statement not covered" >new Uint32Array(this.nodeCount);</span>let nodesToVisitLength=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let iter=this.rootNode().edges();iter.hasNext();iter.next()){const node=<span class="cstat-no" title="statement not covered" >iter.edge.node();<span class="cstat-no" title="statement not covered" ></span>if(this.isUserRoot(node)){<span class="cstat-no" title="statement not covered" >distances[node.ordinal()]=1;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[nodesToVisitLength++]=node.nodeIndex;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._bfs(nodesToVisit,nodesToVisitLength,distances,filter);<span class="cstat-no" title="statement not covered" >d</span>istances[this.rootNode().ordinal()]=HeapSnapshotModel.baseSystemDistance;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[0]=this.rootNode().nodeIndex;<span class="cstat-no" title="statement not covered" >n</span>odesToVisitLength=1;<span class="cstat-no" title="statement not covered" >t</span>his._bfs(nodesToVisit,nodesToVisitLength,distances,filter);}</span>
<span class="fstat-no" title="function not covered" >_b</span>fs(nodesToVisit,nodesToVisitLength,distances,filter){const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const edgeWeakType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const noDistance=<span class="cstat-no" title="statement not covered" >this._noDistance;</span>let index=<span class="cstat-no" title="statement not covered" >0;</span>const edge=<span class="cstat-no" title="statement not covered" >this.createEdge(0);</span>const node=<span class="cstat-no" title="statement not covered" >this.createNode(0);<span class="cstat-no" title="statement not covered" ></span>while(index&lt;nodesToVisitLength){const nodeIndex=<span class="cstat-no" title="statement not covered" >nodesToVisit[index++];</span>const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const distance=<span class="cstat-no" title="statement not covered" >distances[nodeOrdinal]+1;</span>const firstEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const edgesEnd=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >f</span>or(let edgeIndex=firstEdgeIndex;edgeIndex&lt;edgesEnd;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType===edgeWeakType)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(distances[childNodeOrdinal]!==noDistance)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >e</span>dge.edgeIndex=edgeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(node,edge))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >d</span>istances[childNodeOrdinal]=distance;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[nodesToVisitLength++]=childNodeIndex;}</span>}
<span class="cstat-no" title="statement not covered" >if(nodesToVisitLength&gt;nodeCount){<span class="cstat-no" title="statement not covered" >throw new Error('BFS failed. Nodes to visit ('+nodesToVisitLength+') is more than nodes count ('+nodeCount+')');}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildAggregates(filter){const aggregates=<span class="cstat-no" title="statement not covered" >{};</span>const aggregatesByClassName=<span class="cstat-no" title="statement not covered" >{};</span>const classIndexes=<span class="cstat-no" title="statement not covered" >[];</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const selfSizeOffset=<span class="cstat-no" title="statement not covered" >this._nodeSelfSizeOffset;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();</span>const nodeDistances=<span class="cstat-no" title="statement not covered" >this._nodeDistances;<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(node))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst selfSize=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+selfSizeOffset];<span class="cstat-no" title="statement not covered" ></span>if(!selfSize&amp;&amp;nodes[nodeIndex+nodeTypeOffset]!==nodeNativeType)</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst classIndex=<span class="cstat-no" title="statement not covered" >node.classIndex();</span>const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const distance=<span class="cstat-no" title="statement not covered" >nodeDistances[nodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>if(!(classIndex in aggregates)){const nodeType=<span class="cstat-no" title="statement not covered" >node.type();</span>const nameMatters=<span class="cstat-no" title="statement not covered" >nodeType==='object'||nodeType==='native';</span>const value=<span class="cstat-no" title="statement not covered" >{count:1,distance:distance,self:selfSize,maxRet:0,type:nodeType,name:nameMatters?node.name():null,idxs:[nodeIndex]};<span class="cstat-no" title="statement not covered" ></span>aggregates[classIndex]=value;<span class="cstat-no" title="statement not covered" >c</span>lassIndexes.push(classIndex);<span class="cstat-no" title="statement not covered" >a</span>ggregatesByClassName[node.className()]=value;}</span>else{const clss=<span class="cstat-no" title="statement not covered" >aggregates[classIndex];<span class="cstat-no" title="statement not covered" ></span>clss.distance=Math.min(clss.distance,distance);<span class="cstat-no" title="statement not covered" >+</span>+clss.count;<span class="cstat-no" title="statement not covered" >c</span>lss.self+=selfSize;<span class="cstat-no" title="statement not covered" >c</span>lss.idxs.push(nodeIndex);}</span>}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0,l=classIndexes.length;i&lt;l;++i){const classIndex=<span class="cstat-no" title="statement not covered" >classIndexes[i];<span class="cstat-no" title="statement not covered" ></span>aggregates[classIndex].idxs=aggregates[classIndex].idxs.slice();}</span></span>
<span class="cstat-no" title="statement not covered" >return{aggregatesByClassName:aggregatesByClassName,aggregatesByClassIndex:aggregates};}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateClassesRetainedSize(aggregates,filter){const rootNodeIndex=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex;</span>const node=<span class="cstat-no" title="statement not covered" >this.createNode(rootNodeIndex);</span>const list=<span class="cstat-no" title="statement not covered" >[rootNodeIndex];</span>const sizes=<span class="cstat-no" title="statement not covered" >[-1];</span>const classes=<span class="cstat-no" title="statement not covered" >[];</span>const seenClassNameIndexes=<span class="cstat-no" title="statement not covered" >{};</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const dominatedNodes=<span class="cstat-no" title="statement not covered" >this._dominatedNodes;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const firstDominatedNodeIndex=<span class="cstat-no" title="statement not covered" >this._firstDominatedNodeIndex;<span class="cstat-no" title="statement not covered" ></span>while(list.length){const nodeIndex=<span class="cstat-no" title="statement not covered" >list.pop();<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=nodeIndex;l</span>et classIndex=<span class="cstat-no" title="statement not covered" >node.classIndex();</span>const seen=<span class="cstat-no" title="statement not covered" >!!seenClassNameIndexes[classIndex];</span>const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const dominatedIndexFrom=<span class="cstat-no" title="statement not covered" >firstDominatedNodeIndex[nodeOrdinal];</span>const dominatedIndexTo=<span class="cstat-no" title="statement not covered" >firstDominatedNodeIndex[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>if(!seen&amp;&amp;(!filter||filter(node))&amp;&amp;(node.selfSize()||nodes[nodeIndex+nodeTypeOffset]===nodeNativeType)){<span class="cstat-no" title="statement not covered" >aggregates[classIndex].maxRet+=node.retainedSize();<span class="cstat-no" title="statement not covered" >i</span>f(dominatedIndexFrom!==dominatedIndexTo){<span class="cstat-no" title="statement not covered" >seenClassNameIndexes[classIndex]=true;<span class="cstat-no" title="statement not covered" >s</span>izes.push(list.length);<span class="cstat-no" title="statement not covered" >c</span>lasses.push(classIndex);}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(let i=dominatedIndexFrom;i&lt;dominatedIndexTo;i++)</span>
<span class="cstat-no" title="statement not covered" >list.push(dominatedNodes[i]);c</span>onst l=<span class="cstat-no" title="statement not covered" >list.length;<span class="cstat-no" title="statement not covered" ></span>while(sizes[sizes.length-1]===l){<span class="cstat-no" title="statement not covered" >sizes.pop();<span class="cstat-no" title="statement not covered" >c</span>lassIndex=classes.pop();<span class="cstat-no" title="statement not covered" >s</span>eenClassNameIndexes[classIndex]=false;}</span>}</span>}
<span class="fstat-no" title="function not covered" >_s</span>ortAggregateIndexes(aggregates){const nodeA=<span class="cstat-no" title="statement not covered" >this.createNode();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.createNode();<span class="cstat-no" title="statement not covered" ></span>for(const clss in aggregates){<span class="cstat-no" title="statement not covered" >aggregates[clss].idxs.sort(<span class="fstat-no" title="function not covered" >(i</span>dxA,idxB)=&gt;{<span class="cstat-no" title="statement not covered" >nodeA.nodeIndex=idxA;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=idxB;<span class="cstat-no" title="statement not covered" >r</span>eturn nodeA.id()&lt;nodeB.id()?-1:1;}</span>);}</span>}</span>
<span class="fstat-no" title="function not covered" >_i</span>sEssentialEdge(nodeIndex,edgeType){<span class="cstat-no" title="statement not covered" >return edgeType!==this._edgeWeakType&amp;&amp;(edgeType!==this._edgeShortcutType||nodeIndex===this._rootNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildPostOrderIndex(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const rootNodeOrdinal=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex/nodeFieldCount;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const mapAndFlag=<span class="cstat-no" title="statement not covered" >this.userObjectsMapAndFlag();</span>const flags=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.map:null;</span>const flag=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.flag:0;</span>const stackNodes=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const stackCurrentEdge=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const postOrderIndex2NodeOrdinal=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const nodeOrdinal2PostOrderIndex=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const visited=<span class="cstat-no" title="statement not covered" >new Uint8Array(nodeCount);</span>let postOrderIndex=<span class="cstat-no" title="statement not covered" >0;</span>let stackTop=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>stackNodes[0]=rootNodeOrdinal;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[0]=firstEdgeIndexes[rootNodeOrdinal];<span class="cstat-no" title="statement not covered" >v</span>isited[rootNodeOrdinal]=1;l</span>et iteration=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >++iteration;<span class="cstat-no" title="statement not covered" >w</span>hile(stackTop&gt;=0){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >stackNodes[stackTop];</span>const edgeIndex=<span class="cstat-no" title="statement not covered" >stackCurrentEdge[stackTop];</span>const edgesEnd=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>if(edgeIndex&lt;edgesEnd){<span class="cstat-no" title="statement not covered" >stackCurrentEdge[stackTop]+=edgeFieldsCount;c</span>onst edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(!this._isEssentialEdge(nodeOrdinal*nodeFieldCount,edgeType))</span></span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(visited[childNodeOrdinal])</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst nodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[nodeOrdinal]&amp;flag);</span>const childNodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[childNodeOrdinal]&amp;flag);<span class="cstat-no" title="statement not covered" ></span>if(nodeOrdinal!==rootNodeOrdinal&amp;&amp;childNodeFlag&amp;&amp;!nodeFlag)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >+</span>+stackTop;<span class="cstat-no" title="statement not covered" >s</span>tackNodes[stackTop]=childNodeOrdinal;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[stackTop]=firstEdgeIndexes[childNodeOrdinal];<span class="cstat-no" title="statement not covered" >v</span>isited[childNodeOrdinal]=1;}</span>else{<span class="cstat-no" title="statement not covered" >nodeOrdinal2PostOrderIndex[nodeOrdinal]=postOrderIndex;<span class="cstat-no" title="statement not covered" >p</span>ostOrderIndex2NodeOrdinal[postOrderIndex++]=nodeOrdinal;<span class="cstat-no" title="statement not covered" >-</span>-stackTop;}</span>}
<span class="cstat-no" title="statement not covered" >if(postOrderIndex===nodeCount||iteration&gt;1)</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst errors=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotProblemReport(`Heap snapshot: ${</span>
                            nodeCount - postOrderIndex
                          } nodes are unreachable from the root. Following nodes have only weak retainers:`);const dumpNode=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>--postOrderIndex;<span class="cstat-no" title="statement not covered" >s</span>tackTop=0;<span class="cstat-no" title="statement not covered" >s</span>tackNodes[0]=rootNodeOrdinal;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[0]=firstEdgeIndexes[rootNodeOrdinal+1];<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;nodeCount;++i){<span class="cstat-no" title="statement not covered" >if(visited[i]||!this._hasOnlyWeakRetainers(i))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >s</span>tackNodes[++stackTop]=i;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[stackTop]=firstEdgeIndexes[i];<span class="cstat-no" title="statement not covered" >v</span>isited[i]=1;<span class="cstat-no" title="statement not covered" >d</span>umpNode.nodeIndex=i*nodeFieldCount;c</span>onst retainers=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let it=dumpNode.retainers();it.hasNext();it.next())</span>
<span class="cstat-no" title="statement not covered" >retainers.push(`${it.item().node().name()}@${it.item().node().id()}.${it.item().name()}`);<span class="cstat-no" title="statement not covered" >e</span>rrors.addError(`${dumpNode.name()} @${dumpNode.id()}  weak retainers: ${retainers.join(', ')}`);}</span>
<span class="cstat-no" title="statement not covered" >console.warn(errors.toString());}</span>
<span class="cstat-no" title="statement not covered" >if(postOrderIndex!==nodeCount){const errors=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotProblemReport('Still found '+(nodeCount-postOrderIndex)+' unreachable nodes in heap snapshot:');</span>const dumpNode=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>--postOrderIndex;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;nodeCount;++i){<span class="cstat-no" title="statement not covered" >if(visited[i])</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >d</span>umpNode.nodeIndex=i*nodeFieldCount;<span class="cstat-no" title="statement not covered" >e</span>rrors.addError(dumpNode.name()+' @'+dumpNode.id());<span class="cstat-no" title="statement not covered" >n</span>odeOrdinal2PostOrderIndex[i]=postOrderIndex;<span class="cstat-no" title="statement not covered" >p</span>ostOrderIndex2NodeOrdinal[postOrderIndex++]=i;}</span>
<span class="cstat-no" title="statement not covered" >nodeOrdinal2PostOrderIndex[rootNodeOrdinal]=postOrderIndex;<span class="cstat-no" title="statement not covered" >p</span>ostOrderIndex2NodeOrdinal[postOrderIndex++]=rootNodeOrdinal;<span class="cstat-no" title="statement not covered" >c</span>onsole.warn(errors.toString());}</span>
<span class="cstat-no" title="statement not covered" >return{postOrderIndex2NodeOrdinal:postOrderIndex2NodeOrdinal,nodeOrdinal2PostOrderIndex:nodeOrdinal2PostOrderIndex};}</span>
<span class="fstat-no" title="function not covered" >_h</span>asOnlyWeakRetainers(nodeOrdinal){const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeWeakType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const edgeShortcutType=<span class="cstat-no" title="statement not covered" >this._edgeShortcutType;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const retainingEdges=<span class="cstat-no" title="statement not covered" >this._retainingEdges;</span>const beginRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex[nodeOrdinal];</span>const endRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let retainerIndex=beginRetainerIndex;retainerIndex&lt;endRetainerIndex;++retainerIndex){const retainerEdgeIndex=<span class="cstat-no" title="statement not covered" >retainingEdges[retainerIndex];</span>const retainerEdgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[retainerEdgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(retainerEdgeType!==edgeWeakType&amp;&amp;retainerEdgeType!==edgeShortcutType)</span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildDominatorTree(postOrderIndex2NodeOrdinal,nodeOrdinal2PostOrderIndex){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const firstRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex;</span>const retainingNodes=<span class="cstat-no" title="statement not covered" >this._retainingNodes;</span>const retainingEdges=<span class="cstat-no" title="statement not covered" >this._retainingEdges;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const rootNodeIndex=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex;</span>const mapAndFlag=<span class="cstat-no" title="statement not covered" >this.userObjectsMapAndFlag();</span>const flags=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.map:null;</span>const flag=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.flag:0;</span>const nodesCount=<span class="cstat-no" title="statement not covered" >postOrderIndex2NodeOrdinal.length;</span>const rootPostOrderedIndex=<span class="cstat-no" title="statement not covered" >nodesCount-1;</span>const noEntry=<span class="cstat-no" title="statement not covered" >nodesCount;</span>const dominators=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodesCount);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;rootPostOrderedIndex;++i)</span>
<span class="cstat-no" title="statement not covered" >dominators[i]=noEntry;<span class="cstat-no" title="statement not covered" >d</span>ominators[rootPostOrderedIndex]=rootPostOrderedIndex;c</span>onst affected=<span class="cstat-no" title="statement not covered" >new Uint8Array(nodesCount);</span>let nodeOrdinal;{<span class="cstat-no" title="statement not covered" >nodeOrdinal=this._rootNodeIndex/nodeFieldCount;c</span>onst endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=firstEdgeIndexes[nodeOrdinal];edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(!this._isEssentialEdge(this._rootNodeIndex,edgeType))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst childNodeOrdinal=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset]/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]]=1;}</span>}
let changed=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>while(changed){<span class="cstat-no" title="statement not covered" >changed=false;<span class="cstat-no" title="statement not covered" >f</span>or(let postOrderIndex=rootPostOrderedIndex-1;postOrderIndex&gt;=0;--postOrderIndex){<span class="cstat-no" title="statement not covered" >if(affected[postOrderIndex]===0)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >a</span>ffected[postOrderIndex]=0;<span class="cstat-no" title="statement not covered" >i</span>f(dominators[postOrderIndex]===rootPostOrderedIndex)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >n</span>odeOrdinal=postOrderIndex2NodeOrdinal[postOrderIndex];c</span>onst nodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[nodeOrdinal]&amp;flag);</span>let newDominatorIndex=<span class="cstat-no" title="statement not covered" >noEntry;</span>const beginRetainerIndex=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[nodeOrdinal];</span>const endRetainerIndex=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[nodeOrdinal+1];</span>let orphanNode=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>for(let retainerIndex=beginRetainerIndex;retainerIndex&lt;endRetainerIndex;++retainerIndex){const retainerEdgeIndex=<span class="cstat-no" title="statement not covered" >retainingEdges[retainerIndex];</span>const retainerEdgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[retainerEdgeIndex+edgeTypeOffset];</span>const retainerNodeIndex=<span class="cstat-no" title="statement not covered" >retainingNodes[retainerIndex];<span class="cstat-no" title="statement not covered" ></span>if(!this._isEssentialEdge(retainerNodeIndex,retainerEdgeType))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >o</span>rphanNode=false;c</span>onst retainerNodeOrdinal=<span class="cstat-no" title="statement not covered" >retainerNodeIndex/nodeFieldCount;</span>const retainerNodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[retainerNodeOrdinal]&amp;flag);<span class="cstat-no" title="statement not covered" ></span>if(retainerNodeIndex!==rootNodeIndex&amp;&amp;nodeFlag&amp;&amp;!retainerNodeFlag)</span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et retanerPostOrderIndex=<span class="cstat-no" title="statement not covered" >nodeOrdinal2PostOrderIndex[retainerNodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>if(dominators[retanerPostOrderIndex]!==noEntry){<span class="cstat-no" title="statement not covered" >if(newDominatorIndex===noEntry){<span class="cstat-no" title="statement not covered" >newDominatorIndex=retanerPostOrderIndex;}</span>else{<span class="cstat-no" title="statement not covered" >while(retanerPostOrderIndex!==newDominatorIndex){<span class="cstat-no" title="statement not covered" >while(retanerPostOrderIndex&lt;newDominatorIndex)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >retanerPostOrderIndex=dominators[retanerPostOrderIndex];<span class="cstat-no" title="statement not covered" >w</span>hile(newDominatorIndex&lt;retanerPostOrderIndex)</span>
<span class="cstat-no" title="statement not covered" >newDominatorIndex=dominators[newDominatorIndex];}</span>}
<span class="cstat-no" title="statement not covered" >if(newDominatorIndex===rootPostOrderedIndex)</span>
<span class="cstat-no" title="statement not covered" >break;}</span>}
<span class="cstat-no" title="statement not covered" >if(orphanNode)</span>
<span class="cstat-no" title="statement not covered" >newDominatorIndex=rootPostOrderedIndex;<span class="cstat-no" title="statement not covered" >i</span>f(newDominatorIndex!==noEntry&amp;&amp;dominators[postOrderIndex]!==newDominatorIndex){<span class="cstat-no" title="statement not covered" >dominators[postOrderIndex]=newDominatorIndex;<span class="cstat-no" title="statement not covered" >c</span>hanged=true;<span class="cstat-no" title="statement not covered" >n</span>odeOrdinal=postOrderIndex2NodeOrdinal[postOrderIndex];c</span>onst beginEdgeToNodeFieldIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal]+edgeToNodeOffset;</span>const endEdgeToNodeFieldIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let toNodeFieldIndex=beginEdgeToNodeFieldIndex;toNodeFieldIndex&lt;endEdgeToNodeFieldIndex;toNodeFieldIndex+=edgeFieldsCount){const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >containmentEdges[toNodeFieldIndex]/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]]=1;}</span>}</span>}</span>}
const dominatorsTree=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodesCount);<span class="cstat-no" title="statement not covered" ></span>for(let postOrderIndex=0,l=dominators.length;postOrderIndex&lt;l;++postOrderIndex){<span class="cstat-no" title="statement not covered" >nodeOrdinal=postOrderIndex2NodeOrdinal[postOrderIndex];<span class="cstat-no" title="statement not covered" >d</span>ominatorsTree[nodeOrdinal]=postOrderIndex2NodeOrdinal[dominators[postOrderIndex]];}</span></span>
<span class="cstat-no" title="statement not covered" >return dominatorsTree;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateRetainedSizes(postOrderIndex2NodeOrdinal){const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodeSelfSizeOffset=<span class="cstat-no" title="statement not covered" >this._nodeSelfSizeOffset;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const dominatorsTree=<span class="cstat-no" title="statement not covered" >this._dominatorsTree;</span>const retainedSizes=<span class="cstat-no" title="statement not covered" >this._retainedSizes;<span class="cstat-no" title="statement not covered" ></span>for(let nodeOrdinal=0;nodeOrdinal&lt;nodeCount;++nodeOrdinal)</span>
<span class="cstat-no" title="statement not covered" >retainedSizes[nodeOrdinal]=nodes[nodeOrdinal*nodeFieldCount+nodeSelfSizeOffset];<span class="cstat-no" title="statement not covered" >f</span>or(let postOrderIndex=0;postOrderIndex&lt;nodeCount-1;++postOrderIndex){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >postOrderIndex2NodeOrdinal[postOrderIndex];</span>const dominatorOrdinal=<span class="cstat-no" title="statement not covered" >dominatorsTree[nodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>retainedSizes[dominatorOrdinal]+=retainedSizes[nodeOrdinal];}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildDominatedNodes(){const indexArray=<span class="cstat-no" title="statement not covered" >this._firstDominatedNodeIndex;</span>const dominatedNodes=<span class="cstat-no" title="statement not covered" >this._dominatedNodes;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const dominatorsTree=<span class="cstat-no" title="statement not covered" >this._dominatorsTree;</span>let fromNodeOrdinal=<span class="cstat-no" title="statement not covered" >0;</span>let toNodeOrdinal=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const rootNodeOrdinal=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(rootNodeOrdinal===fromNodeOrdinal)</span>
<span class="cstat-no" title="statement not covered" >fromNodeOrdinal=1;e</span>lse <span class="cstat-no" title="statement not covered" >if(rootNodeOrdinal===toNodeOrdinal-1)</span>
<span class="cstat-no" title="statement not covered" >toNodeOrdinal=toNodeOrdinal-1;e</span>lse
<span class="cstat-no" title="statement not covered" >throw new Error('Root node is expected to be either first or last');<span class="cstat-no" title="statement not covered" >f</span>or(let nodeOrdinal=fromNodeOrdinal;nodeOrdinal&lt;toNodeOrdinal;++nodeOrdinal)</span>
<span class="cstat-no" title="statement not covered" >++indexArray[dominatorsTree[nodeOrdinal]];l</span>et firstDominatedNodeIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0,l=this.nodeCount;i&lt;l;++i){const dominatedCount=<span class="cstat-no" title="statement not covered" >dominatedNodes[firstDominatedNodeIndex]=indexArray[i];<span class="cstat-no" title="statement not covered" ></span>indexArray[i]=firstDominatedNodeIndex;<span class="cstat-no" title="statement not covered" >f</span>irstDominatedNodeIndex+=dominatedCount;}</span></span>
<span class="cstat-no" title="statement not covered" >indexArray[this.nodeCount]=dominatedNodes.length;<span class="cstat-no" title="statement not covered" >f</span>or(let nodeOrdinal=fromNodeOrdinal;nodeOrdinal&lt;toNodeOrdinal;++nodeOrdinal){const dominatorOrdinal=<span class="cstat-no" title="statement not covered" >dominatorsTree[nodeOrdinal];</span>let dominatedRefIndex=<span class="cstat-no" title="statement not covered" >indexArray[dominatorOrdinal];<span class="cstat-no" title="statement not covered" ></span>dominatedRefIndex+=(--dominatedNodes[dominatedRefIndex]);<span class="cstat-no" title="statement not covered" >d</span>ominatedNodes[dominatedRefIndex]=nodeOrdinal*nodeFieldCount;}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildSamples(){const samples=<span class="cstat-no" title="statement not covered" >this._rawSamples;<span class="cstat-no" title="statement not covered" ></span>if(!samples||!samples.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst sampleCount=<span class="cstat-no" title="statement not covered" >samples.length/2;</span>const sizeForRange=<span class="cstat-no" title="statement not covered" >new Array(sampleCount);</span>const timestamps=<span class="cstat-no" title="statement not covered" >new Array(sampleCount);</span>const lastAssignedIds=<span class="cstat-no" title="statement not covered" >new Array(sampleCount);</span>const timestampOffset=<span class="cstat-no" title="statement not covered" >this._metaNode.sample_fields.indexOf('timestamp_us');</span>const lastAssignedIdOffset=<span class="cstat-no" title="statement not covered" >this._metaNode.sample_fields.indexOf('last_assigned_id');<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;sampleCount;i++){<span class="cstat-no" title="statement not covered" >sizeForRange[i]=0;<span class="cstat-no" title="statement not covered" >t</span>imestamps[i]=(samples[2*i+timestampOffset])/1000;<span class="cstat-no" title="statement not covered" >l</span>astAssignedIds[i]=samples[2*i+lastAssignedIdOffset];}</span></span>
const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;c</span>onst nodeId=<span class="cstat-no" title="statement not covered" >node.id();<span class="cstat-no" title="statement not covered" ></span>if(nodeId%2===0)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst rangeIndex=<span class="cstat-no" title="statement not covered" >lastAssignedIds.lowerBound(nodeId);<span class="cstat-no" title="statement not covered" ></span>if(rangeIndex===sampleCount){<span class="cstat-no" title="statement not covered" >continue;}</span></span>
<span class="cstat-no" title="statement not covered" >sizeForRange[rangeIndex]+=node.selfSize();}</span>
<span class="cstat-no" title="statement not covered" >this._samples=new HeapSnapshotModel.Samples(timestamps,lastAssignedIds,sizeForRange);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildLocationMap(){const map=<span class="cstat-no" title="statement not covered" >new Map();</span>const locations=<span class="cstat-no" title="statement not covered" >this._locations;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;locations.length;i+=this._locationFieldCount){const nodeIndex=<span class="cstat-no" title="statement not covered" >locations[i+this._locationIndexOffset];</span>const scriptId=<span class="cstat-no" title="statement not covered" >locations[i+this._locationScriptIdOffset];</span>const line=<span class="cstat-no" title="statement not covered" >locations[i+this._locationLineOffset];</span>const col=<span class="cstat-no" title="statement not covered" >locations[i+this._locationColumnOffset];<span class="cstat-no" title="statement not covered" ></span>map.set(nodeIndex,new HeapSnapshotModel.Location(scriptId,line,col));}</span></span>
<span class="cstat-no" title="statement not covered" >this._locationMap=map;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tLocation(nodeIndex){<span class="cstat-no" title="statement not covered" >return this._locationMap.get(nodeIndex)||null;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tSamples(){<span class="cstat-no" title="statement not covered" >return this._samples;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateFlags(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateStatistics(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >us</span>erObjectsMapAndFlag(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateSnapshotDiff(baseSnapshotId,baseSnapshotAggregates){let snapshotDiff=<span class="cstat-no" title="statement not covered" >this._snapshotDiffs[baseSnapshotId];<span class="cstat-no" title="statement not covered" ></span>if(snapshotDiff)</span>
<span class="cstat-no" title="statement not covered" >return snapshotDiff;<span class="cstat-no" title="statement not covered" >s</span>napshotDiff={};c</span>onst aggregates=<span class="cstat-no" title="statement not covered" >this.aggregates(true,'allObjects');<span class="cstat-no" title="statement not covered" ></span>for(const className in baseSnapshotAggregates){const baseAggregate=<span class="cstat-no" title="statement not covered" >baseSnapshotAggregates[className];</span>const diff=<span class="cstat-no" title="statement not covered" >this._calculateDiffForClass(baseAggregate,aggregates[className]);<span class="cstat-no" title="statement not covered" ></span>if(diff)</span></span>
<span class="cstat-no" title="statement not covered" >snapshotDiff[className]=diff;}</span>
const emptyBaseAggregate=<span class="cstat-no" title="statement not covered" >new HeapSnapshotModel.AggregateForDiff();<span class="cstat-no" title="statement not covered" ></span>for(const className in aggregates){<span class="cstat-no" title="statement not covered" >if(className in baseSnapshotAggregates)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >s</span>napshotDiff[className]=this._calculateDiffForClass(emptyBaseAggregate,aggregates[className]);}</span>
<span class="cstat-no" title="statement not covered" >this._snapshotDiffs[baseSnapshotId]=snapshotDiff;<span class="cstat-no" title="statement not covered" >r</span>eturn snapshotDiff;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateDiffForClass(baseAggregate,aggregate){const baseIds=<span class="cstat-no" title="statement not covered" >baseAggregate.ids;</span>const baseIndexes=<span class="cstat-no" title="statement not covered" >baseAggregate.indexes;</span>const baseSelfSizes=<span class="cstat-no" title="statement not covered" >baseAggregate.selfSizes;</span>const indexes=<span class="cstat-no" title="statement not covered" >aggregate?aggregate.idxs:[];</span>let i=<span class="cstat-no" title="statement not covered" >0;</span>let j=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >baseIds.length;</span>const m=<span class="cstat-no" title="statement not covered" >indexes.length;</span>const diff=<span class="cstat-no" title="statement not covered" >new HeapSnapshotModel.Diff();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.createNode(indexes[j]);<span class="cstat-no" title="statement not covered" ></span>while(i&lt;l&amp;&amp;j&lt;m){const nodeAId=<span class="cstat-no" title="statement not covered" >baseIds[i];<span class="cstat-no" title="statement not covered" ></span>if(nodeAId&lt;nodeB.id()){<span class="cstat-no" title="statement not covered" >diff.deletedIndexes.push(baseIndexes[i]);<span class="cstat-no" title="statement not covered" >d</span>iff.removedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.removedSize+=baseSelfSizes[i];<span class="cstat-no" title="statement not covered" >+</span>+i;}</span>else <span class="cstat-no" title="statement not covered" >if(nodeAId&gt;nodeB.id()){<span class="cstat-no" title="statement not covered" >diff.addedIndexes.push(indexes[j]);<span class="cstat-no" title="statement not covered" >d</span>iff.addedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.addedSize+=nodeB.selfSize();<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexes[++j];}</span>else{<span class="cstat-no" title="statement not covered" >++i;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexes[++j];}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(i&lt;l){<span class="cstat-no" title="statement not covered" >diff.deletedIndexes.push(baseIndexes[i]);<span class="cstat-no" title="statement not covered" >d</span>iff.removedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.removedSize+=baseSelfSizes[i];<span class="cstat-no" title="statement not covered" >+</span>+i;}</span></span>
<span class="cstat-no" title="statement not covered" >while(j&lt;m){<span class="cstat-no" title="statement not covered" >diff.addedIndexes.push(indexes[j]);<span class="cstat-no" title="statement not covered" >d</span>iff.addedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.addedSize+=nodeB.selfSize();<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexes[++j];}</span></span>
<span class="cstat-no" title="statement not covered" >diff.countDelta=diff.addedCount-diff.removedCount;<span class="cstat-no" title="statement not covered" >d</span>iff.sizeDelta=diff.addedSize-diff.removedSize;<span class="cstat-no" title="statement not covered" >i</span>f(!diff.addedCount&amp;&amp;!diff.removedCount)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn diff;}</span>
<span class="fstat-no" title="function not covered" >_n</span>odeForSnapshotObjectId(snapshotObjectId){<span class="cstat-no" title="statement not covered" >for(let it=this._allNodes();it.hasNext();it.next()){<span class="cstat-no" title="statement not covered" >if(it.node.id()===snapshotObjectId)</span></span>
<span class="cstat-no" title="statement not covered" >return it.node;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >no</span>deClassName(snapshotObjectId){const node=<span class="cstat-no" title="statement not covered" >this._nodeForSnapshotObjectId(snapshotObjectId);<span class="cstat-no" title="statement not covered" ></span>if(node)</span>
<span class="cstat-no" title="statement not covered" >return node.className();<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>
<span class="fstat-no" title="function not covered" >id</span>sOfObjectsWithName(name){const ids=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let it=this._allNodes();it.hasNext();it.next()){<span class="cstat-no" title="statement not covered" >if(it.item().name()===name)</span></span>
<span class="cstat-no" title="statement not covered" >ids.push(it.item().id());}</span>
<span class="cstat-no" title="statement not covered" >return ids;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdgesProvider(nodeIndex){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const filter=<span class="cstat-no" title="statement not covered" >this.containmentEdgesFilter();</span>const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotEdgeIndexProvider(this);<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotEdgesProvider(this,filter,node.edges(),indexProvider);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdgesProviderForTest(nodeIndex,filter){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotEdgeIndexProvider(this);<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotEdgesProvider(this,filter,node.edges(),indexProvider);}</span>
<span class="fstat-no" title="function not covered" >re</span>tainingEdgesFilter(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >co</span>ntainmentEdgesFilter(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdgesProvider(nodeIndex){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const filter=<span class="cstat-no" title="statement not covered" >this.retainingEdgesFilter();</span>const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotRetainerEdgeIndexProvider(this);<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotEdgesProvider(this,filter,node.retainers(),indexProvider);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateAddedNodesProvider(baseSnapshotId,className){const snapshotDiff=<span class="cstat-no" title="statement not covered" >this._snapshotDiffs[baseSnapshotId];</span>const diffForClass=<span class="cstat-no" title="statement not covered" >snapshotDiff[className];<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotNodesProvider(this,diffForClass.addedIndexes);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateDeletedNodesProvider(nodeIndexes){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotNodesProvider(this,nodeIndexes);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateNodesProviderForClass(className,nodeFilter){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotNodesProvider(this,this.aggregatesWithFilter(nodeFilter)[className].idxs);}</span>
<span class="fstat-no" title="function not covered" >_m</span>axJsNodeId(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>let id=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=this._nodeIdOffset;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){const nextId=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex];<span class="cstat-no" title="statement not covered" ></span>if(nextId%2===0)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(id&lt;nextId)</span>
<span class="cstat-no" title="statement not covered" >id=nextId;}</span>
<span class="cstat-no" title="statement not covered" >return id;}</span>
<span class="fstat-no" title="function not covered" >up</span>dateStaticData(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.StaticData(this.nodeCount,this._rootNodeIndex,this.totalSize,this._maxJsNodeId());}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshot.AggregatedInfo;c</span>onst HeapSnapshotMetainfo=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.node_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.node_types=[];<span class="cstat-no" title="statement not covered" >t</span>his.edge_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.edge_types=[];<span class="cstat-no" title="statement not covered" >t</span>his.trace_function_info_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.trace_node_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.sample_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.type_strings={};}</span>};</span>const HeapSnapshotHeader=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.title='';<span class="cstat-no" title="statement not covered" >t</span>his.meta=new HeapSnapshotMetainfo();<span class="cstat-no" title="statement not covered" >t</span>his.node_count=0;<span class="cstat-no" title="statement not covered" >t</span>his.edge_count=0;<span class="cstat-no" title="statement not covered" >t</span>his.trace_function_count=0;}</span>};<span class="cstat-no" title="statement not covered" ></span>HeapSnapshotWorker.HeapSnapshotItemProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(iterator,indexProvider){<span class="cstat-no" title="statement not covered" >this._iterator=iterator;<span class="cstat-no" title="statement not covered" >t</span>his._indexProvider=indexProvider;<span class="cstat-no" title="statement not covered" >t</span>his._isEmpty=!iterator.hasNext();<span class="cstat-no" title="statement not covered" >t</span>his._iterationOrder=null;<span class="cstat-no" title="statement not covered" >t</span>his._currentComparator=null;<span class="cstat-no" title="statement not covered" >t</span>his._sortedPrefixLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._sortedSuffixLength=0;}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>reateIterationOrder(){<span class="cstat-no" title="statement not covered" >if(this._iterationOrder)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._iterationOrder=[];<span class="cstat-no" title="statement not covered" >f</span>or(let iterator=this._iterator;iterator.hasNext();iterator.next())</span>
<span class="cstat-no" title="statement not covered" >this._iterationOrder.push(iterator.item().itemIndex());}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this._isEmpty;}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeItemsRange(begin,end){<span class="cstat-no" title="statement not covered" >this._createIterationOrder();<span class="cstat-no" title="statement not covered" >i</span>f(begin&gt;end)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Start position &gt; end position: '+begin+' &gt; '+end);<span class="cstat-no" title="statement not covered" >i</span>f(end&gt;this._iterationOrder.length)</span>
<span class="cstat-no" title="statement not covered" >end=this._iterationOrder.length;<span class="cstat-no" title="statement not covered" >i</span>f(this._sortedPrefixLength&lt;end&amp;&amp;begin&lt;this._iterationOrder.length-this._sortedSuffixLength){<span class="cstat-no" title="statement not covered" >this.sort(this._currentComparator,this._sortedPrefixLength,this._iterationOrder.length-1-this._sortedSuffixLength,begin,end-1);<span class="cstat-no" title="statement not covered" >i</span>f(begin&lt;=this._sortedPrefixLength)</span></span>
<span class="cstat-no" title="statement not covered" >this._sortedPrefixLength=end;<span class="cstat-no" title="statement not covered" >i</span>f(end&gt;=this._iterationOrder.length-this._sortedSuffixLength)</span>
<span class="cstat-no" title="statement not covered" >this._sortedSuffixLength=this._iterationOrder.length-begin;}</span>
let position=<span class="cstat-no" title="statement not covered" >begin;</span>const count=<span class="cstat-no" title="statement not covered" >end-begin;</span>const result=<span class="cstat-no" title="statement not covered" >new Array(count);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;count;++i){const itemIndex=<span class="cstat-no" title="statement not covered" >this._iterationOrder[position++];</span>const item=<span class="cstat-no" title="statement not covered" >this._indexProvider.itemForIndex(itemIndex);<span class="cstat-no" title="statement not covered" ></span>result[i]=item.serialize();}</span></span>
<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.ItemsRange(begin,end,this._iterationOrder.length,result);}</span>
<span class="fstat-no" title="function not covered" >so</span>rtAndRewind(comparator){<span class="cstat-no" title="statement not covered" >this._currentComparator=comparator;<span class="cstat-no" title="statement not covered" >t</span>his._sortedPrefixLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._sortedSuffixLength=0;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotEdgesProvider=class extends HeapSnapshotWorker.HeapSnapshotItemProvider{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,filter,edgesIter,indexProvider){const iter=<span class="cstat-no" title="statement not covered" >filter?new HeapSnapshotWorker.HeapSnapshotFilteredIterator(edgesIter,(filter)):edgesIter;<span class="cstat-no" title="statement not covered" ></span>super(iter,indexProvider);<span class="cstat-no" title="statement not covered" >t</span>his.snapshot=snapshot;}</span></span>
<span class="fstat-no" title="function not covered" >so</span>rt(comparator,leftBound,rightBound,windowLeft,windowRight){const fieldName1=<span class="cstat-no" title="statement not covered" >comparator.fieldName1;</span>const fieldName2=<span class="cstat-no" title="statement not covered" >comparator.fieldName2;</span>const ascending1=<span class="cstat-no" title="statement not covered" >comparator.ascending1;</span>const ascending2=<span class="cstat-no" title="statement not covered" >comparator.ascending2;</span>const edgeA=<span class="cstat-no" title="statement not covered" >this._iterator.item().clone();</span>const edgeB=<span class="cstat-no" title="statement not covered" >edgeA.clone();</span>const nodeA=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>function <span class="fstat-no" title="function not covered" >compareEdgeFieldName(</span>ascending,indexA,indexB){<span class="cstat-no" title="statement not covered" >edgeA.edgeIndex=indexA;<span class="cstat-no" title="statement not covered" >e</span>dgeB.edgeIndex=indexB;<span class="cstat-no" title="statement not covered" >i</span>f(edgeB.name()==='__proto__')</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(edgeA.name()==='__proto__')</span>
<span class="cstat-no" title="statement not covered" >return 1;c</span>onst result=<span class="cstat-no" title="statement not covered" >edgeA.hasStringName()===edgeB.hasStringName()?(edgeA.name()&lt;edgeB.name()?-1:(edgeA.name()&gt;edgeB.name()?1:0)):(edgeA.hasStringName()?-1:1);<span class="cstat-no" title="statement not covered" ></span>return ascending?result:-result;}</span>
function <span class="fstat-no" title="function not covered" >compareNodeField(</span>fieldName,ascending,indexA,indexB){<span class="cstat-no" title="statement not covered" >edgeA.edgeIndex=indexA;<span class="cstat-no" title="statement not covered" >n</span>odeA.nodeIndex=edgeA.nodeIndex();c</span>onst valueA=<span class="cstat-no" title="statement not covered" >nodeA[fieldName]();<span class="cstat-no" title="statement not covered" ></span>edgeB.edgeIndex=indexB;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=edgeB.nodeIndex();c</span>onst valueB=<span class="cstat-no" title="statement not covered" >nodeB[fieldName]();</span>const result=<span class="cstat-no" title="statement not covered" >valueA&lt;valueB?-1:(valueA&gt;valueB?1:0);<span class="cstat-no" title="statement not covered" ></span>return ascending?result:-result;}</span>
function <span class="fstat-no" title="function not covered" >compareEdgeAndNode(</span>indexA,indexB){let result=<span class="cstat-no" title="statement not covered" >compareEdgeFieldName(ascending1,indexA,indexB);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=compareNodeField(fieldName2,ascending2,indexA,indexB);<span class="cstat-no" title="statement not covered" >i</span>f(result===0)</span>
<span class="cstat-no" title="statement not covered" >return indexA-indexB;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
function <span class="fstat-no" title="function not covered" >compareNodeAndEdge(</span>indexA,indexB){let result=<span class="cstat-no" title="statement not covered" >compareNodeField(fieldName1,ascending1,indexA,indexB);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=compareEdgeFieldName(ascending2,indexA,indexB);<span class="cstat-no" title="statement not covered" >i</span>f(result===0)</span>
<span class="cstat-no" title="statement not covered" >return indexA-indexB;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
function <span class="fstat-no" title="function not covered" >compareNodeAndNode(</span>indexA,indexB){let result=<span class="cstat-no" title="statement not covered" >compareNodeField(fieldName1,ascending1,indexA,indexB);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=compareNodeField(fieldName2,ascending2,indexA,indexB);<span class="cstat-no" title="statement not covered" >i</span>f(result===0)</span>
<span class="cstat-no" title="statement not covered" >return indexA-indexB;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="cstat-no" title="statement not covered" >if(fieldName1==='!edgeName')</span>
<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(compareEdgeAndNode,leftBound,rightBound,windowLeft,windowRight);e</span>lse <span class="cstat-no" title="statement not covered" >if(fieldName2==='!edgeName')</span>
<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(compareNodeAndEdge,leftBound,rightBound,windowLeft,windowRight);e</span>lse
<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(compareNodeAndNode,leftBound,rightBound,windowLeft,windowRight);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotNodesProvider=class extends HeapSnapshotWorker.HeapSnapshotItemProvider{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,nodeIndexes){const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotNodeIndexProvider(snapshot);</span>const it=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotIndexRangeIterator(indexProvider,nodeIndexes);<span class="cstat-no" title="statement not covered" ></span>super(it,indexProvider);<span class="cstat-no" title="statement not covered" >t</span>his.snapshot=snapshot;}</span></span>
<span class="fstat-no" title="function not covered" >no</span>dePosition(snapshotObjectId){<span class="cstat-no" title="statement not covered" >this._createIterationOrder();c</span>onst node=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>let i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;this._iterationOrder.length;i++){<span class="cstat-no" title="statement not covered" >node.nodeIndex=this._iterationOrder[i];<span class="cstat-no" title="statement not covered" >i</span>f(node.id()===snapshotObjectId)</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>
<span class="cstat-no" title="statement not covered" >if(i===this._iterationOrder.length)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst targetNodeIndex=<span class="cstat-no" title="statement not covered" >this._iterationOrder[i];</span>let smallerCount=<span class="cstat-no" title="statement not covered" >0;</span>const compare=<span class="cstat-no" title="statement not covered" >this._buildCompareFunction(this._currentComparator);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._iterationOrder.length;i++){<span class="cstat-no" title="statement not covered" >if(compare(this._iterationOrder[i],targetNodeIndex)&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >++smallerCount;}</span>
<span class="cstat-no" title="statement not covered" >return smallerCount;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildCompareFunction(comparator){const nodeA=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>const fieldAccessor1=<span class="cstat-no" title="statement not covered" >nodeA[comparator.fieldName1];</span>const fieldAccessor2=<span class="cstat-no" title="statement not covered" >nodeA[comparator.fieldName2];</span>const ascending1=<span class="cstat-no" title="statement not covered" >comparator.ascending1?1:-1;</span>const ascending2=<span class="cstat-no" title="statement not covered" >comparator.ascending2?1:-1;</span>function <span class="fstat-no" title="function not covered" >sortByNodeField(</span>fieldAccessor,ascending){const valueA=<span class="cstat-no" title="statement not covered" >fieldAccessor.call(nodeA);</span>const valueB=<span class="cstat-no" title="statement not covered" >fieldAccessor.call(nodeB);<span class="cstat-no" title="statement not covered" ></span>return valueA&lt;valueB?-ascending:(valueA&gt;valueB?ascending:0);}</span>
function <span class="fstat-no" title="function not covered" >sortByComparator(</span>indexA,indexB){<span class="cstat-no" title="statement not covered" >nodeA.nodeIndex=indexA;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexB;l</span>et result=<span class="cstat-no" title="statement not covered" >sortByNodeField(fieldAccessor1,ascending1);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=sortByNodeField(fieldAccessor2,ascending2);<span class="cstat-no" title="statement not covered" >r</span>eturn result||indexA-indexB;}</span>
<span class="cstat-no" title="statement not covered" >return sortByComparator;}</span>
<span class="fstat-no" title="function not covered" >so</span>rt(comparator,leftBound,rightBound,windowLeft,windowRight){<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(this._buildCompareFunction(comparator),leftBound,rightBound,windowLeft,windowRight);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshot=class extends HeapSnapshotWorker.HeapSnapshot{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,progress){<span class="cstat-no" title="statement not covered" >super(profile,progress);<span class="cstat-no" title="statement not covered" >t</span>his._nodeFlags={canBeQueried:1,detachedDOMTreeNode:2,pageObject:4};<span class="cstat-no" title="statement not covered" >t</span>his._lazyStringCache={};<span class="cstat-no" title="statement not covered" >t</span>his.initialize();}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateNode(nodeIndex){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotNode(this,nodeIndex===undefined?-1:nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdge(edgeIndex){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotEdge(this,edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdge(retainerIndex){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotRetainerEdge(this,retainerIndex);}</span>
<span class="fstat-no" title="function not covered" >co</span>ntainmentEdgesFilter(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ed</span>ge=&gt;<span class="cstat-no" title="statement not covered" >!edge.isInvisible();</span>}</span>
<span class="fstat-no" title="function not covered" >re</span>tainingEdgesFilter(){const containmentEdgesFilter=<span class="cstat-no" title="statement not covered" >this.containmentEdgesFilter();</span>function <span class="fstat-no" title="function not covered" >filter(</span>edge){<span class="cstat-no" title="statement not covered" >return containmentEdgesFilter(edge)&amp;&amp;!edge.node().isRoot()&amp;&amp;!edge.isWeak();}</span>
<span class="cstat-no" title="statement not covered" >return filter;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateFlags(){<span class="cstat-no" title="statement not covered" >this._flags=new Uint32Array(this.nodeCount);<span class="cstat-no" title="statement not covered" >t</span>his._markDetachedDOMTreeNodes();<span class="cstat-no" title="statement not covered" >t</span>his._markQueriableHeapObjects();<span class="cstat-no" title="statement not covered" >t</span>his._markPageOwnedNodes();}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateDistances(){function <span class="fstat-no" title="function not covered" >filter(</span>node,edge){<span class="cstat-no" title="statement not covered" >if(node.isHidden())</span>
<span class="cstat-no" title="statement not covered" >return edge.name()!=='sloppy_function_map'||node.rawName()!=='system / NativeContext';<span class="cstat-no" title="statement not covered" >i</span>f(node.isArray()){<span class="cstat-no" title="statement not covered" >if(node.rawName()!=='(map descriptors)')</span></span>
<span class="cstat-no" title="statement not covered" >return true;c</span>onst index=<span class="cstat-no" title="statement not covered" >edge.name();<span class="cstat-no" title="statement not covered" ></span>return index&lt;2||(index%3)!==1;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="cstat-no" title="statement not covered" >super.calculateDistances(filter);}</span>
<span class="fstat-no" title="function not covered" >is</span>UserRoot(node){<span class="cstat-no" title="statement not covered" >return node.isUserRoot()||node.isDocumentDOMTreesRoot();}</span>
<span class="fstat-no" title="function not covered" >us</span>erObjectsMapAndFlag(){<span class="cstat-no" title="statement not covered" >return{map:this._flags,flag:this._nodeFlags.pageObject};}</span>
<span class="fstat-no" title="function not covered" >_f</span>lagsOfNode(node){<span class="cstat-no" title="statement not covered" >return this._flags[node.nodeIndex/this._nodeFieldCount];}</span>
<span class="fstat-no" title="function not covered" >_m</span>arkDetachedDOMTreeNodes(){const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const flag=<span class="cstat-no" title="statement not covered" >this._nodeFlags.detachedDOMTreeNode;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0,ordinal=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount,ordinal++){const nodeType=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+nodeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(nodeType!==nodeNativeType)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >n</span>ode.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(node.name().startsWith('Detached '))</span>
<span class="cstat-no" title="statement not covered" >this._flags[ordinal]|=flag;}</span>}
<span class="fstat-no" title="function not covered" >_m</span>arkQueriableHeapObjects(){const flag=<span class="cstat-no" title="statement not covered" >this._nodeFlags.canBeQueried;</span>const hiddenEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeHiddenType;</span>const internalEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeInternalType;</span>const invisibleEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeInvisibleType;</span>const weakEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const flags=<span class="cstat-no" title="statement not covered" >this._flags;</span>const list=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let iter=this.rootNode().edges();iter.hasNext();iter.next()){<span class="cstat-no" title="statement not covered" >if(iter.edge.node().isUserRoot())</span></span>
<span class="cstat-no" title="statement not covered" >list.push(iter.edge.node().nodeIndex/nodeFieldCount);}</span>
<span class="cstat-no" title="statement not covered" >while(list.length){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >list.pop();<span class="cstat-no" title="statement not covered" ></span>if(flags[nodeOrdinal]&amp;flag)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span>lags[nodeOrdinal]|=flag;c</span>onst beginEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(flags[childNodeOrdinal]&amp;flag)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst type=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(type===hiddenEdgeType||type===invisibleEdgeType||type===internalEdgeType||type===weakEdgeType)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >l</span>ist.push(childNodeOrdinal);}</span>}}
<span class="fstat-no" title="function not covered" >_m</span>arkPageOwnedNodes(){const edgeShortcutType=<span class="cstat-no" title="statement not covered" >this._edgeShortcutType;</span>const edgeElementType=<span class="cstat-no" title="statement not covered" >this._edgeElementType;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeWeakType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodesCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const flags=<span class="cstat-no" title="statement not covered" >this._flags;</span>const pageObjectFlag=<span class="cstat-no" title="statement not covered" >this._nodeFlags.pageObject;</span>const nodesToVisit=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodesCount);</span>let nodesToVisitLength=<span class="cstat-no" title="statement not covered" >0;</span>const rootNodeOrdinal=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex/nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=firstEdgeIndexes[rootNodeOrdinal],endEdgeIndex=firstEdgeIndexes[rootNodeOrdinal+1];edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];</span>const nodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType===edgeElementType){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(!node.isDocumentDOMTreesRoot())</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;}</span>else <span class="cstat-no" title="statement not covered" >if(edgeType!==edgeShortcutType){<span class="cstat-no" title="statement not covered" >continue;}</span></span>
const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>nodesToVisit[nodesToVisitLength++]=nodeOrdinal;<span class="cstat-no" title="statement not covered" >f</span>lags[nodeOrdinal]|=pageObjectFlag;}</span>
<span class="cstat-no" title="statement not covered" >while(nodesToVisitLength){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodesToVisit[--nodesToVisitLength];</span>const beginEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(flags[childNodeOrdinal]&amp;pageObjectFlag)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst type=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(type===edgeWeakType)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[nodesToVisitLength++]=childNodeOrdinal;<span class="cstat-no" title="statement not covered" >f</span>lags[childNodeOrdinal]|=pageObjectFlag;}</span>}}
<span class="fstat-no" title="function not covered" >ca</span>lculateStatistics(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const nodeSizeOffset=<span class="cstat-no" title="statement not covered" >this._nodeSelfSizeOffset;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const nodeCodeType=<span class="cstat-no" title="statement not covered" >this._nodeCodeType;</span>const nodeConsStringType=<span class="cstat-no" title="statement not covered" >this._nodeConsStringType;</span>const nodeSlicedStringType=<span class="cstat-no" title="statement not covered" >this._nodeSlicedStringType;</span>const distances=<span class="cstat-no" title="statement not covered" >this._nodeDistances;</span>let sizeNative=<span class="cstat-no" title="statement not covered" >0;</span>let sizeCode=<span class="cstat-no" title="statement not covered" >0;</span>let sizeStrings=<span class="cstat-no" title="statement not covered" >0;</span>let sizeJSArrays=<span class="cstat-no" title="statement not covered" >0;</span>let sizeSystem=<span class="cstat-no" title="statement not covered" >0;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){const nodeSize=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+nodeSizeOffset];</span>const ordinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(distances[ordinal]&gt;=HeapSnapshotModel.baseSystemDistance){<span class="cstat-no" title="statement not covered" >sizeSystem+=nodeSize;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
const nodeType=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+nodeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(nodeType===nodeNativeType)</span>
<span class="cstat-no" title="statement not covered" >sizeNative+=nodeSize;e</span>lse <span class="cstat-no" title="statement not covered" >if(nodeType===nodeCodeType)</span>
<span class="cstat-no" title="statement not covered" >sizeCode+=nodeSize;e</span>lse <span class="cstat-no" title="statement not covered" >if(nodeType===nodeConsStringType||nodeType===nodeSlicedStringType||node.type()==='string')</span>
<span class="cstat-no" title="statement not covered" >sizeStrings+=nodeSize;e</span>lse <span class="cstat-no" title="statement not covered" >if(node.name()==='Array')</span>
<span class="cstat-no" title="statement not covered" >sizeJSArrays+=this._calculateArraySize(node);}</span>
<span class="cstat-no" title="statement not covered" >this._statistics=new HeapSnapshotModel.Statistics();<span class="cstat-no" title="statement not covered" >t</span>his._statistics.total=this.totalSize;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.v8heap=this.totalSize-sizeNative;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.native=sizeNative;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.code=sizeCode;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.jsArrays=sizeJSArrays;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.strings=sizeStrings;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.system=sizeSystem;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateArraySize(node){let size=<span class="cstat-no" title="statement not covered" >node.selfSize();</span>const beginEdgeIndex=<span class="cstat-no" title="statement not covered" >node.edgeIndexesStart();</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >node.edgeIndexesEnd();</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const strings=<span class="cstat-no" title="statement not covered" >this.strings;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeNameOffset=<span class="cstat-no" title="statement not covered" >this._edgeNameOffset;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeInternalType=<span class="cstat-no" title="statement not covered" >this._edgeInternalType;<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType!==edgeInternalType)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst edgeName=<span class="cstat-no" title="statement not covered" >strings[containmentEdges[edgeIndex+edgeNameOffset]];<span class="cstat-no" title="statement not covered" ></span>if(edgeName!=='elements')</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst elementsNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=elementsNodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(node.retainersCount()===1)</span>
<span class="cstat-no" title="statement not covered" >size+=node.selfSize();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >return size;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tStatistics(){<span class="cstat-no" title="statement not covered" >return this._statistics;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshotNode=class extends HeapSnapshotWorker.HeapSnapshotNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,nodeIndex){<span class="cstat-no" title="statement not covered" >super(snapshot,nodeIndex);}</span></span>
<span class="fstat-no" title="function not covered" >ca</span>nBeQueried(){const flags=<span class="cstat-no" title="statement not covered" >this._snapshot._flagsOfNode(this);<span class="cstat-no" title="statement not covered" ></span>return!!(flags&amp;this._snapshot._nodeFlags.canBeQueried);}</span>
<span class="fstat-no" title="function not covered" >ra</span>wName(){<span class="cstat-no" title="statement not covered" >return super.name();}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>if(this.rawType()===snapshot._nodeConsStringType){let string=<span class="cstat-no" title="statement not covered" >snapshot._lazyStringCache[this.nodeIndex];<span class="cstat-no" title="statement not covered" ></span>if(typeof string==='undefined'){<span class="cstat-no" title="statement not covered" >string=this._consStringName();<span class="cstat-no" title="statement not covered" >s</span>napshot._lazyStringCache[this.nodeIndex]=string;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return string;}</span>
<span class="cstat-no" title="statement not covered" >return this.rawName();}</span>
<span class="fstat-no" title="function not covered" >_c</span>onsStringName(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>const consStringType=<span class="cstat-no" title="statement not covered" >snapshot._nodeConsStringType;</span>const edgeInternalType=<span class="cstat-no" title="statement not covered" >snapshot._edgeInternalType;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >snapshot._edgeFieldsCount;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >snapshot._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >snapshot._edgeTypeOffset;</span>const edgeNameOffset=<span class="cstat-no" title="statement not covered" >snapshot._edgeNameOffset;</span>const strings=<span class="cstat-no" title="statement not covered" >snapshot.strings;</span>const edges=<span class="cstat-no" title="statement not covered" >snapshot.containmentEdges;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >snapshot._firstEdgeIndexes;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >snapshot._nodeFieldCount;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >snapshot._nodeTypeOffset;</span>const nodeNameOffset=<span class="cstat-no" title="statement not covered" >snapshot._nodeNameOffset;</span>const nodes=<span class="cstat-no" title="statement not covered" >snapshot.nodes;</span>const nodesStack=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>nodesStack.push(this.nodeIndex);l</span>et name=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>while(nodesStack.length&amp;&amp;name.length&lt;1024){const nodeIndex=<span class="cstat-no" title="statement not covered" >nodesStack.pop();<span class="cstat-no" title="statement not covered" ></span>if(nodes[nodeIndex+nodeTypeOffset]!==consStringType){<span class="cstat-no" title="statement not covered" >name+=strings[nodes[nodeIndex+nodeNameOffset]];<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const beginEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];</span>let firstNodeIndex=<span class="cstat-no" title="statement not covered" >0;</span>let secondNodeIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex&amp;&amp;(!firstNodeIndex||!secondNodeIndex);edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >edges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType===edgeInternalType){const edgeName=<span class="cstat-no" title="statement not covered" >strings[edges[edgeIndex+edgeNameOffset]];<span class="cstat-no" title="statement not covered" ></span>if(edgeName==='first')</span></span></span>
<span class="cstat-no" title="statement not covered" >firstNodeIndex=edges[edgeIndex+edgeToNodeOffset];e</span>lse <span class="cstat-no" title="statement not covered" >if(edgeName==='second')</span>
<span class="cstat-no" title="statement not covered" >secondNodeIndex=edges[edgeIndex+edgeToNodeOffset];}</span>}
<span class="cstat-no" title="statement not covered" >nodesStack.push(secondNodeIndex);<span class="cstat-no" title="statement not covered" >n</span>odesStack.push(firstNodeIndex);}</span>
<span class="cstat-no" title="statement not covered" >return name;}</span>
<span class="fstat-no" title="function not covered" >cl</span>assName(){const type=<span class="cstat-no" title="statement not covered" >this.type();<span class="cstat-no" title="statement not covered" ></span>switch(type){case'hidden':<span class="cstat-no" title="statement not covered" >return'(system)';c</span>ase'object':case'native':<span class="cstat-no" title="statement not covered" >return this.name();c</span>ase'code':<span class="cstat-no" title="statement not covered" >return'(compiled code)';d</span>efault:<span class="cstat-no" title="statement not covered" >return'('+type+')';}</span>}</span>
<span class="fstat-no" title="function not covered" >cl</span>assIndex(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>const nodes=<span class="cstat-no" title="statement not covered" >snapshot.nodes;</span>const type=<span class="cstat-no" title="statement not covered" >nodes[this.nodeIndex+snapshot._nodeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(type===snapshot._nodeObjectType||type===snapshot._nodeNativeType)</span>
<span class="cstat-no" title="statement not covered" >return nodes[this.nodeIndex+snapshot._nodeNameOffset];<span class="cstat-no" title="statement not covered" >r</span>eturn-1-type;}</span>
<span class="fstat-no" title="function not covered" >id</span>(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeIdOffset];}</span>
<span class="fstat-no" title="function not covered" >is</span>Hidden(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._nodeHiddenType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Array(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._nodeArrayType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Synthetic(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._nodeSyntheticType;}</span>
<span class="fstat-no" title="function not covered" >is</span>UserRoot(){<span class="cstat-no" title="statement not covered" >return!this.isSynthetic();}</span>
<span class="fstat-no" title="function not covered" >is</span>DocumentDOMTreesRoot(){<span class="cstat-no" title="statement not covered" >return this.isSynthetic()&amp;&amp;this.name()==='(Document DOM trees)';}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){const result=<span class="cstat-no" title="statement not covered" >super.serialize();</span>const flags=<span class="cstat-no" title="statement not covered" >this._snapshot._flagsOfNode(this);<span class="cstat-no" title="statement not covered" ></span>if(flags&amp;this._snapshot._nodeFlags.canBeQueried)</span>
<span class="cstat-no" title="statement not covered" >result.canBeQueried=true;<span class="cstat-no" title="statement not covered" >i</span>f(flags&amp;this._snapshot._nodeFlags.detachedDOMTreeNode)</span>
<span class="cstat-no" title="statement not covered" >result.detachedDOMTreeNode=true;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshotEdge=class extends HeapSnapshotWorker.HeapSnapshotEdge{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,edgeIndex){<span class="cstat-no" title="statement not covered" >super(snapshot,edgeIndex);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){const snapshot=(<span class="cstat-no" title="statement not covered" >this._snapshot)</span>;<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotEdge(snapshot,this.edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sStringName(){<span class="cstat-no" title="statement not covered" >if(!this.isShortcut())</span>
<span class="cstat-no" title="statement not covered" >return this._hasStringName();<span class="cstat-no" title="statement not covered" >r</span>eturn isNaN(parseInt(this._name(),10));}</span>
<span class="fstat-no" title="function not covered" >is</span>Element(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeElementType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Hidden(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeHiddenType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Weak(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeWeakType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Internal(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeInternalType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Invisible(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeInvisibleType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Shortcut(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeShortcutType;}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){const name=<span class="cstat-no" title="statement not covered" >this._name();<span class="cstat-no" title="statement not covered" ></span>if(!this.isShortcut())</span>
<span class="cstat-no" title="statement not covered" >return String(name);c</span>onst numName=<span class="cstat-no" title="statement not covered" >parseInt(name,10);<span class="cstat-no" title="statement not covered" ></span>return String(isNaN(numName)?name:numName);}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){const name=<span class="cstat-no" title="statement not covered" >this.name();<span class="cstat-no" title="statement not covered" ></span>switch(this.type()){case'context':<span class="cstat-no" title="statement not covered" >return'-&gt;'+name;c</span>ase'element':<span class="cstat-no" title="statement not covered" >return'['+name+']';c</span>ase'weak':<span class="cstat-no" title="statement not covered" >return'[['+name+']]';c</span>ase'property':<span class="cstat-no" title="statement not covered" >return name.indexOf(' ')===-1?'.'+name:'["'+name+'"]';c</span>ase'shortcut':<span class="cstat-no" title="statement not covered" >if(typeof name==='string')</span></span>
<span class="cstat-no" title="statement not covered" >return name.indexOf(' ')===-1?'.'+name:'["'+name+'"]';e</span>lse
<span class="cstat-no" title="statement not covered" >return'['+name+']';c</span>ase'internal':case'hidden':case'invisible':<span class="cstat-no" title="statement not covered" >return'{'+name+'}';}</span>
<span class="cstat-no" title="statement not covered" >return'?'+name+'?';}</span>
<span class="fstat-no" title="function not covered" >_h</span>asStringName(){const type=<span class="cstat-no" title="statement not covered" >this.rawType();</span>const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return type!==snapshot._edgeElementType&amp;&amp;type!==snapshot._edgeHiddenType;}</span>
<span class="fstat-no" title="function not covered" >_n</span>ame(){<span class="cstat-no" title="statement not covered" >return this._hasStringName()?this._snapshot.strings[this._nameOrIndex()]:this._nameOrIndex();}</span>
<span class="fstat-no" title="function not covered" >_n</span>ameOrIndex(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeNameOffset];}</span>
<span class="fstat-no" title="function not covered" >ra</span>wType(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset];}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshotRetainerEdge=class extends HeapSnapshotWorker.HeapSnapshotRetainerEdge{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,retainerIndex){<span class="cstat-no" title="statement not covered" >super(snapshot,retainerIndex);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){const snapshot=(<span class="cstat-no" title="statement not covered" >this._snapshot)</span>;<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotRetainerEdge(snapshot,this.retainerIndex());}</span>
<span class="fstat-no" title="function not covered" >is</span>Hidden(){<span class="cstat-no" title="statement not covered" >return this._edge().isHidden();}</span>
<span class="fstat-no" title="function not covered" >is</span>Internal(){<span class="cstat-no" title="statement not covered" >return this._edge().isInternal();}</span>
<span class="fstat-no" title="function not covered" >is</span>Invisible(){<span class="cstat-no" title="statement not covered" >return this._edge().isInvisible();}</span>
<span class="fstat-no" title="function not covered" >is</span>Shortcut(){<span class="cstat-no" title="statement not covered" >return this._edge().isShortcut();}</span>
<span class="fstat-no" title="function not covered" >is</span>Weak(){<span class="cstat-no" title="statement not covered" >return this._edge().isWeak();}</span>};<span class="cstat-no" title="statement not covered" >(function <span class="fstat-no" title="function not covered" >disableLoggingForTest(</span>){<span class="cstat-no" title="statement not covered" >if(self.Runtime&amp;&amp;Runtime.queryParam('test'))</span></span>
<span class="cstat-no" title="statement not covered" >console.warn=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >undefined;</span>}</span>)();;<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotLoader=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(dispatcher){<span class="cstat-no" title="statement not covered" >this._reset();<span class="cstat-no" title="statement not covered" >t</span>his._progress=new HeapSnapshotWorker.HeapSnapshotProgress(dispatcher);<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';<span class="cstat-no" title="statement not covered" >t</span>his._dataCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his._done=false;<span class="cstat-no" title="statement not covered" >t</span>his._parseInput();}</span></span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._reset();}</span>
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >this._json='';<span class="cstat-no" title="statement not covered" >t</span>his._snapshot={};}</span>
<span class="fstat-no" title="function not covered" >cl</span>ose(){<span class="cstat-no" title="statement not covered" >this._done=true;<span class="cstat-no" title="statement not covered" >i</span>f(this._dataCallback)</span>
<span class="cstat-no" title="statement not covered" >this._dataCallback('');}</span>
<span class="fstat-no" title="function not covered" >bu</span>ildSnapshot(){<span class="cstat-no" title="statement not covered" >this._progress.updateStatus(ls`Processing snapshot\u2026`);c</span>onst result=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.JSHeapSnapshot(this._snapshot,this._progress);<span class="cstat-no" title="statement not covered" ></span>this._reset();<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >_p</span>arseUintArray(){let index=<span class="cstat-no" title="statement not covered" >0;</span>const char0=<span class="cstat-no" title="statement not covered" >'0'.charCodeAt(0);</span>const char9=<span class="cstat-no" title="statement not covered" >'9'.charCodeAt(0);</span>const closingBracket=<span class="cstat-no" title="statement not covered" >']'.charCodeAt(0);</span>const length=<span class="cstat-no" title="statement not covered" >this._json.length;<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >while(index&lt;length){const code=<span class="cstat-no" title="statement not covered" >this._json.charCodeAt(index);<span class="cstat-no" title="statement not covered" ></span>if(char0&lt;=code&amp;&amp;code&lt;=char9){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(code===closingBracket){<span class="cstat-no" title="statement not covered" >this._json=this._json.slice(index+1);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >++index;}</span>
<span class="cstat-no" title="statement not covered" >if(index===length){<span class="cstat-no" title="statement not covered" >this._json='';<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
let nextNumber=<span class="cstat-no" title="statement not covered" >0;</span>const startIndex=<span class="cstat-no" title="statement not covered" >index;<span class="cstat-no" title="statement not covered" ></span>while(index&lt;length){const code=<span class="cstat-no" title="statement not covered" >this._json.charCodeAt(index);<span class="cstat-no" title="statement not covered" ></span>if(char0&gt;code||code&gt;char9)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span>extNumber*=10;<span class="cstat-no" title="statement not covered" >n</span>extNumber+=(code-char0);<span class="cstat-no" title="statement not covered" >+</span>+index;}</span>
<span class="cstat-no" title="statement not covered" >if(index===length){<span class="cstat-no" title="statement not covered" >this._json=this._json.slice(startIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >this._array[this._arrayIndex++]=nextNumber;}</span>}
<span class="fstat-no" title="function not covered" >_p</span>arseStringsArray(){<span class="cstat-no" title="statement not covered" >this._progress.updateStatus('Parsing strings\u2026');c</span>onst closingBracketIndex=<span class="cstat-no" title="statement not covered" >this._json.lastIndexOf(']');<span class="cstat-no" title="statement not covered" ></span>if(closingBracketIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Incomplete JSON');<span class="cstat-no" title="statement not covered" >t</span>his._json=this._json.slice(0,closingBracketIndex+1);<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.strings=JSON.parse(this._json);}</span>
<span class="fstat-no" title="function not covered" >wr</span>ite(chunk){<span class="cstat-no" title="statement not covered" >this._buffer+=chunk;<span class="cstat-no" title="statement not covered" >i</span>f(!this._dataCallback)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._dataCallback(this._buffer);<span class="cstat-no" title="statement not covered" >t</span>his._dataCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';}</span>
<span class="fstat-no" title="function not covered" >_f</span>etchChunk(){<span class="cstat-no" title="statement not covered" >return this._done?Promise.resolve(this._buffer):new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this._dataCallback=r)</span>;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _findToken(token,startIndex){<span class="cstat-no" title="statement not covered" >while(true){const pos=<span class="cstat-no" title="statement not covered" >this._json.indexOf(token,startIndex||0);<span class="cstat-no" title="statement not covered" ></span>if(pos!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >return pos;<span class="cstat-no" title="statement not covered" >s</span>tartIndex=this._json.length-token.length+1;<span class="cstat-no" title="statement not covered" >t</span>his._json+=await this._fetchChunk();}</span>}
<span class="fstat-no" title="function not covered" >as</span>ync _parseArray(name,title,length){const nameIndex=<span class="cstat-no" title="statement not covered" >await this._findToken(name);</span>const bracketIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('[',nameIndex);<span class="cstat-no" title="statement not covered" ></span>this._json=this._json.slice(bracketIndex+1);<span class="cstat-no" title="statement not covered" >t</span>his._array=length?new Uint32Array(length):[];<span class="cstat-no" title="statement not covered" >t</span>his._arrayIndex=0;<span class="cstat-no" title="statement not covered" >w</span>hile(this._parseUintArray()){<span class="cstat-no" title="statement not covered" >this._progress.updateProgress(title,this._arrayIndex,this._array.length);<span class="cstat-no" title="statement not covered" >t</span>his._json+=await this._fetchChunk();}</span></span>
const result=<span class="cstat-no" title="statement not covered" >this._array;<span class="cstat-no" title="statement not covered" ></span>this._array=null;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _parseInput(){const snapshotToken=<span class="cstat-no" title="statement not covered" >'"snapshot"';</span>const snapshotTokenIndex=<span class="cstat-no" title="statement not covered" >await this._findToken(snapshotToken);<span class="cstat-no" title="statement not covered" ></span>if(snapshotTokenIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Snapshot token not found');<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus(ls`Loading snapshot info\u2026`);c</span>onst json=<span class="cstat-no" title="statement not covered" >this._json.slice(snapshotTokenIndex+snapshotToken.length+1);<span class="cstat-no" title="statement not covered" ></span>this._jsonTokenizer=new TextUtils.TextUtils.BalancedJSONTokenizer(<span class="fstat-no" title="function not covered" >me</span>taJSON=&gt;{<span class="cstat-no" title="statement not covered" >this._json=this._jsonTokenizer.remainder();<span class="cstat-no" title="statement not covered" >t</span>his._jsonTokenizer=null;<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.snapshot=(JSON.parse(metaJSON));}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._jsonTokenizer.write(json);<span class="cstat-no" title="statement not covered" >w</span>hile(this._jsonTokenizer)</span>
<span class="cstat-no" title="statement not covered" >this._jsonTokenizer.write(await this._fetchChunk());<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.nodes=await this._parseArray('"nodes"',ls`Loading nodes\u2026 %d%%`,this._snapshot.snapshot.meta.node_fields.length*this._snapshot.snapshot.node_count);<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.edges=await this._parseArray('"edges"',ls`Loading edges\u2026 %d%%`,this._snapshot.snapshot.meta.edge_fields.length*this._snapshot.snapshot.edge_count);<span class="cstat-no" title="statement not covered" >i</span>f(this._snapshot.snapshot.trace_function_count){<span class="cstat-no" title="statement not covered" >this._snapshot.trace_function_infos=await this._parseArray('"trace_function_infos"',ls`Loading allocation traces\u2026 %d%%`,this._snapshot.snapshot.meta.trace_function_info_fields.length*this._snapshot.snapshot.trace_function_count);c</span>onst thisTokenEndIndex=<span class="cstat-no" title="statement not covered" >await this._findToken(':');</span>const nextTokenIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('"',thisTokenEndIndex);</span>const openBracketIndex=<span class="cstat-no" title="statement not covered" >this._json.indexOf('[');</span>const closeBracketIndex=<span class="cstat-no" title="statement not covered" >this._json.lastIndexOf(']',nextTokenIndex);<span class="cstat-no" title="statement not covered" ></span>this._snapshot.trace_tree=JSON.parse(this._json.substring(openBracketIndex,closeBracketIndex+1));<span class="cstat-no" title="statement not covered" >t</span>his._json=this._json.slice(closeBracketIndex+1);}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._snapshot.snapshot.meta.sample_fields)</span>
<span class="cstat-no" title="statement not covered" >this._snapshot.samples=await this._parseArray('"samples"',ls`Loading samples\u2026`);<span class="cstat-no" title="statement not covered" >i</span>f(this._snapshot.snapshot.meta['location_fields'])</span>
<span class="cstat-no" title="statement not covered" >this._snapshot.locations=await this._parseArray('"locations"',ls`Loading locations\u2026`);e</span>lse
<span class="cstat-no" title="statement not covered" >this._snapshot.locations=[];<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus(ls`Loading strings\u2026`);c</span>onst stringsTokenIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('"strings"');</span>const bracketIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('[',stringsTokenIndex);<span class="cstat-no" title="statement not covered" ></span>this._json=this._json.slice(bracketIndex);<span class="cstat-no" title="statement not covered" >w</span>hile(!this._done)</span>
<span class="cstat-no" title="statement not covered" >this._json+=await this._fetchChunk();<span class="cstat-no" title="statement not covered" >t</span>his._parseStringsArray();}</span>};;<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotWorkerDispatcher=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(globalObject,postMessage){<span class="cstat-no" title="statement not covered" >this._objects=[];<span class="cstat-no" title="statement not covered" >t</span>his._global=globalObject;<span class="cstat-no" title="statement not covered" >t</span>his._postMessage=postMessage;}</span></span>
<span class="fstat-no" title="function not covered" >_f</span>indFunction(name){const path=<span class="cstat-no" title="statement not covered" >name.split('.');</span>let result=<span class="cstat-no" title="statement not covered" >this._global;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;path.length;++i)</span>
<span class="cstat-no" title="statement not covered" >result=result[path[i]];<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >se</span>ndEvent(name,data){<span class="cstat-no" title="statement not covered" >this._postMessage({eventName:name,data:data});}</span>
<span class="fstat-no" title="function not covered" >di</span>spatchMessage(event){const data=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const response=<span class="cstat-no" title="statement not covered" >{callId:data.callId};<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >switch(data.disposition){case'create':const constructorFunction=<span class="cstat-no" title="statement not covered" >this._findFunction(data.methodName);<span class="cstat-no" title="statement not covered" ></span>this._objects[data.objectId]=new constructorFunction(this);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'dispose':<span class="cstat-no" title="statement not covered" >delete this._objects[data.objectId];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'getter':{const object=<span class="cstat-no" title="statement not covered" >this._objects[data.objectId];</span>const result=<span class="cstat-no" title="statement not covered" >object[data.methodName];<span class="cstat-no" title="statement not covered" ></span>response.result=result;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span>
case'factory':{const object=<span class="cstat-no" title="statement not covered" >this._objects[data.objectId];</span>const result=<span class="cstat-no" title="statement not covered" >object[data.methodName].apply(object,data.methodArguments);<span class="cstat-no" title="statement not covered" ></span>if(result)</span>
<span class="cstat-no" title="statement not covered" >this._objects[data.newObjectId]=result;<span class="cstat-no" title="statement not covered" >r</span>esponse.result=!!result;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case'method':{const object=<span class="cstat-no" title="statement not covered" >this._objects[data.objectId];<span class="cstat-no" title="statement not covered" ></span>response.result=object[data.methodName].apply(object,data.methodArguments);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case'evaluateForTest':<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >response.result=self.eval(data.source);}</span>catch(e){<span class="cstat-no" title="statement not covered" >response.result=e.toString();}</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>}catch(e){<span class="cstat-no" title="statement not covered" >response.error=e.toString();<span class="cstat-no" title="statement not covered" >r</span>esponse.errorCallStack=e.stack;<span class="cstat-no" title="statement not covered" >i</span>f(data.methodName)</span>
<span class="cstat-no" title="statement not covered" >response.errorMethodName=data.methodName;}</span>
<span class="cstat-no" title="statement not covered" >this._postMessage(response);}</span>};;function <span class="fstat-no" title="function not covered" >postMessageWrapper(</span>message){<span class="cstat-no" title="statement not covered" >postMessage(message);}</span>
const dispatcher=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotWorkerDispatcher(this,postMessageWrapper);</span>function <span class="fstat-no" title="function not covered" >installMessageEventListener(</span>listener){<span class="cstat-no" title="statement not covered" >self.addEventListener('message',listener,false);}</span>
<span class="cstat-no" title="statement not covered" >installMessageEventListener(dispatcher.dispatchMessage.bind(dispatcher));;</span>;;<span class="cstat-no" title="statement not covered" >if(!self.Runtime)</span>
<span class="cstat-no" title="statement not covered" >self.importScripts('Runtime.js');<span class="cstat-no" title="statement not covered" >R</span>untime.startWorker('heap_snapshot_worker');</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:04:04 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../sorter.js"></script>
<script src="../../../../block-navigation.js"></script>
</body>
</html>
