<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/linux-unpacked/resources/inspector/timeline_model/timeline_model_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/linux-unpacked/resources/inspector/timeline_model</a> timeline_model_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/1824</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/1149</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/262</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/557</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModelFilter=class{<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return true;}</span>};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineVisibleEventsFilter=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(visibleTypes){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._visibleTypes=new Set(visibleTypes);}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return this._visibleTypes.has(TimelineModel.TimelineVisibleEventsFilter._eventType(event));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _eventType(event){<span class="cstat-no" title="statement not covered" >if(event.hasCategory(TimelineModel.TimelineModel.Category.Console))</span>
<span class="cstat-no" title="statement not covered" >return TimelineModel.TimelineModel.RecordType.ConsoleTime;<span class="cstat-no" title="statement not covered" >i</span>f(event.hasCategory(TimelineModel.TimelineModel.Category.UserTiming))</span>
<span class="cstat-no" title="statement not covered" >return TimelineModel.TimelineModel.RecordType.UserTiming;<span class="cstat-no" title="statement not covered" >i</span>f(event.hasCategory(TimelineModel.TimelineModel.Category.LatencyInfo))</span>
<span class="cstat-no" title="statement not covered" >return TimelineModel.TimelineModel.RecordType.LatencyInfo;<span class="cstat-no" title="statement not covered" >r</span>eturn(event.name);}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineInvisibleEventsFilter=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(invisibleTypes){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._invisibleTypes=new Set(invisibleTypes);}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return!this._invisibleTypes.has(TimelineModel.TimelineVisibleEventsFilter._eventType(event));}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.ExclusiveNameFilter=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(excludeNames){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._excludeNames=new Set(excludeNames);}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return!this._excludeNames.has(event.name);}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.ExcludeTopLevelFilter=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return!SDK.TracingModel.isTopLevelEvent(event);}</span>};;<span class="cstat-no" title="statement not covered" >TimelineModel.TracingLayerPayload;<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TracingLayerTile;<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TracingLayerTree=class extends SDK.LayerTreeBase{<span class="fstat-no" title="function not covered" >co</span>nstructor(target){<span class="cstat-no" title="statement not covered" >super(target);<span class="cstat-no" title="statement not covered" >t</span>his._tileById=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerModel=target&amp;&amp;target.model(SDK.PaintProfilerModel);}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync setLayers(root,layers,paints){const idsToResolve=<span class="cstat-no" title="statement not covered" >new Set();<span class="cstat-no" title="statement not covered" ></span>if(root){<span class="cstat-no" title="statement not covered" >this._extractNodeIdsToResolve(idsToResolve,{},root);}</span>else{<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;layers.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this._extractNodeIdsToResolve(idsToResolve,{},layers[i]);}</span>
<span class="cstat-no" title="statement not covered" >await this.resolveBackendNodeIds(idsToResolve);c</span>onst oldLayersById=<span class="cstat-no" title="statement not covered" >this._layersById;<span class="cstat-no" title="statement not covered" ></span>this._layersById={};<span class="cstat-no" title="statement not covered" >t</span>his.setContentRoot(null);<span class="cstat-no" title="statement not covered" >i</span>f(root){const convertedLayers=<span class="cstat-no" title="statement not covered" >this._innerSetLayers(oldLayersById,root);<span class="cstat-no" title="statement not covered" ></span>this.setRoot(convertedLayers);}</span>else{const processedLayers=<span class="cstat-no" title="statement not covered" >layers.map(this._innerSetLayers.bind(this,oldLayersById));</span>const contentRoot=<span class="cstat-no" title="statement not covered" >this.contentRoot();<span class="cstat-no" title="statement not covered" ></span>this.setRoot(contentRoot);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;processedLayers.length;++i){<span class="cstat-no" title="statement not covered" >if(processedLayers[i].id()!==contentRoot.id())</span></span></span>
<span class="cstat-no" title="statement not covered" >contentRoot.addChild(processedLayers[i]);}</span>}
<span class="cstat-no" title="statement not covered" >this._setPaints(paints);}</span>
<span class="fstat-no" title="function not covered" >se</span>tTiles(tiles){<span class="cstat-no" title="statement not covered" >this._tileById=new Map();<span class="cstat-no" title="statement not covered" >f</span>or(const tile of tiles)</span>
<span class="cstat-no" title="statement not covered" >this._tileById.set(tile.id,tile);}</span>
<span class="fstat-no" title="function not covered" >pi</span>ctureForRasterTile(tileId){const tile=<span class="cstat-no" title="statement not covered" >this._tileById.get('cc::Tile/'+tileId);<span class="cstat-no" title="statement not covered" ></span>if(!tile){<span class="cstat-no" title="statement not covered" >Common.console.error(`Tile ${tileId} is missing`);<span class="cstat-no" title="statement not covered" >r</span>eturn(Promise.resolve(null));}</span></span>
const layer=<span class="cstat-no" title="statement not covered" >this.layerById(tile.layer_id);<span class="cstat-no" title="statement not covered" ></span>if(!layer){<span class="cstat-no" title="statement not covered" >Common.console.error(`Layer ${tile.layer_id} for tile ${tileId} is not found`);<span class="cstat-no" title="statement not covered" >r</span>eturn(Promise.resolve(null));}</span></span>
<span class="cstat-no" title="statement not covered" >return layer._pictureForRect(tile.content_rect);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etPaints(paints){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;paints.length;++i){const layer=<span class="cstat-no" title="statement not covered" >this._layersById[paints[i].layerId()];<span class="cstat-no" title="statement not covered" ></span>if(layer)</span></span>
<span class="cstat-no" title="statement not covered" >layer._addPaintEvent(paints[i]);}</span>}
<span class="fstat-no" title="function not covered" >_i</span>nnerSetLayers(oldLayersById,payload){let layer=(<span class="cstat-no" title="statement not covered" >oldLayersById[payload.layer_id])</span>;<span class="cstat-no" title="statement not covered" >if(layer)</span>
<span class="cstat-no" title="statement not covered" >layer._reset(payload);e</span>lse
<span class="cstat-no" title="statement not covered" >layer=new TimelineModel.TracingLayer(this._paintProfilerModel,payload);<span class="cstat-no" title="statement not covered" >t</span>his._layersById[payload.layer_id]=layer;<span class="cstat-no" title="statement not covered" >i</span>f(payload.owner_node)</span>
<span class="cstat-no" title="statement not covered" >layer._setNode(this.backendNodeIdToNode().get(payload.owner_node)||null);<span class="cstat-no" title="statement not covered" >i</span>f(!this.contentRoot()&amp;&amp;layer.drawsContent())</span>
<span class="cstat-no" title="statement not covered" >this.setContentRoot(layer);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;payload.children&amp;&amp;i&lt;payload.children.length;++i)</span>
<span class="cstat-no" title="statement not covered" >layer.addChild(this._innerSetLayers(oldLayersById,payload.children[i]));<span class="cstat-no" title="statement not covered" >r</span>eturn layer;}</span>
<span class="fstat-no" title="function not covered" >_e</span>xtractNodeIdsToResolve(nodeIdsToResolve,seenNodeIds,payload){const backendNodeId=<span class="cstat-no" title="statement not covered" >payload.owner_node;<span class="cstat-no" title="statement not covered" ></span>if(backendNodeId&amp;&amp;!this.backendNodeIdToNode().has(backendNodeId))</span>
<span class="cstat-no" title="statement not covered" >nodeIdsToResolve.add(backendNodeId);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;payload.children&amp;&amp;i&lt;payload.children.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._extractNodeIdsToResolve(nodeIdsToResolve,seenNodeIds,payload.children[i]);}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TracingLayer=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(paintProfilerModel,payload){<span class="cstat-no" title="statement not covered" >this._paintProfilerModel=paintProfilerModel;<span class="cstat-no" title="statement not covered" >t</span>his._reset(payload);}</span></span>
<span class="fstat-no" title="function not covered" >_r</span>eset(payload){<span class="cstat-no" title="statement not covered" >this._node=null;<span class="cstat-no" title="statement not covered" >t</span>his._layerId=String(payload.layer_id);<span class="cstat-no" title="statement not covered" >t</span>his._offsetX=payload.position[0];<span class="cstat-no" title="statement not covered" >t</span>his._offsetY=payload.position[1];<span class="cstat-no" title="statement not covered" >t</span>his._width=payload.bounds.width;<span class="cstat-no" title="statement not covered" >t</span>his._height=payload.bounds.height;<span class="cstat-no" title="statement not covered" >t</span>his._children=[];<span class="cstat-no" title="statement not covered" >t</span>his._parentLayerId=null;<span class="cstat-no" title="statement not covered" >t</span>his._parent=null;<span class="cstat-no" title="statement not covered" >t</span>his._quad=payload.layer_quad||[];<span class="cstat-no" title="statement not covered" >t</span>his._createScrollRects(payload);<span class="cstat-no" title="statement not covered" >t</span>his._compositingReasons=payload.compositing_reasons||[];<span class="cstat-no" title="statement not covered" >t</span>his._drawsContent=!!payload.draws_content;<span class="cstat-no" title="statement not covered" >t</span>his._gpuMemoryUsage=payload.gpu_memory_usage;<span class="cstat-no" title="statement not covered" >t</span>his._paints=[];}</span>
<span class="fstat-no" title="function not covered" >id</span>(){<span class="cstat-no" title="statement not covered" >return this._layerId;}</span>
<span class="fstat-no" title="function not covered" >pa</span>rentId(){<span class="cstat-no" title="statement not covered" >return this._parentLayerId;}</span>
<span class="fstat-no" title="function not covered" >pa</span>rent(){<span class="cstat-no" title="statement not covered" >return this._parent;}</span>
<span class="fstat-no" title="function not covered" >is</span>Root(){<span class="cstat-no" title="statement not covered" >return!this.parentId();}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >return this._children;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dChild(child){<span class="cstat-no" title="statement not covered" >if(child._parent)</span>
<span class="cstat-no" title="statement not covered" >console.assert(false,'Child already has a parent');<span class="cstat-no" title="statement not covered" >t</span>his._children.push(child);<span class="cstat-no" title="statement not covered" >c</span>hild._parent=this;<span class="cstat-no" title="statement not covered" >c</span>hild._parentLayerId=this._layerId;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etNode(node){<span class="cstat-no" title="statement not covered" >this._node=node;}</span>
<span class="fstat-no" title="function not covered" >no</span>de(){<span class="cstat-no" title="statement not covered" >return this._node;}</span>
<span class="fstat-no" title="function not covered" >no</span>deForSelfOrAncestor(){<span class="cstat-no" title="statement not covered" >for(let layer=this;layer;layer=layer._parent){<span class="cstat-no" title="statement not covered" >if(layer._node)</span></span>
<span class="cstat-no" title="statement not covered" >return layer._node;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >of</span>fsetX(){<span class="cstat-no" title="statement not covered" >return this._offsetX;}</span>
<span class="fstat-no" title="function not covered" >of</span>fsetY(){<span class="cstat-no" title="statement not covered" >return this._offsetY;}</span>
<span class="fstat-no" title="function not covered" >wi</span>dth(){<span class="cstat-no" title="statement not covered" >return this._width;}</span>
<span class="fstat-no" title="function not covered" >he</span>ight(){<span class="cstat-no" title="statement not covered" >return this._height;}</span>
<span class="fstat-no" title="function not covered" >tr</span>ansform(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >qu</span>ad(){<span class="cstat-no" title="statement not covered" >return this._quad;}</span>
<span class="fstat-no" title="function not covered" >an</span>chorPoint(){<span class="cstat-no" title="statement not covered" >return[0.5,0.5,0];}</span>
<span class="fstat-no" title="function not covered" >in</span>visible(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >pa</span>intCount(){<span class="cstat-no" title="statement not covered" >return 0;}</span>
<span class="fstat-no" title="function not covered" >la</span>stPaintRect(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >sc</span>rollRects(){<span class="cstat-no" title="statement not covered" >return this._scrollRects;}</span>
<span class="fstat-no" title="function not covered" >st</span>ickyPositionConstraint(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >gp</span>uMemoryUsage(){<span class="cstat-no" title="statement not covered" >return this._gpuMemoryUsage;}</span>
<span class="fstat-no" title="function not covered" >sn</span>apshots(){<span class="cstat-no" title="statement not covered" >return this._paints.map(<span class="fstat-no" title="function not covered" >pa</span>int=&gt;<span class="cstat-no" title="statement not covered" >paint.snapshotPromise().then(<span class="fstat-no" title="function not covered" >sn</span>apshot=&gt;{<span class="cstat-no" title="statement not covered" >if(!snapshot)</span></span></span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst rect=<span class="cstat-no" title="statement not covered" >{x:snapshot.rect[0],y:snapshot.rect[1],width:snapshot.rect[2],height:snapshot.rect[3]};<span class="cstat-no" title="statement not covered" ></span>return{rect:rect,snapshot:snapshot.snapshot};}</span>));}
<span class="fstat-no" title="function not covered" >_p</span>ictureForRect(targetRect){<span class="cstat-no" title="statement not covered" >return Promise.all(this._paints.map(<span class="fstat-no" title="function not covered" >pa</span>int=&gt;<span class="cstat-no" title="statement not covered" >paint.picturePromise())</span>).then(<span class="fstat-no" title="function not covered" >pi</span>ctures=&gt;{const fragments=<span class="cstat-no" title="statement not covered" >pictures.filter(<span class="fstat-no" title="function not covered" >pi</span>cture=&gt;<span class="cstat-no" title="statement not covered" >picture&amp;&amp;rectsOverlap(picture.rect,targetRect))</span>.map(<span class="fstat-no" title="function not covered" >pi</span>cture=&gt;(<span class="cstat-no" title="statement not covered" >{x:picture.rect[0],y:picture.rect[1],picture:picture.serializedPicture})</span>);<span class="cstat-no" title="statement not covered" ></span>if(!fragments.length||!this._paintProfilerModel)</span></span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst x0=<span class="cstat-no" title="statement not covered" >fragments.reduce(<span class="fstat-no" title="function not covered" >(m</span>in,item)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(min,item.x),</span>Infinity);</span>const y0=<span class="cstat-no" title="statement not covered" >fragments.reduce(<span class="fstat-no" title="function not covered" >(m</span>in,item)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(min,item.y),</span>Infinity);</span>const rect=<span class="cstat-no" title="statement not covered" >{x:targetRect[0]-x0,y:targetRect[1]-y0,width:targetRect[2],height:targetRect[3]};<span class="cstat-no" title="statement not covered" ></span>return this._paintProfilerModel.loadSnapshotFromFragments(fragments).then(<span class="fstat-no" title="function not covered" >sn</span>apshot=&gt;<span class="cstat-no" title="statement not covered" >snapshot?{rect:rect,snapshot:snapshot}:null)</span>;}</span>);function <span class="fstat-no" title="function not covered" >segmentsOverlap(</span>a1,a2,b1,b2){<span class="cstat-no" title="statement not covered" >console.assert(a1&lt;=a2&amp;&amp;b1&lt;=b2,'segments should be specified as ordered pairs');<span class="cstat-no" title="statement not covered" >r</span>eturn a2&gt;b1&amp;&amp;a1&lt;b2;}</span>
function <span class="fstat-no" title="function not covered" >rectsOverlap(</span>a,b){<span class="cstat-no" title="statement not covered" >return segmentsOverlap(a[0],a[0]+a[2],b[0],b[0]+b[2])&amp;&amp;segmentsOverlap(a[1],a[1]+a[3],b[1],b[1]+b[3]);}</span>}
<span class="fstat-no" title="function not covered" >_s</span>crollRectsFromParams(params,type){<span class="cstat-no" title="statement not covered" >return{rect:{x:params[0],y:params[1],width:params[2],height:params[3]},type:type};}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateScrollRects(payload){<span class="cstat-no" title="statement not covered" >this._scrollRects=[];<span class="cstat-no" title="statement not covered" >i</span>f(payload.non_fast_scrollable_region){<span class="cstat-no" title="statement not covered" >this._scrollRects.push(this._scrollRectsFromParams(payload.non_fast_scrollable_region,SDK.Layer.ScrollRectType.NonFastScrollable.name));}</span></span>
<span class="cstat-no" title="statement not covered" >if(payload.touch_event_handler_region){<span class="cstat-no" title="statement not covered" >this._scrollRects.push(this._scrollRectsFromParams(payload.touch_event_handler_region,SDK.Layer.ScrollRectType.TouchEventHandler.name));}</span></span>
<span class="cstat-no" title="statement not covered" >if(payload.wheel_event_handler_region){<span class="cstat-no" title="statement not covered" >this._scrollRects.push(this._scrollRectsFromParams(payload.wheel_event_handler_region,SDK.Layer.ScrollRectType.WheelEventHandler.name));}</span></span>
<span class="cstat-no" title="statement not covered" >if(payload.scroll_event_handler_region){<span class="cstat-no" title="statement not covered" >this._scrollRects.push(this._scrollRectsFromParams(payload.scroll_event_handler_region,SDK.Layer.ScrollRectType.RepaintsOnScroll.name));}</span>}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddPaintEvent(paint){<span class="cstat-no" title="statement not covered" >this._paints.push(paint);}</span>
<span class="fstat-no" title="function not covered" >re</span>questCompositingReasons(){<span class="cstat-no" title="statement not covered" >return Promise.resolve(this._compositingReasons);}</span>
<span class="fstat-no" title="function not covered" >dr</span>awsContent(){<span class="cstat-no" title="statement not covered" >return this._drawsContent;}</span>};;<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._reset();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic forEachEvent(events,onStartEvent,onEndEvent,onInstantEvent,startTime,endTime,filter){<span class="cstat-no" title="statement not covered" >startTime=startTime||0;<span class="cstat-no" title="statement not covered" >e</span>ndTime=endTime||Infinity;c</span>onst stack=<span class="cstat-no" title="statement not covered" >[];</span>const startEvent=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel._topLevelEventEndingAfter(events,startTime);<span class="cstat-no" title="statement not covered" ></span>for(let i=startEvent;i&lt;events.length;++i){const e=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if((e.endTime||e.startTime)&lt;startTime)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(e.startTime&gt;=endTime)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(SDK.TracingModel.isAsyncPhase(e.phase)||SDK.TracingModel.isFlowPhase(e.phase))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >w</span>hile(stack.length&amp;&amp;stack.peekLast().endTime&lt;=e.startTime)</span>
<span class="cstat-no" title="statement not covered" >onEndEvent(stack.pop());<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(e))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(e.duration){<span class="cstat-no" title="statement not covered" >onStartEvent(e);<span class="cstat-no" title="statement not covered" >s</span>tack.push(e);}</span>else{<span class="cstat-no" title="statement not covered" >onInstantEvent&amp;&amp;onInstantEvent(e,stack.peekLast()||null);}</span>}</span>
<span class="cstat-no" title="statement not covered" >while(stack.length)</span>
<span class="cstat-no" title="statement not covered" >onEndEvent(stack.pop());}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _topLevelEventEndingAfter(events,time){let index=<span class="cstat-no" title="statement not covered" >events.upperBound(time,<span class="fstat-no" title="function not covered" >(t</span>ime,event)=&gt;<span class="cstat-no" title="statement not covered" >time-event.startTime)</span>-1;<span class="cstat-no" title="statement not covered" ></span>while(index&gt;0&amp;&amp;!SDK.TracingModel.isTopLevelEvent(events[index]))</span>
<span class="cstat-no" title="statement not covered" >index--;<span class="cstat-no" title="statement not covered" >r</span>eturn Math.max(index,0);}</span>
<span class="fstat-no" title="function not covered" >is</span>MarkerEvent(event){const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>switch(event.name){case recordTypes.TimeStamp:<span class="cstat-no" title="statement not covered" >return true;c</span>ase recordTypes.MarkFirstPaint:case recordTypes.MarkFCP:case recordTypes.MarkFMP:<span class="cstat-no" title="statement not covered" >return this._mainFrame&amp;&amp;event.args.frame===this._mainFrame.frameId&amp;&amp;!!event.args.data;c</span>ase recordTypes.MarkDOMContent:case recordTypes.MarkLoad:<span class="cstat-no" title="statement not covered" >return!!event.args['data']['isMainFrame'];d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span>
<span class="fstat-no" title="function not covered" >st</span>atic globalEventId(event,field){const data=<span class="cstat-no" title="statement not covered" >event.args['data']||event.args['beginData'];</span>const id=<span class="cstat-no" title="statement not covered" >data&amp;&amp;data[field];<span class="cstat-no" title="statement not covered" ></span>if(!id)</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >r</span>eturn`${event.thread.process().id()}.${id}`;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventFrameId(event){const data=<span class="cstat-no" title="statement not covered" >event.args['data']||event.args['beginData'];<span class="cstat-no" title="statement not covered" ></span>return data&amp;&amp;data['frame']||'';}</span>
<span class="fstat-no" title="function not covered" >cp</span>uProfiles(){<span class="cstat-no" title="statement not covered" >return this._cpuProfiles;}</span>
<span class="fstat-no" title="function not covered" >ta</span>rgetByEvent(event){const workerId=<span class="cstat-no" title="statement not covered" >this._workerIdByThread.get(event.thread);</span>const mainTarget=<span class="cstat-no" title="statement not covered" >SDK.targetManager.mainTarget();<span class="cstat-no" title="statement not covered" ></span>return workerId?SDK.targetManager.targetById(workerId):mainTarget;}</span>
<span class="fstat-no" title="function not covered" >se</span>tEvents(tracingModel){<span class="cstat-no" title="statement not covered" >this._reset();<span class="cstat-no" title="statement not covered" >t</span>his._resetProcessingState();<span class="cstat-no" title="statement not covered" >t</span>his._tracingModel=tracingModel;<span class="cstat-no" title="statement not covered" >t</span>his._minimumRecordTime=tracingModel.minimumRecordTime();<span class="cstat-no" title="statement not covered" >t</span>his._maximumRecordTime=tracingModel.maximumRecordTime();<span class="cstat-no" title="statement not covered" >t</span>his._processSyncBrowserEvents(tracingModel);<span class="cstat-no" title="statement not covered" >i</span>f(this._browserFrameTracking){<span class="cstat-no" title="statement not covered" >this._processThreadsForBrowserFrames(tracingModel);}</span>else{const metadataEvents=<span class="cstat-no" title="statement not covered" >this._processMetadataEvents(tracingModel);<span class="cstat-no" title="statement not covered" ></span>this._isGenericTrace=!metadataEvents;<span class="cstat-no" title="statement not covered" >i</span>f(metadataEvents)</span></span>
<span class="cstat-no" title="statement not covered" >this._processMetadataAndThreads(tracingModel,metadataEvents);e</span>lse
<span class="cstat-no" title="statement not covered" >this._processGenericTrace(tracingModel);}</span>
<span class="cstat-no" title="statement not covered" >this._inspectedTargetEvents.stableSort(SDK.TracingModel.Event.compareStartTime);<span class="cstat-no" title="statement not covered" >t</span>his._processAsyncBrowserEvents(tracingModel);<span class="cstat-no" title="statement not covered" >t</span>his._buildGPUEvents(tracingModel);<span class="cstat-no" title="statement not covered" >t</span>his._resetProcessingState();}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessGenericTrace(tracingModel){let browserMainThread=<span class="cstat-no" title="statement not covered" >SDK.TracingModel.browserMainThread(tracingModel);<span class="cstat-no" title="statement not covered" ></span>if(!browserMainThread&amp;&amp;tracingModel.sortedProcesses().length)</span>
<span class="cstat-no" title="statement not covered" >browserMainThread=tracingModel.sortedProcesses()[0].sortedThreads()[0];<span class="cstat-no" title="statement not covered" >f</span>or(const process of tracingModel.sortedProcesses()){<span class="cstat-no" title="statement not covered" >for(const thread of process.sortedThreads()){<span class="cstat-no" title="statement not covered" >this._processThreadEvents(tracingModel,[{from:0,to:Infinity}],thread,thread===browserMainThread,false,true,null);}</span>}</span>}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessMetadataAndThreads(tracingModel,metadataEvents){let startTime=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0,length=metadataEvents.page.length;i&lt;length;i++){const metaEvent=<span class="cstat-no" title="statement not covered" >metadataEvents.page[i];</span>const process=<span class="cstat-no" title="statement not covered" >metaEvent.thread.process();</span>const endTime=<span class="cstat-no" title="statement not covered" >i+1&lt;length?metadataEvents.page[i+1].startTime:Infinity;<span class="cstat-no" title="statement not covered" ></span>if(startTime===endTime)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span>his._legacyCurrentPage=metaEvent.args['data']&amp;&amp;metaEvent.args['data']['page'];<span class="cstat-no" title="statement not covered" >f</span>or(const thread of process.sortedThreads()){let workerUrl=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(thread.name()===TimelineModel.TimelineModel.WorkerThreadName||thread.name()===TimelineModel.TimelineModel.WorkerThreadNameLegacy){const workerMetaEvent=<span class="cstat-no" title="statement not covered" >metadataEvents.workers.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e.args['data']['workerThreadId']!==thread.id())</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(e.args['data']['sessionId']===this._sessionId)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span>eturn!!this._pageFrames.get(TimelineModel.TimelineModel.eventFrameId(e));}</span>);<span class="cstat-no" title="statement not covered" >if(!workerMetaEvent)</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst workerId=<span class="cstat-no" title="statement not covered" >workerMetaEvent.args['data']['workerId'];<span class="cstat-no" title="statement not covered" ></span>if(workerId)</span>
<span class="cstat-no" title="statement not covered" >this._workerIdByThread.set(thread,workerId);<span class="cstat-no" title="statement not covered" >w</span>orkerUrl=workerMetaEvent.args['data']['url']||'';}</span>
<span class="cstat-no" title="statement not covered" >this._processThreadEvents(tracingModel,[{from:startTime,to:endTime}],thread,thread===metaEvent.thread,!!workerUrl,true,workerUrl);}</span>
<span class="cstat-no" title="statement not covered" >startTime=endTime;}</span>}
<span class="fstat-no" title="function not covered" >_p</span>rocessThreadsForBrowserFrames(tracingModel){const processData=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(const frame of this._pageFrames.values()){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;frame.processes.length;i++){const pid=<span class="cstat-no" title="statement not covered" >frame.processes[i].processId;</span>let data=<span class="cstat-no" title="statement not covered" >processData.get(pid);<span class="cstat-no" title="statement not covered" ></span>if(!data){<span class="cstat-no" title="statement not covered" >data=[];<span class="cstat-no" title="statement not covered" >p</span>rocessData.set(pid,data);}</span></span></span></span>
const to=<span class="cstat-no" title="statement not covered" >i===frame.processes.length-1?(frame.deletedTime||this._maximumRecordTime):frame.processes[i+1].time;<span class="cstat-no" title="statement not covered" ></span>data.push({from:frame.processes[i].time,to:to,main:!frame.parent,url:frame.processes[i].url});}</span>}
const allMetadataEvents=<span class="cstat-no" title="statement not covered" >tracingModel.devToolsMetadataEvents();<span class="cstat-no" title="statement not covered" ></span>for(const process of tracingModel.sortedProcesses()){const data=<span class="cstat-no" title="statement not covered" >processData.get(process.id());<span class="cstat-no" title="statement not covered" ></span>if(!data)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >d</span>ata.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a.from-b.from||a.to-b.to)</span>;c</span>onst ranges=<span class="cstat-no" title="statement not covered" >[];</span>let lastUrl=<span class="cstat-no" title="statement not covered" >null;</span>let lastMainUrl=<span class="cstat-no" title="statement not covered" >null;</span>let hasMain=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>for(const item of data){<span class="cstat-no" title="statement not covered" >if(!ranges.length||item.from&gt;ranges.peekLast().to)</span></span>
<span class="cstat-no" title="statement not covered" >ranges.push({from:item.from,to:item.to});e</span>lse
<span class="cstat-no" title="statement not covered" >ranges.peekLast().to=item.to;<span class="cstat-no" title="statement not covered" >i</span>f(item.main)</span>
<span class="cstat-no" title="statement not covered" >hasMain=true;<span class="cstat-no" title="statement not covered" >i</span>f(item.url){<span class="cstat-no" title="statement not covered" >if(item.main)</span></span>
<span class="cstat-no" title="statement not covered" >lastMainUrl=item.url;<span class="cstat-no" title="statement not covered" >l</span>astUrl=item.url;}</span>}
<span class="cstat-no" title="statement not covered" >for(const thread of process.sortedThreads()){<span class="cstat-no" title="statement not covered" >if(thread.name()===TimelineModel.TimelineModel.RendererMainThreadName){<span class="cstat-no" title="statement not covered" >this._processThreadEvents(tracingModel,ranges,thread,true,false,hasMain,hasMain?lastMainUrl:lastUrl);}</span>else <span class="cstat-no" title="statement not covered" >if(thread.name()===TimelineModel.TimelineModel.WorkerThreadName||thread.name()===TimelineModel.TimelineModel.WorkerThreadNameLegacy){const workerMetaEvent=<span class="cstat-no" title="statement not covered" >allMetadataEvents.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e.name!==TimelineModel.TimelineModel.DevToolsMetadataEvent.TracingSessionIdForWorker)</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(e.thread.process()!==process)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(e.args['data']['workerThreadId']!==thread.id())</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn!!this._pageFrames.get(TimelineModel.TimelineModel.eventFrameId(e));}</span>);<span class="cstat-no" title="statement not covered" >if(!workerMetaEvent)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span>his._workerIdByThread.set(thread,workerMetaEvent.args['data']['workerId']||'');<span class="cstat-no" title="statement not covered" >t</span>his._processThreadEvents(tracingModel,ranges,thread,false,true,false,workerMetaEvent.args['data']['url']||'');}</span>else{<span class="cstat-no" title="statement not covered" >this._processThreadEvents(tracingModel,ranges,thread,false,false,false,null);}</span>}}}
<span class="fstat-no" title="function not covered" >_p</span>rocessMetadataEvents(tracingModel){const metadataEvents=<span class="cstat-no" title="statement not covered" >tracingModel.devToolsMetadataEvents();</span>const pageDevToolsMetadataEvents=<span class="cstat-no" title="statement not covered" >[];</span>const workersDevToolsMetadataEvents=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const event of metadataEvents){<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.TracingStartedInPage){<span class="cstat-no" title="statement not covered" >pageDevToolsMetadataEvents.push(event);<span class="cstat-no" title="statement not covered" >i</span>f(event.args['data']&amp;&amp;event.args['data']['persistentIds'])</span></span></span>
<span class="cstat-no" title="statement not covered" >this._persistentIds=true;c</span>onst frames=(<span class="cstat-no" title="statement not covered" >(event.args['data']&amp;&amp;event.args['data']['frames'])||[])</span>;<span class="cstat-no" title="statement not covered" >frames.forEach(<span class="fstat-no" title="function not covered" >pa</span>yload=&gt;<span class="cstat-no" title="statement not covered" >this._addPageFrame(event,payload))</span>;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrame=this.rootFrames()[0];}</span>else <span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.TracingSessionIdForWorker){<span class="cstat-no" title="statement not covered" >workersDevToolsMetadataEvents.push(event);}</span>else <span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.TracingStartedInBrowser){<span class="cstat-no" title="statement not covered" >console.assert(!this._mainFrameNodeId,'Multiple sessions in trace');<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameNodeId=event.args['frameTreeNodeId'];}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(!pageDevToolsMetadataEvents.length)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst sessionId=<span class="cstat-no" title="statement not covered" >pageDevToolsMetadataEvents[0].args['sessionId']||pageDevToolsMetadataEvents[0].args['data']['sessionId'];<span class="cstat-no" title="statement not covered" ></span>this._sessionId=sessionId;c</span>onst mismatchingIds=<span class="cstat-no" title="statement not covered" >new Set();</span>function <span class="fstat-no" title="function not covered" >checkSessionId(</span>event){let args=<span class="cstat-no" title="statement not covered" >event.args;<span class="cstat-no" title="statement not covered" ></span>if(args['data'])</span>
<span class="cstat-no" title="statement not covered" >args=args['data'];c</span>onst id=<span class="cstat-no" title="statement not covered" >args['sessionId'];<span class="cstat-no" title="statement not covered" ></span>if(id===sessionId)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >m</span>ismatchingIds.add(id);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
const result=<span class="cstat-no" title="statement not covered" >{page:pageDevToolsMetadataEvents.filter(checkSessionId).sort(SDK.TracingModel.Event.compareStartTime),workers:workersDevToolsMetadataEvents.sort(SDK.TracingModel.Event.compareStartTime)};<span class="cstat-no" title="statement not covered" ></span>if(mismatchingIds.size){<span class="cstat-no" title="statement not covered" >Common.console.error('Timeline recording was started in more than one page simultaneously. Session id mismatch: '+</span></span>
this._sessionId+' and '+mismatchingIds.valuesArray()+'.');}
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessSyncBrowserEvents(tracingModel){const browserMain=<span class="cstat-no" title="statement not covered" >SDK.TracingModel.browserMainThread(tracingModel);<span class="cstat-no" title="statement not covered" ></span>if(browserMain)</span>
<span class="cstat-no" title="statement not covered" >browserMain.events().forEach(this._processBrowserEvent,this);}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessAsyncBrowserEvents(tracingModel){const browserMain=<span class="cstat-no" title="statement not covered" >SDK.TracingModel.browserMainThread(tracingModel);<span class="cstat-no" title="statement not covered" ></span>if(browserMain)</span>
<span class="cstat-no" title="statement not covered" >this._processAsyncEvents(browserMain,[{from:0,to:Infinity}]);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildGPUEvents(tracingModel){const thread=<span class="cstat-no" title="statement not covered" >tracingModel.threadByName('GPU Process','CrGpuMain');<span class="cstat-no" title="statement not covered" ></span>if(!thread)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst gpuEventName=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType.GPUTask;</span>const track=<span class="cstat-no" title="statement not covered" >this._ensureNamedTrack(TimelineModel.TimelineModel.TrackType.GPU);<span class="cstat-no" title="statement not covered" ></span>track.thread=thread;<span class="cstat-no" title="statement not covered" >t</span>rack.events=thread.events().filter(<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >event.name===gpuEventName)</span>;}</span>
<span class="fstat-no" title="function not covered" >_r</span>esetProcessingState(){<span class="cstat-no" title="statement not covered" >this._asyncEventTracker=new TimelineModel.TimelineAsyncEventTracker();<span class="cstat-no" title="statement not covered" >t</span>his._invalidationTracker=new TimelineModel.InvalidationTracker();<span class="cstat-no" title="statement not covered" >t</span>his._layoutInvalidate={};<span class="cstat-no" title="statement not covered" >t</span>his._lastScheduleStyleRecalculation={};<span class="cstat-no" title="statement not covered" >t</span>his._paintImageEventByPixelRefId={};<span class="cstat-no" title="statement not covered" >t</span>his._lastPaintForLayer={};<span class="cstat-no" title="statement not covered" >t</span>his._lastRecalculateStylesEvent=null;<span class="cstat-no" title="statement not covered" >t</span>his._currentScriptEvent=null;<span class="cstat-no" title="statement not covered" >t</span>his._eventStack=[];<span class="cstat-no" title="statement not covered" >t</span>his._knownInputEvents=new Set();<span class="cstat-no" title="statement not covered" >t</span>his._browserFrameTracking=false;<span class="cstat-no" title="statement not covered" >t</span>his._persistentIds=false;<span class="cstat-no" title="statement not covered" >t</span>his._legacyCurrentPage=null;}</span>
<span class="fstat-no" title="function not covered" >_e</span>xtractCpuProfile(tracingModel,thread){const events=<span class="cstat-no" title="statement not covered" >thread.events();</span>let cpuProfile;let cpuProfileEvent=<span class="cstat-no" title="statement not covered" >events.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(cpuProfileEvent&amp;&amp;cpuProfileEvent.name===TimelineModel.TimelineModel.RecordType.CpuProfile){const eventData=<span class="cstat-no" title="statement not covered" >cpuProfileEvent.args['data'];<span class="cstat-no" title="statement not covered" ></span>cpuProfile=(eventData&amp;&amp;eventData['cpuProfile']);}</span></span>
<span class="cstat-no" title="statement not covered" >if(!cpuProfile){<span class="cstat-no" title="statement not covered" >cpuProfileEvent=events.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.name===TimelineModel.TimelineModel.RecordType.Profile)</span>;<span class="cstat-no" title="statement not covered" >i</span>f(!cpuProfileEvent)</span></span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst profileGroup=<span class="cstat-no" title="statement not covered" >tracingModel.profileGroup(cpuProfileEvent);<span class="cstat-no" title="statement not covered" ></span>if(!profileGroup){<span class="cstat-no" title="statement not covered" >Common.console.error('Invalid CPU profile format.');<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span></span>
<span class="cstat-no" title="statement not covered" >cpuProfile=({startTime:cpuProfileEvent.args['data']['startTime'],endTime:0,nodes:[],samples:[],timeDeltas:[]});<span class="cstat-no" title="statement not covered" >f</span>or(const profileEvent of profileGroup.children){const eventData=<span class="cstat-no" title="statement not covered" >profileEvent.args['data'];<span class="cstat-no" title="statement not covered" ></span>if('startTime'in eventData)</span></span>
<span class="cstat-no" title="statement not covered" >cpuProfile.startTime=eventData['startTime'];<span class="cstat-no" title="statement not covered" >i</span>f('endTime'in eventData)</span>
<span class="cstat-no" title="statement not covered" >cpuProfile.endTime=eventData['endTime'];c</span>onst nodesAndSamples=<span class="cstat-no" title="statement not covered" >eventData['cpuProfile']||{};<span class="cstat-no" title="statement not covered" ></span>cpuProfile.nodes.pushAll(nodesAndSamples['nodes']||[]);<span class="cstat-no" title="statement not covered" >c</span>puProfile.samples.pushAll(nodesAndSamples['samples']||[]);<span class="cstat-no" title="statement not covered" >c</span>puProfile.timeDeltas.pushAll(eventData['timeDeltas']||[]);<span class="cstat-no" title="statement not covered" >i</span>f(cpuProfile.samples.length!==cpuProfile.timeDeltas.length){<span class="cstat-no" title="statement not covered" >Common.console.error('Failed to parse CPU profile.');<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(!cpuProfile.endTime)</span>
<span class="cstat-no" title="statement not covered" >cpuProfile.endTime=cpuProfile.timeDeltas.reduce(<span class="fstat-no" title="function not covered" >(x</span>,y)=&gt;<span class="cstat-no" title="statement not covered" >x+y,</span>cpuProfile.startTime);}</span>
<span class="cstat-no" title="statement not covered" >try{const jsProfileModel=<span class="cstat-no" title="statement not covered" >new SDK.CPUProfileDataModel(cpuProfile);<span class="cstat-no" title="statement not covered" ></span>this._cpuProfiles.push(jsProfileModel);<span class="cstat-no" title="statement not covered" >r</span>eturn jsProfileModel;}</span>catch(e){<span class="cstat-no" title="statement not covered" >Common.console.error('Failed to parse CPU profile.');}</span></span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >_i</span>njectJSFrameEvents(tracingModel,thread){const jsProfileModel=<span class="cstat-no" title="statement not covered" >this._extractCpuProfile(tracingModel,thread);</span>let events=<span class="cstat-no" title="statement not covered" >thread.events();</span>const jsSamples=<span class="cstat-no" title="statement not covered" >jsProfileModel?TimelineModel.TimelineJSProfileProcessor.generateTracingEventsFromCpuProfile(jsProfileModel,thread):null;<span class="cstat-no" title="statement not covered" ></span>if(jsSamples&amp;&amp;jsSamples.length)</span>
<span class="cstat-no" title="statement not covered" >events=events.mergeOrdered(jsSamples,SDK.TracingModel.Event.orderedCompareStartTime);<span class="cstat-no" title="statement not covered" >i</span>f(jsSamples||events.some(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.name===TimelineModel.TimelineModel.RecordType.JSSample)</span>){const jsFrameEvents=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineJSProfileProcessor.generateJSFrameEvents(events);<span class="cstat-no" title="statement not covered" ></span>if(jsFrameEvents&amp;&amp;jsFrameEvents.length)</span></span>
<span class="cstat-no" title="statement not covered" >events=jsFrameEvents.mergeOrdered(events,SDK.TracingModel.Event.orderedCompareStartTime);}</span>
<span class="cstat-no" title="statement not covered" >return events;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessThreadEvents(tracingModel,ranges,thread,isMainThread,isWorker,forMainFrame,url){const track=<span class="cstat-no" title="statement not covered" >new TimelineModel.TimelineModel.Track();<span class="cstat-no" title="statement not covered" ></span>track.name=thread.name()||ls`Thread ${thread.id()}`;<span class="cstat-no" title="statement not covered" >t</span>rack.type=TimelineModel.TimelineModel.TrackType.Other;<span class="cstat-no" title="statement not covered" >t</span>rack.thread=thread;<span class="cstat-no" title="statement not covered" >i</span>f(isMainThread){<span class="cstat-no" title="statement not covered" >track.type=TimelineModel.TimelineModel.TrackType.MainThread;<span class="cstat-no" title="statement not covered" >t</span>rack.url=url||null;<span class="cstat-no" title="statement not covered" >t</span>rack.forMainFrame=forMainFrame;}</span>else <span class="cstat-no" title="statement not covered" >if(isWorker){<span class="cstat-no" title="statement not covered" >track.type=TimelineModel.TimelineModel.TrackType.Worker;<span class="cstat-no" title="statement not covered" >t</span>rack.url=url;}</span>else <span class="cstat-no" title="statement not covered" >if(thread.name().startsWith('CompositorTileWorker')){<span class="cstat-no" title="statement not covered" >track.type=TimelineModel.TimelineModel.TrackType.Raster;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this._tracks.push(track);c</span>onst events=<span class="cstat-no" title="statement not covered" >this._injectJSFrameEvents(tracingModel,thread);<span class="cstat-no" title="statement not covered" ></span>this._eventStack=[];c</span>onst eventStack=<span class="cstat-no" title="statement not covered" >this._eventStack;<span class="cstat-no" title="statement not covered" ></span>for(const range of ranges){let i=<span class="cstat-no" title="statement not covered" >events.lowerBound(range.from,<span class="fstat-no" title="function not covered" >(t</span>ime,event)=&gt;<span class="cstat-no" title="statement not covered" >time-event.startTime)</span>;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;events.length;i++){const event=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(event.startTime&gt;=range.to)</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >w</span>hile(eventStack.length&amp;&amp;eventStack.peekLast().endTime&lt;=event.startTime)</span>
<span class="cstat-no" title="statement not covered" >eventStack.pop();<span class="cstat-no" title="statement not covered" >i</span>f(!this._processEvent(event))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(!SDK.TracingModel.isAsyncPhase(event.phase)&amp;&amp;event.duration){<span class="cstat-no" title="statement not covered" >if(eventStack.length){const parent=<span class="cstat-no" title="statement not covered" >eventStack.peekLast();<span class="cstat-no" title="statement not covered" ></span>parent.selfTime-=event.duration;<span class="cstat-no" title="statement not covered" >i</span>f(parent.selfTime&lt;0)</span></span></span>
<span class="cstat-no" title="statement not covered" >this._fixNegativeDuration(parent,event);}</span>
<span class="cstat-no" title="statement not covered" >event.selfTime=event.duration;<span class="cstat-no" title="statement not covered" >i</span>f(!eventStack.length)</span>
<span class="cstat-no" title="statement not covered" >track.tasks.push(event);<span class="cstat-no" title="statement not covered" >e</span>ventStack.push(event);}</span>
<span class="cstat-no" title="statement not covered" >if(this.isMarkerEvent(event))</span>
<span class="cstat-no" title="statement not covered" >this._timeMarkerEvents.push(event);<span class="cstat-no" title="statement not covered" >t</span>rack.events.push(event);<span class="cstat-no" title="statement not covered" >t</span>his._inspectedTargetEvents.push(event);}</span>}
<span class="cstat-no" title="statement not covered" >this._processAsyncEvents(thread,ranges);}</span>
<span class="fstat-no" title="function not covered" >_f</span>ixNegativeDuration(event,child){const epsilon=<span class="cstat-no" title="statement not covered" >1e-3;<span class="cstat-no" title="statement not covered" ></span>if(event.selfTime&lt;-epsilon){<span class="cstat-no" title="statement not covered" >console.error(`Children are longer than parent at ${event.startTime} `+`(${(child.startTime - this.minimumRecordTime()).toFixed(3)} by ${(-event.selfTime).toFixed(3)}`);}</span></span>
<span class="cstat-no" title="statement not covered" >event.selfTime=0;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessAsyncEvents(thread,ranges){const asyncEvents=<span class="cstat-no" title="statement not covered" >thread.asyncEvents();</span>const groups=<span class="cstat-no" title="statement not covered" >new Map();</span>function <span class="fstat-no" title="function not covered" >group(</span>type){<span class="cstat-no" title="statement not covered" >if(!groups.has(type))</span>
<span class="cstat-no" title="statement not covered" >groups.set(type,[]);<span class="cstat-no" title="statement not covered" >r</span>eturn groups.get(type);}</span>
<span class="cstat-no" title="statement not covered" >for(const range of ranges){let i=<span class="cstat-no" title="statement not covered" >asyncEvents.lowerBound(range.from,<span class="fstat-no" title="function not covered" >fu</span>nction(time,asyncEvent){<span class="cstat-no" title="statement not covered" >return time-asyncEvent.startTime;}</span>);<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;asyncEvents.length;++i){const asyncEvent=<span class="cstat-no" title="statement not covered" >asyncEvents[i];<span class="cstat-no" title="statement not covered" ></span>if(asyncEvent.startTime&gt;=range.to)</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(asyncEvent.hasCategory(TimelineModel.TimelineModel.Category.Console)){<span class="cstat-no" title="statement not covered" >group(TimelineModel.TimelineModel.TrackType.Console).push(asyncEvent);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >if(asyncEvent.hasCategory(TimelineModel.TimelineModel.Category.UserTiming)){<span class="cstat-no" title="statement not covered" >group(TimelineModel.TimelineModel.TrackType.Timings).push(asyncEvent);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >if(asyncEvent.name===TimelineModel.TimelineModel.RecordType.Animation){<span class="cstat-no" title="statement not covered" >group(TimelineModel.TimelineModel.TrackType.Animation).push(asyncEvent);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >if(asyncEvent.hasCategory(TimelineModel.TimelineModel.Category.LatencyInfo)||asyncEvent.name===TimelineModel.TimelineModel.RecordType.ImplSideFling){const lastStep=<span class="cstat-no" title="statement not covered" >asyncEvent.steps.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(lastStep.phase!==SDK.TracingModel.Phase.AsyncEnd)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst data=<span class="cstat-no" title="statement not covered" >lastStep.args['data'];<span class="cstat-no" title="statement not covered" ></span>asyncEvent.causedFrame=!!(data&amp;&amp;data['INPUT_EVENT_LATENCY_RENDERER_SWAP_COMPONENT']);<span class="cstat-no" title="statement not covered" >i</span>f(asyncEvent.hasCategory(TimelineModel.TimelineModel.Category.LatencyInfo)){<span class="cstat-no" title="statement not covered" >if(!this._knownInputEvents.has(lastStep.id))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(asyncEvent.name===TimelineModel.TimelineModel.RecordType.InputLatencyMouseMove&amp;&amp;!asyncEvent.causedFrame)</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst rendererMain=<span class="cstat-no" title="statement not covered" >data['INPUT_EVENT_LATENCY_RENDERER_MAIN_COMPONENT'];<span class="cstat-no" title="statement not covered" ></span>if(rendererMain){const time=<span class="cstat-no" title="statement not covered" >rendererMain['time']/1000;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineData.forEvent(asyncEvent.steps[0]).timeWaitingForMainThread=time-asyncEvent.steps[0].startTime;}</span>}</span>
<span class="cstat-no" title="statement not covered" >group(TimelineModel.TimelineModel.TrackType.Input).push(asyncEvent);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>}}
<span class="cstat-no" title="statement not covered" >for(const[type,events]of groups){const track=<span class="cstat-no" title="statement not covered" >this._ensureNamedTrack(type);<span class="cstat-no" title="statement not covered" ></span>track.thread=thread;<span class="cstat-no" title="statement not covered" >t</span>rack.asyncEvents=track.asyncEvents.mergeOrdered(events,SDK.TracingModel.Event.compareStartTime);}</span>}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessEvent(event){const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const eventStack=<span class="cstat-no" title="statement not covered" >this._eventStack;<span class="cstat-no" title="statement not covered" ></span>if(!eventStack.length){<span class="cstat-no" title="statement not covered" >if(this._currentTaskLayoutAndRecalcEvents&amp;&amp;this._currentTaskLayoutAndRecalcEvents.length){const totalTime=<span class="cstat-no" title="statement not covered" >this._currentTaskLayoutAndRecalcEvents.reduce(<span class="fstat-no" title="function not covered" >(t</span>ime,event)=&gt;<span class="cstat-no" title="statement not covered" >time+event.duration,</span>0);<span class="cstat-no" title="statement not covered" ></span>if(totalTime&gt;TimelineModel.TimelineModel.Thresholds.ForcedLayout){<span class="cstat-no" title="statement not covered" >for(const e of this._currentTaskLayoutAndRecalcEvents){const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(e);<span class="cstat-no" title="statement not covered" ></span>timelineData.warning=e.name===recordTypes.Layout?TimelineModel.TimelineModel.WarningType.ForcedLayout:TimelineModel.TimelineModel.WarningType.ForcedStyle;}</span>}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._currentTaskLayoutAndRecalcEvents=[];}</span>
<span class="cstat-no" title="statement not covered" >if(this._currentScriptEvent&amp;&amp;event.startTime&gt;this._currentScriptEvent.endTime)</span>
<span class="cstat-no" title="statement not covered" >this._currentScriptEvent=null;c</span>onst eventData=<span class="cstat-no" title="statement not covered" >event.args['data']||event.args['beginData']||{};</span>const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(eventData['stackTrace'])</span>
<span class="cstat-no" title="statement not covered" >timelineData.stackTrace=eventData['stackTrace'];<span class="cstat-no" title="statement not covered" >i</span>f(timelineData.stackTrace&amp;&amp;event.name!==recordTypes.JSSample){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;timelineData.stackTrace.length;++i){<span class="cstat-no" title="statement not covered" >--timelineData.stackTrace[i].lineNumber;<span class="cstat-no" title="statement not covered" >-</span>-timelineData.stackTrace[i].columnNumber;}</span>}</span></span>
let pageFrameId=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.eventFrameId(event);<span class="cstat-no" title="statement not covered" ></span>if(!pageFrameId&amp;&amp;eventStack.length)</span>
<span class="cstat-no" title="statement not covered" >pageFrameId=TimelineModel.TimelineData.forEvent(eventStack.peekLast()).frameId;<span class="cstat-no" title="statement not covered" >t</span>imelineData.frameId=pageFrameId||(this._mainFrame&amp;&amp;this._mainFrame.frameId)||'';<span class="cstat-no" title="statement not covered" >t</span>his._asyncEventTracker.processEvent(event);<span class="cstat-no" title="statement not covered" >i</span>f(this.isMarkerEvent(event))</span>
<span class="cstat-no" title="statement not covered" >this._ensureNamedTrack(TimelineModel.TimelineModel.TrackType.Timings);<span class="cstat-no" title="statement not covered" >s</span>witch(event.name){case recordTypes.ResourceSendRequest:case recordTypes.WebSocketCreate:<span class="cstat-no" title="statement not covered" >timelineData.setInitiator(eventStack.peekLast()||null);<span class="cstat-no" title="statement not covered" >t</span>imelineData.url=eventData['url'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.ScheduleStyleRecalculation:<span class="cstat-no" title="statement not covered" >this._lastScheduleStyleRecalculation[eventData['frame']]=event;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.UpdateLayoutTree:case recordTypes.RecalculateStyles:<span class="cstat-no" title="statement not covered" >this._invalidationTracker.didRecalcStyle(event);<span class="cstat-no" title="statement not covered" >i</span>f(event.args['beginData'])</span></span>
<span class="cstat-no" title="statement not covered" >timelineData.setInitiator(this._lastScheduleStyleRecalculation[event.args['beginData']['frame']]);<span class="cstat-no" title="statement not covered" >t</span>his._lastRecalculateStylesEvent=event;<span class="cstat-no" title="statement not covered" >i</span>f(this._currentScriptEvent)</span>
<span class="cstat-no" title="statement not covered" >this._currentTaskLayoutAndRecalcEvents.push(event);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.ScheduleStyleInvalidationTracking:case recordTypes.StyleRecalcInvalidationTracking:case recordTypes.StyleInvalidatorInvalidationTracking:case recordTypes.LayoutInvalidationTracking:case recordTypes.LayerInvalidationTracking:case recordTypes.PaintInvalidationTracking:case recordTypes.ScrollInvalidationTracking:<span class="cstat-no" title="statement not covered" >this._invalidationTracker.addInvalidation(new TimelineModel.InvalidationTrackingEvent(event));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.InvalidateLayout:{let layoutInitator=<span class="cstat-no" title="statement not covered" >event;</span>const frameId=<span class="cstat-no" title="statement not covered" >eventData['frame'];<span class="cstat-no" title="statement not covered" ></span>if(!this._layoutInvalidate[frameId]&amp;&amp;this._lastRecalculateStylesEvent&amp;&amp;this._lastRecalculateStylesEvent.endTime&gt;event.startTime)</span>
<span class="cstat-no" title="statement not covered" >layoutInitator=TimelineModel.TimelineData.forEvent(this._lastRecalculateStylesEvent).initiator();<span class="cstat-no" title="statement not covered" >t</span>his._layoutInvalidate[frameId]=layoutInitator;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.Layout:{<span class="cstat-no" title="statement not covered" >this._invalidationTracker.didLayout(event);c</span>onst frameId=<span class="cstat-no" title="statement not covered" >event.args['beginData']['frame'];<span class="cstat-no" title="statement not covered" ></span>timelineData.setInitiator(this._layoutInvalidate[frameId]);<span class="cstat-no" title="statement not covered" >i</span>f(event.args['endData'])</span>
<span class="cstat-no" title="statement not covered" >timelineData.backendNodeId=event.args['endData']['rootNode'];<span class="cstat-no" title="statement not covered" >t</span>his._layoutInvalidate[frameId]=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._currentScriptEvent)</span>
<span class="cstat-no" title="statement not covered" >this._currentTaskLayoutAndRecalcEvents.push(event);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.EventDispatch:<span class="cstat-no" title="statement not covered" >if(event.duration&gt;TimelineModel.TimelineModel.Thresholds.RecurringHandler)</span>
<span class="cstat-no" title="statement not covered" >timelineData.warning=TimelineModel.TimelineModel.WarningType.LongHandler;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.TimerFire:case recordTypes.FireAnimationFrame:<span class="cstat-no" title="statement not covered" >if(event.duration&gt;TimelineModel.TimelineModel.Thresholds.RecurringHandler)</span>
<span class="cstat-no" title="statement not covered" >timelineData.warning=TimelineModel.TimelineModel.WarningType.LongRecurringHandler;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.FunctionCall:<span class="cstat-no" title="statement not covered" >if(typeof eventData['scriptName']==='string')</span>
<span class="cstat-no" title="statement not covered" >eventData['url']=eventData['scriptName'];<span class="cstat-no" title="statement not covered" >i</span>f(typeof eventData['scriptLine']==='number')</span>
<span class="cstat-no" title="statement not covered" >eventData['lineNumber']=eventData['scriptLine'];c</span>ase recordTypes.EvaluateScript:case recordTypes.CompileScript:<span class="cstat-no" title="statement not covered" >if(typeof eventData['lineNumber']==='number')</span>
<span class="cstat-no" title="statement not covered" >--eventData['lineNumber'];<span class="cstat-no" title="statement not covered" >i</span>f(typeof eventData['columnNumber']==='number')</span>
<span class="cstat-no" title="statement not covered" >--eventData['columnNumber'];c</span>ase recordTypes.RunMicrotasks:<span class="cstat-no" title="statement not covered" >if(!this._currentScriptEvent)</span>
<span class="cstat-no" title="statement not covered" >this._currentScriptEvent=event;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.SetLayerTreeId:<span class="cstat-no" title="statement not covered" >if(this._sessionId&amp;&amp;eventData['sessionId']&amp;&amp;this._sessionId===eventData['sessionId']){<span class="cstat-no" title="statement not covered" >this._mainFrameLayerTreeId=eventData['layerTreeId'];<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
const frameId=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.eventFrameId(event);</span>const pageFrame=<span class="cstat-no" title="statement not covered" >this._pageFrames.get(frameId);<span class="cstat-no" title="statement not covered" ></span>if(!pageFrame||pageFrame.parent)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameLayerTreeId=eventData['layerTreeId'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.Paint:{<span class="cstat-no" title="statement not covered" >this._invalidationTracker.didPaint(event);<span class="cstat-no" title="statement not covered" >t</span>imelineData.backendNodeId=eventData['nodeId'];<span class="cstat-no" title="statement not covered" >i</span>f(!eventData['layerId'])</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst layerId=<span class="cstat-no" title="statement not covered" >eventData['layerId'];<span class="cstat-no" title="statement not covered" ></span>this._lastPaintForLayer[layerId]=event;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.DisplayItemListSnapshot:case recordTypes.PictureSnapshot:{const layerUpdateEvent=<span class="cstat-no" title="statement not covered" >this._findAncestorEvent(recordTypes.UpdateLayer);<span class="cstat-no" title="statement not covered" ></span>if(!layerUpdateEvent||layerUpdateEvent.args['layerTreeId']!==this._mainFrameLayerTreeId)</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst paintEvent=<span class="cstat-no" title="statement not covered" >this._lastPaintForLayer[layerUpdateEvent.args['layerId']];<span class="cstat-no" title="statement not covered" ></span>if(paintEvent){<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(paintEvent).picture=(event);}</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>
case recordTypes.ScrollLayer:<span class="cstat-no" title="statement not covered" >timelineData.backendNodeId=eventData['nodeId'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.PaintImage:<span class="cstat-no" title="statement not covered" >timelineData.backendNodeId=eventData['nodeId'];<span class="cstat-no" title="statement not covered" >t</span>imelineData.url=eventData['url'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.DecodeImage:case recordTypes.ResizeImage:{let paintImageEvent=<span class="cstat-no" title="statement not covered" >this._findAncestorEvent(recordTypes.PaintImage);<span class="cstat-no" title="statement not covered" ></span>if(!paintImageEvent){const decodeLazyPixelRefEvent=<span class="cstat-no" title="statement not covered" >this._findAncestorEvent(recordTypes.DecodeLazyPixelRef);<span class="cstat-no" title="statement not covered" ></span>paintImageEvent=decodeLazyPixelRefEvent&amp;&amp;this._paintImageEventByPixelRefId[decodeLazyPixelRefEvent.args['LazyPixelRef']];}</span></span>
<span class="cstat-no" title="statement not covered" >if(!paintImageEvent)</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst paintImageData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(paintImageEvent);<span class="cstat-no" title="statement not covered" ></span>timelineData.backendNodeId=paintImageData.backendNodeId;<span class="cstat-no" title="statement not covered" >t</span>imelineData.url=paintImageData.url;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.DrawLazyPixelRef:{const paintImageEvent=<span class="cstat-no" title="statement not covered" >this._findAncestorEvent(recordTypes.PaintImage);<span class="cstat-no" title="statement not covered" ></span>if(!paintImageEvent)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span>his._paintImageEventByPixelRefId[event.args['LazyPixelRef']]=paintImageEvent;c</span>onst paintImageData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(paintImageEvent);<span class="cstat-no" title="statement not covered" ></span>timelineData.backendNodeId=paintImageData.backendNodeId;<span class="cstat-no" title="statement not covered" >t</span>imelineData.url=paintImageData.url;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.FrameStartedLoading:<span class="cstat-no" title="statement not covered" >if(timelineData.frameId!==event.args['frame'])</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkDOMContent:case recordTypes.MarkLoad:{const frameId=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.eventFrameId(event);<span class="cstat-no" title="statement not covered" ></span>if(!this._pageFrames.has(frameId))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.CommitLoad:{<span class="cstat-no" title="statement not covered" >if(this._browserFrameTracking)</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst frameId=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.eventFrameId(event);</span>const isMainFrame=<span class="cstat-no" title="statement not covered" >!!eventData['isMainFrame'];</span>const pageFrame=<span class="cstat-no" title="statement not covered" >this._pageFrames.get(frameId);<span class="cstat-no" title="statement not covered" ></span>if(pageFrame){<span class="cstat-no" title="statement not covered" >pageFrame.update(event.startTime,eventData);}</span>else{<span class="cstat-no" title="statement not covered" >if(!this._persistentIds){<span class="cstat-no" title="statement not covered" >if(eventData['page']&amp;&amp;eventData['page']!==this._legacyCurrentPage)</span></span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(isMainFrame){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(!this._addPageFrame(event,eventData)){<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(isMainFrame)</span>
<span class="cstat-no" title="statement not covered" >this._mainFrame=this._pageFrames.get(frameId);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.FireIdleCallback:<span class="cstat-no" title="statement not covered" >if(event.duration&gt;eventData['allottedMilliseconds']+TimelineModel.TimelineModel.Thresholds.IdleCallbackAddon)</span>
<span class="cstat-no" title="statement not covered" >timelineData.warning=TimelineModel.TimelineModel.WarningType.IdleDeadlineExceeded;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessBrowserEvent(event){<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.RecordType.LatencyInfoFlow){const frameId=<span class="cstat-no" title="statement not covered" >event.args['frameTreeNodeId'];<span class="cstat-no" title="statement not covered" ></span>if(typeof frameId==='number'&amp;&amp;frameId===this._mainFrameNodeId)</span></span>
<span class="cstat-no" title="statement not covered" >this._knownInputEvents.add(event.bind_id);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(event.hasCategory(SDK.TracingModel.DevToolsMetadataEventCategory)&amp;&amp;event.args['data']){const data=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.TracingStartedInBrowser){<span class="cstat-no" title="statement not covered" >if(!data['persistentIds'])</span></span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._browserFrameTracking=true;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameNodeId=data['frameTreeNodeId'];c</span>onst frames=<span class="cstat-no" title="statement not covered" >data['frames']||[];<span class="cstat-no" title="statement not covered" ></span>frames.forEach(<span class="fstat-no" title="function not covered" >pa</span>yload=&gt;{const parent=<span class="cstat-no" title="statement not covered" >payload['parent']&amp;&amp;this._pageFrames.get(payload['parent']);<span class="cstat-no" title="statement not covered" ></span>if(payload['parent']&amp;&amp;!parent)</span></span>
<span class="cstat-no" title="statement not covered" >return;l</span>et frame=<span class="cstat-no" title="statement not covered" >this._pageFrames.get(payload['frame']);<span class="cstat-no" title="statement not covered" ></span>if(!frame){<span class="cstat-no" title="statement not covered" >frame=new TimelineModel.TimelineModel.PageFrame(payload);<span class="cstat-no" title="statement not covered" >t</span>his._pageFrames.set(frame.frameId,frame);<span class="cstat-no" title="statement not covered" >i</span>f(parent)</span></span>
<span class="cstat-no" title="statement not covered" >parent.addChild(frame);e</span>lse
<span class="cstat-no" title="statement not covered" >this._mainFrame=frame;}</span>
<span class="cstat-no" title="statement not covered" >frame.update(this._minimumRecordTime,payload);}</span>);<span class="cstat-no" title="statement not covered" >return;}</span>
<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.FrameCommittedInBrowser&amp;&amp;this._browserFrameTracking){let frame=<span class="cstat-no" title="statement not covered" >this._pageFrames.get(data['frame']);<span class="cstat-no" title="statement not covered" ></span>if(!frame){const parent=<span class="cstat-no" title="statement not covered" >data['parent']&amp;&amp;this._pageFrames.get(data['parent']);<span class="cstat-no" title="statement not covered" ></span>if(!parent)</span></span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>rame=new TimelineModel.TimelineModel.PageFrame(data);<span class="cstat-no" title="statement not covered" >t</span>his._pageFrames.set(frame.frameId,frame);<span class="cstat-no" title="statement not covered" >p</span>arent.addChild(frame);}</span>
<span class="cstat-no" title="statement not covered" >frame.update(event.startTime,data);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.ProcessReadyInBrowser&amp;&amp;this._browserFrameTracking){const frame=<span class="cstat-no" title="statement not covered" >this._pageFrames.get(data['frame']);<span class="cstat-no" title="statement not covered" ></span>if(frame)</span></span>
<span class="cstat-no" title="statement not covered" >frame.processReady(data['processPseudoId'],data['processId']);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.DevToolsMetadataEvent.FrameDeletedInBrowser&amp;&amp;this._browserFrameTracking){const frame=<span class="cstat-no" title="statement not covered" >this._pageFrames.get(data['frame']);<span class="cstat-no" title="statement not covered" ></span>if(frame)</span></span>
<span class="cstat-no" title="statement not covered" >frame.deletedTime=event.startTime;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}}
<span class="fstat-no" title="function not covered" >_e</span>nsureNamedTrack(type){<span class="cstat-no" title="statement not covered" >if(!this._namedTracks.has(type)){const track=<span class="cstat-no" title="statement not covered" >new TimelineModel.TimelineModel.Track();<span class="cstat-no" title="statement not covered" ></span>track.type=type;<span class="cstat-no" title="statement not covered" >t</span>his._tracks.push(track);<span class="cstat-no" title="statement not covered" >t</span>his._namedTracks.set(type,track);}</span></span>
<span class="cstat-no" title="statement not covered" >return this._namedTracks.get(type);}</span>
<span class="fstat-no" title="function not covered" >_f</span>indAncestorEvent(name){<span class="cstat-no" title="statement not covered" >for(let i=this._eventStack.length-1;i&gt;=0;--i){const event=<span class="cstat-no" title="statement not covered" >this._eventStack[i];<span class="cstat-no" title="statement not covered" ></span>if(event.name===name)</span></span>
<span class="cstat-no" title="statement not covered" >return event;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddPageFrame(event,payload){const parent=<span class="cstat-no" title="statement not covered" >payload['parent']&amp;&amp;this._pageFrames.get(payload['parent']);<span class="cstat-no" title="statement not covered" ></span>if(payload['parent']&amp;&amp;!parent)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst pageFrame=<span class="cstat-no" title="statement not covered" >new TimelineModel.TimelineModel.PageFrame(payload);<span class="cstat-no" title="statement not covered" ></span>this._pageFrames.set(pageFrame.frameId,pageFrame);<span class="cstat-no" title="statement not covered" >p</span>ageFrame.update(event.startTime,payload);<span class="cstat-no" title="statement not covered" >i</span>f(parent)</span>
<span class="cstat-no" title="statement not covered" >parent.addChild(pageFrame);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >this._isGenericTrace=false;<span class="cstat-no" title="statement not covered" >t</span>his._tracks=[];<span class="cstat-no" title="statement not covered" >t</span>his._namedTracks=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._inspectedTargetEvents=[];<span class="cstat-no" title="statement not covered" >t</span>his._timeMarkerEvents=[];<span class="cstat-no" title="statement not covered" >t</span>his._sessionId=null;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameNodeId=null;<span class="cstat-no" title="statement not covered" >t</span>his._cpuProfiles=[];<span class="cstat-no" title="statement not covered" >t</span>his._workerIdByThread=new WeakMap();<span class="cstat-no" title="statement not covered" >t</span>his._pageFrames=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._mainFrame=null;<span class="cstat-no" title="statement not covered" >t</span>his._minimumRecordTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._maximumRecordTime=0;}</span>
<span class="fstat-no" title="function not covered" >is</span>GenericTrace(){<span class="cstat-no" title="statement not covered" >return this._isGenericTrace;}</span>
<span class="fstat-no" title="function not covered" >tr</span>acingModel(){<span class="cstat-no" title="statement not covered" >return this._tracingModel;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumRecordTime(){<span class="cstat-no" title="statement not covered" >return this._minimumRecordTime;}</span>
<span class="fstat-no" title="function not covered" >ma</span>ximumRecordTime(){<span class="cstat-no" title="statement not covered" >return this._maximumRecordTime;}</span>
<span class="fstat-no" title="function not covered" >in</span>spectedTargetEvents(){<span class="cstat-no" title="statement not covered" >return this._inspectedTargetEvents;}</span>
<span class="fstat-no" title="function not covered" >tr</span>acks(){<span class="cstat-no" title="statement not covered" >return this._tracks;}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this.minimumRecordTime()===0&amp;&amp;this.maximumRecordTime()===0;}</span>
<span class="fstat-no" title="function not covered" >ti</span>meMarkerEvents(){<span class="cstat-no" title="statement not covered" >return this._timeMarkerEvents;}</span>
<span class="fstat-no" title="function not covered" >ro</span>otFrames(){<span class="cstat-no" title="statement not covered" >return Array.from(this._pageFrames.values()).filter(<span class="fstat-no" title="function not covered" >fr</span>ame=&gt;<span class="cstat-no" title="statement not covered" >!frame.parent)</span>;}</span>
<span class="fstat-no" title="function not covered" >pa</span>geURL(){<span class="cstat-no" title="statement not covered" >return this._mainFrame&amp;&amp;this._mainFrame.url||'';}</span>
<span class="fstat-no" title="function not covered" >pa</span>geFrameById(frameId){<span class="cstat-no" title="statement not covered" >return frameId?this._pageFrames.get(frameId)||null:null;}</span>
<span class="fstat-no" title="function not covered" >ne</span>tworkRequests(){<span class="cstat-no" title="statement not covered" >if(this.isGenericTrace())</span>
<span class="cstat-no" title="statement not covered" >return[];c</span>onst requests=<span class="cstat-no" title="statement not covered" >new Map();</span>const requestsList=<span class="cstat-no" title="statement not covered" >[];</span>const zeroStartRequestsList=<span class="cstat-no" title="statement not covered" >[];</span>const types=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const resourceTypes=<span class="cstat-no" title="statement not covered" >new Set([types.ResourceSendRequest,types.ResourceReceiveResponse,types.ResourceReceivedData,types.ResourceFinish]);</span>const events=<span class="cstat-no" title="statement not covered" >this.inspectedTargetEvents();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;events.length;++i){const e=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(!resourceTypes.has(e.name))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst id=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.globalEventId(e,'requestId');</span>let request=<span class="cstat-no" title="statement not covered" >requests.get(id);<span class="cstat-no" title="statement not covered" ></span>if(request){<span class="cstat-no" title="statement not covered" >request.addEvent(e);}</span>else{<span class="cstat-no" title="statement not covered" >request=new TimelineModel.TimelineModel.NetworkRequest(e);<span class="cstat-no" title="statement not covered" >r</span>equests.set(id,request);<span class="cstat-no" title="statement not covered" >i</span>f(request.startTime)</span></span>
<span class="cstat-no" title="statement not covered" >requestsList.push(request);e</span>lse
<span class="cstat-no" title="statement not covered" >zeroStartRequestsList.push(request);}</span>}
<span class="cstat-no" title="statement not covered" >return zeroStartRequestsList.concat(requestsList);}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType={Task:'Task',Program:'Program',EventDispatch:'EventDispatch',GPUTask:'GPUTask',Animation:'Animation',RequestMainThreadFrame:'RequestMainThreadFrame',BeginFrame:'BeginFrame',NeedsBeginFrameChanged:'NeedsBeginFrameChanged',BeginMainThreadFrame:'BeginMainThreadFrame',ActivateLayerTree:'ActivateLayerTree',DrawFrame:'DrawFrame',HitTest:'HitTest',ScheduleStyleRecalculation:'ScheduleStyleRecalculation',RecalculateStyles:'RecalculateStyles',UpdateLayoutTree:'UpdateLayoutTree',InvalidateLayout:'InvalidateLayout',Layout:'Layout',UpdateLayer:'UpdateLayer',UpdateLayerTree:'UpdateLayerTree',PaintSetup:'PaintSetup',Paint:'Paint',PaintImage:'PaintImage',Rasterize:'Rasterize',RasterTask:'RasterTask',ScrollLayer:'ScrollLayer',CompositeLayers:'CompositeLayers',ScheduleStyleInvalidationTracking:'ScheduleStyleInvalidationTracking',StyleRecalcInvalidationTracking:'StyleRecalcInvalidationTracking',StyleInvalidatorInvalidationTracking:'StyleInvalidatorInvalidationTracking',LayoutInvalidationTracking:'LayoutInvalidationTracking',LayerInvalidationTracking:'LayerInvalidationTracking',PaintInvalidationTracking:'PaintInvalidationTracking',ScrollInvalidationTracking:'ScrollInvalidationTracking',ParseHTML:'ParseHTML',ParseAuthorStyleSheet:'ParseAuthorStyleSheet',TimerInstall:'TimerInstall',TimerRemove:'TimerRemove',TimerFire:'TimerFire',XHRReadyStateChange:'XHRReadyStateChange',XHRLoad:'XHRLoad',CompileScript:'v8.compile',EvaluateScript:'EvaluateScript',CompileModule:'v8.compileModule',EvaluateModule:'v8.evaluateModule',FrameStartedLoading:'FrameStartedLoading',CommitLoad:'CommitLoad',MarkLoad:'MarkLoad',MarkDOMContent:'MarkDOMContent',MarkFirstPaint:'MarkFirstPaint',MarkFCP:'firstContentfulPaint',MarkFMP:'firstMeaningfulPaint',TimeStamp:'TimeStamp',ConsoleTime:'ConsoleTime',UserTiming:'UserTiming',ResourceSendRequest:'ResourceSendRequest',ResourceReceiveResponse:'ResourceReceiveResponse',ResourceReceivedData:'ResourceReceivedData',ResourceFinish:'ResourceFinish',RunMicrotasks:'RunMicrotasks',FunctionCall:'FunctionCall',GCEvent:'GCEvent',MajorGC:'MajorGC',MinorGC:'MinorGC',JSFrame:'JSFrame',JSSample:'JSSample',V8Sample:'V8Sample',JitCodeAdded:'JitCodeAdded',JitCodeMoved:'JitCodeMoved',ParseScriptOnBackground:'v8.parseOnBackground',V8Execute:'V8.Execute',UpdateCounters:'UpdateCounters',RequestAnimationFrame:'RequestAnimationFrame',CancelAnimationFrame:'CancelAnimationFrame',FireAnimationFrame:'FireAnimationFrame',RequestIdleCallback:'RequestIdleCallback',CancelIdleCallback:'CancelIdleCallback',FireIdleCallback:'FireIdleCallback',WebSocketCreate:'WebSocketCreate',WebSocketSendHandshakeRequest:'WebSocketSendHandshakeRequest',WebSocketReceiveHandshakeResponse:'WebSocketReceiveHandshakeResponse',WebSocketDestroy:'WebSocketDestroy',EmbedderCallback:'EmbedderCallback',SetLayerTreeId:'SetLayerTreeId',TracingStartedInPage:'TracingStartedInPage',TracingSessionIdForWorker:'TracingSessionIdForWorker',DecodeImage:'Decode Image',ResizeImage:'Resize Image',DrawLazyPixelRef:'Draw LazyPixelRef',DecodeLazyPixelRef:'Decode LazyPixelRef',LazyPixelRef:'LazyPixelRef',LayerTreeHostImplSnapshot:'cc::LayerTreeHostImpl',PictureSnapshot:'cc::Picture',DisplayItemListSnapshot:'cc::DisplayItemList',LatencyInfo:'LatencyInfo',LatencyInfoFlow:'LatencyInfo.Flow',InputLatencyMouseMove:'InputLatency::MouseMove',InputLatencyMouseWheel:'InputLatency::MouseWheel',ImplSideFling:'InputHandlerProxy::HandleGestureFling::started',GCCollectGarbage:'BlinkGC.AtomicPhase',CryptoDoEncrypt:'DoEncrypt',CryptoDoEncryptReply:'DoEncryptReply',CryptoDoDecrypt:'DoDecrypt',CryptoDoDecryptReply:'DoDecryptReply',CryptoDoDigest:'DoDigest',CryptoDoDigestReply:'DoDigestReply',CryptoDoSign:'DoSign',CryptoDoSignReply:'DoSignReply',CryptoDoVerify:'DoVerify',CryptoDoVerifyReply:'DoVerifyReply',CpuProfile:'CpuProfile',Profile:'Profile',AsyncTask:'AsyncTask',};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.Category={Console:'blink.console',UserTiming:'blink.user_timing',LatencyInfo:'latencyInfo'};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.WarningType={ForcedStyle:'ForcedStyle',ForcedLayout:'ForcedLayout',IdleDeadlineExceeded:'IdleDeadlineExceeded',LongHandler:'LongHandler',LongRecurringHandler:'LongRecurringHandler',V8Deopt:'V8Deopt'};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.WorkerThreadName='DedicatedWorker thread';<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.WorkerThreadNameLegacy='DedicatedWorker Thread';<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.RendererMainThreadName='CrRendererMain';<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.BrowserMainThreadName='CrBrowserMain';<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.DevToolsMetadataEvent={TracingStartedInBrowser:'TracingStartedInBrowser',TracingStartedInPage:'TracingStartedInPage',TracingSessionIdForWorker:'TracingSessionIdForWorker',FrameCommittedInBrowser:'FrameCommittedInBrowser',ProcessReadyInBrowser:'ProcessReadyInBrowser',FrameDeletedInBrowser:'FrameDeletedInBrowser',};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.Thresholds={Handler:150,RecurringHandler:50,ForcedLayout:30,IdleCallbackAddon:5};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.Track=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.name='';<span class="cstat-no" title="statement not covered" >t</span>his.type=TimelineModel.TimelineModel.TrackType.Other;<span class="cstat-no" title="statement not covered" >t</span>his.forMainFrame=false;<span class="cstat-no" title="statement not covered" >t</span>his.url='';<span class="cstat-no" title="statement not covered" >t</span>his.events=[];<span class="cstat-no" title="statement not covered" >t</span>his.asyncEvents=[];<span class="cstat-no" title="statement not covered" >t</span>his.tasks=[];<span class="cstat-no" title="statement not covered" >t</span>his._syncEvents=null;<span class="cstat-no" title="statement not covered" >t</span>his.thread=null;}</span></span>
<span class="fstat-no" title="function not covered" >sy</span>ncEvents(){<span class="cstat-no" title="statement not covered" >if(this.events.length)</span>
<span class="cstat-no" title="statement not covered" >return this.events;<span class="cstat-no" title="statement not covered" >i</span>f(this._syncEvents)</span>
<span class="cstat-no" title="statement not covered" >return this._syncEvents;c</span>onst stack=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>this._syncEvents=[];<span class="cstat-no" title="statement not covered" >f</span>or(const event of this.asyncEvents){const startTime=<span class="cstat-no" title="statement not covered" >event.startTime;</span>const endTime=<span class="cstat-no" title="statement not covered" >event.endTime;<span class="cstat-no" title="statement not covered" ></span>while(stack.length&amp;&amp;startTime&gt;=stack.peekLast().endTime)</span></span>
<span class="cstat-no" title="statement not covered" >stack.pop();<span class="cstat-no" title="statement not covered" >i</span>f(stack.length&amp;&amp;endTime&gt;stack.peekLast().endTime){<span class="cstat-no" title="statement not covered" >this._syncEvents=[];<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
const syncEvent=<span class="cstat-no" title="statement not covered" >new SDK.TracingModel.Event(event.categoriesString,event.name,SDK.TracingModel.Phase.Complete,startTime,event.thread);<span class="cstat-no" title="statement not covered" ></span>syncEvent.setEndTime(endTime);<span class="cstat-no" title="statement not covered" >s</span>yncEvent.addArgs(event.args);<span class="cstat-no" title="statement not covered" >t</span>his._syncEvents.push(syncEvent);<span class="cstat-no" title="statement not covered" >s</span>tack.push(syncEvent);}</span>
<span class="cstat-no" title="statement not covered" >return this._syncEvents;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.TrackType={MainThread:Symbol('MainThread'),Worker:Symbol('Worker'),Input:Symbol('Input'),Animation:Symbol('Animation'),Timings:Symbol('Timings'),Console:Symbol('Console'),Raster:Symbol('Raster'),GPU:Symbol('GPU'),Other:Symbol('Other'),};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.PageFrame=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(payload){<span class="cstat-no" title="statement not covered" >this.frameId=payload['frame'];<span class="cstat-no" title="statement not covered" >t</span>his.url=payload['url']||'';<span class="cstat-no" title="statement not covered" >t</span>his.name=payload['name'];<span class="cstat-no" title="statement not covered" >t</span>his.children=[];<span class="cstat-no" title="statement not covered" >t</span>his.parent=null;<span class="cstat-no" title="statement not covered" >t</span>his.processes=[];<span class="cstat-no" title="statement not covered" >t</span>his.deletedTime=null;<span class="cstat-no" title="statement not covered" >t</span>his.ownerNode=null;}</span></span>
<span class="fstat-no" title="function not covered" >up</span>date(time,payload){<span class="cstat-no" title="statement not covered" >this.url=payload['url']||'';<span class="cstat-no" title="statement not covered" >t</span>his.name=payload['name'];<span class="cstat-no" title="statement not covered" >i</span>f(payload['processId']){<span class="cstat-no" title="statement not covered" >this.processes.push({time:time,processId:payload['processId'],processPseudoId:'',url:payload['url']||''});}</span>else{<span class="cstat-no" title="statement not covered" >this.processes.push({time:time,processId:-1,processPseudoId:payload['processPseudoId'],url:payload['url']||''});}</span>}</span>
<span class="fstat-no" title="function not covered" >pr</span>ocessReady(processPseudoId,processId){<span class="cstat-no" title="statement not covered" >for(const process of this.processes){<span class="cstat-no" title="statement not covered" >if(process.processPseudoId===processPseudoId){<span class="cstat-no" title="statement not covered" >process.processPseudoId='';<span class="cstat-no" title="statement not covered" >p</span>rocess.processId=processId;}</span>}</span>}</span>
<span class="fstat-no" title="function not covered" >ad</span>dChild(child){<span class="cstat-no" title="statement not covered" >this.children.push(child);<span class="cstat-no" title="statement not covered" >c</span>hild.parent=this;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.MetadataEvents;<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineModel.NetworkRequest=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(event){<span class="cstat-no" title="statement not covered" >this.startTime=event.name===TimelineModel.TimelineModel.RecordType.ResourceSendRequest?event.startTime:0;<span class="cstat-no" title="statement not covered" >t</span>his.endTime=Infinity;<span class="cstat-no" title="statement not covered" >t</span>his.encodedDataLength=0;<span class="cstat-no" title="statement not covered" >t</span>his.decodedBodyLength=0;<span class="cstat-no" title="statement not covered" >t</span>his.children=[];<span class="cstat-no" title="statement not covered" >t</span>his.timing;<span class="cstat-no" title="statement not covered" >t</span>his.mimeType;<span class="cstat-no" title="statement not covered" >t</span>his.url;<span class="cstat-no" title="statement not covered" >t</span>his.requestMethod;<span class="cstat-no" title="statement not covered" >t</span>his.addEvent(event);}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dEvent(event){<span class="cstat-no" title="statement not covered" >this.children.push(event);c</span>onst recordType=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>this.startTime=Math.min(this.startTime,event.startTime);c</span>onst eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>if(eventData['mimeType'])</span>
<span class="cstat-no" title="statement not covered" >this.mimeType=eventData['mimeType'];<span class="cstat-no" title="statement not covered" >i</span>f('priority'in eventData)</span>
<span class="cstat-no" title="statement not covered" >this.priority=eventData['priority'];<span class="cstat-no" title="statement not covered" >i</span>f(event.name===recordType.ResourceFinish)</span>
<span class="cstat-no" title="statement not covered" >this.endTime=event.startTime;<span class="cstat-no" title="statement not covered" >i</span>f(eventData['finishTime'])</span>
<span class="cstat-no" title="statement not covered" >this.finishTime=eventData['finishTime']*1000;<span class="cstat-no" title="statement not covered" >i</span>f(!this.responseTime&amp;&amp;(event.name===recordType.ResourceReceiveResponse||event.name===recordType.ResourceReceivedData))</span>
<span class="cstat-no" title="statement not covered" >this.responseTime=event.startTime;c</span>onst encodedDataLength=<span class="cstat-no" title="statement not covered" >eventData['encodedDataLength']||0;<span class="cstat-no" title="statement not covered" ></span>if(event.name===recordType.ResourceReceiveResponse){<span class="cstat-no" title="statement not covered" >if(eventData['fromCache'])</span></span>
<span class="cstat-no" title="statement not covered" >this.fromCache=true;<span class="cstat-no" title="statement not covered" >i</span>f(eventData['fromServiceWorker'])</span>
<span class="cstat-no" title="statement not covered" >this.fromServiceWorker=true;<span class="cstat-no" title="statement not covered" >t</span>his.encodedDataLength=encodedDataLength;}</span>
<span class="cstat-no" title="statement not covered" >if(event.name===recordType.ResourceReceivedData)</span>
<span class="cstat-no" title="statement not covered" >this.encodedDataLength+=encodedDataLength;<span class="cstat-no" title="statement not covered" >i</span>f(event.name===recordType.ResourceFinish&amp;&amp;encodedDataLength)</span>
<span class="cstat-no" title="statement not covered" >this.encodedDataLength=encodedDataLength;c</span>onst decodedBodyLength=<span class="cstat-no" title="statement not covered" >eventData['decodedBodyLength'];<span class="cstat-no" title="statement not covered" ></span>if(event.name===recordType.ResourceFinish&amp;&amp;decodedBodyLength)</span>
<span class="cstat-no" title="statement not covered" >this.decodedBodyLength=decodedBodyLength;<span class="cstat-no" title="statement not covered" >i</span>f(!this.url)</span>
<span class="cstat-no" title="statement not covered" >this.url=eventData['url'];<span class="cstat-no" title="statement not covered" >i</span>f(!this.requestMethod)</span>
<span class="cstat-no" title="statement not covered" >this.requestMethod=eventData['requestMethod'];<span class="cstat-no" title="statement not covered" >i</span>f(!this.timing)</span>
<span class="cstat-no" title="statement not covered" >this.timing=eventData['timing'];<span class="cstat-no" title="statement not covered" >i</span>f(eventData['fromServiceWorker'])</span>
<span class="cstat-no" title="statement not covered" >this.fromServiceWorker=true;}</span>
<span class="fstat-no" title="function not covered" >be</span>ginTime(){<span class="cstat-no" title="statement not covered" >return Math.min(this.startTime,this.timing&amp;&amp;this.timing.pushStart*1000||Infinity);}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.InvalidationTrackingEvent=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(event){<span class="cstat-no" title="statement not covered" >this.type=event.name;<span class="cstat-no" title="statement not covered" >t</span>his.startTime=event.startTime;<span class="cstat-no" title="statement not covered" >t</span>his._tracingEvent=event;c</span>onst eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>this.frame=eventData['frame'];<span class="cstat-no" title="statement not covered" >t</span>his.nodeId=eventData['nodeId'];<span class="cstat-no" title="statement not covered" >t</span>his.nodeName=eventData['nodeName'];<span class="cstat-no" title="statement not covered" >t</span>his.paintId=eventData['paintId'];<span class="cstat-no" title="statement not covered" >t</span>his.invalidationSet=eventData['invalidationSet'];<span class="cstat-no" title="statement not covered" >t</span>his.invalidatedSelectorId=eventData['invalidatedSelectorId'];<span class="cstat-no" title="statement not covered" >t</span>his.changedId=eventData['changedId'];<span class="cstat-no" title="statement not covered" >t</span>his.changedClass=eventData['changedClass'];<span class="cstat-no" title="statement not covered" >t</span>his.changedAttribute=eventData['changedAttribute'];<span class="cstat-no" title="statement not covered" >t</span>his.changedPseudo=eventData['changedPseudo'];<span class="cstat-no" title="statement not covered" >t</span>his.selectorPart=eventData['selectorPart'];<span class="cstat-no" title="statement not covered" >t</span>his.extraData=eventData['extraData'];<span class="cstat-no" title="statement not covered" >t</span>his.invalidationList=eventData['invalidationList'];<span class="cstat-no" title="statement not covered" >t</span>his.cause={reason:eventData['reason'],stackTrace:eventData['stackTrace']};<span class="cstat-no" title="statement not covered" >i</span>f(!this.cause.reason&amp;&amp;this.cause.stackTrace&amp;&amp;this.type===TimelineModel.TimelineModel.RecordType.LayoutInvalidationTracking)</span></span>
<span class="cstat-no" title="statement not covered" >this.cause.reason='Layout forced';}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.InvalidationCause;<span class="cstat-no" title="statement not covered" >T</span>imelineModel.InvalidationTracker=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._lastRecalcStyle=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastPaintWithLayer=null;<span class="cstat-no" title="statement not covered" >t</span>his._didPaint=false;<span class="cstat-no" title="statement not covered" >t</span>his._initializePerFrameState();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic invalidationEventsFor(event){<span class="cstat-no" title="statement not covered" >return event[TimelineModel.InvalidationTracker._invalidationTrackingEventsSymbol]||null;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dInvalidation(invalidation){<span class="cstat-no" title="statement not covered" >this._startNewFrameIfNeeded();<span class="cstat-no" title="statement not covered" >i</span>f(!invalidation.nodeId&amp;&amp;!invalidation.paintId){<span class="cstat-no" title="statement not covered" >console.error('Invalidation lacks node information.');<span class="cstat-no" title="statement not covered" >c</span>onsole.error(invalidation);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>if(invalidation.type===recordTypes.PaintInvalidationTracking&amp;&amp;invalidation.nodeId){const invalidations=<span class="cstat-no" title="statement not covered" >this._invalidationsByNodeId[invalidation.nodeId]||[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;invalidations.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >invalidations[i].paintId=invalidation.paintId;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(invalidation.type===recordTypes.StyleRecalcInvalidationTracking&amp;&amp;invalidation.cause.reason==='StyleInvalidator')</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst styleRecalcInvalidation=(<span class="cstat-no" title="statement not covered" >invalidation.type===recordTypes.ScheduleStyleInvalidationTracking||invalidation.type===recordTypes.StyleInvalidatorInvalidationTracking||invalidation.type===recordTypes.StyleRecalcInvalidationTracking)</span>;<span class="cstat-no" title="statement not covered" >if(styleRecalcInvalidation){const duringRecalcStyle=<span class="cstat-no" title="statement not covered" >invalidation.startTime&amp;&amp;this._lastRecalcStyle&amp;&amp;invalidation.startTime&gt;=this._lastRecalcStyle.startTime&amp;&amp;invalidation.startTime&lt;=this._lastRecalcStyle.endTime;<span class="cstat-no" title="statement not covered" ></span>if(duringRecalcStyle)</span></span>
<span class="cstat-no" title="statement not covered" >this._associateWithLastRecalcStyleEvent(invalidation);}</span>
<span class="cstat-no" title="statement not covered" >if(this._invalidations[invalidation.type])</span>
<span class="cstat-no" title="statement not covered" >this._invalidations[invalidation.type].push(invalidation);e</span>lse
<span class="cstat-no" title="statement not covered" >this._invalidations[invalidation.type]=[invalidation];<span class="cstat-no" title="statement not covered" >i</span>f(invalidation.nodeId){<span class="cstat-no" title="statement not covered" >if(this._invalidationsByNodeId[invalidation.nodeId])</span></span>
<span class="cstat-no" title="statement not covered" >this._invalidationsByNodeId[invalidation.nodeId].push(invalidation);e</span>lse
<span class="cstat-no" title="statement not covered" >this._invalidationsByNodeId[invalidation.nodeId]=[invalidation];}</span>}
<span class="fstat-no" title="function not covered" >di</span>dRecalcStyle(recalcStyleEvent){<span class="cstat-no" title="statement not covered" >this._lastRecalcStyle=recalcStyleEvent;c</span>onst types=<span class="cstat-no" title="statement not covered" >[TimelineModel.TimelineModel.RecordType.ScheduleStyleInvalidationTracking,TimelineModel.TimelineModel.RecordType.StyleInvalidatorInvalidationTracking,TimelineModel.TimelineModel.RecordType.StyleRecalcInvalidationTracking];<span class="cstat-no" title="statement not covered" ></span>for(const invalidation of this._invalidationsOfTypes(types))</span>
<span class="cstat-no" title="statement not covered" >this._associateWithLastRecalcStyleEvent(invalidation);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ssociateWithLastRecalcStyleEvent(invalidation){<span class="cstat-no" title="statement not covered" >if(invalidation.linkedRecalcStyleEvent)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const recalcStyleFrameId=<span class="cstat-no" title="statement not covered" >this._lastRecalcStyle.args['beginData']['frame'];<span class="cstat-no" title="statement not covered" ></span>if(invalidation.type===recordTypes.StyleInvalidatorInvalidationTracking){<span class="cstat-no" title="statement not covered" >this._addSyntheticStyleRecalcInvalidations(this._lastRecalcStyle,recalcStyleFrameId,invalidation);}</span>else <span class="cstat-no" title="statement not covered" >if(invalidation.type===recordTypes.ScheduleStyleInvalidationTracking){}else{<span class="cstat-no" title="statement not covered" >this._addInvalidationToEvent(this._lastRecalcStyle,recalcStyleFrameId,invalidation);}</span></span></span>
<span class="cstat-no" title="statement not covered" >invalidation.linkedRecalcStyleEvent=true;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddSyntheticStyleRecalcInvalidations(event,frameId,styleInvalidatorInvalidation){<span class="cstat-no" title="statement not covered" >if(!styleInvalidatorInvalidation.invalidationList){<span class="cstat-no" title="statement not covered" >this._addSyntheticStyleRecalcInvalidation(styleInvalidatorInvalidation._tracingEvent,styleInvalidatorInvalidation);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!styleInvalidatorInvalidation.nodeId){<span class="cstat-no" title="statement not covered" >console.error('Invalidation lacks node information.');<span class="cstat-no" title="statement not covered" >c</span>onsole.error(styleInvalidatorInvalidation);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;styleInvalidatorInvalidation.invalidationList.length;i++){const setId=<span class="cstat-no" title="statement not covered" >styleInvalidatorInvalidation.invalidationList[i]['id'];</span>let lastScheduleStyleRecalculation;const nodeInvalidations=<span class="cstat-no" title="statement not covered" >this._invalidationsByNodeId[styleInvalidatorInvalidation.nodeId]||[];<span class="cstat-no" title="statement not covered" ></span>for(let j=0;j&lt;nodeInvalidations.length;j++){const invalidation=<span class="cstat-no" title="statement not covered" >nodeInvalidations[j];<span class="cstat-no" title="statement not covered" ></span>if(invalidation.frame!==frameId||invalidation.invalidationSet!==setId||invalidation.type!==TimelineModel.TimelineModel.RecordType.ScheduleStyleInvalidationTracking)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >l</span>astScheduleStyleRecalculation=invalidation;}</span>
<span class="cstat-no" title="statement not covered" >if(!lastScheduleStyleRecalculation){<span class="cstat-no" title="statement not covered" >console.error('Failed to lookup the event that scheduled a style invalidator invalidation.');<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >this._addSyntheticStyleRecalcInvalidation(lastScheduleStyleRecalculation._tracingEvent,styleInvalidatorInvalidation);}</span>}
<span class="fstat-no" title="function not covered" >_a</span>ddSyntheticStyleRecalcInvalidation(baseEvent,styleInvalidatorInvalidation){const invalidation=<span class="cstat-no" title="statement not covered" >new TimelineModel.InvalidationTrackingEvent(baseEvent);<span class="cstat-no" title="statement not covered" ></span>invalidation.type=TimelineModel.TimelineModel.RecordType.StyleRecalcInvalidationTracking;<span class="cstat-no" title="statement not covered" >i</span>f(styleInvalidatorInvalidation.cause.reason)</span>
<span class="cstat-no" title="statement not covered" >invalidation.cause.reason=styleInvalidatorInvalidation.cause.reason;<span class="cstat-no" title="statement not covered" >i</span>f(styleInvalidatorInvalidation.selectorPart)</span>
<span class="cstat-no" title="statement not covered" >invalidation.selectorPart=styleInvalidatorInvalidation.selectorPart;<span class="cstat-no" title="statement not covered" >t</span>his.addInvalidation(invalidation);<span class="cstat-no" title="statement not covered" >i</span>f(!invalidation.linkedRecalcStyleEvent)</span>
<span class="cstat-no" title="statement not covered" >this._associateWithLastRecalcStyleEvent(invalidation);}</span>
<span class="fstat-no" title="function not covered" >di</span>dLayout(layoutEvent){const layoutFrameId=<span class="cstat-no" title="statement not covered" >layoutEvent.args['beginData']['frame'];<span class="cstat-no" title="statement not covered" ></span>for(const invalidation of this._invalidationsOfTypes([TimelineModel.TimelineModel.RecordType.LayoutInvalidationTracking])){<span class="cstat-no" title="statement not covered" >if(invalidation.linkedLayoutEvent)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span>his._addInvalidationToEvent(layoutEvent,layoutFrameId,invalidation);<span class="cstat-no" title="statement not covered" >i</span>nvalidation.linkedLayoutEvent=true;}</span>}
<span class="fstat-no" title="function not covered" >di</span>dPaint(paintEvent){<span class="cstat-no" title="statement not covered" >this._didPaint=true;c</span>onst layerId=<span class="cstat-no" title="statement not covered" >paintEvent.args['data']['layerId'];<span class="cstat-no" title="statement not covered" ></span>if(layerId)</span>
<span class="cstat-no" title="statement not covered" >this._lastPaintWithLayer=paintEvent;<span class="cstat-no" title="statement not covered" >i</span>f(!this._lastPaintWithLayer)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst effectivePaintId=<span class="cstat-no" title="statement not covered" >this._lastPaintWithLayer.args['data']['nodeId'];</span>const paintFrameId=<span class="cstat-no" title="statement not covered" >paintEvent.args['data']['frame'];</span>const types=<span class="cstat-no" title="statement not covered" >[TimelineModel.TimelineModel.RecordType.StyleRecalcInvalidationTracking,TimelineModel.TimelineModel.RecordType.LayoutInvalidationTracking,TimelineModel.TimelineModel.RecordType.PaintInvalidationTracking,TimelineModel.TimelineModel.RecordType.ScrollInvalidationTracking];<span class="cstat-no" title="statement not covered" ></span>for(const invalidation of this._invalidationsOfTypes(types)){<span class="cstat-no" title="statement not covered" >if(invalidation.paintId===effectivePaintId)</span></span>
<span class="cstat-no" title="statement not covered" >this._addInvalidationToEvent(paintEvent,paintFrameId,invalidation);}</span>}
<span class="fstat-no" title="function not covered" >_a</span>ddInvalidationToEvent(event,eventFrameId,invalidation){<span class="cstat-no" title="statement not covered" >if(eventFrameId!==invalidation.frame)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!event[TimelineModel.InvalidationTracker._invalidationTrackingEventsSymbol])</span>
<span class="cstat-no" title="statement not covered" >event[TimelineModel.InvalidationTracker._invalidationTrackingEventsSymbol]=[invalidation];e</span>lse
<span class="cstat-no" title="statement not covered" >event[TimelineModel.InvalidationTracker._invalidationTrackingEventsSymbol].push(invalidation);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nvalidationsOfTypes(types){const invalidations=<span class="cstat-no" title="statement not covered" >this._invalidations;<span class="cstat-no" title="statement not covered" ></span>if(!types)</span>
<span class="cstat-no" title="statement not covered" >types=Object.keys(invalidations);f</span>unction*<span class="fstat-no" title="function not covered" >generator(</span>){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;types.length;++i){const invalidationList=<span class="cstat-no" title="statement not covered" >invalidations[types[i]]||[];<span class="cstat-no" title="statement not covered" ></span>for(let j=0;j&lt;invalidationList.length;++j)</span></span>
<span class="cstat-no" title="statement not covered" >yield invalidationList[j];}</span>}
<span class="cstat-no" title="statement not covered" >return generator();}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartNewFrameIfNeeded(){<span class="cstat-no" title="statement not covered" >if(!this._didPaint)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._initializePerFrameState();}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitializePerFrameState(){<span class="cstat-no" title="statement not covered" >this._invalidations={};<span class="cstat-no" title="statement not covered" >t</span>his._invalidationsByNodeId={};<span class="cstat-no" title="statement not covered" >t</span>his._lastRecalcStyle=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastPaintWithLayer=null;<span class="cstat-no" title="statement not covered" >t</span>his._didPaint=false;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.InvalidationTracker._invalidationTrackingEventsSymbol=Symbol('invalidationTrackingEvents');<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineAsyncEventTracker=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineAsyncEventTracker._initialize();<span class="cstat-no" title="statement not covered" >t</span>his._initiatorByType=new Map();<span class="cstat-no" title="statement not covered" >f</span>or(const initiator of TimelineModel.TimelineAsyncEventTracker._asyncEvents.keys())</span></span>
<span class="cstat-no" title="statement not covered" >this._initiatorByType.set(initiator,new Map());}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _initialize(){<span class="cstat-no" title="statement not covered" >if(TimelineModel.TimelineAsyncEventTracker._asyncEvents)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst events=<span class="cstat-no" title="statement not covered" >new Map();</span>let type=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>events.set(type.TimerInstall,{causes:[type.TimerFire],joinBy:'timerId'});<span class="cstat-no" title="statement not covered" >e</span>vents.set(type.ResourceSendRequest,{causes:[type.ResourceReceiveResponse,type.ResourceReceivedData,type.ResourceFinish],joinBy:'requestId'});<span class="cstat-no" title="statement not covered" >e</span>vents.set(type.RequestAnimationFrame,{causes:[type.FireAnimationFrame],joinBy:'id'});<span class="cstat-no" title="statement not covered" >e</span>vents.set(type.RequestIdleCallback,{causes:[type.FireIdleCallback],joinBy:'id'});<span class="cstat-no" title="statement not covered" >e</span>vents.set(type.WebSocketCreate,{causes:[type.WebSocketSendHandshakeRequest,type.WebSocketReceiveHandshakeResponse,type.WebSocketDestroy],joinBy:'identifier'});<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineAsyncEventTracker._asyncEvents=events;<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineAsyncEventTracker._typeToInitiator=new Map();<span class="cstat-no" title="statement not covered" >f</span>or(const entry of events){const types=<span class="cstat-no" title="statement not covered" >entry[1].causes;<span class="cstat-no" title="statement not covered" ></span>for(type of types)</span></span>
<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineAsyncEventTracker._typeToInitiator.set(type,entry[0]);}</span>}
<span class="fstat-no" title="function not covered" >pr</span>ocessEvent(event){let initiatorType=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineAsyncEventTracker._typeToInitiator.get((event.name));</span>const isInitiator=<span class="cstat-no" title="statement not covered" >!initiatorType;<span class="cstat-no" title="statement not covered" ></span>if(!initiatorType)</span>
<span class="cstat-no" title="statement not covered" >initiatorType=(event.name);c</span>onst initiatorInfo=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineAsyncEventTracker._asyncEvents.get(initiatorType);<span class="cstat-no" title="statement not covered" ></span>if(!initiatorInfo)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst id=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.globalEventId(event,initiatorInfo.joinBy);<span class="cstat-no" title="statement not covered" ></span>if(!id)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst initiatorMap=<span class="cstat-no" title="statement not covered" >this._initiatorByType.get(initiatorType);<span class="cstat-no" title="statement not covered" ></span>if(isInitiator){<span class="cstat-no" title="statement not covered" >initiatorMap.set(id,event);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const initiator=<span class="cstat-no" title="statement not covered" >initiatorMap.get(id)||null;</span>const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);<span class="cstat-no" title="statement not covered" ></span>timelineData.setInitiator(initiator);<span class="cstat-no" title="statement not covered" >i</span>f(!timelineData.frameId&amp;&amp;initiator)</span>
<span class="cstat-no" title="statement not covered" >timelineData.frameId=TimelineModel.TimelineModel.eventFrameId(initiator);}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.warning=null;<span class="cstat-no" title="statement not covered" >t</span>his.previewElement=null;<span class="cstat-no" title="statement not covered" >t</span>his.url=null;<span class="cstat-no" title="statement not covered" >t</span>his.backendNodeId=0;<span class="cstat-no" title="statement not covered" >t</span>his.stackTrace=null;<span class="cstat-no" title="statement not covered" >t</span>his.picture=null;<span class="cstat-no" title="statement not covered" >t</span>his._initiator=null;<span class="cstat-no" title="statement not covered" >t</span>his.frameId='';<span class="cstat-no" title="statement not covered" >t</span>his.timeWaitingForMainThread;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tInitiator(initiator){<span class="cstat-no" title="statement not covered" >this._initiator=initiator;<span class="cstat-no" title="statement not covered" >i</span>f(!initiator||this.url)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst initiatorURL=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(initiator).url;<span class="cstat-no" title="statement not covered" ></span>if(initiatorURL)</span>
<span class="cstat-no" title="statement not covered" >this.url=initiatorURL;}</span>
<span class="fstat-no" title="function not covered" >in</span>itiator(){<span class="cstat-no" title="statement not covered" >return this._initiator;}</span>
<span class="fstat-no" title="function not covered" >to</span>pFrame(){const stackTrace=<span class="cstat-no" title="statement not covered" >this.stackTraceForSelfOrInitiator();<span class="cstat-no" title="statement not covered" ></span>return stackTrace&amp;&amp;stackTrace[0]||null;}</span>
<span class="fstat-no" title="function not covered" >st</span>ackTraceForSelfOrInitiator(){<span class="cstat-no" title="statement not covered" >return this.stackTrace||(this._initiator&amp;&amp;TimelineModel.TimelineData.forEvent(this._initiator).stackTrace);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic forEvent(event){let data=<span class="cstat-no" title="statement not covered" >event[TimelineModel.TimelineData._symbol];<span class="cstat-no" title="statement not covered" ></span>if(!data){<span class="cstat-no" title="statement not covered" >data=new TimelineModel.TimelineData();<span class="cstat-no" title="statement not covered" >e</span>vent[TimelineModel.TimelineData._symbol]=data;}</span></span>
<span class="cstat-no" title="statement not covered" >return data;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData._symbol=Symbol('timelineData');;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineIRModel=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.reset();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic phaseForEvent(event){<span class="cstat-no" title="statement not covered" >return event[TimelineModel.TimelineIRModel._eventIRPhase];}</span>
<span class="fstat-no" title="function not covered" >po</span>pulate(inputLatencies,animations){<span class="cstat-no" title="statement not covered" >this.reset();<span class="cstat-no" title="statement not covered" >i</span>f(!inputLatencies)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._processInputLatencies(inputLatencies);<span class="cstat-no" title="statement not covered" >i</span>f(animations)</span>
<span class="cstat-no" title="statement not covered" >this._processAnimations(animations);c</span>onst range=<span class="cstat-no" title="statement not covered" >new Common.SegmentedRange();<span class="cstat-no" title="statement not covered" ></span>range.appendRange(this._drags);<span class="cstat-no" title="statement not covered" >r</span>ange.appendRange(this._cssAnimations);<span class="cstat-no" title="statement not covered" >r</span>ange.appendRange(this._scrolls);<span class="cstat-no" title="statement not covered" >r</span>ange.appendRange(this._responses);<span class="cstat-no" title="statement not covered" >t</span>his._segments=range.segments();}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessInputLatencies(events){const eventTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel.InputEvents;</span>const phases=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel.Phases;</span>const thresholdsMs=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel._mergeThresholdsMs;</span>let scrollStart;let flingStart;let touchStart;let firstTouchMove;let mouseWheel;let mouseDown;let mouseMove;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;events.length;++i){const event=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(i&gt;0&amp;&amp;events[i].startTime&lt;events[i-1].startTime)</span></span>
<span class="cstat-no" title="statement not covered" >console.assert(false,'Unordered input events');c</span>onst type=<span class="cstat-no" title="statement not covered" >this._inputEventType(event.name);<span class="cstat-no" title="statement not covered" ></span>switch(type){case eventTypes.ScrollBegin:<span class="cstat-no" title="statement not covered" >this._scrolls.append(this._segmentForEvent(event,phases.Scroll));<span class="cstat-no" title="statement not covered" >s</span>crollStart=event;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.ScrollEnd:<span class="cstat-no" title="statement not covered" >if(scrollStart)</span></span>
<span class="cstat-no" title="statement not covered" >this._scrolls.append(this._segmentForEventRange(scrollStart,event,phases.Scroll));e</span>lse
<span class="cstat-no" title="statement not covered" >this._scrolls.append(this._segmentForEvent(event,phases.Scroll));<span class="cstat-no" title="statement not covered" >s</span>crollStart=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.ScrollUpdate:<span class="cstat-no" title="statement not covered" >touchStart=null;<span class="cstat-no" title="statement not covered" >t</span>his._scrolls.append(this._segmentForEvent(event,phases.Scroll));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.FlingStart:<span class="cstat-no" title="statement not covered" >if(flingStart){<span class="cstat-no" title="statement not covered" >Common.console.error(Common.UIString('Two flings at the same time? %s vs %s',flingStart.startTime,event.startTime));<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
<span class="cstat-no" title="statement not covered" >flingStart=event;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.FlingCancel:<span class="cstat-no" title="statement not covered" >if(!flingStart)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span>his._scrolls.append(this._segmentForEventRange(flingStart,event,phases.Fling));<span class="cstat-no" title="statement not covered" >f</span>lingStart=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.ImplSideFling:<span class="cstat-no" title="statement not covered" >this._scrolls.append(this._segmentForEvent(event,phases.Fling));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.ShowPress:case eventTypes.Tap:case eventTypes.KeyDown:case eventTypes.KeyDownRaw:case eventTypes.KeyUp:case eventTypes.Char:case eventTypes.Click:case eventTypes.ContextMenu:<span class="cstat-no" title="statement not covered" >this._responses.append(this._segmentForEvent(event,phases.Response));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.TouchStart:<span class="cstat-no" title="statement not covered" >if(touchStart){<span class="cstat-no" title="statement not covered" >Common.console.error(Common.UIString('Two touches at the same time? %s vs %s',touchStart.startTime,event.startTime));<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
<span class="cstat-no" title="statement not covered" >touchStart=event;<span class="cstat-no" title="statement not covered" >e</span>vent.steps[0][TimelineModel.TimelineIRModel._eventIRPhase]=phases.Response;<span class="cstat-no" title="statement not covered" >f</span>irstTouchMove=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.TouchCancel:<span class="cstat-no" title="statement not covered" >touchStart=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.TouchMove:<span class="cstat-no" title="statement not covered" >if(firstTouchMove){<span class="cstat-no" title="statement not covered" >this._drags.append(this._segmentForEvent(event,phases.Drag));}</span>else <span class="cstat-no" title="statement not covered" >if(touchStart){<span class="cstat-no" title="statement not covered" >firstTouchMove=event;<span class="cstat-no" title="statement not covered" >t</span>his._responses.append(this._segmentForEventRange(touchStart,event,phases.Response));}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase eventTypes.TouchEnd:<span class="cstat-no" title="statement not covered" >touchStart=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.MouseDown:<span class="cstat-no" title="statement not covered" >mouseDown=event;<span class="cstat-no" title="statement not covered" >m</span>ouseMove=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.MouseMove:<span class="cstat-no" title="statement not covered" >if(mouseDown&amp;&amp;!mouseMove&amp;&amp;mouseDown.startTime+thresholdsMs.mouse&gt;event.startTime){<span class="cstat-no" title="statement not covered" >this._responses.append(this._segmentForEvent(mouseDown,phases.Response));<span class="cstat-no" title="statement not covered" >t</span>his._responses.append(this._segmentForEvent(event,phases.Response));}</span>else <span class="cstat-no" title="statement not covered" >if(mouseDown){<span class="cstat-no" title="statement not covered" >this._drags.append(this._segmentForEvent(event,phases.Drag));}</span></span></span>
<span class="cstat-no" title="statement not covered" >mouseMove=event;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.MouseUp:<span class="cstat-no" title="statement not covered" >this._responses.append(this._segmentForEvent(event,phases.Response));<span class="cstat-no" title="statement not covered" >m</span>ouseDown=null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase eventTypes.MouseWheel:<span class="cstat-no" title="statement not covered" >if(mouseWheel&amp;&amp;canMerge(thresholdsMs.mouse,mouseWheel,event))</span>
<span class="cstat-no" title="statement not covered" >this._scrolls.append(this._segmentForEventRange(mouseWheel,event,phases.Scroll));e</span>lse
<span class="cstat-no" title="statement not covered" >this._scrolls.append(this._segmentForEvent(event,phases.Scroll));<span class="cstat-no" title="statement not covered" >m</span>ouseWheel=event;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}
function <span class="fstat-no" title="function not covered" >canMerge(</span>threshold,first,second){<span class="cstat-no" title="statement not covered" >return first.endTime&lt;second.startTime&amp;&amp;second.startTime&lt;first.endTime+threshold;}</span>}
<span class="fstat-no" title="function not covered" >_p</span>rocessAnimations(events){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;events.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._cssAnimations.append(this._segmentForEvent(events[i],TimelineModel.TimelineIRModel.Phases.Animation));}</span>
<span class="fstat-no" title="function not covered" >_s</span>egmentForEvent(event,phase){<span class="cstat-no" title="statement not covered" >this._setPhaseForEvent(event,phase);<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Segment(event.startTime,event.endTime,phase);}</span>
<span class="fstat-no" title="function not covered" >_s</span>egmentForEventRange(startEvent,endEvent,phase){<span class="cstat-no" title="statement not covered" >this._setPhaseForEvent(startEvent,phase);<span class="cstat-no" title="statement not covered" >t</span>his._setPhaseForEvent(endEvent,phase);<span class="cstat-no" title="statement not covered" >r</span>eturn new Common.Segment(startEvent.startTime,endEvent.endTime,phase);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etPhaseForEvent(asyncEvent,phase){<span class="cstat-no" title="statement not covered" >asyncEvent.steps[0][TimelineModel.TimelineIRModel._eventIRPhase]=phase;}</span>
<span class="fstat-no" title="function not covered" >in</span>teractionRecords(){<span class="cstat-no" title="statement not covered" >return this._segments;}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){const thresholdsMs=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel._mergeThresholdsMs;<span class="cstat-no" title="statement not covered" ></span>this._segments=[];<span class="cstat-no" title="statement not covered" >t</span>his._drags=new Common.SegmentedRange(merge.bind(null,thresholdsMs.mouse));<span class="cstat-no" title="statement not covered" >t</span>his._cssAnimations=new Common.SegmentedRange(merge.bind(null,thresholdsMs.animation));<span class="cstat-no" title="statement not covered" >t</span>his._responses=new Common.SegmentedRange(merge.bind(null,0));<span class="cstat-no" title="statement not covered" >t</span>his._scrolls=new Common.SegmentedRange(merge.bind(null,thresholdsMs.animation));f</span>unction <span class="fstat-no" title="function not covered" >merge(</span>threshold,first,second){<span class="cstat-no" title="statement not covered" >return first.end+threshold&gt;=second.begin&amp;&amp;first.data===second.data?first:null;}</span>}
<span class="fstat-no" title="function not covered" >_i</span>nputEventType(eventName){const prefix=<span class="cstat-no" title="statement not covered" >'InputLatency::';<span class="cstat-no" title="statement not covered" ></span>if(!eventName.startsWith(prefix)){<span class="cstat-no" title="statement not covered" >if(eventName===TimelineModel.TimelineIRModel.InputEvents.ImplSideFling)</span></span>
<span class="cstat-no" title="statement not covered" >return(eventName);<span class="cstat-no" title="statement not covered" >c</span>onsole.error('Unrecognized input latency event: '+eventName);<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>
<span class="cstat-no" title="statement not covered" >return(eventName.substr(prefix.length));}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel.Phases={Idle:'Idle',Response:'Response',Scroll:'Scroll',Fling:'Fling',Drag:'Drag',Animation:'Animation',Uncategorized:'Uncategorized'};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineIRModel.InputEvents={Char:'Char',Click:'GestureClick',ContextMenu:'ContextMenu',FlingCancel:'GestureFlingCancel',FlingStart:'GestureFlingStart',ImplSideFling:TimelineModel.TimelineModel.RecordType.ImplSideFling,KeyDown:'KeyDown',KeyDownRaw:'RawKeyDown',KeyUp:'KeyUp',LatencyScrollUpdate:'ScrollUpdate',MouseDown:'MouseDown',MouseMove:'MouseMove',MouseUp:'MouseUp',MouseWheel:'MouseWheel',PinchBegin:'GesturePinchBegin',PinchEnd:'GesturePinchEnd',PinchUpdate:'GesturePinchUpdate',ScrollBegin:'GestureScrollBegin',ScrollEnd:'GestureScrollEnd',ScrollUpdate:'GestureScrollUpdate',ScrollUpdateRenderer:'ScrollUpdate',ShowPress:'GestureShowPress',Tap:'GestureTap',TapCancel:'GestureTapCancel',TapDown:'GestureTapDown',TouchCancel:'TouchCancel',TouchEnd:'TouchEnd',TouchMove:'TouchMove',TouchStart:'TouchStart'};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineIRModel._mergeThresholdsMs={animation:1,mouse:40,};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineIRModel._eventIRPhase=Symbol('eventIRPhase');;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineJSProfileProcessor=class{<span class="fstat-no" title="function not covered" >st</span>atic generateTracingEventsFromCpuProfile(jsProfileModel,thread){const idleNode=<span class="cstat-no" title="statement not covered" >jsProfileModel.idleNode;</span>const programNode=<span class="cstat-no" title="statement not covered" >jsProfileModel.programNode;</span>const gcNode=<span class="cstat-no" title="statement not covered" >jsProfileModel.gcNode;</span>const samples=<span class="cstat-no" title="statement not covered" >jsProfileModel.samples;</span>const timestamps=<span class="cstat-no" title="statement not covered" >jsProfileModel.timestamps;</span>const jsEvents=<span class="cstat-no" title="statement not covered" >[];</span>const nodeToStackMap=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>nodeToStackMap.set(programNode,[]);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;samples.length;++i){let node=<span class="cstat-no" title="statement not covered" >jsProfileModel.nodeByIndex(i);<span class="cstat-no" title="statement not covered" ></span>if(!node){<span class="cstat-no" title="statement not covered" >console.error(`Node with unknown id ${samples[i]} at index ${i}`);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(node===gcNode||node===idleNode)</span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et callFrames=<span class="cstat-no" title="statement not covered" >nodeToStackMap.get(node);<span class="cstat-no" title="statement not covered" ></span>if(!callFrames){<span class="cstat-no" title="statement not covered" >callFrames=(new Array(node.depth+1));<span class="cstat-no" title="statement not covered" >n</span>odeToStackMap.set(node,callFrames);<span class="cstat-no" title="statement not covered" >f</span>or(let j=0;node.parent;node=node.parent)</span></span>
<span class="cstat-no" title="statement not covered" >callFrames[j++]=(node);}</span>
const jsSampleEvent=<span class="cstat-no" title="statement not covered" >new SDK.TracingModel.Event(SDK.TracingModel.DevToolsTimelineEventCategory,TimelineModel.TimelineModel.RecordType.JSSample,SDK.TracingModel.Phase.Instant,timestamps[i],thread);<span class="cstat-no" title="statement not covered" ></span>jsSampleEvent.args['data']={stackTrace:callFrames};<span class="cstat-no" title="statement not covered" >j</span>sEvents.push(jsSampleEvent);}</span>
<span class="cstat-no" title="statement not covered" >return jsEvents;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic generateJSFrameEvents(events){function <span class="fstat-no" title="function not covered" >equalFrames(</span>frame1,frame2){<span class="cstat-no" title="statement not covered" >return frame1.scriptId===frame2.scriptId&amp;&amp;frame1.functionName===frame2.functionName&amp;&amp;frame1.lineNumber===frame2.lineNumber;}</span>
function <span class="fstat-no" title="function not covered" >isJSInvocationEvent(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.name){case TimelineModel.TimelineModel.RecordType.RunMicrotasks:case TimelineModel.TimelineModel.RecordType.FunctionCall:case TimelineModel.TimelineModel.RecordType.EvaluateScript:case TimelineModel.TimelineModel.RecordType.EvaluateModule:case TimelineModel.TimelineModel.RecordType.EventDispatch:case TimelineModel.TimelineModel.RecordType.V8Execute:<span class="cstat-no" title="statement not covered" >return true;}</span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
const jsFrameEvents=<span class="cstat-no" title="statement not covered" >[];</span>const jsFramesStack=<span class="cstat-no" title="statement not covered" >[];</span>const lockedJsStackDepth=<span class="cstat-no" title="statement not covered" >[];</span>let ordinal=<span class="cstat-no" title="statement not covered" >0;</span>const showAllEvents=<span class="cstat-no" title="statement not covered" >Runtime.experiments.isEnabled('timelineShowAllEvents');</span>const showRuntimeCallStats=<span class="cstat-no" title="statement not covered" >Runtime.experiments.isEnabled('timelineV8RuntimeCallStats');</span>const showNativeFunctions=<span class="cstat-no" title="statement not covered" >Common.moduleSetting('showNativeFunctionsInJSProfile').get();</span>function <span class="fstat-no" title="function not covered" >onStartEvent(</span>e){<span class="cstat-no" title="statement not covered" >e.ordinal=++ordinal;<span class="cstat-no" title="statement not covered" >e</span>xtractStackTrace(e);<span class="cstat-no" title="statement not covered" >l</span>ockedJsStackDepth.push(jsFramesStack.length);}</span>
function <span class="fstat-no" title="function not covered" >onInstantEvent(</span>e,parent){<span class="cstat-no" title="statement not covered" >e.ordinal=++ordinal;<span class="cstat-no" title="statement not covered" >i</span>f(parent&amp;&amp;isJSInvocationEvent(parent))</span>
<span class="cstat-no" title="statement not covered" >extractStackTrace(e);}</span>
function <span class="fstat-no" title="function not covered" >onEndEvent(</span>e){<span class="cstat-no" title="statement not covered" >truncateJSStack(lockedJsStackDepth.pop(),e.endTime);}</span>
function <span class="fstat-no" title="function not covered" >truncateJSStack(</span>depth,time){<span class="cstat-no" title="statement not covered" >if(lockedJsStackDepth.length){const lockedDepth=<span class="cstat-no" title="statement not covered" >lockedJsStackDepth.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(depth&lt;lockedDepth){<span class="cstat-no" title="statement not covered" >console.error(`Child stack is shallower (${depth}) than the parent stack (${lockedDepth}) at ${time}`);<span class="cstat-no" title="statement not covered" >d</span>epth=lockedDepth;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(jsFramesStack.length&lt;depth){<span class="cstat-no" title="statement not covered" >console.error(`Trying to truncate higher than the current stack size at ${time}`);<span class="cstat-no" title="statement not covered" >d</span>epth=jsFramesStack.length;}</span></span>
<span class="cstat-no" title="statement not covered" >for(let k=0;k&lt;jsFramesStack.length;++k)</span>
<span class="cstat-no" title="statement not covered" >jsFramesStack[k].setEndTime(time);<span class="cstat-no" title="statement not covered" >j</span>sFramesStack.length=depth;}</span>
function <span class="fstat-no" title="function not covered" >showNativeName(</span>name){<span class="cstat-no" title="statement not covered" >return showRuntimeCallStats&amp;&amp;!!TimelineModel.TimelineJSProfileProcessor.nativeGroup(name);}</span>
function <span class="fstat-no" title="function not covered" >filterStackFrames(</span>stack){<span class="cstat-no" title="statement not covered" >if(showAllEvents)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et previousNativeFrameName=<span class="cstat-no" title="statement not covered" >null;</span>let j=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;stack.length;++i){const frame=<span class="cstat-no" title="statement not covered" >stack[i];</span>const url=<span class="cstat-no" title="statement not covered" >frame.url;</span>const isNativeFrame=<span class="cstat-no" title="statement not covered" >url&amp;&amp;url.startsWith('native ');<span class="cstat-no" title="statement not covered" ></span>if(!showNativeFunctions&amp;&amp;isNativeFrame)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst isNativeRuntimeFrame=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineJSProfileProcessor.isNativeRuntimeFrame(frame);<span class="cstat-no" title="statement not covered" ></span>if(isNativeRuntimeFrame&amp;&amp;!showNativeName(frame.functionName))</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst nativeFrameName=<span class="cstat-no" title="statement not covered" >isNativeRuntimeFrame?TimelineModel.TimelineJSProfileProcessor.nativeGroup(frame.functionName):null;<span class="cstat-no" title="statement not covered" ></span>if(previousNativeFrameName&amp;&amp;previousNativeFrameName===nativeFrameName)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span>reviousNativeFrameName=nativeFrameName;<span class="cstat-no" title="statement not covered" >s</span>tack[j++]=frame;}</span>
<span class="cstat-no" title="statement not covered" >stack.length=j;}</span>
function <span class="fstat-no" title="function not covered" >extractStackTrace(</span>e){const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const callFrames=<span class="cstat-no" title="statement not covered" >e.name===recordTypes.JSSample?e.args['data']['stackTrace'].slice().reverse():jsFramesStack.map(<span class="fstat-no" title="function not covered" >fr</span>ameEvent=&gt;<span class="cstat-no" title="statement not covered" >frameEvent.args['data'])</span>;<span class="cstat-no" title="statement not covered" ></span>filterStackFrames(callFrames);c</span>onst endTime=<span class="cstat-no" title="statement not covered" >e.endTime||e.startTime;</span>const minFrames=<span class="cstat-no" title="statement not covered" >Math.min(callFrames.length,jsFramesStack.length);</span>let i;<span class="cstat-no" title="statement not covered" >for(i=lockedJsStackDepth.peekLast()||0;i&lt;minFrames;++i){const newFrame=<span class="cstat-no" title="statement not covered" >callFrames[i];</span>const oldFrame=<span class="cstat-no" title="statement not covered" >jsFramesStack[i].args['data'];<span class="cstat-no" title="statement not covered" ></span>if(!equalFrames(newFrame,oldFrame))</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >j</span>sFramesStack[i].setEndTime(Math.max(jsFramesStack[i].endTime,endTime));}</span>
<span class="cstat-no" title="statement not covered" >truncateJSStack(i,e.startTime);<span class="cstat-no" title="statement not covered" >f</span>or(;i&lt;callFrames.length;++i){const frame=<span class="cstat-no" title="statement not covered" >callFrames[i];</span>const jsFrameEvent=<span class="cstat-no" title="statement not covered" >new SDK.TracingModel.Event(SDK.TracingModel.DevToolsTimelineEventCategory,recordTypes.JSFrame,SDK.TracingModel.Phase.Complete,e.startTime,e.thread);<span class="cstat-no" title="statement not covered" ></span>jsFrameEvent.ordinal=e.ordinal;<span class="cstat-no" title="statement not covered" >j</span>sFrameEvent.addArgs({data:frame});<span class="cstat-no" title="statement not covered" >j</span>sFrameEvent.setEndTime(endTime);<span class="cstat-no" title="statement not covered" >j</span>sFramesStack.push(jsFrameEvent);<span class="cstat-no" title="statement not covered" >j</span>sFrameEvents.push(jsFrameEvent);}</span>}</span>
const firstTopLevelEvent=<span class="cstat-no" title="statement not covered" >events.find(SDK.TracingModel.isTopLevelEvent);</span>const startTime=<span class="cstat-no" title="statement not covered" >firstTopLevelEvent?firstTopLevelEvent.startTime:0;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineModel.forEachEvent(events,onStartEvent,onEndEvent,onInstantEvent,startTime);<span class="cstat-no" title="statement not covered" >r</span>eturn jsFrameEvents;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic isNativeRuntimeFrame(frame){<span class="cstat-no" title="statement not covered" >return frame.url==='native V8Runtime';}</span>
<span class="fstat-no" title="function not covered" >st</span>atic nativeGroup(nativeName){<span class="cstat-no" title="statement not covered" >if(nativeName.startsWith('Parse'))</span>
<span class="cstat-no" title="statement not covered" >return TimelineModel.TimelineJSProfileProcessor.NativeGroups.Parse;<span class="cstat-no" title="statement not covered" >i</span>f(nativeName.startsWith('Compile')||nativeName.startsWith('Recompile'))</span>
<span class="cstat-no" title="statement not covered" >return TimelineModel.TimelineJSProfileProcessor.NativeGroups.Compile;<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic buildTraceProfileFromCpuProfile(profile,tid,injectPageEvent,name){const events=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(injectPageEvent)</span>
<span class="cstat-no" title="statement not covered" >appendEvent('TracingStartedInPage',{data:{'sessionId':'1'}},0,0,'M');<span class="cstat-no" title="statement not covered" >i</span>f(!name)</span>
<span class="cstat-no" title="statement not covered" >name=ls`Thread ${tid}`;<span class="cstat-no" title="statement not covered" >a</span>ppendEvent(SDK.TracingModel.MetadataEvent.ThreadName,{name},0,0,'M','__metadata');<span class="cstat-no" title="statement not covered" >i</span>f(!profile)</span>
<span class="cstat-no" title="statement not covered" >return events;c</span>onst idToNode=<span class="cstat-no" title="statement not covered" >new Map();</span>const nodes=<span class="cstat-no" title="statement not covered" >profile['nodes'];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;nodes.length;++i)</span>
<span class="cstat-no" title="statement not covered" >idToNode.set(nodes[i].id,nodes[i]);l</span>et programEvent=<span class="cstat-no" title="statement not covered" >null;</span>let functionEvent=<span class="cstat-no" title="statement not covered" >null;</span>let nextTime=<span class="cstat-no" title="statement not covered" >profile.startTime;</span>let currentTime;const samples=<span class="cstat-no" title="statement not covered" >profile['samples'];</span>const timeDeltas=<span class="cstat-no" title="statement not covered" >profile['timeDeltas'];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;samples.length;++i){<span class="cstat-no" title="statement not covered" >currentTime=nextTime;<span class="cstat-no" title="statement not covered" >n</span>extTime+=timeDeltas[i];c</span>onst node=<span class="cstat-no" title="statement not covered" >idToNode.get(samples[i]);</span>const name=<span class="cstat-no" title="statement not covered" >node.callFrame.functionName;<span class="cstat-no" title="statement not covered" ></span>if(name==='(idle)'){<span class="cstat-no" title="statement not covered" >closeEvents();<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!programEvent)</span>
<span class="cstat-no" title="statement not covered" >programEvent=appendEvent('MessageLoop::RunTask',{},currentTime,0,'X','toplevel');<span class="cstat-no" title="statement not covered" >i</span>f(name==='(program)'){<span class="cstat-no" title="statement not covered" >if(functionEvent){<span class="cstat-no" title="statement not covered" >functionEvent.dur=currentTime-functionEvent.ts;<span class="cstat-no" title="statement not covered" >f</span>unctionEvent=null;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!functionEvent)</span></span>
<span class="cstat-no" title="statement not covered" >functionEvent=appendEvent('FunctionCall',{data:{'sessionId':'1'}},currentTime);}</span>}
<span class="cstat-no" title="statement not covered" >closeEvents();<span class="cstat-no" title="statement not covered" >a</span>ppendEvent('CpuProfile',{data:{'cpuProfile':profile}},profile.endTime,0,'I');<span class="cstat-no" title="statement not covered" >r</span>eturn events;f</span>unction <span class="fstat-no" title="function not covered" >closeEvents(</span>){<span class="cstat-no" title="statement not covered" >if(programEvent)</span>
<span class="cstat-no" title="statement not covered" >programEvent.dur=currentTime-programEvent.ts;<span class="cstat-no" title="statement not covered" >i</span>f(functionEvent)</span>
<span class="cstat-no" title="statement not covered" >functionEvent.dur=currentTime-functionEvent.ts;<span class="cstat-no" title="statement not covered" >p</span>rogramEvent=null;<span class="cstat-no" title="statement not covered" >f</span>unctionEvent=null;}</span>
function <span class="fstat-no" title="function not covered" >appendEvent(</span>name,args,ts,dur,ph,cat){const event=(<span class="cstat-no" title="statement not covered" >{cat:cat||'disabled-by-default-devtools.timeline',name,ph:ph||'X',pid:1,tid,ts,args})</span>;<span class="cstat-no" title="statement not covered" >if(dur)</span>
<span class="cstat-no" title="statement not covered" >event.dur=dur;<span class="cstat-no" title="statement not covered" >e</span>vents.push(event);<span class="cstat-no" title="statement not covered" >r</span>eturn event;}</span>}};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineJSProfileProcessor.NativeGroups={'Compile':'Compile','Parse':'Parse'};;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineFrameModel=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(categoryMapper){<span class="cstat-no" title="statement not covered" >this._categoryMapper=categoryMapper;<span class="cstat-no" title="statement not covered" >t</span>his.reset();}</span></span>
<span class="fstat-no" title="function not covered" >fr</span>ames(startTime,endTime){<span class="cstat-no" title="statement not covered" >if(!startTime&amp;&amp;!endTime)</span>
<span class="cstat-no" title="statement not covered" >return this._frames;c</span>onst firstFrame=<span class="cstat-no" title="statement not covered" >this._frames.lowerBound(startTime||0,<span class="fstat-no" title="function not covered" >(t</span>ime,frame)=&gt;<span class="cstat-no" title="statement not covered" >time-frame.endTime)</span>;</span>const lastFrame=<span class="cstat-no" title="statement not covered" >this._frames.lowerBound(endTime||Infinity,<span class="fstat-no" title="function not covered" >(t</span>ime,frame)=&gt;<span class="cstat-no" title="statement not covered" >time-frame.startTime)</span>;<span class="cstat-no" title="statement not covered" ></span>return this._frames.slice(firstFrame,lastFrame);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sRasterTile(rasterTask){const data=<span class="cstat-no" title="statement not covered" >rasterTask.args['tileData'];<span class="cstat-no" title="statement not covered" ></span>if(!data)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst frameId=<span class="cstat-no" title="statement not covered" >data['sourceFrameNumber'];</span>const frame=<span class="cstat-no" title="statement not covered" >frameId&amp;&amp;this._frameById[frameId];<span class="cstat-no" title="statement not covered" ></span>if(!frame||!frame.layerTree)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >ra</span>sterTilePromise(rasterTask){<span class="cstat-no" title="statement not covered" >if(!this._target)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve(null);c</span>onst data=<span class="cstat-no" title="statement not covered" >rasterTask.args['tileData'];</span>const frameId=<span class="cstat-no" title="statement not covered" >data['sourceFrameNumber'];</span>const tileId=<span class="cstat-no" title="statement not covered" >data['tileId']&amp;&amp;data['tileId']['id_ref'];</span>const frame=<span class="cstat-no" title="statement not covered" >frameId&amp;&amp;this._frameById[frameId];<span class="cstat-no" title="statement not covered" ></span>if(!frame||!frame.layerTree||!tileId)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve(null);<span class="cstat-no" title="statement not covered" >r</span>eturn frame.layerTree.layerTreePromise().then(<span class="fstat-no" title="function not covered" >la</span>yerTree=&gt;<span class="cstat-no" title="statement not covered" >layerTree&amp;&amp;layerTree.pictureForRasterTile(tileId))</span>;}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._minimumRecordTime=Infinity;<span class="cstat-no" title="statement not covered" >t</span>his._frames=[];<span class="cstat-no" title="statement not covered" >t</span>his._frameById={};<span class="cstat-no" title="statement not covered" >t</span>his._lastFrame=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastLayerTree=null;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameCommitted=false;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameRequested=false;<span class="cstat-no" title="statement not covered" >t</span>his._framePendingCommit=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastBeginFrame=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastNeedsBeginFrame=null;<span class="cstat-no" title="statement not covered" >t</span>his._framePendingActivation=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastTaskBeginTime=null;<span class="cstat-no" title="statement not covered" >t</span>his._target=null;<span class="cstat-no" title="statement not covered" >t</span>his._layerTreeId=null;<span class="cstat-no" title="statement not covered" >t</span>his._currentTaskTimeByCategory={};}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleBeginFrame(startTime){<span class="cstat-no" title="statement not covered" >if(!this._lastFrame)</span>
<span class="cstat-no" title="statement not covered" >this._startFrame(startTime);<span class="cstat-no" title="statement not covered" >t</span>his._lastBeginFrame=startTime;}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleDrawFrame(startTime){<span class="cstat-no" title="statement not covered" >if(!this._lastFrame){<span class="cstat-no" title="statement not covered" >this._startFrame(startTime);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._mainFrameCommitted||!this._mainFrameRequested){<span class="cstat-no" title="statement not covered" >if(this._lastNeedsBeginFrame){const idleTimeEnd=<span class="cstat-no" title="statement not covered" >this._framePendingActivation?this._framePendingActivation.triggerTime:(this._lastBeginFrame||this._lastNeedsBeginFrame);<span class="cstat-no" title="statement not covered" ></span>if(idleTimeEnd&gt;this._lastFrame.startTime){<span class="cstat-no" title="statement not covered" >this._lastFrame.idle=true;<span class="cstat-no" title="statement not covered" >t</span>his._startFrame(idleTimeEnd);<span class="cstat-no" title="statement not covered" >i</span>f(this._framePendingActivation)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this._commitPendingFrame();<span class="cstat-no" title="statement not covered" >t</span>his._lastBeginFrame=null;}</span>
<span class="cstat-no" title="statement not covered" >this._lastNeedsBeginFrame=null;}</span>
<span class="cstat-no" title="statement not covered" >this._startFrame(startTime);}</span>
<span class="cstat-no" title="statement not covered" >this._mainFrameCommitted=false;}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleActivateLayerTree(){<span class="cstat-no" title="statement not covered" >if(!this._lastFrame)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._framePendingActivation&amp;&amp;!this._lastNeedsBeginFrame)</span>
<span class="cstat-no" title="statement not covered" >this._commitPendingFrame();}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleRequestMainThreadFrame(){<span class="cstat-no" title="statement not covered" >if(!this._lastFrame)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameRequested=true;}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleCompositeLayers(){<span class="cstat-no" title="statement not covered" >if(!this._framePendingCommit)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._framePendingActivation=this._framePendingCommit;<span class="cstat-no" title="statement not covered" >t</span>his._framePendingCommit=null;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameRequested=false;<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameCommitted=true;}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleLayerTreeSnapshot(layerTree){<span class="cstat-no" title="statement not covered" >this._lastLayerTree=layerTree;}</span>
<span class="fstat-no" title="function not covered" >ha</span>ndleNeedFrameChanged(startTime,needsBeginFrame){<span class="cstat-no" title="statement not covered" >if(needsBeginFrame)</span>
<span class="cstat-no" title="statement not covered" >this._lastNeedsBeginFrame=startTime;}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartFrame(startTime){<span class="cstat-no" title="statement not covered" >if(this._lastFrame)</span>
<span class="cstat-no" title="statement not covered" >this._flushFrame(this._lastFrame,startTime);<span class="cstat-no" title="statement not covered" >t</span>his._lastFrame=new TimelineModel.TimelineFrame(startTime,startTime-this._minimumRecordTime);}</span>
<span class="fstat-no" title="function not covered" >_f</span>lushFrame(frame,endTime){<span class="cstat-no" title="statement not covered" >frame._setLayerTree(this._lastLayerTree);<span class="cstat-no" title="statement not covered" >f</span>rame._setEndTime(endTime);<span class="cstat-no" title="statement not covered" >i</span>f(this._lastLayerTree)</span>
<span class="cstat-no" title="statement not covered" >this._lastLayerTree._setPaints(frame._paints);<span class="cstat-no" title="statement not covered" >i</span>f(this._frames.length&amp;&amp;(frame.startTime!==this._frames.peekLast().endTime||frame.startTime&gt;frame.endTime)){<span class="cstat-no" title="statement not covered" >console.assert(false,`Inconsistent frame time for frame ${this._frames.length} (${frame.startTime} - ${frame.endTime})`);}</span></span>
<span class="cstat-no" title="statement not covered" >this._frames.push(frame);<span class="cstat-no" title="statement not covered" >i</span>f(typeof frame._mainFrameId==='number')</span>
<span class="cstat-no" title="statement not covered" >this._frameById[frame._mainFrameId]=frame;}</span>
<span class="fstat-no" title="function not covered" >_c</span>ommitPendingFrame(){<span class="cstat-no" title="statement not covered" >this._lastFrame._addTimeForCategories(this._framePendingActivation.timeByCategory);<span class="cstat-no" title="statement not covered" >t</span>his._lastFrame._paints=this._framePendingActivation.paints;<span class="cstat-no" title="statement not covered" >t</span>his._lastFrame._mainFrameId=this._framePendingActivation.mainFrameId;<span class="cstat-no" title="statement not covered" >t</span>his._framePendingActivation=null;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dTraceEvents(target,events,threadData){<span class="cstat-no" title="statement not covered" >this._target=target;l</span>et j=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this._currentProcessMainThread=threadData.length&amp;&amp;threadData[0].thread||null;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;events.length;++i){<span class="cstat-no" title="statement not covered" >while(j+1&lt;threadData.length&amp;&amp;threadData[j+1].time&lt;=events[i].startTime)</span></span>
<span class="cstat-no" title="statement not covered" >this._currentProcessMainThread=threadData[++j].thread;<span class="cstat-no" title="statement not covered" >t</span>his._addTraceEvent(events[i]);}</span>
<span class="cstat-no" title="statement not covered" >this._currentProcessMainThread=null;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddTraceEvent(event){const eventNames=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>if(event.startTime&amp;&amp;event.startTime&lt;this._minimumRecordTime)</span>
<span class="cstat-no" title="statement not covered" >this._minimumRecordTime=event.startTime;<span class="cstat-no" title="statement not covered" >i</span>f(event.name===eventNames.SetLayerTreeId){<span class="cstat-no" title="statement not covered" >this._layerTreeId=event.args['layerTreeId']||event.args['data']['layerTreeId'];}</span>else <span class="cstat-no" title="statement not covered" >if(event.phase===SDK.TracingModel.Phase.SnapshotObject&amp;&amp;event.name===eventNames.LayerTreeHostImplSnapshot&amp;&amp;parseInt(event.id,0)===this._layerTreeId){const snapshot=(<span class="cstat-no" title="statement not covered" >event)</span>;<span class="cstat-no" title="statement not covered" >this.handleLayerTreeSnapshot(new TimelineModel.TracingFrameLayerTree(this._target,snapshot));}</span>else{<span class="cstat-no" title="statement not covered" >this._processCompositorEvents(event);<span class="cstat-no" title="statement not covered" >i</span>f(event.thread===this._currentProcessMainThread)</span></span></span>
<span class="cstat-no" title="statement not covered" >this._addMainThreadTraceEvent(event);e</span>lse <span class="cstat-no" title="statement not covered" >if(this._lastFrame&amp;&amp;event.selfTime&amp;&amp;!SDK.TracingModel.isTopLevelEvent(event))</span>
<span class="cstat-no" title="statement not covered" >this._lastFrame._addTimeForCategory(this._categoryMapper(event),event.selfTime);}</span>}
<span class="fstat-no" title="function not covered" >_p</span>rocessCompositorEvents(event){const eventNames=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>if(event.args['layerTreeId']!==this._layerTreeId)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timestamp=<span class="cstat-no" title="statement not covered" >event.startTime;<span class="cstat-no" title="statement not covered" ></span>if(event.name===eventNames.BeginFrame)</span>
<span class="cstat-no" title="statement not covered" >this.handleBeginFrame(timestamp);e</span>lse <span class="cstat-no" title="statement not covered" >if(event.name===eventNames.DrawFrame)</span>
<span class="cstat-no" title="statement not covered" >this.handleDrawFrame(timestamp);e</span>lse <span class="cstat-no" title="statement not covered" >if(event.name===eventNames.ActivateLayerTree)</span>
<span class="cstat-no" title="statement not covered" >this.handleActivateLayerTree();e</span>lse <span class="cstat-no" title="statement not covered" >if(event.name===eventNames.RequestMainThreadFrame)</span>
<span class="cstat-no" title="statement not covered" >this.handleRequestMainThreadFrame();e</span>lse <span class="cstat-no" title="statement not covered" >if(event.name===eventNames.NeedsBeginFrameChanged)</span>
<span class="cstat-no" title="statement not covered" >this.handleNeedFrameChanged(timestamp,event.args['data']&amp;&amp;event.args['data']['needsBeginFrame']);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddMainThreadTraceEvent(event){const eventNames=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>if(SDK.TracingModel.isTopLevelEvent(event)){<span class="cstat-no" title="statement not covered" >this._currentTaskTimeByCategory={};<span class="cstat-no" title="statement not covered" >t</span>his._lastTaskBeginTime=event.startTime;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!this._framePendingCommit&amp;&amp;TimelineModel.TimelineFrameModel._mainFrameMarkers.indexOf(event.name)&gt;=0){<span class="cstat-no" title="statement not covered" >this._framePendingCommit=new TimelineModel.PendingFrame(this._lastTaskBeginTime||event.startTime,this._currentTaskTimeByCategory);}</span></span>
<span class="cstat-no" title="statement not covered" >if(!this._framePendingCommit){<span class="cstat-no" title="statement not covered" >this._addTimeForCategory(this._currentTaskTimeByCategory,event);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._addTimeForCategory(this._framePendingCommit.timeByCategory,event);<span class="cstat-no" title="statement not covered" >i</span>f(event.name===eventNames.BeginMainThreadFrame&amp;&amp;event.args['data']&amp;&amp;event.args['data']['frameId'])</span>
<span class="cstat-no" title="statement not covered" >this._framePendingCommit.mainFrameId=event.args['data']['frameId'];<span class="cstat-no" title="statement not covered" >i</span>f(event.name===eventNames.Paint&amp;&amp;event.args['data']['layerId']&amp;&amp;TimelineModel.TimelineData.forEvent(event).picture&amp;&amp;this._target)</span>
<span class="cstat-no" title="statement not covered" >this._framePendingCommit.paints.push(new TimelineModel.LayerPaintEvent(event,this._target));<span class="cstat-no" title="statement not covered" >i</span>f(event.name===eventNames.CompositeLayers&amp;&amp;event.args['layerTreeId']===this._layerTreeId)</span>
<span class="cstat-no" title="statement not covered" >this.handleCompositeLayers();}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddTimeForCategory(timeByCategory,event){<span class="cstat-no" title="statement not covered" >if(!event.selfTime)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst categoryName=<span class="cstat-no" title="statement not covered" >this._categoryMapper(event);<span class="cstat-no" title="statement not covered" ></span>timeByCategory[categoryName]=(timeByCategory[categoryName]||0)+event.selfTime;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineFrameModel._mainFrameMarkers=[TimelineModel.TimelineModel.RecordType.ScheduleStyleRecalculation,TimelineModel.TimelineModel.RecordType.InvalidateLayout,TimelineModel.TimelineModel.RecordType.BeginMainThreadFrame,TimelineModel.TimelineModel.RecordType.ScrollLayer];<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TracingFrameLayerTree=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(target,snapshot){<span class="cstat-no" title="statement not covered" >this._target=target;<span class="cstat-no" title="statement not covered" >t</span>his._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._paints;}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync layerTreePromise(){const result=<span class="cstat-no" title="statement not covered" >await this._snapshot.objectPromise();<span class="cstat-no" title="statement not covered" ></span>if(!result)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst viewport=<span class="cstat-no" title="statement not covered" >result['device_viewport_size'];</span>const tiles=<span class="cstat-no" title="statement not covered" >result['active_tiles'];</span>const rootLayer=<span class="cstat-no" title="statement not covered" >result['active_tree']['root_layer'];</span>const layers=<span class="cstat-no" title="statement not covered" >result['active_tree']['layers'];</span>const layerTree=<span class="cstat-no" title="statement not covered" >new TimelineModel.TracingLayerTree(this._target);<span class="cstat-no" title="statement not covered" ></span>layerTree.setViewportSize(viewport);<span class="cstat-no" title="statement not covered" >l</span>ayerTree.setTiles(tiles);<span class="cstat-no" title="statement not covered" >a</span>wait layerTree.setLayers(rootLayer,layers,this._paints||[]);<span class="cstat-no" title="statement not covered" >r</span>eturn layerTree;}</span>
<span class="fstat-no" title="function not covered" >pa</span>ints(){<span class="cstat-no" title="statement not covered" >return this._paints||[];}</span>
<span class="fstat-no" title="function not covered" >_s</span>etPaints(paints){<span class="cstat-no" title="statement not covered" >this._paints=paints;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineFrame=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(startTime,startTimeOffset){<span class="cstat-no" title="statement not covered" >this.startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his.startTimeOffset=startTimeOffset;<span class="cstat-no" title="statement not covered" >t</span>his.endTime=this.startTime;<span class="cstat-no" title="statement not covered" >t</span>his.duration=0;<span class="cstat-no" title="statement not covered" >t</span>his.timeByCategory={};<span class="cstat-no" title="statement not covered" >t</span>his.cpuTime=0;<span class="cstat-no" title="statement not covered" >t</span>his.idle=false;<span class="cstat-no" title="statement not covered" >t</span>his.layerTree=null;<span class="cstat-no" title="statement not covered" >t</span>his._paints=[];<span class="cstat-no" title="statement not covered" >t</span>his._mainFrameId=undefined;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sWarnings(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etEndTime(endTime){<span class="cstat-no" title="statement not covered" >this.endTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his.duration=this.endTime-this.startTime;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etLayerTree(layerTree){<span class="cstat-no" title="statement not covered" >this.layerTree=layerTree;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddTimeForCategories(timeByCategory){<span class="cstat-no" title="statement not covered" >for(const category in timeByCategory)</span>
<span class="cstat-no" title="statement not covered" >this._addTimeForCategory(category,timeByCategory[category]);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddTimeForCategory(category,time){<span class="cstat-no" title="statement not covered" >this.timeByCategory[category]=(this.timeByCategory[category]||0)+time;<span class="cstat-no" title="statement not covered" >t</span>his.cpuTime+=time;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.LayerPaintEvent=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(event,target){<span class="cstat-no" title="statement not covered" >this._event=event;<span class="cstat-no" title="statement not covered" >t</span>his._target=target;}</span></span>
<span class="fstat-no" title="function not covered" >la</span>yerId(){<span class="cstat-no" title="statement not covered" >return this._event.args['data']['layerId'];}</span>
<span class="fstat-no" title="function not covered" >ev</span>ent(){<span class="cstat-no" title="statement not covered" >return this._event;}</span>
<span class="fstat-no" title="function not covered" >pi</span>cturePromise(){const picture=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(this._event).picture;<span class="cstat-no" title="statement not covered" ></span>return picture.objectPromise().then(<span class="fstat-no" title="function not covered" >re</span>sult=&gt;{<span class="cstat-no" title="statement not covered" >if(!result)</span></span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst rect=<span class="cstat-no" title="statement not covered" >result['params']&amp;&amp;result['params']['layer_rect'];</span>const picture=<span class="cstat-no" title="statement not covered" >result['skp64'];<span class="cstat-no" title="statement not covered" ></span>return rect&amp;&amp;picture?{rect:rect,serializedPicture:picture}:null;}</span>);}
<span class="fstat-no" title="function not covered" >sn</span>apshotPromise(){const paintProfilerModel=<span class="cstat-no" title="statement not covered" >this._target&amp;&amp;this._target.model(SDK.PaintProfilerModel);<span class="cstat-no" title="statement not covered" ></span>return this.picturePromise().then(<span class="fstat-no" title="function not covered" >pi</span>cture=&gt;{<span class="cstat-no" title="statement not covered" >if(!picture||!paintProfilerModel)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn paintProfilerModel.loadSnapshot(picture.serializedPicture).then(<span class="fstat-no" title="function not covered" >sn</span>apshot=&gt;<span class="cstat-no" title="statement not covered" >snapshot?{rect:picture.rect,snapshot:snapshot}:null)</span>;}</span>);}};<span class="cstat-no" title="statement not covered" >TimelineModel.PendingFrame=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(triggerTime,timeByCategory){<span class="cstat-no" title="statement not covered" >this.timeByCategory=timeByCategory;<span class="cstat-no" title="statement not covered" >t</span>his.paints=[];<span class="cstat-no" title="statement not covered" >t</span>his.mainFrameId=undefined;<span class="cstat-no" title="statement not covered" >t</span>his.triggerTime=triggerTime;}</span>};;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineProfileTree={};<span class="cstat-no" title="statement not covered" >T</span>imelineModel.TimelineProfileTree.Node=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,event){<span class="cstat-no" title="statement not covered" >this.totalTime=0;<span class="cstat-no" title="statement not covered" >t</span>his.selfTime=0;<span class="cstat-no" title="statement not covered" >t</span>his.id=id;<span class="cstat-no" title="statement not covered" >t</span>his.event=event;<span class="cstat-no" title="statement not covered" >t</span>his.parent;<span class="cstat-no" title="statement not covered" >t</span>his._groupId='';<span class="cstat-no" title="statement not covered" >t</span>his._isGroupNode=false;}</span></span>
<span class="fstat-no" title="function not covered" >is</span>GroupNode(){<span class="cstat-no" title="statement not covered" >return this._isGroupNode;}</span>
<span class="fstat-no" title="function not covered" >ha</span>sChildren(){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >throw'Not implemented';}</span>
<span class="fstat-no" title="function not covered" >se</span>archTree(matchFunction,results){<span class="cstat-no" title="statement not covered" >results=results||[];<span class="cstat-no" title="statement not covered" >i</span>f(this.event&amp;&amp;matchFunction(this.event))</span>
<span class="cstat-no" title="statement not covered" >results.push(this);<span class="cstat-no" title="statement not covered" >f</span>or(const child of this.children().values())</span>
<span class="cstat-no" title="statement not covered" >child.searchTree(matchFunction,results);<span class="cstat-no" title="statement not covered" >r</span>eturn results;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.TopDownNode=class extends TimelineModel.TimelineProfileTree.Node{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,event,parent){<span class="cstat-no" title="statement not covered" >super(id,event);<span class="cstat-no" title="statement not covered" >t</span>his._root=parent&amp;&amp;parent._root;<span class="cstat-no" title="statement not covered" >t</span>his._hasChildren=false;<span class="cstat-no" title="statement not covered" >t</span>his._children=null;<span class="cstat-no" title="statement not covered" >t</span>his.parent=parent;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sChildren(){<span class="cstat-no" title="statement not covered" >return this._hasChildren;}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >return this._children||this._buildChildren();}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildChildren(){const path=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let node=this;node.parent&amp;&amp;!node._isGroupNode;node=node.parent)</span>
<span class="cstat-no" title="statement not covered" >path.push((node));<span class="cstat-no" title="statement not covered" >p</span>ath.reverse();c</span>onst children=<span class="cstat-no" title="statement not covered" >new Map();</span>const self=<span class="cstat-no" title="statement not covered" >this;</span>const root=<span class="cstat-no" title="statement not covered" >this._root;</span>const startTime=<span class="cstat-no" title="statement not covered" >root._startTime;</span>const endTime=<span class="cstat-no" title="statement not covered" >root._endTime;</span>const instantEventCallback=<span class="cstat-no" title="statement not covered" >root._doNotAggregate?onInstantEvent:undefined;</span>const eventIdCallback=<span class="cstat-no" title="statement not covered" >root._doNotAggregate?undefined:TimelineModel.TimelineProfileTree._eventId;</span>const eventGroupIdCallback=<span class="cstat-no" title="statement not covered" >root._eventGroupIdCallback;</span>let depth=<span class="cstat-no" title="statement not covered" >0;</span>let matchedDepth=<span class="cstat-no" title="statement not covered" >0;</span>let currentDirectChild=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineModel.forEachEvent(root._events,onStartEvent,onEndEvent,instantEventCallback,startTime,endTime,root._filter);f</span>unction <span class="fstat-no" title="function not covered" >onStartEvent(</span>e){<span class="cstat-no" title="statement not covered" >++depth;<span class="cstat-no" title="statement not covered" >i</span>f(depth&gt;path.length+2)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!matchPath(e))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst duration=<span class="cstat-no" title="statement not covered" >Math.min(endTime,e.endTime)-Math.max(startTime,e.startTime);<span class="cstat-no" title="statement not covered" ></span>if(duration&lt;0)</span>
<span class="cstat-no" title="statement not covered" >console.error('Negative event duration');<span class="cstat-no" title="statement not covered" >p</span>rocessEvent(e,duration);}</span>
function <span class="fstat-no" title="function not covered" >onInstantEvent(</span>e){<span class="cstat-no" title="statement not covered" >++depth;<span class="cstat-no" title="statement not covered" >i</span>f(matchedDepth===path.length&amp;&amp;depth&lt;=path.length+2)</span>
<span class="cstat-no" title="statement not covered" >processEvent(e,0);<span class="cstat-no" title="statement not covered" >-</span>-depth;}</span>
function <span class="fstat-no" title="function not covered" >processEvent(</span>e,duration){<span class="cstat-no" title="statement not covered" >if(depth===path.length+2){<span class="cstat-no" title="statement not covered" >currentDirectChild._hasChildren=true;<span class="cstat-no" title="statement not covered" >c</span>urrentDirectChild.selfTime-=duration;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
let id;let groupId=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(!eventIdCallback){<span class="cstat-no" title="statement not covered" >id=Symbol('uniqueId');}</span>else{<span class="cstat-no" title="statement not covered" >id=eventIdCallback(e);<span class="cstat-no" title="statement not covered" >g</span>roupId=eventGroupIdCallback?eventGroupIdCallback(e):'';<span class="cstat-no" title="statement not covered" >i</span>f(groupId)</span></span>
<span class="cstat-no" title="statement not covered" >id+='/'+groupId;}</span>
let node=<span class="cstat-no" title="statement not covered" >children.get(id);<span class="cstat-no" title="statement not covered" ></span>if(!node){<span class="cstat-no" title="statement not covered" >node=new TimelineModel.TimelineProfileTree.TopDownNode(id,e,self);<span class="cstat-no" title="statement not covered" >n</span>ode._groupId=groupId;<span class="cstat-no" title="statement not covered" >c</span>hildren.set(id,node);}</span></span>
<span class="cstat-no" title="statement not covered" >node.selfTime+=duration;<span class="cstat-no" title="statement not covered" >n</span>ode.totalTime+=duration;<span class="cstat-no" title="statement not covered" >c</span>urrentDirectChild=node;}</span>
function <span class="fstat-no" title="function not covered" >matchPath(</span>e){<span class="cstat-no" title="statement not covered" >if(matchedDepth===path.length)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span>f(matchedDepth!==depth-1)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(!e.endTime)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(!eventIdCallback){<span class="cstat-no" title="statement not covered" >if(e===path[matchedDepth].event)</span></span>
<span class="cstat-no" title="statement not covered" >++matchedDepth;<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
let id=<span class="cstat-no" title="statement not covered" >eventIdCallback(e);</span>const groupId=<span class="cstat-no" title="statement not covered" >eventGroupIdCallback?eventGroupIdCallback(e):'';<span class="cstat-no" title="statement not covered" ></span>if(groupId)</span>
<span class="cstat-no" title="statement not covered" >id+='/'+groupId;<span class="cstat-no" title="statement not covered" >i</span>f(id===path[matchedDepth].id)</span>
<span class="cstat-no" title="statement not covered" >++matchedDepth;<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
function <span class="fstat-no" title="function not covered" >onEndEvent(</span>e){<span class="cstat-no" title="statement not covered" >--depth;<span class="cstat-no" title="statement not covered" >i</span>f(matchedDepth&gt;depth)</span>
<span class="cstat-no" title="statement not covered" >matchedDepth=depth;}</span>
<span class="cstat-no" title="statement not covered" >this._children=children;<span class="cstat-no" title="statement not covered" >r</span>eturn children;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.TopDownRootNode=class extends TimelineModel.TimelineProfileTree.TopDownNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(events,filters,startTime,endTime,doNotAggregate,eventGroupIdCallback){<span class="cstat-no" title="statement not covered" >super('',null,null);<span class="cstat-no" title="statement not covered" >t</span>his._root=this;<span class="cstat-no" title="statement not covered" >t</span>his._events=events;<span class="cstat-no" title="statement not covered" >t</span>his._filter=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >filters.every(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >f.accept(e))</span>;<span class="cstat-no" title="statement not covered" ></span>t</span>his._startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._endTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._eventGroupIdCallback=eventGroupIdCallback;<span class="cstat-no" title="statement not covered" >t</span>his._doNotAggregate=doNotAggregate;<span class="cstat-no" title="statement not covered" >t</span>his.totalTime=endTime-startTime;<span class="cstat-no" title="statement not covered" >t</span>his.selfTime=this.totalTime;}</span></span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >return this._children||this._grouppedTopNodes();}</span>
<span class="fstat-no" title="function not covered" >_g</span>rouppedTopNodes(){const flatNodes=<span class="cstat-no" title="statement not covered" >super.children();<span class="cstat-no" title="statement not covered" ></span>for(const node of flatNodes.values())</span>
<span class="cstat-no" title="statement not covered" >this.selfTime-=node.totalTime;<span class="cstat-no" title="statement not covered" >i</span>f(!this._eventGroupIdCallback)</span>
<span class="cstat-no" title="statement not covered" >return flatNodes;c</span>onst groupNodes=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(const node of flatNodes.values()){const groupId=<span class="cstat-no" title="statement not covered" >this._eventGroupIdCallback((node.event));</span>let groupNode=<span class="cstat-no" title="statement not covered" >groupNodes.get(groupId);<span class="cstat-no" title="statement not covered" ></span>if(!groupNode){<span class="cstat-no" title="statement not covered" >groupNode=new TimelineModel.TimelineProfileTree.GroupNode(groupId,this,(node.event));<span class="cstat-no" title="statement not covered" >g</span>roupNodes.set(groupId,groupNode);}</span></span></span>
<span class="cstat-no" title="statement not covered" >groupNode.addChild(node,node.selfTime,node.totalTime);}</span>
<span class="cstat-no" title="statement not covered" >this._children=groupNodes;<span class="cstat-no" title="statement not covered" >r</span>eturn groupNodes;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.BottomUpRootNode=class extends TimelineModel.TimelineProfileTree.Node{<span class="fstat-no" title="function not covered" >co</span>nstructor(events,filters,startTime,endTime,eventGroupIdCallback){<span class="cstat-no" title="statement not covered" >super('',null);<span class="cstat-no" title="statement not covered" >t</span>his._children=null;<span class="cstat-no" title="statement not covered" >t</span>his._events=events;<span class="cstat-no" title="statement not covered" >t</span>his._filter=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >filters.every(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >f.accept(e))</span>;<span class="cstat-no" title="statement not covered" ></span>t</span>his._startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._endTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._eventGroupIdCallback=eventGroupIdCallback;<span class="cstat-no" title="statement not covered" >t</span>his.totalTime=endTime-startTime;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sChildren(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >return this._children||this._grouppedTopNodes();}</span>
<span class="fstat-no" title="function not covered" >_u</span>ngrouppedTopNodes(){const root=<span class="cstat-no" title="statement not covered" >this;</span>const startTime=<span class="cstat-no" title="statement not covered" >this._startTime;</span>const endTime=<span class="cstat-no" title="statement not covered" >this._endTime;</span>const nodeById=<span class="cstat-no" title="statement not covered" >new Map();</span>const selfTimeStack=<span class="cstat-no" title="statement not covered" >[endTime-startTime];</span>const firstNodeStack=<span class="cstat-no" title="statement not covered" >[];</span>const totalTimeById=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineModel.forEachEvent(this._events,onStartEvent,onEndEvent,undefined,startTime,endTime,this._filter);f</span>unction <span class="fstat-no" title="function not covered" >onStartEvent(</span>e){const duration=<span class="cstat-no" title="statement not covered" >Math.min(e.endTime,endTime)-Math.max(e.startTime,startTime);<span class="cstat-no" title="statement not covered" ></span>selfTimeStack[selfTimeStack.length-1]-=duration;<span class="cstat-no" title="statement not covered" >s</span>elfTimeStack.push(duration);c</span>onst id=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree._eventId(e);</span>const noNodeOnStack=<span class="cstat-no" title="statement not covered" >!totalTimeById.has(id);<span class="cstat-no" title="statement not covered" ></span>if(noNodeOnStack)</span>
<span class="cstat-no" title="statement not covered" >totalTimeById.set(id,duration);<span class="cstat-no" title="statement not covered" >f</span>irstNodeStack.push(noNodeOnStack);}</span>
function <span class="fstat-no" title="function not covered" >onEndEvent(</span>e){const id=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree._eventId(e);</span>let node=<span class="cstat-no" title="statement not covered" >nodeById.get(id);<span class="cstat-no" title="statement not covered" ></span>if(!node){<span class="cstat-no" title="statement not covered" >node=new TimelineModel.TimelineProfileTree.BottomUpNode(root,id,e,false,root);<span class="cstat-no" title="statement not covered" >n</span>odeById.set(id,node);}</span></span>
<span class="cstat-no" title="statement not covered" >node.selfTime+=selfTimeStack.pop();<span class="cstat-no" title="statement not covered" >i</span>f(firstNodeStack.pop()){<span class="cstat-no" title="statement not covered" >node.totalTime+=totalTimeById.get(id);<span class="cstat-no" title="statement not covered" >t</span>otalTimeById.delete(id);}</span></span>
<span class="cstat-no" title="statement not covered" >if(firstNodeStack.length)</span>
<span class="cstat-no" title="statement not covered" >node.setHasChildren();}</span>
<span class="cstat-no" title="statement not covered" >this.selfTime=selfTimeStack.pop();<span class="cstat-no" title="statement not covered" >f</span>or(const pair of nodeById){<span class="cstat-no" title="statement not covered" >if(pair[1].selfTime&lt;=0)</span></span>
<span class="cstat-no" title="statement not covered" >nodeById.delete((pair[0]));}</span>
<span class="cstat-no" title="statement not covered" >return nodeById;}</span>
<span class="fstat-no" title="function not covered" >_g</span>rouppedTopNodes(){const flatNodes=<span class="cstat-no" title="statement not covered" >this._ungrouppedTopNodes();<span class="cstat-no" title="statement not covered" ></span>if(!this._eventGroupIdCallback){<span class="cstat-no" title="statement not covered" >this._children=flatNodes;<span class="cstat-no" title="statement not covered" >r</span>eturn flatNodes;}</span></span>
const groupNodes=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(const node of flatNodes.values()){const groupId=<span class="cstat-no" title="statement not covered" >this._eventGroupIdCallback((node.event));</span>let groupNode=<span class="cstat-no" title="statement not covered" >groupNodes.get(groupId);<span class="cstat-no" title="statement not covered" ></span>if(!groupNode){<span class="cstat-no" title="statement not covered" >groupNode=new TimelineModel.TimelineProfileTree.GroupNode(groupId,this,(node.event));<span class="cstat-no" title="statement not covered" >g</span>roupNodes.set(groupId,groupNode);}</span></span></span>
<span class="cstat-no" title="statement not covered" >groupNode.addChild(node,node.selfTime,node.selfTime);}</span>
<span class="cstat-no" title="statement not covered" >this._children=groupNodes;<span class="cstat-no" title="statement not covered" >r</span>eturn groupNodes;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.GroupNode=class extends TimelineModel.TimelineProfileTree.Node{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,parent,event){<span class="cstat-no" title="statement not covered" >super(id,event);<span class="cstat-no" title="statement not covered" >t</span>his._children=new Map();<span class="cstat-no" title="statement not covered" >t</span>his.parent=parent;<span class="cstat-no" title="statement not covered" >t</span>his._isGroupNode=true;}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dChild(child,selfTime,totalTime){<span class="cstat-no" title="statement not covered" >this._children.set(child.id,child);<span class="cstat-no" title="statement not covered" >t</span>his.selfTime+=selfTime;<span class="cstat-no" title="statement not covered" >t</span>his.totalTime+=totalTime;<span class="cstat-no" title="statement not covered" >c</span>hild.parent=this;}</span>
<span class="fstat-no" title="function not covered" >ha</span>sChildren(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >return this._children;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.BottomUpNode=class extends TimelineModel.TimelineProfileTree.Node{<span class="fstat-no" title="function not covered" >co</span>nstructor(root,id,event,hasChildren,parent){<span class="cstat-no" title="statement not covered" >super(id,event);<span class="cstat-no" title="statement not covered" >t</span>his.parent=parent;<span class="cstat-no" title="statement not covered" >t</span>his._root=root;<span class="cstat-no" title="statement not covered" >t</span>his._depth=(parent._depth||0)+1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedChildren=null;<span class="cstat-no" title="statement not covered" >t</span>his._hasChildren=hasChildren;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tHasChildren(){<span class="cstat-no" title="statement not covered" >this._hasChildren=true;}</span>
<span class="fstat-no" title="function not covered" >ha</span>sChildren(){<span class="cstat-no" title="statement not covered" >return this._hasChildren;}</span>
<span class="fstat-no" title="function not covered" >ch</span>ildren(){<span class="cstat-no" title="statement not covered" >if(this._cachedChildren)</span>
<span class="cstat-no" title="statement not covered" >return this._cachedChildren;c</span>onst selfTimeStack=<span class="cstat-no" title="statement not covered" >[0];</span>const eventIdStack=<span class="cstat-no" title="statement not covered" >[];</span>const eventStack=<span class="cstat-no" title="statement not covered" >[];</span>const nodeById=<span class="cstat-no" title="statement not covered" >new Map();</span>const startTime=<span class="cstat-no" title="statement not covered" >this._root._startTime;</span>const endTime=<span class="cstat-no" title="statement not covered" >this._root._endTime;</span>let lastTimeMarker=<span class="cstat-no" title="statement not covered" >startTime;</span>const self=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineModel.forEachEvent(this._root._events,onStartEvent,onEndEvent,undefined,startTime,endTime,this._root._filter);f</span>unction <span class="fstat-no" title="function not covered" >onStartEvent(</span>e){const duration=<span class="cstat-no" title="statement not covered" >Math.min(e.endTime,endTime)-Math.max(e.startTime,startTime);<span class="cstat-no" title="statement not covered" ></span>if(duration&lt;0)</span>
<span class="cstat-no" title="statement not covered" >console.assert(false,'Negative duration of an event');<span class="cstat-no" title="statement not covered" >s</span>elfTimeStack[selfTimeStack.length-1]-=duration;<span class="cstat-no" title="statement not covered" >s</span>elfTimeStack.push(duration);c</span>onst id=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree._eventId(e);<span class="cstat-no" title="statement not covered" ></span>eventIdStack.push(id);<span class="cstat-no" title="statement not covered" >e</span>ventStack.push(e);}</span>
function <span class="fstat-no" title="function not covered" >onEndEvent(</span>e){const selfTime=<span class="cstat-no" title="statement not covered" >selfTimeStack.pop();</span>const id=<span class="cstat-no" title="statement not covered" >eventIdStack.pop();<span class="cstat-no" title="statement not covered" ></span>eventStack.pop();l</span>et node;<span class="cstat-no" title="statement not covered" >for(node=self;node._depth&gt;1;node=node.parent){<span class="cstat-no" title="statement not covered" >if(node.id!==eventIdStack[eventIdStack.length+1-node._depth])</span></span>
<span class="cstat-no" title="statement not covered" >return;}</span>
<span class="cstat-no" title="statement not covered" >if(node.id!==id||eventIdStack.length&lt;self._depth)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst childId=<span class="cstat-no" title="statement not covered" >eventIdStack[eventIdStack.length-self._depth];<span class="cstat-no" title="statement not covered" ></span>node=nodeById.get(childId);<span class="cstat-no" title="statement not covered" >i</span>f(!node){const event=<span class="cstat-no" title="statement not covered" >eventStack[eventStack.length-self._depth];</span>const hasChildren=<span class="cstat-no" title="statement not covered" >eventStack.length&gt;self._depth;<span class="cstat-no" title="statement not covered" ></span>node=new TimelineModel.TimelineProfileTree.BottomUpNode(self._root,childId,event,hasChildren,self);<span class="cstat-no" title="statement not covered" >n</span>odeById.set(childId,node);}</span></span>
const totalTime=<span class="cstat-no" title="statement not covered" >Math.min(e.endTime,endTime)-Math.max(e.startTime,lastTimeMarker);<span class="cstat-no" title="statement not covered" ></span>node.selfTime+=selfTime;<span class="cstat-no" title="statement not covered" >n</span>ode.totalTime+=totalTime;<span class="cstat-no" title="statement not covered" >l</span>astTimeMarker=Math.min(e.endTime,endTime);}</span>
<span class="cstat-no" title="statement not covered" >this._cachedChildren=nodeById;<span class="cstat-no" title="statement not covered" >r</span>eturn nodeById;}</span>
<span class="fstat-no" title="function not covered" >se</span>archTree(matchFunction,results){<span class="cstat-no" title="statement not covered" >results=results||[];<span class="cstat-no" title="statement not covered" >i</span>f(this.event&amp;&amp;matchFunction(this.event))</span>
<span class="cstat-no" title="statement not covered" >results.push(this);<span class="cstat-no" title="statement not covered" >r</span>eturn results;}</span>};<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventURL=<span class="fstat-no" title="function not covered" >fu</span>nction(event){const data=<span class="cstat-no" title="statement not covered" >event.args['data']||event.args['beginData'];<span class="cstat-no" title="statement not covered" ></span>if(data&amp;&amp;data['url'])</span></span>
<span class="cstat-no" title="statement not covered" >return data['url'];l</span>et frame=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventStackFrame(event);<span class="cstat-no" title="statement not covered" ></span>while(frame){const url=<span class="cstat-no" title="statement not covered" >frame['url'];<span class="cstat-no" title="statement not covered" ></span>if(url)</span></span>
<span class="cstat-no" title="statement not covered" >return url;<span class="cstat-no" title="statement not covered" >f</span>rame=frame.parent;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>;<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventStackFrame=<span class="fstat-no" title="function not covered" >fu</span>nction(event){<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.RecordType.JSFrame)</span></span>
<span class="cstat-no" title="statement not covered" >return(event.args['data']||null);<span class="cstat-no" title="statement not covered" >r</span>eturn TimelineModel.TimelineData.forEvent(event).topFrame();}</span>;<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree._eventId=<span class="fstat-no" title="function not covered" >fu</span>nction(event){<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.RecordType.TimeStamp)</span></span>
<span class="cstat-no" title="statement not covered" >return`${event.name}:${event.args.data.message}`;<span class="cstat-no" title="statement not covered" >i</span>f(event.name!==TimelineModel.TimelineModel.RecordType.JSFrame)</span>
<span class="cstat-no" title="statement not covered" >return event.name;c</span>onst frame=<span class="cstat-no" title="statement not covered" >event.args['data'];</span>const location=<span class="cstat-no" title="statement not covered" >frame['scriptId']||frame['url']||'';</span>const functionName=<span class="cstat-no" title="statement not covered" >frame['functionName'];</span>const name=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineJSProfileProcessor.isNativeRuntimeFrame(frame)?TimelineModel.TimelineJSProfileProcessor.nativeGroup(functionName)||functionName:`${functionName}:${frame['lineNumber']}:${frame['columnNumber']}`;<span class="cstat-no" title="statement not covered" ></span>return`f:${name}@${location}`;}</span>;;</pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:04:04 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
