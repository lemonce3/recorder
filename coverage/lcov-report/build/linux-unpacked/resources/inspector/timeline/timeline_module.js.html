<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/linux-unpacked/resources/inspector/timeline/timeline_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/linux-unpacked/resources/inspector/timeline</a> timeline_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/4597</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/1988</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/670</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/1187</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a>
<a name='L559'></a><a href='#L559'>559</a>
<a name='L560'></a><a href='#L560'>560</a>
<a name='L561'></a><a href='#L561'>561</a>
<a name='L562'></a><a href='#L562'>562</a>
<a name='L563'></a><a href='#L563'>563</a>
<a name='L564'></a><a href='#L564'>564</a>
<a name='L565'></a><a href='#L565'>565</a>
<a name='L566'></a><a href='#L566'>566</a>
<a name='L567'></a><a href='#L567'>567</a>
<a name='L568'></a><a href='#L568'>568</a>
<a name='L569'></a><a href='#L569'>569</a>
<a name='L570'></a><a href='#L570'>570</a>
<a name='L571'></a><a href='#L571'>571</a>
<a name='L572'></a><a href='#L572'>572</a>
<a name='L573'></a><a href='#L573'>573</a>
<a name='L574'></a><a href='#L574'>574</a>
<a name='L575'></a><a href='#L575'>575</a>
<a name='L576'></a><a href='#L576'>576</a>
<a name='L577'></a><a href='#L577'>577</a>
<a name='L578'></a><a href='#L578'>578</a>
<a name='L579'></a><a href='#L579'>579</a>
<a name='L580'></a><a href='#L580'>580</a>
<a name='L581'></a><a href='#L581'>581</a>
<a name='L582'></a><a href='#L582'>582</a>
<a name='L583'></a><a href='#L583'>583</a>
<a name='L584'></a><a href='#L584'>584</a>
<a name='L585'></a><a href='#L585'>585</a>
<a name='L586'></a><a href='#L586'>586</a>
<a name='L587'></a><a href='#L587'>587</a>
<a name='L588'></a><a href='#L588'>588</a>
<a name='L589'></a><a href='#L589'>589</a>
<a name='L590'></a><a href='#L590'>590</a>
<a name='L591'></a><a href='#L591'>591</a>
<a name='L592'></a><a href='#L592'>592</a>
<a name='L593'></a><a href='#L593'>593</a>
<a name='L594'></a><a href='#L594'>594</a>
<a name='L595'></a><a href='#L595'>595</a>
<a name='L596'></a><a href='#L596'>596</a>
<a name='L597'></a><a href='#L597'>597</a>
<a name='L598'></a><a href='#L598'>598</a>
<a name='L599'></a><a href='#L599'>599</a>
<a name='L600'></a><a href='#L600'>600</a>
<a name='L601'></a><a href='#L601'>601</a>
<a name='L602'></a><a href='#L602'>602</a>
<a name='L603'></a><a href='#L603'>603</a>
<a name='L604'></a><a href='#L604'>604</a>
<a name='L605'></a><a href='#L605'>605</a>
<a name='L606'></a><a href='#L606'>606</a>
<a name='L607'></a><a href='#L607'>607</a>
<a name='L608'></a><a href='#L608'>608</a>
<a name='L609'></a><a href='#L609'>609</a>
<a name='L610'></a><a href='#L610'>610</a>
<a name='L611'></a><a href='#L611'>611</a>
<a name='L612'></a><a href='#L612'>612</a>
<a name='L613'></a><a href='#L613'>613</a>
<a name='L614'></a><a href='#L614'>614</a>
<a name='L615'></a><a href='#L615'>615</a>
<a name='L616'></a><a href='#L616'>616</a>
<a name='L617'></a><a href='#L617'>617</a>
<a name='L618'></a><a href='#L618'>618</a>
<a name='L619'></a><a href='#L619'>619</a>
<a name='L620'></a><a href='#L620'>620</a>
<a name='L621'></a><a href='#L621'>621</a>
<a name='L622'></a><a href='#L622'>622</a>
<a name='L623'></a><a href='#L623'>623</a>
<a name='L624'></a><a href='#L624'>624</a>
<a name='L625'></a><a href='#L625'>625</a>
<a name='L626'></a><a href='#L626'>626</a>
<a name='L627'></a><a href='#L627'>627</a>
<a name='L628'></a><a href='#L628'>628</a>
<a name='L629'></a><a href='#L629'>629</a>
<a name='L630'></a><a href='#L630'>630</a>
<a name='L631'></a><a href='#L631'>631</a>
<a name='L632'></a><a href='#L632'>632</a>
<a name='L633'></a><a href='#L633'>633</a>
<a name='L634'></a><a href='#L634'>634</a>
<a name='L635'></a><a href='#L635'>635</a>
<a name='L636'></a><a href='#L636'>636</a>
<a name='L637'></a><a href='#L637'>637</a>
<a name='L638'></a><a href='#L638'>638</a>
<a name='L639'></a><a href='#L639'>639</a>
<a name='L640'></a><a href='#L640'>640</a>
<a name='L641'></a><a href='#L641'>641</a>
<a name='L642'></a><a href='#L642'>642</a>
<a name='L643'></a><a href='#L643'>643</a>
<a name='L644'></a><a href='#L644'>644</a>
<a name='L645'></a><a href='#L645'>645</a>
<a name='L646'></a><a href='#L646'>646</a>
<a name='L647'></a><a href='#L647'>647</a>
<a name='L648'></a><a href='#L648'>648</a>
<a name='L649'></a><a href='#L649'>649</a>
<a name='L650'></a><a href='#L650'>650</a>
<a name='L651'></a><a href='#L651'>651</a>
<a name='L652'></a><a href='#L652'>652</a>
<a name='L653'></a><a href='#L653'>653</a>
<a name='L654'></a><a href='#L654'>654</a>
<a name='L655'></a><a href='#L655'>655</a>
<a name='L656'></a><a href='#L656'>656</a>
<a name='L657'></a><a href='#L657'>657</a>
<a name='L658'></a><a href='#L658'>658</a>
<a name='L659'></a><a href='#L659'>659</a>
<a name='L660'></a><a href='#L660'>660</a>
<a name='L661'></a><a href='#L661'>661</a>
<a name='L662'></a><a href='#L662'>662</a>
<a name='L663'></a><a href='#L663'>663</a>
<a name='L664'></a><a href='#L664'>664</a>
<a name='L665'></a><a href='#L665'>665</a>
<a name='L666'></a><a href='#L666'>666</a>
<a name='L667'></a><a href='#L667'>667</a>
<a name='L668'></a><a href='#L668'>668</a>
<a name='L669'></a><a href='#L669'>669</a>
<a name='L670'></a><a href='#L670'>670</a>
<a name='L671'></a><a href='#L671'>671</a>
<a name='L672'></a><a href='#L672'>672</a>
<a name='L673'></a><a href='#L673'>673</a>
<a name='L674'></a><a href='#L674'>674</a>
<a name='L675'></a><a href='#L675'>675</a>
<a name='L676'></a><a href='#L676'>676</a>
<a name='L677'></a><a href='#L677'>677</a>
<a name='L678'></a><a href='#L678'>678</a>
<a name='L679'></a><a href='#L679'>679</a>
<a name='L680'></a><a href='#L680'>680</a>
<a name='L681'></a><a href='#L681'>681</a>
<a name='L682'></a><a href='#L682'>682</a>
<a name='L683'></a><a href='#L683'>683</a>
<a name='L684'></a><a href='#L684'>684</a>
<a name='L685'></a><a href='#L685'>685</a>
<a name='L686'></a><a href='#L686'>686</a>
<a name='L687'></a><a href='#L687'>687</a>
<a name='L688'></a><a href='#L688'>688</a>
<a name='L689'></a><a href='#L689'>689</a>
<a name='L690'></a><a href='#L690'>690</a>
<a name='L691'></a><a href='#L691'>691</a>
<a name='L692'></a><a href='#L692'>692</a>
<a name='L693'></a><a href='#L693'>693</a>
<a name='L694'></a><a href='#L694'>694</a>
<a name='L695'></a><a href='#L695'>695</a>
<a name='L696'></a><a href='#L696'>696</a>
<a name='L697'></a><a href='#L697'>697</a>
<a name='L698'></a><a href='#L698'>698</a>
<a name='L699'></a><a href='#L699'>699</a>
<a name='L700'></a><a href='#L700'>700</a>
<a name='L701'></a><a href='#L701'>701</a>
<a name='L702'></a><a href='#L702'>702</a>
<a name='L703'></a><a href='#L703'>703</a>
<a name='L704'></a><a href='#L704'>704</a>
<a name='L705'></a><a href='#L705'>705</a>
<a name='L706'></a><a href='#L706'>706</a>
<a name='L707'></a><a href='#L707'>707</a>
<a name='L708'></a><a href='#L708'>708</a>
<a name='L709'></a><a href='#L709'>709</a>
<a name='L710'></a><a href='#L710'>710</a>
<a name='L711'></a><a href='#L711'>711</a>
<a name='L712'></a><a href='#L712'>712</a>
<a name='L713'></a><a href='#L713'>713</a>
<a name='L714'></a><a href='#L714'>714</a>
<a name='L715'></a><a href='#L715'>715</a>
<a name='L716'></a><a href='#L716'>716</a>
<a name='L717'></a><a href='#L717'>717</a>
<a name='L718'></a><a href='#L718'>718</a>
<a name='L719'></a><a href='#L719'>719</a>
<a name='L720'></a><a href='#L720'>720</a>
<a name='L721'></a><a href='#L721'>721</a>
<a name='L722'></a><a href='#L722'>722</a>
<a name='L723'></a><a href='#L723'>723</a>
<a name='L724'></a><a href='#L724'>724</a>
<a name='L725'></a><a href='#L725'>725</a>
<a name='L726'></a><a href='#L726'>726</a>
<a name='L727'></a><a href='#L727'>727</a>
<a name='L728'></a><a href='#L728'>728</a>
<a name='L729'></a><a href='#L729'>729</a>
<a name='L730'></a><a href='#L730'>730</a>
<a name='L731'></a><a href='#L731'>731</a>
<a name='L732'></a><a href='#L732'>732</a>
<a name='L733'></a><a href='#L733'>733</a>
<a name='L734'></a><a href='#L734'>734</a>
<a name='L735'></a><a href='#L735'>735</a>
<a name='L736'></a><a href='#L736'>736</a>
<a name='L737'></a><a href='#L737'>737</a>
<a name='L738'></a><a href='#L738'>738</a>
<a name='L739'></a><a href='#L739'>739</a>
<a name='L740'></a><a href='#L740'>740</a>
<a name='L741'></a><a href='#L741'>741</a>
<a name='L742'></a><a href='#L742'>742</a>
<a name='L743'></a><a href='#L743'>743</a>
<a name='L744'></a><a href='#L744'>744</a>
<a name='L745'></a><a href='#L745'>745</a>
<a name='L746'></a><a href='#L746'>746</a>
<a name='L747'></a><a href='#L747'>747</a>
<a name='L748'></a><a href='#L748'>748</a>
<a name='L749'></a><a href='#L749'>749</a>
<a name='L750'></a><a href='#L750'>750</a>
<a name='L751'></a><a href='#L751'>751</a>
<a name='L752'></a><a href='#L752'>752</a>
<a name='L753'></a><a href='#L753'>753</a>
<a name='L754'></a><a href='#L754'>754</a>
<a name='L755'></a><a href='#L755'>755</a>
<a name='L756'></a><a href='#L756'>756</a>
<a name='L757'></a><a href='#L757'>757</a>
<a name='L758'></a><a href='#L758'>758</a>
<a name='L759'></a><a href='#L759'>759</a>
<a name='L760'></a><a href='#L760'>760</a>
<a name='L761'></a><a href='#L761'>761</a>
<a name='L762'></a><a href='#L762'>762</a>
<a name='L763'></a><a href='#L763'>763</a>
<a name='L764'></a><a href='#L764'>764</a>
<a name='L765'></a><a href='#L765'>765</a>
<a name='L766'></a><a href='#L766'>766</a>
<a name='L767'></a><a href='#L767'>767</a>
<a name='L768'></a><a href='#L768'>768</a>
<a name='L769'></a><a href='#L769'>769</a>
<a name='L770'></a><a href='#L770'>770</a>
<a name='L771'></a><a href='#L771'>771</a>
<a name='L772'></a><a href='#L772'>772</a>
<a name='L773'></a><a href='#L773'>773</a>
<a name='L774'></a><a href='#L774'>774</a>
<a name='L775'></a><a href='#L775'>775</a>
<a name='L776'></a><a href='#L776'>776</a>
<a name='L777'></a><a href='#L777'>777</a>
<a name='L778'></a><a href='#L778'>778</a>
<a name='L779'></a><a href='#L779'>779</a>
<a name='L780'></a><a href='#L780'>780</a>
<a name='L781'></a><a href='#L781'>781</a>
<a name='L782'></a><a href='#L782'>782</a>
<a name='L783'></a><a href='#L783'>783</a>
<a name='L784'></a><a href='#L784'>784</a>
<a name='L785'></a><a href='#L785'>785</a>
<a name='L786'></a><a href='#L786'>786</a>
<a name='L787'></a><a href='#L787'>787</a>
<a name='L788'></a><a href='#L788'>788</a>
<a name='L789'></a><a href='#L789'>789</a>
<a name='L790'></a><a href='#L790'>790</a>
<a name='L791'></a><a href='#L791'>791</a>
<a name='L792'></a><a href='#L792'>792</a>
<a name='L793'></a><a href='#L793'>793</a>
<a name='L794'></a><a href='#L794'>794</a>
<a name='L795'></a><a href='#L795'>795</a>
<a name='L796'></a><a href='#L796'>796</a>
<a name='L797'></a><a href='#L797'>797</a>
<a name='L798'></a><a href='#L798'>798</a>
<a name='L799'></a><a href='#L799'>799</a>
<a name='L800'></a><a href='#L800'>800</a>
<a name='L801'></a><a href='#L801'>801</a>
<a name='L802'></a><a href='#L802'>802</a>
<a name='L803'></a><a href='#L803'>803</a>
<a name='L804'></a><a href='#L804'>804</a>
<a name='L805'></a><a href='#L805'>805</a>
<a name='L806'></a><a href='#L806'>806</a>
<a name='L807'></a><a href='#L807'>807</a>
<a name='L808'></a><a href='#L808'>808</a>
<a name='L809'></a><a href='#L809'>809</a>
<a name='L810'></a><a href='#L810'>810</a>
<a name='L811'></a><a href='#L811'>811</a>
<a name='L812'></a><a href='#L812'>812</a>
<a name='L813'></a><a href='#L813'>813</a>
<a name='L814'></a><a href='#L814'>814</a>
<a name='L815'></a><a href='#L815'>815</a>
<a name='L816'></a><a href='#L816'>816</a>
<a name='L817'></a><a href='#L817'>817</a>
<a name='L818'></a><a href='#L818'>818</a>
<a name='L819'></a><a href='#L819'>819</a>
<a name='L820'></a><a href='#L820'>820</a>
<a name='L821'></a><a href='#L821'>821</a>
<a name='L822'></a><a href='#L822'>822</a>
<a name='L823'></a><a href='#L823'>823</a>
<a name='L824'></a><a href='#L824'>824</a>
<a name='L825'></a><a href='#L825'>825</a>
<a name='L826'></a><a href='#L826'>826</a>
<a name='L827'></a><a href='#L827'>827</a>
<a name='L828'></a><a href='#L828'>828</a>
<a name='L829'></a><a href='#L829'>829</a>
<a name='L830'></a><a href='#L830'>830</a>
<a name='L831'></a><a href='#L831'>831</a>
<a name='L832'></a><a href='#L832'>832</a>
<a name='L833'></a><a href='#L833'>833</a>
<a name='L834'></a><a href='#L834'>834</a>
<a name='L835'></a><a href='#L835'>835</a>
<a name='L836'></a><a href='#L836'>836</a>
<a name='L837'></a><a href='#L837'>837</a>
<a name='L838'></a><a href='#L838'>838</a>
<a name='L839'></a><a href='#L839'>839</a>
<a name='L840'></a><a href='#L840'>840</a>
<a name='L841'></a><a href='#L841'>841</a>
<a name='L842'></a><a href='#L842'>842</a>
<a name='L843'></a><a href='#L843'>843</a>
<a name='L844'></a><a href='#L844'>844</a>
<a name='L845'></a><a href='#L845'>845</a>
<a name='L846'></a><a href='#L846'>846</a>
<a name='L847'></a><a href='#L847'>847</a>
<a name='L848'></a><a href='#L848'>848</a>
<a name='L849'></a><a href='#L849'>849</a>
<a name='L850'></a><a href='#L850'>850</a>
<a name='L851'></a><a href='#L851'>851</a>
<a name='L852'></a><a href='#L852'>852</a>
<a name='L853'></a><a href='#L853'>853</a>
<a name='L854'></a><a href='#L854'>854</a>
<a name='L855'></a><a href='#L855'>855</a>
<a name='L856'></a><a href='#L856'>856</a>
<a name='L857'></a><a href='#L857'>857</a>
<a name='L858'></a><a href='#L858'>858</a>
<a name='L859'></a><a href='#L859'>859</a>
<a name='L860'></a><a href='#L860'>860</a>
<a name='L861'></a><a href='#L861'>861</a>
<a name='L862'></a><a href='#L862'>862</a>
<a name='L863'></a><a href='#L863'>863</a>
<a name='L864'></a><a href='#L864'>864</a>
<a name='L865'></a><a href='#L865'>865</a>
<a name='L866'></a><a href='#L866'>866</a>
<a name='L867'></a><a href='#L867'>867</a>
<a name='L868'></a><a href='#L868'>868</a>
<a name='L869'></a><a href='#L869'>869</a>
<a name='L870'></a><a href='#L870'>870</a>
<a name='L871'></a><a href='#L871'>871</a>
<a name='L872'></a><a href='#L872'>872</a>
<a name='L873'></a><a href='#L873'>873</a>
<a name='L874'></a><a href='#L874'>874</a>
<a name='L875'></a><a href='#L875'>875</a>
<a name='L876'></a><a href='#L876'>876</a>
<a name='L877'></a><a href='#L877'>877</a>
<a name='L878'></a><a href='#L878'>878</a>
<a name='L879'></a><a href='#L879'>879</a>
<a name='L880'></a><a href='#L880'>880</a>
<a name='L881'></a><a href='#L881'>881</a>
<a name='L882'></a><a href='#L882'>882</a>
<a name='L883'></a><a href='#L883'>883</a>
<a name='L884'></a><a href='#L884'>884</a>
<a name='L885'></a><a href='#L885'>885</a>
<a name='L886'></a><a href='#L886'>886</a>
<a name='L887'></a><a href='#L887'>887</a>
<a name='L888'></a><a href='#L888'>888</a>
<a name='L889'></a><a href='#L889'>889</a>
<a name='L890'></a><a href='#L890'>890</a>
<a name='L891'></a><a href='#L891'>891</a>
<a name='L892'></a><a href='#L892'>892</a>
<a name='L893'></a><a href='#L893'>893</a>
<a name='L894'></a><a href='#L894'>894</a>
<a name='L895'></a><a href='#L895'>895</a>
<a name='L896'></a><a href='#L896'>896</a>
<a name='L897'></a><a href='#L897'>897</a>
<a name='L898'></a><a href='#L898'>898</a>
<a name='L899'></a><a href='#L899'>899</a>
<a name='L900'></a><a href='#L900'>900</a>
<a name='L901'></a><a href='#L901'>901</a>
<a name='L902'></a><a href='#L902'>902</a>
<a name='L903'></a><a href='#L903'>903</a>
<a name='L904'></a><a href='#L904'>904</a>
<a name='L905'></a><a href='#L905'>905</a>
<a name='L906'></a><a href='#L906'>906</a>
<a name='L907'></a><a href='#L907'>907</a>
<a name='L908'></a><a href='#L908'>908</a>
<a name='L909'></a><a href='#L909'>909</a>
<a name='L910'></a><a href='#L910'>910</a>
<a name='L911'></a><a href='#L911'>911</a>
<a name='L912'></a><a href='#L912'>912</a>
<a name='L913'></a><a href='#L913'>913</a>
<a name='L914'></a><a href='#L914'>914</a>
<a name='L915'></a><a href='#L915'>915</a>
<a name='L916'></a><a href='#L916'>916</a>
<a name='L917'></a><a href='#L917'>917</a>
<a name='L918'></a><a href='#L918'>918</a>
<a name='L919'></a><a href='#L919'>919</a>
<a name='L920'></a><a href='#L920'>920</a>
<a name='L921'></a><a href='#L921'>921</a>
<a name='L922'></a><a href='#L922'>922</a>
<a name='L923'></a><a href='#L923'>923</a>
<a name='L924'></a><a href='#L924'>924</a>
<a name='L925'></a><a href='#L925'>925</a>
<a name='L926'></a><a href='#L926'>926</a>
<a name='L927'></a><a href='#L927'>927</a>
<a name='L928'></a><a href='#L928'>928</a>
<a name='L929'></a><a href='#L929'>929</a>
<a name='L930'></a><a href='#L930'>930</a>
<a name='L931'></a><a href='#L931'>931</a>
<a name='L932'></a><a href='#L932'>932</a>
<a name='L933'></a><a href='#L933'>933</a>
<a name='L934'></a><a href='#L934'>934</a>
<a name='L935'></a><a href='#L935'>935</a>
<a name='L936'></a><a href='#L936'>936</a>
<a name='L937'></a><a href='#L937'>937</a>
<a name='L938'></a><a href='#L938'>938</a>
<a name='L939'></a><a href='#L939'>939</a>
<a name='L940'></a><a href='#L940'>940</a>
<a name='L941'></a><a href='#L941'>941</a>
<a name='L942'></a><a href='#L942'>942</a>
<a name='L943'></a><a href='#L943'>943</a>
<a name='L944'></a><a href='#L944'>944</a>
<a name='L945'></a><a href='#L945'>945</a>
<a name='L946'></a><a href='#L946'>946</a>
<a name='L947'></a><a href='#L947'>947</a>
<a name='L948'></a><a href='#L948'>948</a>
<a name='L949'></a><a href='#L949'>949</a>
<a name='L950'></a><a href='#L950'>950</a>
<a name='L951'></a><a href='#L951'>951</a>
<a name='L952'></a><a href='#L952'>952</a>
<a name='L953'></a><a href='#L953'>953</a>
<a name='L954'></a><a href='#L954'>954</a>
<a name='L955'></a><a href='#L955'>955</a>
<a name='L956'></a><a href='#L956'>956</a>
<a name='L957'></a><a href='#L957'>957</a>
<a name='L958'></a><a href='#L958'>958</a>
<a name='L959'></a><a href='#L959'>959</a>
<a name='L960'></a><a href='#L960'>960</a>
<a name='L961'></a><a href='#L961'>961</a>
<a name='L962'></a><a href='#L962'>962</a>
<a name='L963'></a><a href='#L963'>963</a>
<a name='L964'></a><a href='#L964'>964</a>
<a name='L965'></a><a href='#L965'>965</a>
<a name='L966'></a><a href='#L966'>966</a>
<a name='L967'></a><a href='#L967'>967</a>
<a name='L968'></a><a href='#L968'>968</a>
<a name='L969'></a><a href='#L969'>969</a>
<a name='L970'></a><a href='#L970'>970</a>
<a name='L971'></a><a href='#L971'>971</a>
<a name='L972'></a><a href='#L972'>972</a>
<a name='L973'></a><a href='#L973'>973</a>
<a name='L974'></a><a href='#L974'>974</a>
<a name='L975'></a><a href='#L975'>975</a>
<a name='L976'></a><a href='#L976'>976</a>
<a name='L977'></a><a href='#L977'>977</a>
<a name='L978'></a><a href='#L978'>978</a>
<a name='L979'></a><a href='#L979'>979</a>
<a name='L980'></a><a href='#L980'>980</a>
<a name='L981'></a><a href='#L981'>981</a>
<a name='L982'></a><a href='#L982'>982</a>
<a name='L983'></a><a href='#L983'>983</a>
<a name='L984'></a><a href='#L984'>984</a>
<a name='L985'></a><a href='#L985'>985</a>
<a name='L986'></a><a href='#L986'>986</a>
<a name='L987'></a><a href='#L987'>987</a>
<a name='L988'></a><a href='#L988'>988</a>
<a name='L989'></a><a href='#L989'>989</a>
<a name='L990'></a><a href='#L990'>990</a>
<a name='L991'></a><a href='#L991'>991</a>
<a name='L992'></a><a href='#L992'>992</a>
<a name='L993'></a><a href='#L993'>993</a>
<a name='L994'></a><a href='#L994'>994</a>
<a name='L995'></a><a href='#L995'>995</a>
<a name='L996'></a><a href='#L996'>996</a>
<a name='L997'></a><a href='#L997'>997</a>
<a name='L998'></a><a href='#L998'>998</a>
<a name='L999'></a><a href='#L999'>999</a>
<a name='L1000'></a><a href='#L1000'>1000</a>
<a name='L1001'></a><a href='#L1001'>1001</a>
<a name='L1002'></a><a href='#L1002'>1002</a>
<a name='L1003'></a><a href='#L1003'>1003</a>
<a name='L1004'></a><a href='#L1004'>1004</a>
<a name='L1005'></a><a href='#L1005'>1005</a>
<a name='L1006'></a><a href='#L1006'>1006</a>
<a name='L1007'></a><a href='#L1007'>1007</a>
<a name='L1008'></a><a href='#L1008'>1008</a>
<a name='L1009'></a><a href='#L1009'>1009</a>
<a name='L1010'></a><a href='#L1010'>1010</a>
<a name='L1011'></a><a href='#L1011'>1011</a>
<a name='L1012'></a><a href='#L1012'>1012</a>
<a name='L1013'></a><a href='#L1013'>1013</a>
<a name='L1014'></a><a href='#L1014'>1014</a>
<a name='L1015'></a><a href='#L1015'>1015</a>
<a name='L1016'></a><a href='#L1016'>1016</a>
<a name='L1017'></a><a href='#L1017'>1017</a>
<a name='L1018'></a><a href='#L1018'>1018</a>
<a name='L1019'></a><a href='#L1019'>1019</a>
<a name='L1020'></a><a href='#L1020'>1020</a>
<a name='L1021'></a><a href='#L1021'>1021</a>
<a name='L1022'></a><a href='#L1022'>1022</a>
<a name='L1023'></a><a href='#L1023'>1023</a>
<a name='L1024'></a><a href='#L1024'>1024</a>
<a name='L1025'></a><a href='#L1025'>1025</a>
<a name='L1026'></a><a href='#L1026'>1026</a>
<a name='L1027'></a><a href='#L1027'>1027</a>
<a name='L1028'></a><a href='#L1028'>1028</a>
<a name='L1029'></a><a href='#L1029'>1029</a>
<a name='L1030'></a><a href='#L1030'>1030</a>
<a name='L1031'></a><a href='#L1031'>1031</a>
<a name='L1032'></a><a href='#L1032'>1032</a>
<a name='L1033'></a><a href='#L1033'>1033</a>
<a name='L1034'></a><a href='#L1034'>1034</a>
<a name='L1035'></a><a href='#L1035'>1035</a>
<a name='L1036'></a><a href='#L1036'>1036</a>
<a name='L1037'></a><a href='#L1037'>1037</a>
<a name='L1038'></a><a href='#L1038'>1038</a>
<a name='L1039'></a><a href='#L1039'>1039</a>
<a name='L1040'></a><a href='#L1040'>1040</a>
<a name='L1041'></a><a href='#L1041'>1041</a>
<a name='L1042'></a><a href='#L1042'>1042</a>
<a name='L1043'></a><a href='#L1043'>1043</a>
<a name='L1044'></a><a href='#L1044'>1044</a>
<a name='L1045'></a><a href='#L1045'>1045</a>
<a name='L1046'></a><a href='#L1046'>1046</a>
<a name='L1047'></a><a href='#L1047'>1047</a>
<a name='L1048'></a><a href='#L1048'>1048</a>
<a name='L1049'></a><a href='#L1049'>1049</a>
<a name='L1050'></a><a href='#L1050'>1050</a>
<a name='L1051'></a><a href='#L1051'>1051</a>
<a name='L1052'></a><a href='#L1052'>1052</a>
<a name='L1053'></a><a href='#L1053'>1053</a>
<a name='L1054'></a><a href='#L1054'>1054</a>
<a name='L1055'></a><a href='#L1055'>1055</a>
<a name='L1056'></a><a href='#L1056'>1056</a>
<a name='L1057'></a><a href='#L1057'>1057</a>
<a name='L1058'></a><a href='#L1058'>1058</a>
<a name='L1059'></a><a href='#L1059'>1059</a>
<a name='L1060'></a><a href='#L1060'>1060</a>
<a name='L1061'></a><a href='#L1061'>1061</a>
<a name='L1062'></a><a href='#L1062'>1062</a>
<a name='L1063'></a><a href='#L1063'>1063</a>
<a name='L1064'></a><a href='#L1064'>1064</a>
<a name='L1065'></a><a href='#L1065'>1065</a>
<a name='L1066'></a><a href='#L1066'>1066</a>
<a name='L1067'></a><a href='#L1067'>1067</a>
<a name='L1068'></a><a href='#L1068'>1068</a>
<a name='L1069'></a><a href='#L1069'>1069</a>
<a name='L1070'></a><a href='#L1070'>1070</a>
<a name='L1071'></a><a href='#L1071'>1071</a>
<a name='L1072'></a><a href='#L1072'>1072</a>
<a name='L1073'></a><a href='#L1073'>1073</a>
<a name='L1074'></a><a href='#L1074'>1074</a>
<a name='L1075'></a><a href='#L1075'>1075</a>
<a name='L1076'></a><a href='#L1076'>1076</a>
<a name='L1077'></a><a href='#L1077'>1077</a>
<a name='L1078'></a><a href='#L1078'>1078</a>
<a name='L1079'></a><a href='#L1079'>1079</a>
<a name='L1080'></a><a href='#L1080'>1080</a>
<a name='L1081'></a><a href='#L1081'>1081</a>
<a name='L1082'></a><a href='#L1082'>1082</a>
<a name='L1083'></a><a href='#L1083'>1083</a>
<a name='L1084'></a><a href='#L1084'>1084</a>
<a name='L1085'></a><a href='#L1085'>1085</a>
<a name='L1086'></a><a href='#L1086'>1086</a>
<a name='L1087'></a><a href='#L1087'>1087</a>
<a name='L1088'></a><a href='#L1088'>1088</a>
<a name='L1089'></a><a href='#L1089'>1089</a>
<a name='L1090'></a><a href='#L1090'>1090</a>
<a name='L1091'></a><a href='#L1091'>1091</a>
<a name='L1092'></a><a href='#L1092'>1092</a>
<a name='L1093'></a><a href='#L1093'>1093</a>
<a name='L1094'></a><a href='#L1094'>1094</a>
<a name='L1095'></a><a href='#L1095'>1095</a>
<a name='L1096'></a><a href='#L1096'>1096</a>
<a name='L1097'></a><a href='#L1097'>1097</a>
<a name='L1098'></a><a href='#L1098'>1098</a>
<a name='L1099'></a><a href='#L1099'>1099</a>
<a name='L1100'></a><a href='#L1100'>1100</a>
<a name='L1101'></a><a href='#L1101'>1101</a>
<a name='L1102'></a><a href='#L1102'>1102</a>
<a name='L1103'></a><a href='#L1103'>1103</a>
<a name='L1104'></a><a href='#L1104'>1104</a>
<a name='L1105'></a><a href='#L1105'>1105</a>
<a name='L1106'></a><a href='#L1106'>1106</a>
<a name='L1107'></a><a href='#L1107'>1107</a>
<a name='L1108'></a><a href='#L1108'>1108</a>
<a name='L1109'></a><a href='#L1109'>1109</a>
<a name='L1110'></a><a href='#L1110'>1110</a>
<a name='L1111'></a><a href='#L1111'>1111</a>
<a name='L1112'></a><a href='#L1112'>1112</a>
<a name='L1113'></a><a href='#L1113'>1113</a>
<a name='L1114'></a><a href='#L1114'>1114</a>
<a name='L1115'></a><a href='#L1115'>1115</a>
<a name='L1116'></a><a href='#L1116'>1116</a>
<a name='L1117'></a><a href='#L1117'>1117</a>
<a name='L1118'></a><a href='#L1118'>1118</a>
<a name='L1119'></a><a href='#L1119'>1119</a>
<a name='L1120'></a><a href='#L1120'>1120</a>
<a name='L1121'></a><a href='#L1121'>1121</a>
<a name='L1122'></a><a href='#L1122'>1122</a>
<a name='L1123'></a><a href='#L1123'>1123</a>
<a name='L1124'></a><a href='#L1124'>1124</a>
<a name='L1125'></a><a href='#L1125'>1125</a>
<a name='L1126'></a><a href='#L1126'>1126</a>
<a name='L1127'></a><a href='#L1127'>1127</a>
<a name='L1128'></a><a href='#L1128'>1128</a>
<a name='L1129'></a><a href='#L1129'>1129</a>
<a name='L1130'></a><a href='#L1130'>1130</a>
<a name='L1131'></a><a href='#L1131'>1131</a>
<a name='L1132'></a><a href='#L1132'>1132</a>
<a name='L1133'></a><a href='#L1133'>1133</a>
<a name='L1134'></a><a href='#L1134'>1134</a>
<a name='L1135'></a><a href='#L1135'>1135</a>
<a name='L1136'></a><a href='#L1136'>1136</a>
<a name='L1137'></a><a href='#L1137'>1137</a>
<a name='L1138'></a><a href='#L1138'>1138</a>
<a name='L1139'></a><a href='#L1139'>1139</a>
<a name='L1140'></a><a href='#L1140'>1140</a>
<a name='L1141'></a><a href='#L1141'>1141</a>
<a name='L1142'></a><a href='#L1142'>1142</a>
<a name='L1143'></a><a href='#L1143'>1143</a>
<a name='L1144'></a><a href='#L1144'>1144</a>
<a name='L1145'></a><a href='#L1145'>1145</a>
<a name='L1146'></a><a href='#L1146'>1146</a>
<a name='L1147'></a><a href='#L1147'>1147</a>
<a name='L1148'></a><a href='#L1148'>1148</a>
<a name='L1149'></a><a href='#L1149'>1149</a>
<a name='L1150'></a><a href='#L1150'>1150</a>
<a name='L1151'></a><a href='#L1151'>1151</a>
<a name='L1152'></a><a href='#L1152'>1152</a>
<a name='L1153'></a><a href='#L1153'>1153</a>
<a name='L1154'></a><a href='#L1154'>1154</a>
<a name='L1155'></a><a href='#L1155'>1155</a>
<a name='L1156'></a><a href='#L1156'>1156</a>
<a name='L1157'></a><a href='#L1157'>1157</a>
<a name='L1158'></a><a href='#L1158'>1158</a>
<a name='L1159'></a><a href='#L1159'>1159</a>
<a name='L1160'></a><a href='#L1160'>1160</a>
<a name='L1161'></a><a href='#L1161'>1161</a>
<a name='L1162'></a><a href='#L1162'>1162</a>
<a name='L1163'></a><a href='#L1163'>1163</a>
<a name='L1164'></a><a href='#L1164'>1164</a>
<a name='L1165'></a><a href='#L1165'>1165</a>
<a name='L1166'></a><a href='#L1166'>1166</a>
<a name='L1167'></a><a href='#L1167'>1167</a>
<a name='L1168'></a><a href='#L1168'>1168</a>
<a name='L1169'></a><a href='#L1169'>1169</a>
<a name='L1170'></a><a href='#L1170'>1170</a>
<a name='L1171'></a><a href='#L1171'>1171</a>
<a name='L1172'></a><a href='#L1172'>1172</a>
<a name='L1173'></a><a href='#L1173'>1173</a>
<a name='L1174'></a><a href='#L1174'>1174</a>
<a name='L1175'></a><a href='#L1175'>1175</a>
<a name='L1176'></a><a href='#L1176'>1176</a>
<a name='L1177'></a><a href='#L1177'>1177</a>
<a name='L1178'></a><a href='#L1178'>1178</a>
<a name='L1179'></a><a href='#L1179'>1179</a>
<a name='L1180'></a><a href='#L1180'>1180</a>
<a name='L1181'></a><a href='#L1181'>1181</a>
<a name='L1182'></a><a href='#L1182'>1182</a>
<a name='L1183'></a><a href='#L1183'>1183</a>
<a name='L1184'></a><a href='#L1184'>1184</a>
<a name='L1185'></a><a href='#L1185'>1185</a>
<a name='L1186'></a><a href='#L1186'>1186</a>
<a name='L1187'></a><a href='#L1187'>1187</a>
<a name='L1188'></a><a href='#L1188'>1188</a>
<a name='L1189'></a><a href='#L1189'>1189</a>
<a name='L1190'></a><a href='#L1190'>1190</a>
<a name='L1191'></a><a href='#L1191'>1191</a>
<a name='L1192'></a><a href='#L1192'>1192</a>
<a name='L1193'></a><a href='#L1193'>1193</a>
<a name='L1194'></a><a href='#L1194'>1194</a>
<a name='L1195'></a><a href='#L1195'>1195</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >Timeline.CountersGraph=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(delegate){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.id='memory-graphs-container';<span class="cstat-no" title="statement not covered" >t</span>his._delegate=delegate;<span class="cstat-no" title="statement not covered" >t</span>his._calculator=new Timeline.CountersGraph.Calculator();<span class="cstat-no" title="statement not covered" >t</span>his._header=new UI.HBox();<span class="cstat-no" title="statement not covered" >t</span>his._header.element.classList.add('timeline-memory-header');<span class="cstat-no" title="statement not covered" >t</span>his._header.show(this.element);<span class="cstat-no" title="statement not covered" >t</span>his._toolbar=new UI.Toolbar('timeline-memory-toolbar');<span class="cstat-no" title="statement not covered" >t</span>his._header.element.appendChild(this._toolbar.element);<span class="cstat-no" title="statement not covered" >t</span>his._graphsContainer=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._graphsContainer.show(this.element);c</span>onst canvasWidget=<span class="cstat-no" title="statement not covered" >new UI.VBoxWithResizeCallback(this._resize.bind(this));<span class="cstat-no" title="statement not covered" ></span>canvasWidget.show(this._graphsContainer.element);<span class="cstat-no" title="statement not covered" >t</span>his._createCurrentValuesBar();<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer=canvasWidget.element;<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer.id='memory-graphs-canvas-container';<span class="cstat-no" title="statement not covered" >t</span>his._canvas=this._canvasContainer.createChild('canvas');<span class="cstat-no" title="statement not covered" >t</span>his._canvas.id='memory-counters-graph';<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer.addEventListener('mouseover',this._onMouseMove.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer.addEventListener('mousemove',this._onMouseMove.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer.addEventListener('mouseleave',this._onMouseLeave.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer.addEventListener('click',this._onClick.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._timelineGrid=new PerfUI.TimelineGrid();<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer.appendChild(this._timelineGrid.dividersElement);<span class="cstat-no" title="statement not covered" >t</span>his._counters=[];<span class="cstat-no" title="statement not covered" >t</span>his._counterUI=[];<span class="cstat-no" title="statement not covered" >t</span>his._countersByName={};<span class="cstat-no" title="statement not covered" >t</span>his._countersByName['jsHeapSizeUsed']=this._createCounter(Common.UIString('JS Heap'),Common.UIString('JS Heap: %s'),'hsl(220, 90%, 43%)',Number.bytesToString);<span class="cstat-no" title="statement not covered" >t</span>his._countersByName['documents']=this._createCounter(Common.UIString('Documents'),Common.UIString('Documents: %s'),'hsl(0, 90%, 43%)');<span class="cstat-no" title="statement not covered" >t</span>his._countersByName['nodes']=this._createCounter(Common.UIString('Nodes'),Common.UIString('Nodes: %s'),'hsl(120, 90%, 43%)');<span class="cstat-no" title="statement not covered" >t</span>his._countersByName['jsEventListeners']=this._createCounter(Common.UIString('Listeners'),Common.UIString('Listeners: %s'),'hsl(38, 90%, 43%)');<span class="cstat-no" title="statement not covered" >t</span>his._gpuMemoryCounter=this._createCounter(Common.UIString('GPU Memory'),Common.UIString('GPU Memory [KB]: %s'),'hsl(300, 90%, 43%)',Number.bytesToString);<span class="cstat-no" title="statement not covered" >t</span>his._countersByName['gpuMemoryUsedKB']=this._gpuMemoryCounter;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tModel(model,track){<span class="cstat-no" title="statement not covered" >if(this._model!==model){<span class="cstat-no" title="statement not covered" >if(this._model)</span></span>
<span class="cstat-no" title="statement not covered" >this._model.removeEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._model=model;<span class="cstat-no" title="statement not covered" >i</span>f(this._model)</span>
<span class="cstat-no" title="statement not covered" >this._model.addEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onWindowChanged,this);}</span>
<span class="cstat-no" title="statement not covered" >this._calculator.setZeroTime(model?model.timelineModel().minimumRecordTime():0);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._counters.length;++i){<span class="cstat-no" title="statement not covered" >this._counters[i].reset();<span class="cstat-no" title="statement not covered" >t</span>his._counterUI[i].reset();}</span></span>
<span class="cstat-no" title="statement not covered" >this.scheduleRefresh();<span class="cstat-no" title="statement not covered" >t</span>his._track=track;<span class="cstat-no" title="statement not covered" >i</span>f(!track)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst events=<span class="cstat-no" title="statement not covered" >track.syncEvents();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;events.length;++i){const event=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(event.name!==TimelineModel.TimelineModel.RecordType.UpdateCounters)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst counters=<span class="cstat-no" title="statement not covered" >event.args.data;<span class="cstat-no" title="statement not covered" ></span>if(!counters)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const name in counters){const counter=<span class="cstat-no" title="statement not covered" >this._countersByName[name];<span class="cstat-no" title="statement not covered" ></span>if(counter)</span></span>
<span class="cstat-no" title="statement not covered" >counter.appendSample(event.startTime,counters[name]);}</span>
const gpuMemoryLimitCounterName=<span class="cstat-no" title="statement not covered" >'gpuMemoryLimitKB';<span class="cstat-no" title="statement not covered" ></span>if(gpuMemoryLimitCounterName in counters)</span>
<span class="cstat-no" title="statement not covered" >this._gpuMemoryCounter.setLimit(counters[gpuMemoryLimitCounterName]);}</span>}
<span class="fstat-no" title="function not covered" >_c</span>reateCurrentValuesBar(){<span class="cstat-no" title="statement not covered" >this._currentValuesBar=this._graphsContainer.element.createChild('div');<span class="cstat-no" title="statement not covered" >t</span>his._currentValuesBar.id='counter-values-bar';}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateCounter(uiName,uiValueTemplate,color,formatter){const counter=<span class="cstat-no" title="statement not covered" >new Timeline.CountersGraph.Counter();<span class="cstat-no" title="statement not covered" ></span>this._counters.push(counter);<span class="cstat-no" title="statement not covered" >t</span>his._counterUI.push(new Timeline.CountersGraph.CounterUI(this,uiName,uiValueTemplate,color,counter,formatter));<span class="cstat-no" title="statement not covered" >r</span>eturn counter;}</span>
<span class="fstat-no" title="function not covered" >re</span>sizerElement(){<span class="cstat-no" title="statement not covered" >return this._header.element;}</span>
<span class="fstat-no" title="function not covered" >_r</span>esize(){const parentElement=<span class="cstat-no" title="statement not covered" >this._canvas.parentElement;<span class="cstat-no" title="statement not covered" ></span>this._canvas.width=parentElement.clientWidth*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._canvas.height=parentElement.clientHeight*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._calculator.setDisplayWidth(this._canvas.width);<span class="cstat-no" title="statement not covered" >t</span>his.refresh();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(event){const window=(<span class="cstat-no" title="statement not covered" >event.data.window)</span>;<span class="cstat-no" title="statement not covered" >this._calculator.setWindow(window.left,window.right);<span class="cstat-no" title="statement not covered" >t</span>his.scheduleRefresh();}</span>
<span class="fstat-no" title="function not covered" >sc</span>heduleRefresh(){<span class="cstat-no" title="statement not covered" >UI.invokeOnceAfterBatchUpdate(this,this.refresh);}</span>
<span class="fstat-no" title="function not covered" >dr</span>aw(){<span class="cstat-no" title="statement not covered" >this._clear();<span class="cstat-no" title="statement not covered" >f</span>or(const counter of this._counters){<span class="cstat-no" title="statement not covered" >counter._calculateVisibleIndexes(this._calculator);<span class="cstat-no" title="statement not covered" >c</span>ounter._calculateXValues(this._canvas.width);}</span></span>
<span class="cstat-no" title="statement not covered" >for(const counterUI of this._counterUI)</span>
<span class="cstat-no" title="statement not covered" >counterUI._drawGraph(this._canvas);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nClick(event){const x=<span class="cstat-no" title="statement not covered" >event.x-this._canvasContainer.totalOffsetLeft();</span>let minDistance=<span class="cstat-no" title="statement not covered" >Infinity;</span>let bestTime;<span class="cstat-no" title="statement not covered" >for(const counterUI of this._counterUI){<span class="cstat-no" title="statement not covered" >if(!counterUI.counter.times.length)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst index=<span class="cstat-no" title="statement not covered" >counterUI._recordIndexAt(x);</span>const distance=<span class="cstat-no" title="statement not covered" >Math.abs(x*window.devicePixelRatio-counterUI.counter.x[index]);<span class="cstat-no" title="statement not covered" ></span>if(distance&lt;minDistance){<span class="cstat-no" title="statement not covered" >minDistance=distance;<span class="cstat-no" title="statement not covered" >b</span>estTime=counterUI.counter.times[index];}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(bestTime!==undefined){<span class="cstat-no" title="statement not covered" >this._delegate.selectEntryAtTime(this._track.events.length?this._track.events:this._track.asyncEvents,bestTime);}</span>}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseLeave(event){<span class="cstat-no" title="statement not covered" >delete this._markerXPosition;<span class="cstat-no" title="statement not covered" >t</span>his._clearCurrentValueAndMarker();}</span>
<span class="fstat-no" title="function not covered" >_c</span>learCurrentValueAndMarker(){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._counterUI.length;i++)</span>
<span class="cstat-no" title="statement not covered" >this._counterUI[i]._clearCurrentValueAndMarker();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){const x=<span class="cstat-no" title="statement not covered" >event.x-this._canvasContainer.totalOffsetLeft();<span class="cstat-no" title="statement not covered" ></span>this._markerXPosition=x;<span class="cstat-no" title="statement not covered" >t</span>his._refreshCurrentValues();}</span>
<span class="fstat-no" title="function not covered" >_r</span>efreshCurrentValues(){<span class="cstat-no" title="statement not covered" >if(this._markerXPosition===undefined)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._counterUI.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._counterUI[i].updateCurrentValue(this._markerXPosition);}</span>
<span class="fstat-no" title="function not covered" >re</span>fresh(){<span class="cstat-no" title="statement not covered" >this._timelineGrid.updateDividers(this._calculator);<span class="cstat-no" title="statement not covered" >t</span>his.draw();<span class="cstat-no" title="statement not covered" >t</span>his._refreshCurrentValues();}</span>
<span class="fstat-no" title="function not covered" >_c</span>lear(){const ctx=<span class="cstat-no" title="statement not covered" >this._canvas.getContext('2d');<span class="cstat-no" title="statement not covered" ></span>ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.CountersGraph.Counter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.times=[];<span class="cstat-no" title="statement not covered" >t</span>his.values=[];}</span></span>
<span class="fstat-no" title="function not covered" >ap</span>pendSample(time,value){<span class="cstat-no" title="statement not covered" >if(this.values.length&amp;&amp;this.values.peekLast()===value)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.times.push(time);<span class="cstat-no" title="statement not covered" >t</span>his.values.push(value);}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this.times=[];<span class="cstat-no" title="statement not covered" >t</span>his.values=[];}</span>
<span class="fstat-no" title="function not covered" >se</span>tLimit(value){<span class="cstat-no" title="statement not covered" >this._limitValue=value;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateBounds(){let maxValue;let minValue;<span class="cstat-no" title="statement not covered" >for(let i=this._minimumIndex;i&lt;=this._maximumIndex;i++){const value=<span class="cstat-no" title="statement not covered" >this.values[i];<span class="cstat-no" title="statement not covered" ></span>if(minValue===undefined||value&lt;minValue)</span></span>
<span class="cstat-no" title="statement not covered" >minValue=value;<span class="cstat-no" title="statement not covered" >i</span>f(maxValue===undefined||value&gt;maxValue)</span>
<span class="cstat-no" title="statement not covered" >maxValue=value;}</span>
<span class="cstat-no" title="statement not covered" >minValue=minValue||0;<span class="cstat-no" title="statement not covered" >m</span>axValue=maxValue||1;<span class="cstat-no" title="statement not covered" >i</span>f(this._limitValue){<span class="cstat-no" title="statement not covered" >if(maxValue&gt;this._limitValue*0.5)</span></span>
<span class="cstat-no" title="statement not covered" >maxValue=Math.max(maxValue,this._limitValue);<span class="cstat-no" title="statement not covered" >m</span>inValue=Math.min(minValue,this._limitValue);}</span>
<span class="cstat-no" title="statement not covered" >return{min:minValue,max:maxValue};}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateVisibleIndexes(calculator){const start=<span class="cstat-no" title="statement not covered" >calculator.minimumBoundary();</span>const end=<span class="cstat-no" title="statement not covered" >calculator.maximumBoundary();<span class="cstat-no" title="statement not covered" ></span>this._minimumIndex=Number.constrain(this.times.upperBound(start)-1,0,this.times.length-1);<span class="cstat-no" title="statement not covered" >t</span>his._maximumIndex=Number.constrain(this.times.lowerBound(end),0,this.times.length-1);<span class="cstat-no" title="statement not covered" >t</span>his._minTime=start;<span class="cstat-no" title="statement not covered" >t</span>his._maxTime=end;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateXValues(width){<span class="cstat-no" title="statement not covered" >if(!this.values.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst xFactor=<span class="cstat-no" title="statement not covered" >width/(this._maxTime-this._minTime);<span class="cstat-no" title="statement not covered" ></span>this.x=new Array(this.values.length);<span class="cstat-no" title="statement not covered" >f</span>or(let i=this._minimumIndex+1;i&lt;=this._maximumIndex;i++)</span>
<span class="cstat-no" title="statement not covered" >this.x[i]=xFactor*(this.times[i]-this._minTime);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.CountersGraph.CounterUI=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(countersPane,title,currentValueLabel,graphColor,counter,formatter){<span class="cstat-no" title="statement not covered" >this._countersPane=countersPane;<span class="cstat-no" title="statement not covered" >t</span>his.counter=counter;<span class="cstat-no" title="statement not covered" >t</span>his._formatter=formatter||Number.withThousandsSeparator;<span class="cstat-no" title="statement not covered" >t</span>his._setting=Common.settings.createSetting('timelineCountersGraph-'+title,true);<span class="cstat-no" title="statement not covered" >t</span>his._setting.setTitle(title);<span class="cstat-no" title="statement not covered" >t</span>his._filter=new UI.ToolbarSettingCheckbox(this._setting,title);<span class="cstat-no" title="statement not covered" >t</span>his._filter.inputElement.classList.add('-theme-preserve');c</span>onst color=<span class="cstat-no" title="statement not covered" >Common.Color.parse(graphColor).setAlpha(0.5).asString(Common.Color.Format.RGBA);<span class="cstat-no" title="statement not covered" ></span>if(color){<span class="cstat-no" title="statement not covered" >this._filter.element.backgroundColor=color;<span class="cstat-no" title="statement not covered" >t</span>his._filter.element.borderColor='transparent';}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._filter.inputElement.addEventListener('click',this._toggleCounterGraph.bind(this));<span class="cstat-no" title="statement not covered" >c</span>ountersPane._toolbar.appendToolbarItem(this._filter);<span class="cstat-no" title="statement not covered" >t</span>his._range=this._filter.element.createChild('span','range');<span class="cstat-no" title="statement not covered" >t</span>his._value=countersPane._currentValuesBar.createChild('span','memory-counter-value');<span class="cstat-no" title="statement not covered" >t</span>his._value.style.color=graphColor;<span class="cstat-no" title="statement not covered" >t</span>his.graphColor=graphColor;<span class="cstat-no" title="statement not covered" >t</span>his.limitColor=Common.Color.parse(graphColor).setAlpha(0.3).asString(Common.Color.Format.RGBA);<span class="cstat-no" title="statement not covered" >t</span>his.graphYValues=[];<span class="cstat-no" title="statement not covered" >t</span>his._verticalPadding=10;<span class="cstat-no" title="statement not covered" >t</span>his._currentValueLabel=currentValueLabel;<span class="cstat-no" title="statement not covered" >t</span>his._marker=countersPane._canvasContainer.createChild('div','memory-counter-marker');<span class="cstat-no" title="statement not covered" >t</span>his._marker.style.backgroundColor=graphColor;<span class="cstat-no" title="statement not covered" >t</span>his._clearCurrentValueAndMarker();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._range.textContent='';}</span>
<span class="fstat-no" title="function not covered" >se</span>tRange(minValue,maxValue){const min=<span class="cstat-no" title="statement not covered" >this._formatter(minValue);</span>const max=<span class="cstat-no" title="statement not covered" >this._formatter(maxValue);<span class="cstat-no" title="statement not covered" ></span>this._range.textContent=Common.UIString('[%s\xa0\u2013\xa0%s]',min,max);}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleCounterGraph(event){<span class="cstat-no" title="statement not covered" >this._value.classList.toggle('hidden',!this._filter.checked());<span class="cstat-no" title="statement not covered" >t</span>his._countersPane.refresh();}</span>
<span class="fstat-no" title="function not covered" >_r</span>ecordIndexAt(x){<span class="cstat-no" title="statement not covered" >return this.counter.x.upperBound(x*window.devicePixelRatio,null,this.counter._minimumIndex+1,this.counter._maximumIndex+1)-</span>
1;}
<span class="fstat-no" title="function not covered" >up</span>dateCurrentValue(x){<span class="cstat-no" title="statement not covered" >if(!this.visible()||!this.counter.values.length||!this.counter.x)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst index=<span class="cstat-no" title="statement not covered" >this._recordIndexAt(x);</span>const value=<span class="cstat-no" title="statement not covered" >Number.withThousandsSeparator(this.counter.values[index]);<span class="cstat-no" title="statement not covered" ></span>this._value.textContent=Common.UIString(this._currentValueLabel,value);c</span>onst y=<span class="cstat-no" title="statement not covered" >this.graphYValues[index]/window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>this._marker.style.left=x+'px';<span class="cstat-no" title="statement not covered" >t</span>his._marker.style.top=y+'px';<span class="cstat-no" title="statement not covered" >t</span>his._marker.classList.remove('hidden');}</span>
<span class="fstat-no" title="function not covered" >_c</span>learCurrentValueAndMarker(){<span class="cstat-no" title="statement not covered" >this._value.textContent='';<span class="cstat-no" title="statement not covered" >t</span>his._marker.classList.add('hidden');}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawGraph(canvas){const ctx=<span class="cstat-no" title="statement not covered" >canvas.getContext('2d');</span>const width=<span class="cstat-no" title="statement not covered" >canvas.width;</span>const height=<span class="cstat-no" title="statement not covered" >canvas.height-2*this._verticalPadding;<span class="cstat-no" title="statement not covered" ></span>if(height&lt;=0){<span class="cstat-no" title="statement not covered" >this.graphYValues=[];<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const originY=<span class="cstat-no" title="statement not covered" >this._verticalPadding;</span>const counter=<span class="cstat-no" title="statement not covered" >this.counter;</span>const values=<span class="cstat-no" title="statement not covered" >counter.values;<span class="cstat-no" title="statement not covered" ></span>if(!values.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst bounds=<span class="cstat-no" title="statement not covered" >counter._calculateBounds();</span>const minValue=<span class="cstat-no" title="statement not covered" >bounds.min;</span>const maxValue=<span class="cstat-no" title="statement not covered" >bounds.max;<span class="cstat-no" title="statement not covered" ></span>this.setRange(minValue,maxValue);<span class="cstat-no" title="statement not covered" >i</span>f(!this.visible())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst yValues=<span class="cstat-no" title="statement not covered" >this.graphYValues;</span>const maxYRange=<span class="cstat-no" title="statement not covered" >maxValue-minValue;</span>const yFactor=<span class="cstat-no" title="statement not covered" >maxYRange?height/(maxYRange):1;<span class="cstat-no" title="statement not covered" ></span>ctx.save();<span class="cstat-no" title="statement not covered" >c</span>tx.lineWidth=window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >i</span>f(ctx.lineWidth%2)</span>
<span class="cstat-no" title="statement not covered" >ctx.translate(0.5,0.5);<span class="cstat-no" title="statement not covered" >c</span>tx.beginPath();l</span>et value=<span class="cstat-no" title="statement not covered" >values[counter._minimumIndex];</span>let currentY=<span class="cstat-no" title="statement not covered" >Math.round(originY+height-(value-minValue)*yFactor);<span class="cstat-no" title="statement not covered" ></span>ctx.moveTo(0,currentY);l</span>et i=<span class="cstat-no" title="statement not covered" >counter._minimumIndex;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;=counter._maximumIndex;i++){const x=<span class="cstat-no" title="statement not covered" >Math.round(counter.x[i]);<span class="cstat-no" title="statement not covered" ></span>ctx.lineTo(x,currentY);c</span>onst currentValue=<span class="cstat-no" title="statement not covered" >values[i];<span class="cstat-no" title="statement not covered" ></span>if(typeof currentValue!=='undefined')</span></span>
<span class="cstat-no" title="statement not covered" >value=currentValue;<span class="cstat-no" title="statement not covered" >c</span>urrentY=Math.round(originY+height-(value-minValue)*yFactor);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,currentY);<span class="cstat-no" title="statement not covered" >y</span>Values[i]=currentY;}</span>
<span class="cstat-no" title="statement not covered" >yValues.length=i;<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(width,currentY);<span class="cstat-no" title="statement not covered" >c</span>tx.strokeStyle=this.graphColor;<span class="cstat-no" title="statement not covered" >c</span>tx.stroke();<span class="cstat-no" title="statement not covered" >i</span>f(counter._limitValue){const limitLineY=<span class="cstat-no" title="statement not covered" >Math.round(originY+height-(counter._limitValue-minValue)*yFactor);<span class="cstat-no" title="statement not covered" ></span>ctx.moveTo(0,limitLineY);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(width,limitLineY);<span class="cstat-no" title="statement not covered" >c</span>tx.strokeStyle=this.limitColor;<span class="cstat-no" title="statement not covered" >c</span>tx.stroke();}</span></span>
<span class="cstat-no" title="statement not covered" >ctx.closePath();<span class="cstat-no" title="statement not covered" >c</span>tx.restore();}</span>
<span class="fstat-no" title="function not covered" >vi</span>sible(){<span class="cstat-no" title="statement not covered" >return this._filter.checked();}</span>};<span class="cstat-no" title="statement not covered" >Timeline.CountersGraph.Calculator=class{<span class="fstat-no" title="function not covered" >se</span>tZeroTime(time){<span class="cstat-no" title="statement not covered" >this._zeroTime=time;}</span></span>
<span class="fstat-no" title="function not covered" >co</span>mputePosition(time){<span class="cstat-no" title="statement not covered" >return(time-this._minimumBoundary)/this.boundarySpan()*this._workingArea;}</span>
<span class="fstat-no" title="function not covered" >se</span>tWindow(minimumBoundary,maximumBoundary){<span class="cstat-no" title="statement not covered" >this._minimumBoundary=minimumBoundary;<span class="cstat-no" title="statement not covered" >t</span>his._maximumBoundary=maximumBoundary;}</span>
<span class="fstat-no" title="function not covered" >se</span>tDisplayWidth(clientWidth){<span class="cstat-no" title="statement not covered" >this._workingArea=clientWidth;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Number.preciseMillisToString(value-this.zeroTime(),precision);}</span>
<span class="fstat-no" title="function not covered" >ma</span>ximumBoundary(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundary;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundary;}</span>
<span class="fstat-no" title="function not covered" >ze</span>roTime(){<span class="cstat-no" title="statement not covered" >return this._zeroTime;}</span>
<span class="fstat-no" title="function not covered" >bo</span>undarySpan(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundary-this._minimumBoundary;}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.ExtensionTracingSession=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(provider,performanceModel){<span class="cstat-no" title="statement not covered" >this._provider=provider;<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=performanceModel;<span class="cstat-no" title="statement not covered" >t</span>his._completionCallback;<span class="cstat-no" title="statement not covered" >t</span>his._completionPromise=new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfill=&gt;{<span class="cstat-no" title="statement not covered" >this._completionCallback=fulfill;}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._timeOffset=0;}</span></span>
<span class="fstat-no" title="function not covered" >lo</span>adingStarted(){}
<span class="fstat-no" title="function not covered" >pr</span>ocessingStarted(){}
<span class="fstat-no" title="function not covered" >lo</span>adingProgress(progress){}
<span class="fstat-no" title="function not covered" >lo</span>adingComplete(tracingModel){<span class="cstat-no" title="statement not covered" >if(!tracingModel)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel.addExtensionEvents(this._provider.longDisplayName(),tracingModel,this._timeOffset);<span class="cstat-no" title="statement not covered" >t</span>his._completionCallback();}</span>
<span class="fstat-no" title="function not covered" >co</span>mplete(url,timeOffsetMicroseconds){<span class="cstat-no" title="statement not covered" >if(!url){<span class="cstat-no" title="statement not covered" >this._completionCallback();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._timeOffset=timeOffsetMicroseconds;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineLoader.loadFromURL(url,this);}</span>
<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >this._provider.start(this);}</span>
<span class="fstat-no" title="function not covered" >st</span>op(){<span class="cstat-no" title="statement not covered" >this._provider.stop();<span class="cstat-no" title="statement not covered" >r</span>eturn this._completionPromise;}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.PerformanceModel=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._mainTarget=null;<span class="cstat-no" title="statement not covered" >t</span>his._tracingModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._filters=[];<span class="cstat-no" title="statement not covered" >t</span>his._timelineModel=new TimelineModel.TimelineModel();<span class="cstat-no" title="statement not covered" >t</span>his._frameModel=new TimelineModel.TimelineFrameModel(<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(event).category.name)</span>;<span class="cstat-no" title="statement not covered" >t</span>his._filmStripModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._irModel=new TimelineModel.TimelineIRModel();<span class="cstat-no" title="statement not covered" >t</span>his._window={left:0,right:Infinity};<span class="cstat-no" title="statement not covered" >t</span>his._extensionTracingModels=[];<span class="cstat-no" title="statement not covered" >t</span>his._recordStartTime=undefined;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tMainTarget(target){<span class="cstat-no" title="statement not covered" >this._mainTarget=target;}</span>
<span class="fstat-no" title="function not covered" >se</span>tRecordStartTime(time){<span class="cstat-no" title="statement not covered" >this._recordStartTime=time;}</span>
<span class="fstat-no" title="function not covered" >re</span>cordStartTime(){<span class="cstat-no" title="statement not covered" >return this._recordStartTime;}</span>
<span class="fstat-no" title="function not covered" >se</span>tFilters(filters){<span class="cstat-no" title="statement not covered" >this._filters=filters;}</span>
<span class="fstat-no" title="function not covered" >fi</span>lters(){<span class="cstat-no" title="statement not covered" >return this._filters;}</span>
<span class="fstat-no" title="function not covered" >is</span>Visible(event){<span class="cstat-no" title="statement not covered" >return this._filters.every(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >f.accept(event))</span>;}</span>
<span class="fstat-no" title="function not covered" >se</span>tTracingModel(model){<span class="cstat-no" title="statement not covered" >this._tracingModel=model;<span class="cstat-no" title="statement not covered" >t</span>his._timelineModel.setEvents(model);l</span>et inputEvents=<span class="cstat-no" title="statement not covered" >null;</span>let animationEvents=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>for(const track of this._timelineModel.tracks()){<span class="cstat-no" title="statement not covered" >if(track.type===TimelineModel.TimelineModel.TrackType.Input)</span></span>
<span class="cstat-no" title="statement not covered" >inputEvents=track.asyncEvents;<span class="cstat-no" title="statement not covered" >i</span>f(track.type===TimelineModel.TimelineModel.TrackType.Animation)</span>
<span class="cstat-no" title="statement not covered" >animationEvents=track.asyncEvents;}</span>
<span class="cstat-no" title="statement not covered" >if(inputEvents||animationEvents)</span>
<span class="cstat-no" title="statement not covered" >this._irModel.populate(inputEvents||[],animationEvents||[]);c</span>onst mainTracks=<span class="cstat-no" title="statement not covered" >this._timelineModel.tracks().filter(<span class="fstat-no" title="function not covered" >tr</span>ack=&gt;<span class="cstat-no" title="statement not covered" >track.type===TimelineModel.TimelineModel.TrackType.MainThread&amp;&amp;track.forMainFrame&amp;&amp;track.events.length)</span>;</span>const threadData=<span class="cstat-no" title="statement not covered" >mainTracks.map(<span class="fstat-no" title="function not covered" >tr</span>ack=&gt;{const event=<span class="cstat-no" title="statement not covered" >track.events[0];<span class="cstat-no" title="statement not covered" ></span>return{thread:event.thread,time:event.startTime};}</span>);<span class="cstat-no" title="statement not covered" ></span>this._frameModel.addTraceEvents(this._mainTarget,this._timelineModel.inspectedTargetEvents(),threadData);<span class="cstat-no" title="statement not covered" >f</span>or(const entry of this._extensionTracingModels){<span class="cstat-no" title="statement not covered" >entry.model.adjustTime(this._tracingModel.minimumRecordTime()+(entry.timeOffset/1000)-this._recordStartTime);}</span></span>
<span class="cstat-no" title="statement not covered" >this._autoWindowTimes();}</span>
<span class="fstat-no" title="function not covered" >ad</span>dExtensionEvents(title,model,timeOffset){<span class="cstat-no" title="statement not covered" >this._extensionTracingModels.push({model:model,title:title,timeOffset:timeOffset});<span class="cstat-no" title="statement not covered" >i</span>f(!this._tracingModel)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >m</span>odel.adjustTime(this._tracingModel.minimumRecordTime()+(timeOffset/1000)-this._recordStartTime);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Timeline.PerformanceModel.Events.ExtensionDataAdded);}</span>
<span class="fstat-no" title="function not covered" >tr</span>acingModel(){<span class="cstat-no" title="statement not covered" >if(!this._tracingModel)</span>
<span class="cstat-no" title="statement not covered" >throw'call setTracingModel before accessing PerformanceModel';<span class="cstat-no" title="statement not covered" >r</span>eturn this._tracingModel;}</span>
<span class="fstat-no" title="function not covered" >ti</span>melineModel(){<span class="cstat-no" title="statement not covered" >return this._timelineModel;}</span>
<span class="fstat-no" title="function not covered" >fi</span>lmStripModel(){<span class="cstat-no" title="statement not covered" >if(this._filmStripModel)</span>
<span class="cstat-no" title="statement not covered" >return this._filmStripModel;<span class="cstat-no" title="statement not covered" >i</span>f(!this._tracingModel)</span>
<span class="cstat-no" title="statement not covered" >throw'call setTracingModel before accessing PerformanceModel';<span class="cstat-no" title="statement not covered" >t</span>his._filmStripModel=new SDK.FilmStripModel(this._tracingModel);<span class="cstat-no" title="statement not covered" >r</span>eturn this._filmStripModel;}</span>
<span class="fstat-no" title="function not covered" >fr</span>ames(){<span class="cstat-no" title="statement not covered" >return this._frameModel.frames();}</span>
<span class="fstat-no" title="function not covered" >fr</span>ameModel(){<span class="cstat-no" title="statement not covered" >return this._frameModel;}</span>
<span class="fstat-no" title="function not covered" >in</span>teractionRecords(){<span class="cstat-no" title="statement not covered" >return this._irModel.interactionRecords();}</span>
<span class="fstat-no" title="function not covered" >ex</span>tensionInfo(){<span class="cstat-no" title="statement not covered" >return this._extensionTracingModels;}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >if(this._tracingModel)</span>
<span class="cstat-no" title="statement not covered" >this._tracingModel.dispose();<span class="cstat-no" title="statement not covered" >f</span>or(const extensionEntry of this._extensionTracingModels)</span>
<span class="cstat-no" title="statement not covered" >extensionEntry.model.dispose();}</span>
<span class="fstat-no" title="function not covered" >fi</span>lmStripModelFrame(frame){const screenshotTime=<span class="cstat-no" title="statement not covered" >frame.idle?frame.startTime:frame.endTime;</span>const filmStripFrame=<span class="cstat-no" title="statement not covered" >this._filmStripModel.frameByTimestamp(screenshotTime);<span class="cstat-no" title="statement not covered" ></span>return filmStripFrame&amp;&amp;filmStripFrame.timestamp-frame.endTime&lt;10?filmStripFrame:null;}</span>
<span class="fstat-no" title="function not covered" >sa</span>ve(stream){const backingStorage=(<span class="cstat-no" title="statement not covered" >this._tracingModel.backingStorage())</span>;<span class="cstat-no" title="statement not covered" >return backingStorage.writeToStream(stream);}</span>
<span class="fstat-no" title="function not covered" >se</span>tWindow(window,animate){<span class="cstat-no" title="statement not covered" >this._window=window;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Timeline.PerformanceModel.Events.WindowChanged,{window,animate});}</span>
<span class="fstat-no" title="function not covered" >wi</span>ndow(){<span class="cstat-no" title="statement not covered" >return this._window;}</span>
<span class="fstat-no" title="function not covered" >_a</span>utoWindowTimes(){const timelineModel=<span class="cstat-no" title="statement not covered" >this._timelineModel;</span>let tasks=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const track of timelineModel.tracks()){<span class="cstat-no" title="statement not covered" >if(track.type===TimelineModel.TimelineModel.TrackType.MainThread&amp;&amp;track.forMainFrame)</span></span>
<span class="cstat-no" title="statement not covered" >tasks=track.tasks;}</span>
<span class="cstat-no" title="statement not covered" >if(!tasks.length){<span class="cstat-no" title="statement not covered" >this.setWindow({left:timelineModel.minimumRecordTime(),right:timelineModel.maximumRecordTime()});<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
function <span class="fstat-no" title="function not covered" >findLowUtilizationRegion(</span>startIndex,stopIndex){const threshold=<span class="cstat-no" title="statement not covered" >0.1;</span>let cutIndex=<span class="cstat-no" title="statement not covered" >startIndex;</span>let cutTime=<span class="cstat-no" title="statement not covered" >(tasks[cutIndex].startTime+tasks[cutIndex].endTime)/2;</span>let usedTime=<span class="cstat-no" title="statement not covered" >0;</span>const step=<span class="cstat-no" title="statement not covered" >Math.sign(stopIndex-startIndex);<span class="cstat-no" title="statement not covered" ></span>for(let i=startIndex;i!==stopIndex;i+=step){const task=<span class="cstat-no" title="statement not covered" >tasks[i];</span>const taskTime=<span class="cstat-no" title="statement not covered" >(task.startTime+task.endTime)/2;</span>const interval=<span class="cstat-no" title="statement not covered" >Math.abs(cutTime-taskTime);<span class="cstat-no" title="statement not covered" ></span>if(usedTime&lt;threshold*interval){<span class="cstat-no" title="statement not covered" >cutIndex=i;<span class="cstat-no" title="statement not covered" >c</span>utTime=taskTime;<span class="cstat-no" title="statement not covered" >u</span>sedTime=0;}</span></span></span>
<span class="cstat-no" title="statement not covered" >usedTime+=task.duration;}</span>
<span class="cstat-no" title="statement not covered" >return cutIndex;}</span>
const rightIndex=<span class="cstat-no" title="statement not covered" >findLowUtilizationRegion(tasks.length-1,0);</span>const leftIndex=<span class="cstat-no" title="statement not covered" >findLowUtilizationRegion(0,rightIndex);</span>let leftTime=<span class="cstat-no" title="statement not covered" >tasks[leftIndex].startTime;</span>let rightTime=<span class="cstat-no" title="statement not covered" >tasks[rightIndex].endTime;</span>const span=<span class="cstat-no" title="statement not covered" >rightTime-leftTime;</span>const totalSpan=<span class="cstat-no" title="statement not covered" >timelineModel.maximumRecordTime()-timelineModel.minimumRecordTime();<span class="cstat-no" title="statement not covered" ></span>if(span&lt;totalSpan*0.1){<span class="cstat-no" title="statement not covered" >leftTime=timelineModel.minimumRecordTime();<span class="cstat-no" title="statement not covered" >r</span>ightTime=timelineModel.maximumRecordTime();}</span>else{<span class="cstat-no" title="statement not covered" >leftTime=Math.max(leftTime-0.05*span,timelineModel.minimumRecordTime());<span class="cstat-no" title="statement not covered" >r</span>ightTime=Math.min(rightTime+0.05*span,timelineModel.maximumRecordTime());}</span></span>
<span class="cstat-no" title="statement not covered" >this.setWindow({left:leftTime,right:rightTime});}</span>};<span class="cstat-no" title="statement not covered" >Timeline.PerformanceModel.Events={ExtensionDataAdded:Symbol('ExtensionDataAdded'),WindowChanged:Symbol('WindowChanged')};<span class="cstat-no" title="statement not covered" >T</span>imeline.PerformanceModel.Window;;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineController=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(target,client){<span class="cstat-no" title="statement not covered" >this._target=target;<span class="cstat-no" title="statement not covered" >t</span>his._tracingManager=target.model(SDK.TracingManager);<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=new Timeline.PerformanceModel();<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel.setMainTarget(target);<span class="cstat-no" title="statement not covered" >t</span>his._client=client;c</span>onst backingStorage=<span class="cstat-no" title="statement not covered" >new Bindings.TempFileBackingStorage();<span class="cstat-no" title="statement not covered" ></span>this._tracingModel=new SDK.TracingModel(backingStorage);<span class="cstat-no" title="statement not covered" >t</span>his._extensionSessions=[];<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.observeModels(SDK.CPUProfilerModel,this);}</span></span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >SDK.targetManager.unobserveModels(SDK.CPUProfilerModel,this);}</span>
<span class="fstat-no" title="function not covered" >ma</span>inTarget(){<span class="cstat-no" title="statement not covered" >return this._target;}</span>
<span class="fstat-no" title="function not covered" >st</span>artRecording(options,providers){<span class="cstat-no" title="statement not covered" >this._extensionTraceProviders=Extensions.extensionServer.traceProviders().slice();f</span>unction <span class="fstat-no" title="function not covered" >disabledByDefault(</span>category){<span class="cstat-no" title="statement not covered" >return'disabled-by-default-'+category;}</span>
const categoriesArray=<span class="cstat-no" title="statement not covered" >['-*','devtools.timeline','v8.execute',disabledByDefault('devtools.timeline'),disabledByDefault('devtools.timeline.frame'),SDK.TracingModel.TopLevelEventCategory,TimelineModel.TimelineModel.Category.Console,TimelineModel.TimelineModel.Category.UserTiming];<span class="cstat-no" title="statement not covered" ></span>categoriesArray.push(TimelineModel.TimelineModel.Category.LatencyInfo);<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('timelineFlowEvents'))</span>
<span class="cstat-no" title="statement not covered" >categoriesArray.push('devtools.timeline.async');<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('timelineV8RuntimeCallStats')&amp;&amp;options.enableJSSampling)</span>
<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('v8.runtime_stats_sampling'));<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('timelineTracingJSProfile')&amp;&amp;options.enableJSSampling){<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('v8.cpu_profiler'));<span class="cstat-no" title="statement not covered" >i</span>f(Common.moduleSetting('highResolutionCpuProfiling').get())</span></span>
<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('v8.cpu_profiler.hires'));}</span>
<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('devtools.timeline.stack'));<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('timelineInvalidationTracking'))</span>
<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('devtools.timeline.invalidationTracking'));<span class="cstat-no" title="statement not covered" >i</span>f(options.capturePictures){<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('devtools.timeline.layers'),disabledByDefault('devtools.timeline.picture'),disabledByDefault('blink.graphics_context_annotations'));}</span></span>
<span class="cstat-no" title="statement not covered" >if(options.captureFilmStrip)</span>
<span class="cstat-no" title="statement not covered" >categoriesArray.push(disabledByDefault('devtools.screenshot'));<span class="cstat-no" title="statement not covered" >t</span>his._extensionSessions=providers.map(<span class="fstat-no" title="function not covered" >pr</span>ovider=&gt;<span class="cstat-no" title="statement not covered" >new Timeline.ExtensionTracingSession(provider,this._performanceModel))</span>;<span class="cstat-no" title="statement not covered" >t</span>his._extensionSessions.forEach(<span class="fstat-no" title="function not covered" >se</span>ssion=&gt;<span class="cstat-no" title="statement not covered" >session.start())</span>;c</span>onst startPromise=<span class="cstat-no" title="statement not covered" >this._startRecordingWithCategories(categoriesArray.join(','),options.enableJSSampling);<span class="cstat-no" title="statement not covered" ></span>this._performanceModel.setRecordStartTime(Date.now());<span class="cstat-no" title="statement not covered" >r</span>eturn startPromise;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync stopRecording(){const tracingStoppedPromises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(this._tracingManager)</span>
<span class="cstat-no" title="statement not covered" >tracingStoppedPromises.push(new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >this._tracingCompleteCallback=resolve)</span>);<span class="cstat-no" title="statement not covered" >t</span>racingStoppedPromises.push(this._stopProfilingOnAllModels());<span class="cstat-no" title="statement not covered" >i</span>f(this._tracingManager)</span>
<span class="cstat-no" title="statement not covered" >this._tracingManager.stop();<span class="cstat-no" title="statement not covered" >t</span>his._client.loadingStarted();c</span>onst extensionCompletionPromises=<span class="cstat-no" title="statement not covered" >this._extensionSessions.map(<span class="fstat-no" title="function not covered" >se</span>ssion=&gt;<span class="cstat-no" title="statement not covered" >session.stop())</span>;<span class="cstat-no" title="statement not covered" ></span>if(extensionCompletionPromises.length){<span class="cstat-no" title="statement not covered" >tracingStoppedPromises.push(Promise.race([Promise.all(extensionCompletionPromises),new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >setTimeout(r,5000))</span>]));}</span></span>
<span class="cstat-no" title="statement not covered" >await Promise.all(tracingStoppedPromises);<span class="cstat-no" title="statement not covered" >t</span>his._allSourcesFinished();<span class="cstat-no" title="statement not covered" >r</span>eturn this._performanceModel;}</span>
<span class="fstat-no" title="function not covered" >mo</span>delAdded(cpuProfilerModel){<span class="cstat-no" title="statement not covered" >if(this._profiling)</span>
<span class="cstat-no" title="statement not covered" >cpuProfilerModel.startRecording();}</span>
<span class="fstat-no" title="function not covered" >mo</span>delRemoved(cpuProfilerModel){}
<span class="fstat-no" title="function not covered" >_s</span>tartProfilingOnAllModels(){<span class="cstat-no" title="statement not covered" >this._profiling=true;c</span>onst models=<span class="cstat-no" title="statement not covered" >SDK.targetManager.models(SDK.CPUProfilerModel);<span class="cstat-no" title="statement not covered" ></span>return Promise.all(models.map(<span class="fstat-no" title="function not covered" >mo</span>del=&gt;<span class="cstat-no" title="statement not covered" >model.startRecording())</span>);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddCpuProfile(targetId,cpuProfile){<span class="cstat-no" title="statement not covered" >if(!cpuProfile){<span class="cstat-no" title="statement not covered" >Common.console.warn(Common.UIString('CPU profile for a target is not available.'));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!this._cpuProfiles)</span>
<span class="cstat-no" title="statement not covered" >this._cpuProfiles=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._cpuProfiles.set(targetId,cpuProfile);}</span>
<span class="fstat-no" title="function not covered" >_s</span>topProfilingOnAllModels(){const models=<span class="cstat-no" title="statement not covered" >this._profiling?SDK.targetManager.models(SDK.CPUProfilerModel):[];<span class="cstat-no" title="statement not covered" ></span>this._profiling=false;c</span>onst promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const model of models){const targetId=<span class="cstat-no" title="statement not covered" >model.target().id();</span>const modelPromise=<span class="cstat-no" title="statement not covered" >model.stopRecording().then(this._addCpuProfile.bind(this,targetId));<span class="cstat-no" title="statement not covered" ></span>promises.push(modelPromise);}</span></span>
<span class="cstat-no" title="statement not covered" >return Promise.all(promises);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _startRecordingWithCategories(categories,enableJSSampling){<span class="cstat-no" title="statement not covered" >SDK.targetManager.suspendAllTargets();<span class="cstat-no" title="statement not covered" >i</span>f(enableJSSampling&amp;&amp;!Runtime.experiments.isEnabled('timelineTracingJSProfile'))</span>
<span class="cstat-no" title="statement not covered" >await this._startProfilingOnAllModels();<span class="cstat-no" title="statement not covered" >i</span>f(!this._tracingManager)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst samplingFrequencyHz=<span class="cstat-no" title="statement not covered" >Common.moduleSetting('highResolutionCpuProfiling').get()?10000:1000;</span>const options=<span class="cstat-no" title="statement not covered" >'sampling-frequency='+samplingFrequencyHz;<span class="cstat-no" title="statement not covered" ></span>return this._tracingManager.start(this,categories,options);}</span>
<span class="fstat-no" title="function not covered" >tr</span>aceEventsCollected(events){<span class="cstat-no" title="statement not covered" >this._tracingModel.addEvents(events);}</span>
<span class="fstat-no" title="function not covered" >tr</span>acingComplete(){<span class="cstat-no" title="statement not covered" >this._tracingCompleteCallback();<span class="cstat-no" title="statement not covered" >t</span>his._tracingCompleteCallback=null;}</span>
<span class="fstat-no" title="function not covered" >_a</span>llSourcesFinished(){<span class="cstat-no" title="statement not covered" >this._client.processingStarted();<span class="cstat-no" title="statement not covered" >s</span>etTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._finalizeTrace(),</span>0);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _finalizeTrace(){<span class="cstat-no" title="statement not covered" >this._injectCpuProfileEvents();<span class="cstat-no" title="statement not covered" >a</span>wait SDK.targetManager.resumeAllTargets();<span class="cstat-no" title="statement not covered" >t</span>his._tracingModel.tracingComplete();<span class="cstat-no" title="statement not covered" >t</span>his._client.loadingComplete(this._tracingModel);}</span>
<span class="fstat-no" title="function not covered" >_i</span>njectCpuProfileEvent(pid,tid,cpuProfile){<span class="cstat-no" title="statement not covered" >if(!cpuProfile)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst cpuProfileEvent=(<span class="cstat-no" title="statement not covered" >{cat:SDK.TracingModel.DevToolsMetadataEventCategory,ph:SDK.TracingModel.Phase.Instant,ts:this._tracingModel.maximumRecordTime()*1000,pid:pid,tid:tid,name:TimelineModel.TimelineModel.RecordType.CpuProfile,args:{data:{cpuProfile:cpuProfile}}})</span>;<span class="cstat-no" title="statement not covered" >this._tracingModel.addEvents([cpuProfileEvent]);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildTargetToProcessIdMap(){const metadataEventTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.DevToolsMetadataEvent;</span>const metadataEvents=<span class="cstat-no" title="statement not covered" >this._tracingModel.devToolsMetadataEvents();</span>const browserMetaEvent=<span class="cstat-no" title="statement not covered" >metadataEvents.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.name===metadataEventTypes.TracingStartedInBrowser)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!browserMetaEvent)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst pseudoPidToFrames=<span class="cstat-no" title="statement not covered" >new Multimap();</span>const targetIdToPid=<span class="cstat-no" title="statement not covered" >new Map();</span>const frames=<span class="cstat-no" title="statement not covered" >browserMetaEvent.args.data['frames'];<span class="cstat-no" title="statement not covered" ></span>for(const frameInfo of frames)</span>
<span class="cstat-no" title="statement not covered" >targetIdToPid.set(frameInfo.frame,frameInfo.processId);<span class="cstat-no" title="statement not covered" >f</span>or(const event of metadataEvents){const data=<span class="cstat-no" title="statement not covered" >event.args.data;<span class="cstat-no" title="statement not covered" ></span>switch(event.name){case metadataEventTypes.FrameCommittedInBrowser:<span class="cstat-no" title="statement not covered" >if(data.processId)</span></span></span>
<span class="cstat-no" title="statement not covered" >targetIdToPid.set(data.frame,data.processId);e</span>lse
<span class="cstat-no" title="statement not covered" >pseudoPidToFrames.set(data.processPseudoId,data.frame);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase metadataEventTypes.ProcessReadyInBrowser:<span class="cstat-no" title="statement not covered" >for(const frame of pseudoPidToFrames.get(data.processPseudoId)||[])</span>
<span class="cstat-no" title="statement not covered" >targetIdToPid.set(frame,data.processId);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}
const mainFrame=<span class="cstat-no" title="statement not covered" >frames.find(<span class="fstat-no" title="function not covered" >fr</span>ame=&gt;<span class="cstat-no" title="statement not covered" >!frame.parent)</span>;</span>const mainRendererProcessId=<span class="cstat-no" title="statement not covered" >mainFrame.processId;</span>const mainProcess=<span class="cstat-no" title="statement not covered" >this._tracingModel.processById(mainRendererProcessId);<span class="cstat-no" title="statement not covered" ></span>if(mainProcess)</span>
<span class="cstat-no" title="statement not covered" >targetIdToPid.set(SDK.targetManager.mainTarget().id(),mainProcess.id());<span class="cstat-no" title="statement not covered" >r</span>eturn targetIdToPid;}</span>
<span class="fstat-no" title="function not covered" >_i</span>njectCpuProfileEvents(){<span class="cstat-no" title="statement not covered" >if(!this._cpuProfiles)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst metadataEventTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.DevToolsMetadataEvent;</span>const metadataEvents=<span class="cstat-no" title="statement not covered" >this._tracingModel.devToolsMetadataEvents();</span>const targetIdToPid=<span class="cstat-no" title="statement not covered" >this._buildTargetToProcessIdMap();<span class="cstat-no" title="statement not covered" ></span>if(targetIdToPid){<span class="cstat-no" title="statement not covered" >for(const[id,profile]of this._cpuProfiles){const pid=<span class="cstat-no" title="statement not covered" >targetIdToPid.get(id);<span class="cstat-no" title="statement not covered" ></span>if(!pid)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst process=<span class="cstat-no" title="statement not covered" >this._tracingModel.processById(pid);</span>const thread=<span class="cstat-no" title="statement not covered" >process&amp;&amp;process.threadByName(TimelineModel.TimelineModel.RendererMainThreadName);<span class="cstat-no" title="statement not covered" ></span>if(thread)</span>
<span class="cstat-no" title="statement not covered" >this._injectCpuProfileEvent(pid,thread.id(),profile);}</span>}else{const mainMetaEvent=<span class="cstat-no" title="statement not covered" >metadataEvents.filter(<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >event.name===metadataEventTypes.TracingStartedInPage)</span>.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(mainMetaEvent){const pid=<span class="cstat-no" title="statement not covered" >mainMetaEvent.thread.process().id();</span>const mainCpuProfile=<span class="cstat-no" title="statement not covered" >this._cpuProfiles.get(this._tracingManager.target().id());<span class="cstat-no" title="statement not covered" ></span>this._injectCpuProfileEvent(pid,mainMetaEvent.thread.id(),mainCpuProfile);}</span>else{let tid=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const pair of this._cpuProfiles){const target=<span class="cstat-no" title="statement not covered" >SDK.targetManager.targetById(pair[0]);</span>const name=<span class="cstat-no" title="statement not covered" >target&amp;&amp;target.name();<span class="cstat-no" title="statement not covered" ></span>this._tracingModel.addEvents(TimelineModel.TimelineJSProfileProcessor.buildTraceProfileFromCpuProfile(pair[1],++tid,tid===1,name));}</span>}</span>}</span>
const workerMetaEvents=<span class="cstat-no" title="statement not covered" >metadataEvents.filter(<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >event.name===metadataEventTypes.TracingSessionIdForWorker)</span>;<span class="cstat-no" title="statement not covered" ></span>for(const metaEvent of workerMetaEvents){const workerId=<span class="cstat-no" title="statement not covered" >metaEvent.args['data']['workerId'];</span>const cpuProfile=<span class="cstat-no" title="statement not covered" >this._cpuProfiles.get(workerId);<span class="cstat-no" title="statement not covered" ></span>this._injectCpuProfileEvent(metaEvent.thread.process().id(),metaEvent.args['data']['workerThreadId'],cpuProfile);}</span></span>
<span class="cstat-no" title="statement not covered" >this._cpuProfiles=null;}</span>
<span class="fstat-no" title="function not covered" >tr</span>acingBufferUsage(usage){<span class="cstat-no" title="statement not covered" >this._client.recordingProgress(usage);}</span>
<span class="fstat-no" title="function not covered" >ev</span>entsRetrievalProgress(progress){<span class="cstat-no" title="statement not covered" >this._client.loadingProgress(progress);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineController.Client=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineController.Client.prototype={recordingProgress(usage){},};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineController.RecordingOptions;;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineDetailsView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(delegate){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('timeline-details');<span class="cstat-no" title="statement not covered" >t</span>his._detailsLinkifier=new Components.Linkifier();<span class="cstat-no" title="statement not covered" >t</span>his._badgePool=new ProductRegistry.BadgePool();<span class="cstat-no" title="statement not covered" >t</span>his._badgePool.setShowTitles(true);<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane=new UI.TabbedPane();<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane.show(this.element);c</span>onst tabIds=<span class="cstat-no" title="statement not covered" >Timeline.TimelineDetailsView.Tab;<span class="cstat-no" title="statement not covered" ></span>this._defaultDetailsWidget=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._defaultDetailsWidget.element.classList.add('timeline-details-view');<span class="cstat-no" title="statement not covered" >t</span>his._defaultDetailsContentElement=this._defaultDetailsWidget.element.createChild('div','timeline-details-view-body vbox');<span class="cstat-no" title="statement not covered" >t</span>his._defaultDetailsContentElement.tabIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._appendTab(tabIds.Details,Common.UIString('Summary'),this._defaultDetailsWidget);<span class="cstat-no" title="statement not covered" >t</span>his.setPreferredTab(tabIds.Details);<span class="cstat-no" title="statement not covered" >t</span>his._rangeDetailViews=new Map();c</span>onst bottomUpView=<span class="cstat-no" title="statement not covered" >new Timeline.BottomUpTimelineTreeView();<span class="cstat-no" title="statement not covered" ></span>this._appendTab(tabIds.BottomUp,Common.UIString('Bottom-Up'),bottomUpView);<span class="cstat-no" title="statement not covered" >t</span>his._rangeDetailViews.set(tabIds.BottomUp,bottomUpView);c</span>onst callTreeView=<span class="cstat-no" title="statement not covered" >new Timeline.CallTreeTimelineTreeView();<span class="cstat-no" title="statement not covered" ></span>this._appendTab(tabIds.CallTree,Common.UIString('Call Tree'),callTreeView);<span class="cstat-no" title="statement not covered" >t</span>his._rangeDetailViews.set(tabIds.CallTree,callTreeView);c</span>onst eventsView=<span class="cstat-no" title="statement not covered" >new Timeline.EventsTimelineTreeView(delegate);<span class="cstat-no" title="statement not covered" ></span>this._appendTab(tabIds.EventLog,Common.UIString('Event Log'),eventsView);<span class="cstat-no" title="statement not covered" >t</span>his._rangeDetailViews.set(tabIds.EventLog,eventsView);<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane.addEventListener(UI.TabbedPane.Events.TabSelected,this._tabSelected,this);}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tModel(model,track){<span class="cstat-no" title="statement not covered" >if(this._model!==model){<span class="cstat-no" title="statement not covered" >if(this._model)</span></span>
<span class="cstat-no" title="statement not covered" >this._model.removeEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._model=model;<span class="cstat-no" title="statement not covered" >i</span>f(this._model)</span>
<span class="cstat-no" title="statement not covered" >this._model.addEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onWindowChanged,this);}</span>
<span class="cstat-no" title="statement not covered" >this._track=track;<span class="cstat-no" title="statement not covered" >t</span>his._tabbedPane.closeTabs([Timeline.TimelineDetailsView.Tab.PaintProfiler,Timeline.TimelineDetailsView.Tab.LayerViewer],false);<span class="cstat-no" title="statement not covered" >f</span>or(const view of this._rangeDetailViews.values())</span>
<span class="cstat-no" title="statement not covered" >view.setModel(model,track);<span class="cstat-no" title="statement not covered" >t</span>his._lazyPaintProfilerView=null;<span class="cstat-no" title="statement not covered" >t</span>his._lazyLayersView=null;<span class="cstat-no" title="statement not covered" >t</span>his.setSelection(null);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etContent(node){const allTabs=<span class="cstat-no" title="statement not covered" >this._tabbedPane.otherTabs(Timeline.TimelineDetailsView.Tab.Details);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;allTabs.length;++i){<span class="cstat-no" title="statement not covered" >if(!this._rangeDetailViews.has(allTabs[i]))</span></span>
<span class="cstat-no" title="statement not covered" >this._tabbedPane.closeTab(allTabs[i]);}</span>
<span class="cstat-no" title="statement not covered" >this._defaultDetailsContentElement.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._defaultDetailsContentElement.appendChild(node);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateContents(){const view=<span class="cstat-no" title="statement not covered" >this._rangeDetailViews.get(this._tabbedPane.selectedTabId||'');<span class="cstat-no" title="statement not covered" ></span>if(view){const window=<span class="cstat-no" title="statement not covered" >this._model.window();<span class="cstat-no" title="statement not covered" ></span>view.updateContents(this._selection||Timeline.TimelineSelection.fromRange(window.left,window.right));}</span>}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendTab(id,tabTitle,view,isCloseable){<span class="cstat-no" title="statement not covered" >this._tabbedPane.appendTab(id,tabTitle,view,undefined,undefined,isCloseable);<span class="cstat-no" title="statement not covered" >i</span>f(this._preferredTabId!==this._tabbedPane.selectedTabId)</span>
<span class="cstat-no" title="statement not covered" >this._tabbedPane.selectTab(id);}</span>
<span class="fstat-no" title="function not covered" >he</span>aderElement(){<span class="cstat-no" title="statement not covered" >return this._tabbedPane.headerElement();}</span>
<span class="fstat-no" title="function not covered" >se</span>tPreferredTab(tabId){<span class="cstat-no" title="statement not covered" >this._preferredTabId=tabId;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(event){<span class="cstat-no" title="statement not covered" >if(!this._selection)</span>
<span class="cstat-no" title="statement not covered" >this._updateContentsFromWindow();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateContentsFromWindow(){<span class="cstat-no" title="statement not covered" >if(!this._model){<span class="cstat-no" title="statement not covered" >this._setContent(UI.html`&lt;div/&gt;`);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const window=<span class="cstat-no" title="statement not covered" >this._model.window();<span class="cstat-no" title="statement not covered" ></span>this._updateSelectedRangeStats(window.left,window.right);<span class="cstat-no" title="statement not covered" >t</span>his._updateContents();}</span>
<span class="fstat-no" title="function not covered" >se</span>tSelection(selection){<span class="cstat-no" title="statement not covered" >this._detailsLinkifier.reset();<span class="cstat-no" title="statement not covered" >t</span>his._badgePool.reset();<span class="cstat-no" title="statement not covered" >t</span>his._selection=selection;<span class="cstat-no" title="statement not covered" >i</span>f(!this._selection){<span class="cstat-no" title="statement not covered" >this._updateContentsFromWindow();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >switch(this._selection.type()){case Timeline.TimelineSelection.Type.TraceEvent:const event=(<span class="cstat-no" title="statement not covered" >this._selection.object())</span>;<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.buildTraceEventDetails(event,this._model.timelineModel(),this._detailsLinkifier,this._badgePool,true).then(<span class="fstat-no" title="function not covered" >fr</span>agment=&gt;<span class="cstat-no" title="statement not covered" >this._appendDetailsTabsForTraceEventAndShowDetails(event,fragment))</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Timeline.TimelineSelection.Type.Frame:const frame=(<span class="cstat-no" title="statement not covered" >this._selection.object())</span>;const filmStripFrame=<span class="cstat-no" title="statement not covered" >this._model.filmStripModelFrame(frame);<span class="cstat-no" title="statement not covered" ></span>this._setContent(Timeline.TimelineUIUtils.generateDetailsContentForFrame(frame,filmStripFrame));<span class="cstat-no" title="statement not covered" >i</span>f(frame.layerTree){const layersView=<span class="cstat-no" title="statement not covered" >this._layersView();<span class="cstat-no" title="statement not covered" ></span>layersView.showLayerTree(frame.layerTree);<span class="cstat-no" title="statement not covered" >i</span>f(!this._tabbedPane.hasTab(Timeline.TimelineDetailsView.Tab.LayerViewer))</span></span></span>
<span class="cstat-no" title="statement not covered" >this._appendTab(Timeline.TimelineDetailsView.Tab.LayerViewer,Common.UIString('Layers'),layersView);}</span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase Timeline.TimelineSelection.Type.NetworkRequest:const request=(<span class="cstat-no" title="statement not covered" >this._selection.object())</span>;<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.buildNetworkRequestDetails(request,this._model.timelineModel(),this._detailsLinkifier,this._badgePool).then(this._setContent.bind(this));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Timeline.TimelineSelection.Type.Range:<span class="cstat-no" title="statement not covered" >this._updateSelectedRangeStats(this._selection.startTime(),this._selection.endTime());<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >this._updateContents();}</span>
<span class="fstat-no" title="function not covered" >_t</span>abSelected(event){<span class="cstat-no" title="statement not covered" >if(!event.data.isUserGesture)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.setPreferredTab(event.data.tabId);<span class="cstat-no" title="statement not covered" >t</span>his._updateContents();}</span>
<span class="fstat-no" title="function not covered" >_l</span>ayersView(){<span class="cstat-no" title="statement not covered" >if(this._lazyLayersView)</span>
<span class="cstat-no" title="statement not covered" >return this._lazyLayersView;<span class="cstat-no" title="statement not covered" >t</span>his._lazyLayersView=new Timeline.TimelineLayersView(this._model.timelineModel(),this._showSnapshotInPaintProfiler.bind(this));<span class="cstat-no" title="statement not covered" >r</span>eturn this._lazyLayersView;}</span>
<span class="fstat-no" title="function not covered" >_p</span>aintProfilerView(){<span class="cstat-no" title="statement not covered" >if(this._lazyPaintProfilerView)</span>
<span class="cstat-no" title="statement not covered" >return this._lazyPaintProfilerView;<span class="cstat-no" title="statement not covered" >t</span>his._lazyPaintProfilerView=new Timeline.TimelinePaintProfilerView(this._model.frameModel());<span class="cstat-no" title="statement not covered" >r</span>eturn this._lazyPaintProfilerView;}</span>
<span class="fstat-no" title="function not covered" >_s</span>howSnapshotInPaintProfiler(snapshot){const paintProfilerView=<span class="cstat-no" title="statement not covered" >this._paintProfilerView();<span class="cstat-no" title="statement not covered" ></span>paintProfilerView.setSnapshot(snapshot);<span class="cstat-no" title="statement not covered" >i</span>f(!this._tabbedPane.hasTab(Timeline.TimelineDetailsView.Tab.PaintProfiler)){<span class="cstat-no" title="statement not covered" >this._appendTab(Timeline.TimelineDetailsView.Tab.PaintProfiler,Common.UIString('Paint Profiler'),paintProfilerView,true);}</span></span>
<span class="cstat-no" title="statement not covered" >this._tabbedPane.selectTab(Timeline.TimelineDetailsView.Tab.PaintProfiler,true);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendDetailsTabsForTraceEventAndShowDetails(event,content){<span class="cstat-no" title="statement not covered" >this._setContent(content);<span class="cstat-no" title="statement not covered" >i</span>f(event.name===TimelineModel.TimelineModel.RecordType.Paint||event.name===TimelineModel.TimelineModel.RecordType.RasterTask)</span>
<span class="cstat-no" title="statement not covered" >this._showEventInPaintProfiler(event);}</span>
<span class="fstat-no" title="function not covered" >_s</span>howEventInPaintProfiler(event){const paintProfilerModel=<span class="cstat-no" title="statement not covered" >SDK.targetManager.models(SDK.PaintProfilerModel)[0];<span class="cstat-no" title="statement not covered" ></span>if(!paintProfilerModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst paintProfilerView=<span class="cstat-no" title="statement not covered" >this._paintProfilerView();</span>const hasProfileData=<span class="cstat-no" title="statement not covered" >paintProfilerView.setEvent(paintProfilerModel,event);<span class="cstat-no" title="statement not covered" ></span>if(!hasProfileData)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._tabbedPane.hasTab(Timeline.TimelineDetailsView.Tab.PaintProfiler))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._appendTab(Timeline.TimelineDetailsView.Tab.PaintProfiler,Common.UIString('Paint Profiler'),paintProfilerView);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateSelectedRangeStats(startTime,endTime){<span class="cstat-no" title="statement not covered" >if(!this._model||!this._track)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst aggregatedStats=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.statsForTimeRange(this._track.syncEvents(),startTime,endTime);</span>const startOffset=<span class="cstat-no" title="statement not covered" >startTime-this._model.timelineModel().minimumRecordTime();</span>const endOffset=<span class="cstat-no" title="statement not covered" >endTime-this._model.timelineModel().minimumRecordTime();</span>const contentHelper=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineDetailsContentHelper(null,null);<span class="cstat-no" title="statement not covered" ></span>contentHelper.addSection(ls`Range:  ${Number.millisToString(startOffset)} \u2013 ${Number.millisToString(endOffset)}`);c</span>onst pieChart=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.generatePieChart(aggregatedStats);<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendElementRow('',pieChart);<span class="cstat-no" title="statement not covered" >t</span>his._setContent(contentHelper.fragment);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineDetailsView.Tab={Details:'Details',EventLog:'EventLog',CallTree:'CallTree',BottomUp:'BottomUp',PaintProfiler:'PaintProfiler',LayerViewer:'LayerViewer'};;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineLoader=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(client){<span class="cstat-no" title="statement not covered" >this._client=client;<span class="cstat-no" title="statement not covered" >t</span>his._backingStorage=new Bindings.TempFileBackingStorage();<span class="cstat-no" title="statement not covered" >t</span>his._tracingModel=new SDK.TracingModel(this._backingStorage);<span class="cstat-no" title="statement not covered" >t</span>his._canceledCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his._state=Timeline.TimelineLoader.State.Initial;<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';<span class="cstat-no" title="statement not covered" >t</span>his._firstRawChunk=true;<span class="cstat-no" title="statement not covered" >t</span>his._firstChunk=true;<span class="cstat-no" title="statement not covered" >t</span>his._loadedBytes=0;<span class="cstat-no" title="statement not covered" >t</span>his._totalSize;<span class="cstat-no" title="statement not covered" >t</span>his._jsonTokenizer=new TextUtils.TextUtils.BalancedJSONTokenizer(this._writeBalancedJSON.bind(this),true);}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic loadFromFile(file,client){const loader=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineLoader(client);</span>const fileReader=<span class="cstat-no" title="statement not covered" >new Bindings.ChunkedFileReader(file,Timeline.TimelineLoader.TransferChunkLengthBytes);<span class="cstat-no" title="statement not covered" ></span>loader._canceledCallback=fileReader.cancel.bind(fileReader);<span class="cstat-no" title="statement not covered" >l</span>oader._totalSize=file.size;<span class="cstat-no" title="statement not covered" >f</span>ileReader.read(loader).then(<span class="fstat-no" title="function not covered" >su</span>ccess=&gt;{<span class="cstat-no" title="statement not covered" >if(!success)</span></span>
<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(fileReader.error().message);}</span>);<span class="cstat-no" title="statement not covered" >return loader;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic loadFromEvents(events,client){const loader=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineLoader(client);<span class="cstat-no" title="statement not covered" ></span>setTimeout(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const eventsPerChunk=<span class="cstat-no" title="statement not covered" >5000;<span class="cstat-no" title="statement not covered" ></span>client.loadingStarted();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;events.length;i+=eventsPerChunk){const chunk=<span class="cstat-no" title="statement not covered" >events.slice(i,i+eventsPerChunk);<span class="cstat-no" title="statement not covered" ></span>loader._tracingModel.addEvents(chunk);<span class="cstat-no" title="statement not covered" >c</span>lient.loadingProgress((i+chunk.length)/events.length);<span class="cstat-no" title="statement not covered" >a</span>wait new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >setTimeout(r))</span>;}</span></span></span>
<span class="cstat-no" title="statement not covered" >loader.close();}</span>);<span class="cstat-no" title="statement not covered" >return loader;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic loadFromURL(url,client){const loader=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineLoader(client);<span class="cstat-no" title="statement not covered" ></span>Host.ResourceLoader.loadAsStream(url,null,loader);<span class="cstat-no" title="statement not covered" >r</span>eturn loader;}</span>
<span class="fstat-no" title="function not covered" >ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._tracingModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._backingStorage.reset();<span class="cstat-no" title="statement not covered" >t</span>his._client.loadingComplete(null);<span class="cstat-no" title="statement not covered" >t</span>his._client=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._canceledCallback)</span>
<span class="cstat-no" title="statement not covered" >this._canceledCallback();}</span>
<span class="fstat-no" title="function not covered" >wr</span>ite(chunk){<span class="cstat-no" title="statement not covered" >if(!this._client)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._loadedBytes+=chunk.length;<span class="cstat-no" title="statement not covered" >i</span>f(this._firstRawChunk)</span>
<span class="cstat-no" title="statement not covered" >this._client.loadingStarted();e</span>lse
<span class="cstat-no" title="statement not covered" >this._client.loadingProgress(this._totalSize?this._loadedBytes/this._totalSize:undefined);<span class="cstat-no" title="statement not covered" >t</span>his._firstRawChunk=false;<span class="cstat-no" title="statement not covered" >i</span>f(this._state===Timeline.TimelineLoader.State.Initial){<span class="cstat-no" title="statement not covered" >if(chunk.startsWith('{"nodes":[')){<span class="cstat-no" title="statement not covered" >this._state=Timeline.TimelineLoader.State.LoadingCPUProfileFormat;}</span>else <span class="cstat-no" title="statement not covered" >if(chunk[0]==='{'){<span class="cstat-no" title="statement not covered" >this._state=Timeline.TimelineLoader.State.LookingForEvents;}</span>else <span class="cstat-no" title="statement not covered" >if(chunk[0]==='['){<span class="cstat-no" title="statement not covered" >this._state=Timeline.TimelineLoader.State.ReadingEvents;}</span>else{<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(Common.UIString('Malformed timeline data: Unknown JSON format'));<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(this._state===Timeline.TimelineLoader.State.LoadingCPUProfileFormat){<span class="cstat-no" title="statement not covered" >this._buffer+=chunk;<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._state===Timeline.TimelineLoader.State.LookingForEvents){const objectName=<span class="cstat-no" title="statement not covered" >'"traceEvents":';</span>const startPos=<span class="cstat-no" title="statement not covered" >this._buffer.length-objectName.length;<span class="cstat-no" title="statement not covered" ></span>this._buffer+=chunk;c</span>onst pos=<span class="cstat-no" title="statement not covered" >this._buffer.indexOf(objectName,startPos);<span class="cstat-no" title="statement not covered" ></span>if(pos===-1)</span></span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >c</span>hunk=this._buffer.slice(pos+objectName.length);<span class="cstat-no" title="statement not covered" >t</span>his._state=Timeline.TimelineLoader.State.ReadingEvents;}</span>
<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelineLoader.State.ReadingEvents)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >i</span>f(this._jsonTokenizer.write(chunk))</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._state=Timeline.TimelineLoader.State.SkippingTail;<span class="cstat-no" title="statement not covered" >i</span>f(this._firstChunk)</span>
<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(Common.UIString('Malformed timeline input, wrong JSON brackets balance'));<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span>
<span class="fstat-no" title="function not covered" >_w</span>riteBalancedJSON(data){let json=<span class="cstat-no" title="statement not covered" >data+']';<span class="cstat-no" title="statement not covered" ></span>if(!this._firstChunk){const commaIndex=<span class="cstat-no" title="statement not covered" >json.indexOf(',');<span class="cstat-no" title="statement not covered" ></span>if(commaIndex!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >json=json.slice(commaIndex+1);<span class="cstat-no" title="statement not covered" >j</span>son='['+json;}</span>
let items;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >items=(JSON.parse(json));}</span>catch(e){<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(Common.UIString('Malformed timeline data: %s',e.toString()));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._firstChunk){<span class="cstat-no" title="statement not covered" >this._firstChunk=false;<span class="cstat-no" title="statement not covered" >i</span>f(this._looksLikeAppVersion(items[0])){<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(Common.UIString('Legacy Timeline format is not supported.'));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this._tracingModel.addEvents(items);}</span>catch(e){<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(Common.UIString('Malformed timeline data: %s',e.toString()));}</span>}</span>
<span class="fstat-no" title="function not covered" >_r</span>eportErrorAndCancelLoading(message){<span class="cstat-no" title="statement not covered" >if(message)</span>
<span class="cstat-no" title="statement not covered" >Common.console.error(message);<span class="cstat-no" title="statement not covered" >t</span>his.cancel();}</span>
<span class="fstat-no" title="function not covered" >_l</span>ooksLikeAppVersion(item){<span class="cstat-no" title="statement not covered" >return typeof item==='string'&amp;&amp;item.indexOf('Chrome')!==-1;}</span>
<span class="fstat-no" title="function not covered" >cl</span>ose(){<span class="cstat-no" title="statement not covered" >if(!this._client)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._client.processingStarted();<span class="cstat-no" title="statement not covered" >s</span>etTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._finalizeTrace(),</span>0);}</span>
<span class="fstat-no" title="function not covered" >_f</span>inalizeTrace(){<span class="cstat-no" title="statement not covered" >if(this._state===Timeline.TimelineLoader.State.LoadingCPUProfileFormat){<span class="cstat-no" title="statement not covered" >this._parseCPUProfileFormat(this._buffer);<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';}</span></span>
<span class="cstat-no" title="statement not covered" >this._tracingModel.tracingComplete();<span class="cstat-no" title="statement not covered" >t</span>his._client.loadingComplete(this._tracingModel);}</span>
<span class="fstat-no" title="function not covered" >_p</span>arseCPUProfileFormat(text){let traceEvents;<span class="cstat-no" title="statement not covered" >try{const profile=<span class="cstat-no" title="statement not covered" >JSON.parse(text);<span class="cstat-no" title="statement not covered" ></span>traceEvents=TimelineModel.TimelineJSProfileProcessor.buildTraceProfileFromCpuProfile(profile,1,true);}</span>catch(e){<span class="cstat-no" title="statement not covered" >this._reportErrorAndCancelLoading(Common.UIString('Malformed CPU profile format'));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._tracingModel.addEvents(traceEvents);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineLoader.TransferChunkLengthBytes=5000000;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineLoader.Client=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineLoader.Client.prototype={loadingStarted(){},loadingProgress(progress){},processingStarted(){},loadingComplete(tracingModel){},};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineLoader.State={Initial:Symbol('Initial'),LookingForEvents:Symbol('LookingForEvents'),ReadingEvents:Symbol('ReadingEvents'),SkippingTail:Symbol('SkippingTail'),LoadingCPUProfileFormat:Symbol('LoadingCPUProfileFormat')};;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineEventOverview=class extends PerfUI.TimelineOverviewBase{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,title){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.id='timeline-overview-'+id;<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('overview-strip');<span class="cstat-no" title="statement not covered" >t</span>his._model=null;<span class="cstat-no" title="statement not covered" >i</span>f(title)</span></span>
<span class="cstat-no" title="statement not covered" >this.element.createChild('div','timeline-overview-strip-title').textContent=title;}</span>
<span class="fstat-no" title="function not covered" >se</span>tModel(model){<span class="cstat-no" title="statement not covered" >this._model=model;}</span>
<span class="fstat-no" title="function not covered" >_r</span>enderBar(begin,end,position,height,color){const x=<span class="cstat-no" title="statement not covered" >begin;</span>const width=<span class="cstat-no" title="statement not covered" >end-begin;</span>const ctx=<span class="cstat-no" title="statement not covered" >this.context();<span class="cstat-no" title="statement not covered" ></span>ctx.fillStyle=color;<span class="cstat-no" title="statement not covered" >c</span>tx.fillRect(x,position,width,height);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineEventOverviewInput=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('input',null);}</span></span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst height=<span class="cstat-no" title="statement not covered" >this.height();</span>const descriptors=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventDispatchDesciptors();</span>const descriptorsByType=<span class="cstat-no" title="statement not covered" >new Map();</span>let maxPriority=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>for(const descriptor of descriptors){<span class="cstat-no" title="statement not covered" >for(const type of descriptor.eventTypes)</span></span>
<span class="cstat-no" title="statement not covered" >descriptorsByType.set(type,descriptor);<span class="cstat-no" title="statement not covered" >m</span>axPriority=Math.max(maxPriority,descriptor.priority);}</span>
const minWidth=<span class="cstat-no" title="statement not covered" >2*window.devicePixelRatio;</span>const timeOffset=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().minimumRecordTime();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().maximumRecordTime()-timeOffset;</span>const canvasWidth=<span class="cstat-no" title="statement not covered" >this.width();</span>const scale=<span class="cstat-no" title="statement not covered" >canvasWidth/timeSpan;<span class="cstat-no" title="statement not covered" ></span>for(let priority=0;priority&lt;=maxPriority;++priority){<span class="cstat-no" title="statement not covered" >for(const track of this._model.timelineModel().tracks()){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;track.events.length;++i){const event=<span class="cstat-no" title="statement not covered" >track.events[i];<span class="cstat-no" title="statement not covered" ></span>if(event.name!==TimelineModel.TimelineModel.RecordType.EventDispatch)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst descriptor=<span class="cstat-no" title="statement not covered" >descriptorsByType.get(event.args['data']['type']);<span class="cstat-no" title="statement not covered" ></span>if(!descriptor||descriptor.priority!==priority)</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst start=<span class="cstat-no" title="statement not covered" >Number.constrain(Math.floor((event.startTime-timeOffset)*scale),0,canvasWidth);</span>const end=<span class="cstat-no" title="statement not covered" >Number.constrain(Math.ceil((event.endTime-timeOffset)*scale),0,canvasWidth);</span>const width=<span class="cstat-no" title="statement not covered" >Math.max(end-start,minWidth);<span class="cstat-no" title="statement not covered" ></span>this._renderBar(start,start+width,0,height,descriptor.color);}</span>}}}};<span class="cstat-no" title="statement not covered" >Timeline.TimelineEventOverviewNetwork=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('network',Common.UIString('NET'));}</span></span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineModel=<span class="cstat-no" title="statement not covered" >this._model.timelineModel();</span>const bandHeight=<span class="cstat-no" title="statement not covered" >this.height()/2;</span>const timeOffset=<span class="cstat-no" title="statement not covered" >timelineModel.minimumRecordTime();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >timelineModel.maximumRecordTime()-timeOffset;</span>const canvasWidth=<span class="cstat-no" title="statement not covered" >this.width();</span>const scale=<span class="cstat-no" title="statement not covered" >canvasWidth/timeSpan;</span>const highPath=<span class="cstat-no" title="statement not covered" >new Path2D();</span>const lowPath=<span class="cstat-no" title="statement not covered" >new Path2D();</span>const priorities=<span class="cstat-no" title="statement not covered" >Protocol.Network.ResourcePriority;</span>const highPrioritySet=<span class="cstat-no" title="statement not covered" >new Set([priorities.VeryHigh,priorities.High,priorities.Medium]);<span class="cstat-no" title="statement not covered" ></span>for(const request of timelineModel.networkRequests()){const path=<span class="cstat-no" title="statement not covered" >highPrioritySet.has(request.priority)?highPath:lowPath;</span>const s=<span class="cstat-no" title="statement not covered" >Math.max(Math.floor((request.startTime-timeOffset)*scale),0);</span>const e=<span class="cstat-no" title="statement not covered" >Math.min(Math.ceil((request.endTime-timeOffset)*scale+1),canvasWidth);<span class="cstat-no" title="statement not covered" ></span>path.rect(s,0,e-s,bandHeight-1);}</span></span>
const ctx=<span class="cstat-no" title="statement not covered" >this.context();<span class="cstat-no" title="statement not covered" ></span>ctx.save();<span class="cstat-no" title="statement not covered" >c</span>tx.fillStyle='hsl(214, 60%, 60%)';<span class="cstat-no" title="statement not covered" >c</span>tx.fill((highPath));<span class="cstat-no" title="statement not covered" >c</span>tx.translate(0,bandHeight);<span class="cstat-no" title="statement not covered" >c</span>tx.fillStyle='hsl(214, 80%, 80%)';<span class="cstat-no" title="statement not covered" >c</span>tx.fill((lowPath));<span class="cstat-no" title="statement not covered" >c</span>tx.restore();}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineEventOverviewCPUActivity=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('cpu-activity',Common.UIString('CPU'));<span class="cstat-no" title="statement not covered" >t</span>his._backgroundCanvas=this.element.createChild('canvas','fill background');}</span></span>
<span class="fstat-no" title="function not covered" >re</span>setCanvas(){<span class="cstat-no" title="statement not covered" >super.resetCanvas();<span class="cstat-no" title="statement not covered" >t</span>his._backgroundCanvas.width=this.element.clientWidth*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._backgroundCanvas.height=this.element.clientHeight*window.devicePixelRatio;}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineModel=<span class="cstat-no" title="statement not covered" >this._model.timelineModel();</span>const quantSizePx=<span class="cstat-no" title="statement not covered" >4*window.devicePixelRatio;</span>const width=<span class="cstat-no" title="statement not covered" >this.width();</span>const height=<span class="cstat-no" title="statement not covered" >this.height();</span>const baseLine=<span class="cstat-no" title="statement not covered" >height;</span>const timeOffset=<span class="cstat-no" title="statement not covered" >timelineModel.minimumRecordTime();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >timelineModel.maximumRecordTime()-timeOffset;</span>const scale=<span class="cstat-no" title="statement not covered" >width/timeSpan;</span>const quantTime=<span class="cstat-no" title="statement not covered" >quantSizePx/scale;</span>const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.categories();</span>const categoryOrder=<span class="cstat-no" title="statement not covered" >['idle','loading','painting','rendering','scripting','other'];</span>const otherIndex=<span class="cstat-no" title="statement not covered" >categoryOrder.indexOf('other');</span>const idleIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>console.assert(idleIndex===categoryOrder.indexOf('idle'));<span class="cstat-no" title="statement not covered" >f</span>or(let i=idleIndex+1;i&lt;categoryOrder.length;++i)</span>
<span class="cstat-no" title="statement not covered" >categories[categoryOrder[i]]._overviewIndex=i;c</span>onst backgroundContext=<span class="cstat-no" title="statement not covered" >this._backgroundCanvas.getContext('2d');<span class="cstat-no" title="statement not covered" ></span>for(const track of timelineModel.tracks()){<span class="cstat-no" title="statement not covered" >if(track.type===TimelineModel.TimelineModel.TrackType.MainThread&amp;&amp;track.forMainFrame)</span></span>
<span class="cstat-no" title="statement not covered" >drawThreadEvents(this.context(),track.events);e</span>lse
<span class="cstat-no" title="statement not covered" >drawThreadEvents(backgroundContext,track.events);}</span>
<span class="cstat-no" title="statement not covered" >applyPattern(backgroundContext);f</span>unction <span class="fstat-no" title="function not covered" >drawThreadEvents(</span>ctx,events){const quantizer=<span class="cstat-no" title="statement not covered" >new Timeline.Quantizer(timeOffset,quantTime,drawSample);</span>let x=<span class="cstat-no" title="statement not covered" >0;</span>const categoryIndexStack=<span class="cstat-no" title="statement not covered" >[];</span>const paths=<span class="cstat-no" title="statement not covered" >[];</span>const lastY=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;categoryOrder.length;++i){<span class="cstat-no" title="statement not covered" >paths[i]=new Path2D();<span class="cstat-no" title="statement not covered" >p</span>aths[i].moveTo(0,height);<span class="cstat-no" title="statement not covered" >l</span>astY[i]=height;}</span></span>
function <span class="fstat-no" title="function not covered" >drawSample(</span>counters){let y=<span class="cstat-no" title="statement not covered" >baseLine;<span class="cstat-no" title="statement not covered" ></span>for(let i=idleIndex+1;i&lt;categoryOrder.length;++i){const h=<span class="cstat-no" title="statement not covered" >(counters[i]||0)/quantTime*height;<span class="cstat-no" title="statement not covered" ></span>y-=h;<span class="cstat-no" title="statement not covered" >p</span>aths[i].bezierCurveTo(x,lastY[i],x,y,x+quantSizePx/2,y);<span class="cstat-no" title="statement not covered" >l</span>astY[i]=y;}</span></span>
<span class="cstat-no" title="statement not covered" >x+=quantSizePx;}</span>
function <span class="fstat-no" title="function not covered" >onEventStart(</span>e){const index=<span class="cstat-no" title="statement not covered" >categoryIndexStack.length?categoryIndexStack.peekLast():idleIndex;<span class="cstat-no" title="statement not covered" ></span>quantizer.appendInterval(e.startTime,index);<span class="cstat-no" title="statement not covered" >c</span>ategoryIndexStack.push(Timeline.TimelineUIUtils.eventStyle(e).category._overviewIndex||otherIndex);}</span>
function <span class="fstat-no" title="function not covered" >onEventEnd(</span>e){<span class="cstat-no" title="statement not covered" >quantizer.appendInterval(e.endTime,categoryIndexStack.pop());}</span>
<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.forEachEvent(events,onEventStart,onEventEnd);<span class="cstat-no" title="statement not covered" >q</span>uantizer.appendInterval(timeOffset+timeSpan+quantTime,idleIndex);<span class="cstat-no" title="statement not covered" >f</span>or(let i=categoryOrder.length-1;i&gt;0;--i){<span class="cstat-no" title="statement not covered" >paths[i].lineTo(width,height);<span class="cstat-no" title="statement not covered" >c</span>tx.fillStyle=categories[categoryOrder[i]].color;<span class="cstat-no" title="statement not covered" >c</span>tx.fill(paths[i]);}</span>}</span>
function <span class="fstat-no" title="function not covered" >applyPattern(</span>ctx){const step=<span class="cstat-no" title="statement not covered" >4*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>ctx.save();<span class="cstat-no" title="statement not covered" >c</span>tx.lineWidth=step/Math.sqrt(8);<span class="cstat-no" title="statement not covered" >f</span>or(let x=0.5;x&lt;width+height;x+=step){<span class="cstat-no" title="statement not covered" >ctx.moveTo(x,0);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x-height,height);}</span></span>
<span class="cstat-no" title="statement not covered" >ctx.globalCompositeOperation='destination-out';<span class="cstat-no" title="statement not covered" >c</span>tx.stroke();<span class="cstat-no" title="statement not covered" >c</span>tx.restore();}</span>}};<span class="cstat-no" title="statement not covered" >Timeline.TimelineEventOverviewResponsiveness=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('responsiveness',null);}</span></span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst height=<span class="cstat-no" title="statement not covered" >this.height();</span>const timeOffset=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().minimumRecordTime();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().maximumRecordTime()-timeOffset;</span>const scale=<span class="cstat-no" title="statement not covered" >this.width()/timeSpan;</span>const frames=<span class="cstat-no" title="statement not covered" >this._model.frames();</span>const ctx=(<span class="cstat-no" title="statement not covered" >this.context())</span>;const fillPath=<span class="cstat-no" title="statement not covered" >new Path2D();</span>const markersPath=<span class="cstat-no" title="statement not covered" >new Path2D();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;frames.length;++i){const frame=<span class="cstat-no" title="statement not covered" >frames[i];<span class="cstat-no" title="statement not covered" ></span>if(!frame.hasWarnings())</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span>aintWarningDecoration(frame.startTime,frame.duration);}</span>
<span class="cstat-no" title="statement not covered" >for(const track of this._model.timelineModel().tracks()){const events=<span class="cstat-no" title="statement not covered" >track.events;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;events.length;++i){<span class="cstat-no" title="statement not covered" >if(!TimelineModel.TimelineData.forEvent(events[i]).warning)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span>aintWarningDecoration(events[i].startTime,events[i].duration);}</span>}
<span class="cstat-no" title="statement not covered" >ctx.fillStyle='hsl(0, 80%, 90%)';<span class="cstat-no" title="statement not covered" >c</span>tx.strokeStyle='red';<span class="cstat-no" title="statement not covered" >c</span>tx.lineWidth=2*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >c</span>tx.fill(fillPath);<span class="cstat-no" title="statement not covered" >c</span>tx.stroke(markersPath);f</span>unction <span class="fstat-no" title="function not covered" >paintWarningDecoration(</span>time,duration){const x=<span class="cstat-no" title="statement not covered" >Math.round(scale*(time-timeOffset));</span>const w=<span class="cstat-no" title="statement not covered" >Math.round(scale*duration);<span class="cstat-no" title="statement not covered" ></span>fillPath.rect(x,0,w,height);<span class="cstat-no" title="statement not covered" >m</span>arkersPath.moveTo(x+w,0);<span class="cstat-no" title="statement not covered" >m</span>arkersPath.lineTo(x+w,height);}</span>}};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFilmStripOverview=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('filmstrip',null);<span class="cstat-no" title="statement not covered" >t</span>his.reset();}</span></span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();c</span>onst frames=<span class="cstat-no" title="statement not covered" >this._model?this._model.filmStripModel().frames():[];<span class="cstat-no" title="statement not covered" ></span>if(!frames.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst drawGeneration=<span class="cstat-no" title="statement not covered" >Symbol('drawGeneration');<span class="cstat-no" title="statement not covered" ></span>this._drawGeneration=drawGeneration;<span class="cstat-no" title="statement not covered" >t</span>his._imageByFrame(frames[0]).then(<span class="fstat-no" title="function not covered" >im</span>age=&gt;{<span class="cstat-no" title="statement not covered" >if(this._drawGeneration!==drawGeneration)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!image||!image.naturalWidth||!image.naturalHeight)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst imageHeight=<span class="cstat-no" title="statement not covered" >this.height()-2*Timeline.TimelineFilmStripOverview.Padding;</span>const imageWidth=<span class="cstat-no" title="statement not covered" >Math.ceil(imageHeight*image.naturalWidth/image.naturalHeight);</span>const popoverScale=<span class="cstat-no" title="statement not covered" >Math.min(200/image.naturalWidth,1);<span class="cstat-no" title="statement not covered" ></span>this._emptyImage=new Image(image.naturalWidth*popoverScale,image.naturalHeight*popoverScale);<span class="cstat-no" title="statement not covered" >t</span>his._drawFrames(imageWidth,imageHeight);}</span>);}
<span class="fstat-no" title="function not covered" >_i</span>mageByFrame(frame){let imagePromise=<span class="cstat-no" title="statement not covered" >this._frameToImagePromise.get(frame);<span class="cstat-no" title="statement not covered" ></span>if(!imagePromise){<span class="cstat-no" title="statement not covered" >imagePromise=frame.imageDataPromise().then(<span class="fstat-no" title="function not covered" >da</span>ta=&gt;<span class="cstat-no" title="statement not covered" >UI.loadImageFromData(data))</span>;<span class="cstat-no" title="statement not covered" >t</span>his._frameToImagePromise.set(frame,imagePromise);}</span></span>
<span class="cstat-no" title="statement not covered" >return imagePromise;}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawFrames(imageWidth,imageHeight){<span class="cstat-no" title="statement not covered" >if(!imageWidth||!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst filmStripModel=<span class="cstat-no" title="statement not covered" >this._model.filmStripModel();<span class="cstat-no" title="statement not covered" ></span>if(!filmStripModel.frames().length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst padding=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFilmStripOverview.Padding;</span>const width=<span class="cstat-no" title="statement not covered" >this.width();</span>const zeroTime=<span class="cstat-no" title="statement not covered" >filmStripModel.zeroTime();</span>const spanTime=<span class="cstat-no" title="statement not covered" >filmStripModel.spanTime();</span>const scale=<span class="cstat-no" title="statement not covered" >spanTime/width;</span>const context=<span class="cstat-no" title="statement not covered" >this.context();</span>const drawGeneration=<span class="cstat-no" title="statement not covered" >this._drawGeneration;<span class="cstat-no" title="statement not covered" ></span>context.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(let x=padding;x&lt;width;x+=imageWidth+2*padding){const time=<span class="cstat-no" title="statement not covered" >zeroTime+(x+imageWidth/2)*scale;</span>const frame=<span class="cstat-no" title="statement not covered" >filmStripModel.frameByTimestamp(time);<span class="cstat-no" title="statement not covered" ></span>if(!frame)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >c</span>ontext.rect(x-0.5,0.5,imageWidth+1,imageHeight+1);<span class="cstat-no" title="statement not covered" >t</span>his._imageByFrame(frame).then(drawFrameImage.bind(this,x));}</span>
<span class="cstat-no" title="statement not covered" >context.strokeStyle='#ddd';<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();f</span>unction <span class="fstat-no" title="function not covered" >drawFrameImage(</span>x,image){<span class="cstat-no" title="statement not covered" >if(this._drawGeneration!==drawGeneration||!image)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>ontext.drawImage(image,x,1,imageWidth,imageHeight);}</span>}
<span class="fstat-no" title="function not covered" >ov</span>erviewInfoPromise(x){<span class="cstat-no" title="statement not covered" >if(!this._model||!this._model.filmStripModel().frames().length)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve((null));c</span>onst time=<span class="cstat-no" title="statement not covered" >this.calculator().positionToTime(x);</span>const frame=<span class="cstat-no" title="statement not covered" >this._model.filmStripModel().frameByTimestamp(time);<span class="cstat-no" title="statement not covered" ></span>if(frame===this._lastFrame)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve(this._lastElement);c</span>onst imagePromise=<span class="cstat-no" title="statement not covered" >frame?this._imageByFrame(frame):Promise.resolve(this._emptyImage);<span class="cstat-no" title="statement not covered" ></span>return imagePromise.then(createFrameElement.bind(this));f</span>unction <span class="fstat-no" title="function not covered" >createFrameElement(</span>image){const element=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','frame');<span class="cstat-no" title="statement not covered" ></span>if(image)</span>
<span class="cstat-no" title="statement not covered" >element.createChild('div','thumbnail').appendChild(image);<span class="cstat-no" title="statement not covered" >t</span>his._lastFrame=frame;<span class="cstat-no" title="statement not covered" >t</span>his._lastElement=element;<span class="cstat-no" title="statement not covered" >r</span>eturn element;}</span>}
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._lastFrame=undefined;<span class="cstat-no" title="statement not covered" >t</span>his._lastElement=null;<span class="cstat-no" title="statement not covered" >t</span>his._frameToImagePromise=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._imageWidth=0;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFilmStripOverview.Padding=2;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineEventOverviewFrames=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('framerate',Common.UIString('FPS'));}</span></span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst frames=<span class="cstat-no" title="statement not covered" >this._model.frames();<span class="cstat-no" title="statement not covered" ></span>if(!frames.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst height=<span class="cstat-no" title="statement not covered" >this.height();</span>const padding=<span class="cstat-no" title="statement not covered" >1*window.devicePixelRatio;</span>const baseFrameDurationMs=<span class="cstat-no" title="statement not covered" >1e3/60;</span>const visualHeight=<span class="cstat-no" title="statement not covered" >height-2*padding;</span>const timeOffset=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().minimumRecordTime();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().maximumRecordTime()-timeOffset;</span>const scale=<span class="cstat-no" title="statement not covered" >this.width()/timeSpan;</span>const baseY=<span class="cstat-no" title="statement not covered" >height-padding;</span>const ctx=<span class="cstat-no" title="statement not covered" >this.context();</span>const bottomY=<span class="cstat-no" title="statement not covered" >baseY+10*window.devicePixelRatio;</span>let x=<span class="cstat-no" title="statement not covered" >0;</span>let y=<span class="cstat-no" title="statement not covered" >bottomY;</span>const lineWidth=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;</span>const offset=<span class="cstat-no" title="statement not covered" >lineWidth&amp;1?0.5:0;</span>const tickDepth=<span class="cstat-no" title="statement not covered" >1.5*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>ctx.beginPath();<span class="cstat-no" title="statement not covered" >c</span>tx.moveTo(0,y);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;frames.length;++i){const frame=<span class="cstat-no" title="statement not covered" >frames[i];<span class="cstat-no" title="statement not covered" ></span>x=Math.round((frame.startTime-timeOffset)*scale)+offset;<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,y);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,y+tickDepth);<span class="cstat-no" title="statement not covered" >y</span>=frame.idle?bottomY:Math.round(baseY-visualHeight*Math.min(baseFrameDurationMs/frame.duration,1))-offset;<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,y+tickDepth);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,y);}</span></span>
const lastFrame=<span class="cstat-no" title="statement not covered" >frames.peekLast();<span class="cstat-no" title="statement not covered" ></span>x=Math.round((lastFrame.startTime+lastFrame.duration-timeOffset)*scale)+offset;<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,y);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,bottomY);<span class="cstat-no" title="statement not covered" >c</span>tx.fillStyle='hsl(110, 50%, 88%)';<span class="cstat-no" title="statement not covered" >c</span>tx.strokeStyle='hsl(110, 50%, 60%)';<span class="cstat-no" title="statement not covered" >c</span>tx.lineWidth=lineWidth;<span class="cstat-no" title="statement not covered" >c</span>tx.fill();<span class="cstat-no" title="statement not covered" >c</span>tx.stroke();}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineEventOverviewMemory=class extends Timeline.TimelineEventOverview{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('memory',Common.UIString('HEAP'));<span class="cstat-no" title="statement not covered" >t</span>his._heapSizeLabel=this.element.createChild('div','memory-graph-label');}</span></span>
<span class="fstat-no" title="function not covered" >re</span>setHeapSizeLabels(){<span class="cstat-no" title="statement not covered" >this._heapSizeLabel.textContent='';}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >super.update();c</span>onst ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>if(!this._model){<span class="cstat-no" title="statement not covered" >this.resetHeapSizeLabels();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const tracks=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().tracks().filter(<span class="fstat-no" title="function not covered" >tr</span>ack=&gt;<span class="cstat-no" title="statement not covered" >track.type===TimelineModel.TimelineModel.TrackType.MainThread&amp;&amp;track.forMainFrame)</span>;</span>const trackEvents=<span class="cstat-no" title="statement not covered" >tracks.map(<span class="fstat-no" title="function not covered" >tr</span>ack=&gt;<span class="cstat-no" title="statement not covered" >track.events)</span>;</span>const lowerOffset=<span class="cstat-no" title="statement not covered" >3*ratio;</span>let maxUsedHeapSize=<span class="cstat-no" title="statement not covered" >0;</span>let minUsedHeapSize=<span class="cstat-no" title="statement not covered" >100000000000;</span>const minTime=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().minimumRecordTime();</span>const maxTime=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().maximumRecordTime();</span>function <span class="fstat-no" title="function not covered" >isUpdateCountersEvent(</span>event){<span class="cstat-no" title="statement not covered" >return event.name===TimelineModel.TimelineModel.RecordType.UpdateCounters;}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;trackEvents.length;i++)</span>
<span class="cstat-no" title="statement not covered" >trackEvents[i]=trackEvents[i].filter(isUpdateCountersEvent);f</span>unction <span class="fstat-no" title="function not covered" >calculateMinMaxSizes(</span>event){const counters=<span class="cstat-no" title="statement not covered" >event.args.data;<span class="cstat-no" title="statement not covered" ></span>if(!counters||!counters.jsHeapSizeUsed)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >m</span>axUsedHeapSize=Math.max(maxUsedHeapSize,counters.jsHeapSizeUsed);<span class="cstat-no" title="statement not covered" >m</span>inUsedHeapSize=Math.min(minUsedHeapSize,counters.jsHeapSizeUsed);}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;trackEvents.length;i++)</span>
<span class="cstat-no" title="statement not covered" >trackEvents[i].forEach(calculateMinMaxSizes);<span class="cstat-no" title="statement not covered" >m</span>inUsedHeapSize=Math.min(minUsedHeapSize,maxUsedHeapSize);c</span>onst lineWidth=<span class="cstat-no" title="statement not covered" >1;</span>const width=<span class="cstat-no" title="statement not covered" >this.width();</span>const height=<span class="cstat-no" title="statement not covered" >this.height()-lowerOffset;</span>const xFactor=<span class="cstat-no" title="statement not covered" >width/(maxTime-minTime);</span>const yFactor=<span class="cstat-no" title="statement not covered" >(height-lineWidth)/Math.max(maxUsedHeapSize-minUsedHeapSize,1);</span>const histogram=<span class="cstat-no" title="statement not covered" >new Array(width);</span>function <span class="fstat-no" title="function not covered" >buildHistogram(</span>event){const counters=<span class="cstat-no" title="statement not covered" >event.args.data;<span class="cstat-no" title="statement not covered" ></span>if(!counters||!counters.jsHeapSizeUsed)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst x=<span class="cstat-no" title="statement not covered" >Math.round((event.startTime-minTime)*xFactor);</span>const y=<span class="cstat-no" title="statement not covered" >Math.round((counters.jsHeapSizeUsed-minUsedHeapSize)*yFactor);<span class="cstat-no" title="statement not covered" ></span>histogram[x]=Math.max(histogram[x]||0,y);}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;trackEvents.length;i++)</span>
<span class="cstat-no" title="statement not covered" >trackEvents[i].forEach(buildHistogram);c</span>onst ctx=<span class="cstat-no" title="statement not covered" >this.context();</span>const heightBeyondView=<span class="cstat-no" title="statement not covered" >height+lowerOffset+lineWidth;<span class="cstat-no" title="statement not covered" ></span>ctx.translate(0.5,0.5);<span class="cstat-no" title="statement not covered" >c</span>tx.beginPath();<span class="cstat-no" title="statement not covered" >c</span>tx.moveTo(-lineWidth,heightBeyondView);l</span>et y=<span class="cstat-no" title="statement not covered" >0;</span>let isFirstPoint=<span class="cstat-no" title="statement not covered" >true;</span>let lastX=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let x=0;x&lt;histogram.length;x++){<span class="cstat-no" title="statement not covered" >if(typeof histogram[x]==='undefined')</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(isFirstPoint){<span class="cstat-no" title="statement not covered" >isFirstPoint=false;<span class="cstat-no" title="statement not covered" >y</span>=histogram[x];<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(-lineWidth,height-y);}</span></span>
const nextY=<span class="cstat-no" title="statement not covered" >histogram[x];<span class="cstat-no" title="statement not covered" ></span>if(Math.abs(nextY-y)&gt;2&amp;&amp;Math.abs(x-lastX)&gt;1)</span>
<span class="cstat-no" title="statement not covered" >ctx.lineTo(x,height-y);<span class="cstat-no" title="statement not covered" >y</span>=nextY;<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(x,height-y);<span class="cstat-no" title="statement not covered" >l</span>astX=x;}</span>
<span class="cstat-no" title="statement not covered" >ctx.lineTo(width+lineWidth,height-y);<span class="cstat-no" title="statement not covered" >c</span>tx.lineTo(width+lineWidth,heightBeyondView);<span class="cstat-no" title="statement not covered" >c</span>tx.closePath();<span class="cstat-no" title="statement not covered" >c</span>tx.fillStyle='hsla(220, 90%, 70%, 0.2)';<span class="cstat-no" title="statement not covered" >c</span>tx.fill();<span class="cstat-no" title="statement not covered" >c</span>tx.lineWidth=lineWidth;<span class="cstat-no" title="statement not covered" >c</span>tx.strokeStyle='hsl(220, 90%, 70%)';<span class="cstat-no" title="statement not covered" >c</span>tx.stroke();<span class="cstat-no" title="statement not covered" >t</span>his._heapSizeLabel.textContent=Common.UIString('%s \u2013 %s',Number.bytesToString(minUsedHeapSize),Number.bytesToString(maxUsedHeapSize));}</span>};<span class="cstat-no" title="statement not covered" >Timeline.Quantizer=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(startTime,quantDuration,callback){<span class="cstat-no" title="statement not covered" >this._lastTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._quantDuration=quantDuration;<span class="cstat-no" title="statement not covered" >t</span>his._callback=callback;<span class="cstat-no" title="statement not covered" >t</span>his._counters=[];<span class="cstat-no" title="statement not covered" >t</span>his._remainder=quantDuration;}</span></span>
<span class="fstat-no" title="function not covered" >ap</span>pendInterval(time,group){let interval=<span class="cstat-no" title="statement not covered" >time-this._lastTime;<span class="cstat-no" title="statement not covered" ></span>if(interval&lt;=this._remainder){<span class="cstat-no" title="statement not covered" >this._counters[group]=(this._counters[group]||0)+interval;<span class="cstat-no" title="statement not covered" >t</span>his._remainder-=interval;<span class="cstat-no" title="statement not covered" >t</span>his._lastTime=time;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._counters[group]=(this._counters[group]||0)+this._remainder;<span class="cstat-no" title="statement not covered" >t</span>his._callback(this._counters);<span class="cstat-no" title="statement not covered" >i</span>nterval-=this._remainder;<span class="cstat-no" title="statement not covered" >w</span>hile(interval&gt;=this._quantDuration){const counters=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>counters[group]=this._quantDuration;<span class="cstat-no" title="statement not covered" >t</span>his._callback(counters);<span class="cstat-no" title="statement not covered" >i</span>nterval-=this._quantDuration;}</span></span>
<span class="cstat-no" title="statement not covered" >this._counters=[];<span class="cstat-no" title="statement not covered" >t</span>his._counters[group]=interval;<span class="cstat-no" title="statement not covered" >t</span>his._lastTime=time;<span class="cstat-no" title="statement not covered" >t</span>his._remainder=this._quantDuration-interval;}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.TimelineFilters={};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineFilters.IsLong=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._minimumRecordDuration=0;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tMinimumRecordDuration(value){<span class="cstat-no" title="statement not covered" >this._minimumRecordDuration=value;}</span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){const duration=<span class="cstat-no" title="statement not covered" >event.endTime?event.endTime-event.startTime:0;<span class="cstat-no" title="statement not covered" ></span>return duration&gt;=this._minimumRecordDuration;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFilters.Category=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();}</span></span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return!Timeline.TimelineUIUtils.eventStyle(event).category.hidden;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFilters.RegExp=class extends TimelineModel.TimelineModelFilter{<span class="fstat-no" title="function not covered" >co</span>nstructor(regExp){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._regExp;<span class="cstat-no" title="statement not covered" >t</span>his.setRegExp(regExp||null);}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tRegExp(regExp){<span class="cstat-no" title="statement not covered" >this._regExp=regExp;}</span>
<span class="fstat-no" title="function not covered" >re</span>gExp(){<span class="cstat-no" title="statement not covered" >return this._regExp;}</span>
<span class="fstat-no" title="function not covered" >ac</span>cept(event){<span class="cstat-no" title="statement not covered" >return!this._regExp||Timeline.TimelineUIUtils.testContentMatching(event,this._regExp);}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.reset();<span class="cstat-no" title="statement not covered" >t</span>his._font='11px '+Host.fontFamily();<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=null;<span class="cstat-no" title="statement not covered" >t</span>his._currentLevel=0;<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._model=null;<span class="cstat-no" title="statement not covered" >t</span>his._minimumBoundary=0;<span class="cstat-no" title="statement not covered" >t</span>his._maximumBoundary=0;<span class="cstat-no" title="statement not covered" >t</span>his._timeSpan=0;<span class="cstat-no" title="statement not covered" >t</span>his._consoleColorGenerator=new Common.Color.Generator({min:30,max:55},{min:70,max:100,count:6},50,0.7);<span class="cstat-no" title="statement not covered" >t</span>his._extensionColorGenerator=new Common.Color.Generator({min:210,max:300},{min:70,max:100,count:6},70,0.7);<span class="cstat-no" title="statement not covered" >t</span>his._headerLevel1=this._buildGroupStyle({shareHeaderLine:false});<span class="cstat-no" title="statement not covered" >t</span>his._headerLevel2=this._buildGroupStyle({padding:2,nestingLevel:1,collapsible:false});<span class="cstat-no" title="statement not covered" >t</span>his._staticHeader=this._buildGroupStyle({collapsible:false});<span class="cstat-no" title="statement not covered" >t</span>his._framesHeader=this._buildGroupStyle({useFirstLineForOverview:true});<span class="cstat-no" title="statement not covered" >t</span>his._timingsHeader=this._buildGroupStyle({shareHeaderLine:true,useFirstLineForOverview:true});<span class="cstat-no" title="statement not covered" >t</span>his._screenshotsHeader=this._buildGroupStyle({useFirstLineForOverview:true,nestingLevel:1,collapsible:false,itemsHeight:150});<span class="cstat-no" title="statement not covered" >t</span>his._interactionsHeaderLevel1=this._buildGroupStyle({useFirstLineForOverview:true});<span class="cstat-no" title="statement not covered" >t</span>his._interactionsHeaderLevel2=this._buildGroupStyle({padding:2,nestingLevel:1});<span class="cstat-no" title="statement not covered" >t</span>his._flowEventIndexById=new Map();}</span></span>
<span class="fstat-no" title="function not covered" >_b</span>uildGroupStyle(extra){const defaultGroupStyle=<span class="cstat-no" title="statement not covered" >{padding:4,height:17,collapsible:true,color:UI.themeSupport.patchColorText('#222',UI.ThemeSupport.ColorUsage.Foreground),backgroundColor:UI.themeSupport.patchColorText('white',UI.ThemeSupport.ColorUsage.Background),font:this._font,nestingLevel:0,shareHeaderLine:true};<span class="cstat-no" title="statement not covered" ></span>return(Object.assign(defaultGroupStyle,extra));}</span>
<span class="fstat-no" title="function not covered" >se</span>tModel(performanceModel){<span class="cstat-no" title="statement not covered" >this.reset();<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=performanceModel;<span class="cstat-no" title="statement not covered" >t</span>his._model=performanceModel&amp;&amp;performanceModel.timelineModel();}</span>
<span class="fstat-no" title="function not covered" >gr</span>oupTrack(group){<span class="cstat-no" title="statement not covered" >return group._track||null;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryTitle(entryIndex){const entryTypes=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType;</span>const entryType=<span class="cstat-no" title="statement not covered" >this._entryType(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(entryType===entryTypes.Event){const event=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >if(event.phase===SDK.TracingModel.Phase.AsyncStepInto||event.phase===SDK.TracingModel.Phase.AsyncStepPast)</span></span>
<span class="cstat-no" title="statement not covered" >return event.name+':'+event.args['step'];<span class="cstat-no" title="statement not covered" >i</span>f(event._blackboxRoot)</span>
<span class="cstat-no" title="statement not covered" >return Common.UIString('Blackboxed');<span class="cstat-no" title="statement not covered" >i</span>f(this._performanceModel.timelineModel().isMarkerEvent(event))</span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.markerShortTitle(event);c</span>onst name=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(event).title;</span>const detailsText=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.buildDetailsTextForTraceEvent(event,this._model.targetByEvent(event));<span class="cstat-no" title="statement not covered" ></span>if(event.name===TimelineModel.TimelineModel.RecordType.JSFrame&amp;&amp;detailsText)</span>
<span class="cstat-no" title="statement not covered" >return detailsText;<span class="cstat-no" title="statement not covered" >r</span>eturn detailsText?Common.UIString('%s (%s)',name,detailsText):name;}</span>
<span class="cstat-no" title="statement not covered" >if(entryType===entryTypes.ExtensionEvent){const event=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >return event.name;}</span></span>
<span class="cstat-no" title="statement not covered" >if(entryType===entryTypes.Screenshot)</span>
<span class="cstat-no" title="statement not covered" >return'';l</span>et title=<span class="cstat-no" title="statement not covered" >this._entryIndexToTitle[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(!title){<span class="cstat-no" title="statement not covered" >title=Common.UIString('Unexpected entryIndex %d',entryIndex);<span class="cstat-no" title="statement not covered" >c</span>onsole.error(title);}</span></span>
<span class="cstat-no" title="statement not covered" >return title;}</span>
<span class="fstat-no" title="function not covered" >te</span>xtColor(index){const event=<span class="cstat-no" title="statement not covered" >this._entryData[index];<span class="cstat-no" title="statement not covered" ></span>return event&amp;&amp;event._blackboxRoot?'#888':Timeline.FlameChartStyle.textColor;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryFont(index){<span class="cstat-no" title="statement not covered" >return this._font;}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._currentLevel=0;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=null;<span class="cstat-no" title="statement not covered" >t</span>his._entryData=[];<span class="cstat-no" title="statement not covered" >t</span>his._entryParent=[];<span class="cstat-no" title="statement not covered" >t</span>his._entryTypeByLevel=[];<span class="cstat-no" title="statement not covered" >t</span>his._entryIndexToTitle=[];<span class="cstat-no" title="statement not covered" >t</span>his._markers=[];<span class="cstat-no" title="statement not covered" >t</span>his._asyncColorByCategory=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._asyncColorByInteractionPhase=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._extensionInfo=[];<span class="cstat-no" title="statement not covered" >t</span>his._screenshotImageCache=new Map();}</span>
<span class="fstat-no" title="function not covered" >ma</span>xStackDepth(){<span class="cstat-no" title="statement not covered" >return this._currentLevel;}</span>
<span class="fstat-no" title="function not covered" >ti</span>melineData(){<span class="cstat-no" title="statement not covered" >if(this._timelineData)</span>
<span class="cstat-no" title="statement not covered" >return this._timelineData;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=new PerfUI.FlameChart.TimelineData([],[],[],[]);<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return this._timelineData;<span class="cstat-no" title="statement not covered" >t</span>his._flowEventIndexById.clear();<span class="cstat-no" title="statement not covered" >t</span>his._minimumBoundary=this._model.minimumRecordTime();<span class="cstat-no" title="statement not covered" >t</span>his._timeSpan=this._model.isEmpty()?1000:this._model.maximumRecordTime()-this._minimumBoundary;<span class="cstat-no" title="statement not covered" >t</span>his._currentLevel=0;<span class="cstat-no" title="statement not covered" >i</span>f(this._model.isGenericTrace())</span>
<span class="cstat-no" title="statement not covered" >this._processGenericTrace();e</span>lse
<span class="cstat-no" title="statement not covered" >this._processInspectorTrace();<span class="cstat-no" title="statement not covered" >r</span>eturn this._timelineData;}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessGenericTrace(){const processGroupStyle=<span class="cstat-no" title="statement not covered" >this._buildGroupStyle({shareHeaderLine:false});</span>const threadGroupStyle=<span class="cstat-no" title="statement not covered" >this._buildGroupStyle({padding:2,nestingLevel:1,shareHeaderLine:false});</span>const eventEntryType=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType.Event;</span>const tracksByProcess=<span class="cstat-no" title="statement not covered" >new Multimap();<span class="cstat-no" title="statement not covered" ></span>for(const track of this._model.tracks())</span>
<span class="cstat-no" title="statement not covered" >tracksByProcess.set(track.thread.process(),track);<span class="cstat-no" title="statement not covered" >f</span>or(const process of tracksByProcess.keysArray()){<span class="cstat-no" title="statement not covered" >if(tracksByProcess.size&gt;1){const name=<span class="cstat-no" title="statement not covered" >`${process.name()} ${process.id()}`;<span class="cstat-no" title="statement not covered" ></span>this._appendHeader(name,processGroupStyle,false);}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(const track of tracksByProcess.get(process)){const group=<span class="cstat-no" title="statement not covered" >this._appendSyncEvents(track,track.events,track.name,threadGroupStyle,eventEntryType,true);<span class="cstat-no" title="statement not covered" ></span>if(!this._timelineData.selectedGroup||track.name===TimelineModel.TimelineModel.BrowserMainThreadName)</span></span>
<span class="cstat-no" title="statement not covered" >this._timelineData.selectedGroup=group;}</span>}}
<span class="fstat-no" title="function not covered" >_p</span>rocessInspectorTrace(){<span class="cstat-no" title="statement not covered" >this._appendFrames();<span class="cstat-no" title="statement not covered" >t</span>his._appendInteractionRecords();c</span>onst eventEntryType=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType.Event;</span>const weight=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >tr</span>ack=&gt;{<span class="cstat-no" title="statement not covered" >switch(track.type){case TimelineModel.TimelineModel.TrackType.Input:<span class="cstat-no" title="statement not covered" >return 0;c</span>ase TimelineModel.TimelineModel.TrackType.Animation:<span class="cstat-no" title="statement not covered" >return 1;c</span>ase TimelineModel.TimelineModel.TrackType.Timings:<span class="cstat-no" title="statement not covered" >return 2;c</span>ase TimelineModel.TimelineModel.TrackType.Console:<span class="cstat-no" title="statement not covered" >return 3;c</span>ase TimelineModel.TimelineModel.TrackType.MainThread:<span class="cstat-no" title="statement not covered" >return track.forMainFrame?4:5;c</span>ase TimelineModel.TimelineModel.TrackType.Worker:<span class="cstat-no" title="statement not covered" >return 6;c</span>ase TimelineModel.TimelineModel.TrackType.Raster:<span class="cstat-no" title="statement not covered" >return 7;c</span>ase TimelineModel.TimelineModel.TrackType.GPU:<span class="cstat-no" title="statement not covered" >return 8;c</span>ase TimelineModel.TimelineModel.TrackType.Other:<span class="cstat-no" title="statement not covered" >return 9;}</span>}</span>;</span>const tracks=<span class="cstat-no" title="statement not covered" >this._model.tracks().slice();<span class="cstat-no" title="statement not covered" ></span>tracks.stableSort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >weight(a)-weight(b))</span>;l</span>et rasterCount=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const track of tracks){<span class="cstat-no" title="statement not covered" >switch(track.type){case TimelineModel.TimelineModel.TrackType.Input:<span class="cstat-no" title="statement not covered" >this._appendAsyncEventsGroup(track,ls`Input`,track.asyncEvents,this._interactionsHeaderLevel2,eventEntryType,false);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.Animation:<span class="cstat-no" title="statement not covered" >this._appendAsyncEventsGroup(track,ls`Animation`,track.asyncEvents,this._interactionsHeaderLevel2,eventEntryType,false);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.Timings:const group=<span class="cstat-no" title="statement not covered" >this._appendHeader(ls`Timings`,this._timingsHeader,true);<span class="cstat-no" title="statement not covered" ></span>group._track=track;<span class="cstat-no" title="statement not covered" >t</span>his._appendPageMetrics();<span class="cstat-no" title="statement not covered" >t</span>his._appendAsyncEventsGroup(track,null,track.asyncEvents,this._timingsHeader,eventEntryType,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.Console:<span class="cstat-no" title="statement not covered" >this._appendAsyncEventsGroup(track,ls`Console`,track.asyncEvents,this._headerLevel1,eventEntryType,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.MainThread:<span class="cstat-no" title="statement not covered" >if(track.forMainFrame){const group=<span class="cstat-no" title="statement not covered" >this._appendSyncEvents(track,track.events,track.url?ls`Main \u2014 ${track.url}`:ls`Main`,this._headerLevel1,eventEntryType,true);<span class="cstat-no" title="statement not covered" ></span>if(group)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this._timelineData.selectedGroup=group;}</span>else{<span class="cstat-no" title="statement not covered" >this._appendSyncEvents(track,track.events,track.url?ls`Frame \u2014 ${track.url}`:ls`Subframe`,this._headerLevel1,eventEntryType,true);}</span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase TimelineModel.TimelineModel.TrackType.Worker:<span class="cstat-no" title="statement not covered" >this._appendSyncEvents(track,track.events,track.url?ls`Worker \u2014 ${track.url}`:ls`Dedicated Worker`,this._headerLevel1,eventEntryType,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.Raster:<span class="cstat-no" title="statement not covered" >if(!rasterCount)</span>
<span class="cstat-no" title="statement not covered" >this._appendHeader(ls`Raster`,this._headerLevel1,false);<span class="cstat-no" title="statement not covered" >+</span>+rasterCount;<span class="cstat-no" title="statement not covered" >t</span>his._appendSyncEvents(track,track.events,ls`Rasterizer Thread ${rasterCount}`,this._headerLevel2,eventEntryType,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.GPU:<span class="cstat-no" title="statement not covered" >this._appendSyncEvents(track,track.events,ls`GPU`,this._headerLevel1,eventEntryType,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.TrackType.Other:<span class="cstat-no" title="statement not covered" >this._appendSyncEvents(track,track.events,track.name||ls`Thread`,this._headerLevel1,eventEntryType,true);<span class="cstat-no" title="statement not covered" >t</span>his._appendAsyncEventsGroup(track,track.name,track.asyncEvents,this._headerLevel1,eventEntryType,true);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}
<span class="cstat-no" title="statement not covered" >if(this._timelineData.selectedGroup)</span>
<span class="cstat-no" title="statement not covered" >this._timelineData.selectedGroup.expanded=true;<span class="cstat-no" title="statement not covered" >f</span>or(let extensionIndex=0;extensionIndex&lt;this._extensionInfo.length;extensionIndex++)</span>
<span class="cstat-no" title="statement not covered" >this._innerAppendExtensionEvents(extensionIndex);<span class="cstat-no" title="statement not covered" >t</span>his._markers.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a.startTime()-b.startTime())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.markers=this._markers;<span class="cstat-no" title="statement not covered" >t</span>his._flowEventIndexById.clear();}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundary;}</span>
<span class="fstat-no" title="function not covered" >to</span>talTime(){<span class="cstat-no" title="statement not covered" >return this._timeSpan;}</span>
<span class="fstat-no" title="function not covered" >se</span>arch(startTime,endTime,filter){const result=<span class="cstat-no" title="statement not covered" >[];</span>const entryTypes=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType;<span class="cstat-no" title="statement not covered" ></span>this.timelineData();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._entryData.length;++i){<span class="cstat-no" title="statement not covered" >if(this._entryType(i)!==entryTypes.Event)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst event=(<span class="cstat-no" title="statement not covered" >this._entryData[i])</span>;<span class="cstat-no" title="statement not covered" >if(event.startTime&gt;endTime)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f((event.endTime||event.startTime)&lt;startTime)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(filter.accept(event))</span>
<span class="cstat-no" title="statement not covered" >result.push(i);}</span>
<span class="cstat-no" title="statement not covered" >result.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >SDK.TracingModel.Event.compareStartTime((this._entryData[a]),(this._entryData[b])))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendSyncEvents(track,events,title,style,entryType,selectable){<span class="cstat-no" title="statement not covered" >if(!events.length)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst isExtension=<span class="cstat-no" title="statement not covered" >entryType===Timeline.TimelineFlameChartDataProvider.EntryType.ExtensionEvent;</span>const openEvents=<span class="cstat-no" title="statement not covered" >[];</span>const flowEventsEnabled=<span class="cstat-no" title="statement not covered" >Runtime.experiments.isEnabled('timelineFlowEvents');</span>const blackboxingEnabled=<span class="cstat-no" title="statement not covered" >!isExtension&amp;&amp;Runtime.experiments.isEnabled('blackboxJSFramesOnTimeline');</span>let maxStackDepth=<span class="cstat-no" title="statement not covered" >0;</span>let group=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(track&amp;&amp;track.type===TimelineModel.TimelineModel.TrackType.MainThread){<span class="cstat-no" title="statement not covered" >group=this._appendHeader(title,style,selectable);<span class="cstat-no" title="statement not covered" >g</span>roup._track=track;}</span></span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;events.length;++i){const e=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(!isExtension&amp;&amp;this._performanceModel.timelineModel().isMarkerEvent(e)){<span class="cstat-no" title="statement not covered" >this._markers.push(new Timeline.TimelineFlameChartMarker(e.startTime,e.startTime-this._model.minimumRecordTime(),Timeline.TimelineUIUtils.markerStyleForEvent(e)));}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!SDK.TracingModel.isFlowPhase(e.phase)){<span class="cstat-no" title="statement not covered" >if(!e.endTime&amp;&amp;e.phase!==SDK.TracingModel.Phase.Instant)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(SDK.TracingModel.isAsyncPhase(e.phase))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(!isExtension&amp;&amp;!this._performanceModel.isVisible(e))</span>
<span class="cstat-no" title="statement not covered" >continue;}</span>
<span class="cstat-no" title="statement not covered" >while(openEvents.length&amp;&amp;openEvents.peekLast().endTime&lt;=e.startTime)</span>
<span class="cstat-no" title="statement not covered" >openEvents.pop();<span class="cstat-no" title="statement not covered" >e</span>._blackboxRoot=false;<span class="cstat-no" title="statement not covered" >i</span>f(blackboxingEnabled&amp;&amp;this._isBlackboxedEvent(e)){const parent=<span class="cstat-no" title="statement not covered" >openEvents.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(parent&amp;&amp;parent._blackboxRoot)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >e</span>._blackboxRoot=true;}</span>
<span class="cstat-no" title="statement not covered" >if(!group){<span class="cstat-no" title="statement not covered" >group=this._appendHeader(title,style,selectable);<span class="cstat-no" title="statement not covered" >i</span>f(selectable)</span></span>
<span class="cstat-no" title="statement not covered" >group._track=track;}</span>
const level=<span class="cstat-no" title="statement not covered" >this._currentLevel+openEvents.length;<span class="cstat-no" title="statement not covered" ></span>if(flowEventsEnabled)</span>
<span class="cstat-no" title="statement not covered" >this._appendFlowEvent(e,level);c</span>onst index=<span class="cstat-no" title="statement not covered" >this._appendEvent(e,level);<span class="cstat-no" title="statement not covered" ></span>if(openEvents.length)</span>
<span class="cstat-no" title="statement not covered" >this._entryParent[index]=openEvents.peekLast();<span class="cstat-no" title="statement not covered" >i</span>f(!isExtension&amp;&amp;this._performanceModel.timelineModel().isMarkerEvent(e))</span>
<span class="cstat-no" title="statement not covered" >this._timelineData.entryTotalTimes[this._entryData.length]=undefined;<span class="cstat-no" title="statement not covered" >m</span>axStackDepth=Math.max(maxStackDepth,openEvents.length+1);<span class="cstat-no" title="statement not covered" >i</span>f(e.endTime)</span>
<span class="cstat-no" title="statement not covered" >openEvents.push(e);}</span>
<span class="cstat-no" title="statement not covered" >this._entryTypeByLevel.length=this._currentLevel+maxStackDepth;<span class="cstat-no" title="statement not covered" >t</span>his._entryTypeByLevel.fill(entryType,this._currentLevel);<span class="cstat-no" title="statement not covered" >t</span>his._currentLevel+=maxStackDepth;<span class="cstat-no" title="statement not covered" >r</span>eturn group;}</span>
<span class="fstat-no" title="function not covered" >_i</span>sBlackboxedEvent(event){<span class="cstat-no" title="statement not covered" >if(event.name!==TimelineModel.TimelineModel.RecordType.JSFrame)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst url=<span class="cstat-no" title="statement not covered" >event.args['data']['url'];<span class="cstat-no" title="statement not covered" ></span>return url&amp;&amp;this._isBlackboxedURL(url);}</span>
<span class="fstat-no" title="function not covered" >_i</span>sBlackboxedURL(url){<span class="cstat-no" title="statement not covered" >return Bindings.blackboxManager.isBlackboxedURL(url);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendAsyncEventsGroup(track,header,events,style,entryType,selectable){<span class="cstat-no" title="statement not covered" >if(!events.length)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst lastUsedTimeByLevel=<span class="cstat-no" title="statement not covered" >[];</span>let group=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;events.length;++i){const asyncEvent=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(!this._performanceModel.isVisible(asyncEvent))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(!group&amp;&amp;header){<span class="cstat-no" title="statement not covered" >group=this._appendHeader(header,style,selectable);<span class="cstat-no" title="statement not covered" >i</span>f(selectable)</span></span>
<span class="cstat-no" title="statement not covered" >group._track=track;}</span>
const startTime=<span class="cstat-no" title="statement not covered" >asyncEvent.startTime;</span>let level;<span class="cstat-no" title="statement not covered" >for(level=0;level&lt;lastUsedTimeByLevel.length&amp;&amp;lastUsedTimeByLevel[level]&gt;startTime;++level){}</span>
<span class="cstat-no" title="statement not covered" >this._appendAsyncEvent(asyncEvent,this._currentLevel+level);<span class="cstat-no" title="statement not covered" >l</span>astUsedTimeByLevel[level]=asyncEvent.endTime;}</span>
<span class="cstat-no" title="statement not covered" >this._entryTypeByLevel.length=this._currentLevel+lastUsedTimeByLevel.length;<span class="cstat-no" title="statement not covered" >t</span>his._entryTypeByLevel.fill(entryType,this._currentLevel);<span class="cstat-no" title="statement not covered" >t</span>his._currentLevel+=lastUsedTimeByLevel.length;<span class="cstat-no" title="statement not covered" >r</span>eturn group;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendInteractionRecords(){const interactionRecords=<span class="cstat-no" title="statement not covered" >this._performanceModel.interactionRecords();<span class="cstat-no" title="statement not covered" ></span>if(!interactionRecords.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._appendHeader(ls`Interactions`,this._interactionsHeaderLevel1,false);<span class="cstat-no" title="statement not covered" >f</span>or(const segment of interactionRecords){const index=<span class="cstat-no" title="statement not covered" >this._entryData.length;<span class="cstat-no" title="statement not covered" ></span>this._entryData.push((segment.data));<span class="cstat-no" title="statement not covered" >t</span>his._entryIndexToTitle[index]=(segment.data);<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryLevels[index]=this._currentLevel;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryTotalTimes[index]=segment.end-segment.begin;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryStartTimes[index]=segment.begin;}</span></span>
<span class="cstat-no" title="statement not covered" >this._entryTypeByLevel[this._currentLevel++]=Timeline.TimelineFlameChartDataProvider.EntryType.InteractionRecord;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendPageMetrics(){<span class="cstat-no" title="statement not covered" >this._entryTypeByLevel[this._currentLevel]=Timeline.TimelineFlameChartDataProvider.EntryType.Event;c</span>onst metricEvents=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const track of this._model.tracks()){<span class="cstat-no" title="statement not covered" >for(const event of track.events){<span class="cstat-no" title="statement not covered" >if(!this._performanceModel.timelineModel().isMarkerEvent(event))</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >m</span>etricEvents.push(event);}</span>}
<span class="cstat-no" title="statement not covered" >metricEvents.stableSort(SDK.TracingModel.Event.compareStartTime);c</span>onst totalTimes=<span class="cstat-no" title="statement not covered" >this._timelineData.entryTotalTimes;<span class="cstat-no" title="statement not covered" ></span>for(const event of metricEvents){<span class="cstat-no" title="statement not covered" >this._appendEvent(event,this._currentLevel);<span class="cstat-no" title="statement not covered" >t</span>otalTimes[totalTimes.length-1]=Number.NaN;}</span></span>
<span class="cstat-no" title="statement not covered" >++this._currentLevel;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendFrames(){const screenshots=<span class="cstat-no" title="statement not covered" >this._performanceModel.filmStripModel().frames();</span>const hasFilmStrip=<span class="cstat-no" title="statement not covered" >!!screenshots.length;<span class="cstat-no" title="statement not covered" ></span>this._framesHeader.collapsible=hasFilmStrip;<span class="cstat-no" title="statement not covered" >t</span>his._appendHeader(Common.UIString('Frames'),this._framesHeader,false);<span class="cstat-no" title="statement not covered" >t</span>his._frameGroup=this._timelineData.groups.peekLast();c</span>onst style=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.markerStyleForFrame();<span class="cstat-no" title="statement not covered" ></span>this._entryTypeByLevel[this._currentLevel]=Timeline.TimelineFlameChartDataProvider.EntryType.Frame;<span class="cstat-no" title="statement not covered" >f</span>or(const frame of this._performanceModel.frames()){<span class="cstat-no" title="statement not covered" >this._markers.push(new Timeline.TimelineFlameChartMarker(frame.startTime,frame.startTime-this._model.minimumRecordTime(),style));<span class="cstat-no" title="statement not covered" >t</span>his._appendFrame(frame);}</span></span>
<span class="cstat-no" title="statement not covered" >++this._currentLevel;<span class="cstat-no" title="statement not covered" >i</span>f(!hasFilmStrip)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._appendHeader('',this._screenshotsHeader,false);<span class="cstat-no" title="statement not covered" >t</span>his._entryTypeByLevel[this._currentLevel]=Timeline.TimelineFlameChartDataProvider.EntryType.Screenshot;l</span>et prevTimestamp;<span class="cstat-no" title="statement not covered" >for(const screenshot of screenshots){<span class="cstat-no" title="statement not covered" >this._entryData.push(screenshot);<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryLevels.push(this._currentLevel);<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryStartTimes.push(screenshot.timestamp);<span class="cstat-no" title="statement not covered" >i</span>f(prevTimestamp)</span></span>
<span class="cstat-no" title="statement not covered" >this._timelineData.entryTotalTimes.push(screenshot.timestamp-prevTimestamp);<span class="cstat-no" title="statement not covered" >p</span>revTimestamp=screenshot.timestamp;}</span>
<span class="cstat-no" title="statement not covered" >if(screenshots.length)</span>
<span class="cstat-no" title="statement not covered" >this._timelineData.entryTotalTimes.push(this._model.maximumRecordTime()-prevTimestamp);<span class="cstat-no" title="statement not covered" >+</span>+this._currentLevel;}</span>
<span class="fstat-no" title="function not covered" >_e</span>ntryType(entryIndex){<span class="cstat-no" title="statement not covered" >return this._entryTypeByLevel[this._timelineData.entryLevels[entryIndex]];}</span>
<span class="fstat-no" title="function not covered" >pr</span>epareHighlightedEntryInfo(entryIndex){let time=<span class="cstat-no" title="statement not covered" >'';</span>let title;let warning;const type=<span class="cstat-no" title="statement not covered" >this._entryType(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(type===Timeline.TimelineFlameChartDataProvider.EntryType.Event){const event=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;const totalTime=<span class="cstat-no" title="statement not covered" >event.duration;</span>const selfTime=<span class="cstat-no" title="statement not covered" >event.selfTime;</span>const eps=<span class="cstat-no" title="statement not covered" >1e-6;<span class="cstat-no" title="statement not covered" ></span>if(typeof totalTime==='number'){<span class="cstat-no" title="statement not covered" >time=Math.abs(totalTime-selfTime)&gt;eps&amp;&amp;selfTime&gt;eps?Common.UIString('%s (self %s)',Number.millisToString(totalTime,true),Number.millisToString(selfTime,true)):Number.millisToString(totalTime,true);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this._performanceModel.timelineModel().isMarkerEvent(event))</span>
<span class="cstat-no" title="statement not covered" >title=Timeline.TimelineUIUtils.eventTitle(event);e</span>lse
<span class="cstat-no" title="statement not covered" >title=this.entryTitle(entryIndex);<span class="cstat-no" title="statement not covered" >w</span>arning=Timeline.TimelineUIUtils.eventWarning(event);}</span>else <span class="cstat-no" title="statement not covered" >if(type===Timeline.TimelineFlameChartDataProvider.EntryType.Frame){const frame=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >time=Common.UIString('%s ~ %.0f\xa0fps',Number.preciseMillisToString(frame.duration,1),(1000/frame.duration));<span class="cstat-no" title="statement not covered" >t</span>itle=frame.idle?Common.UIString('Idle Frame'):Common.UIString('Frame');<span class="cstat-no" title="statement not covered" >i</span>f(frame.hasWarnings()){<span class="cstat-no" title="statement not covered" >warning=createElement('span');<span class="cstat-no" title="statement not covered" >w</span>arning.textContent=Common.UIString('Long frame');}</span>}</span>else{<span class="cstat-no" title="statement not covered" >return null;}</span></span>
const element=<span class="cstat-no" title="statement not covered" >createElement('div');</span>const root=<span class="cstat-no" title="statement not covered" >UI.createShadowRootWithCoreStyles(element,'timeline/timelineFlamechartPopover.css');</span>const contents=<span class="cstat-no" title="statement not covered" >root.createChild('div','timeline-flamechart-popover');<span class="cstat-no" title="statement not covered" ></span>contents.createChild('span','timeline-info-time').textContent=time;<span class="cstat-no" title="statement not covered" >c</span>ontents.createChild('span','timeline-info-title').textContent=title;<span class="cstat-no" title="statement not covered" >i</span>f(warning){<span class="cstat-no" title="statement not covered" >warning.classList.add('timeline-info-warning');<span class="cstat-no" title="statement not covered" >c</span>ontents.appendChild(warning);}</span></span>
<span class="cstat-no" title="statement not covered" >return element;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryColor(entryIndex){function <span class="fstat-no" title="function not covered" >patchColorAndCache(</span>cache,key,lookupColor){let color=<span class="cstat-no" title="statement not covered" >cache.get(key);<span class="cstat-no" title="statement not covered" ></span>if(color)</span>
<span class="cstat-no" title="statement not covered" >return color;c</span>onst parsedColor=<span class="cstat-no" title="statement not covered" >Common.Color.parse(lookupColor(key));<span class="cstat-no" title="statement not covered" ></span>color=parsedColor.setAlpha(0.7).asString(Common.Color.Format.RGBA)||'';<span class="cstat-no" title="statement not covered" >c</span>ache.set(key,color);<span class="cstat-no" title="statement not covered" >r</span>eturn color;}</span>
const entryTypes=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType;</span>const type=<span class="cstat-no" title="statement not covered" >this._entryType(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(type===entryTypes.Event){const event=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >if(this._model.isGenericTrace())</span></span>
<span class="cstat-no" title="statement not covered" >return this._genericTraceEventColor(event);<span class="cstat-no" title="statement not covered" >i</span>f(this._performanceModel.timelineModel().isMarkerEvent(event))</span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.markerStyleForEvent(event).color;<span class="cstat-no" title="statement not covered" >i</span>f(!SDK.TracingModel.isAsyncPhase(event.phase))</span>
<span class="cstat-no" title="statement not covered" >return this._colorForEvent(event);<span class="cstat-no" title="statement not covered" >i</span>f(event.hasCategory(TimelineModel.TimelineModel.Category.Console)||event.hasCategory(TimelineModel.TimelineModel.Category.UserTiming))</span>
<span class="cstat-no" title="statement not covered" >return this._consoleColorGenerator.colorForID(event.name);<span class="cstat-no" title="statement not covered" >i</span>f(event.hasCategory(TimelineModel.TimelineModel.Category.LatencyInfo)){const phase=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel.phaseForEvent(event)||TimelineModel.TimelineIRModel.Phases.Uncategorized;<span class="cstat-no" title="statement not covered" ></span>return patchColorAndCache(this._asyncColorByInteractionPhase,phase,Timeline.TimelineUIUtils.interactionPhaseColor);}</span></span>
const category=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(event).category;<span class="cstat-no" title="statement not covered" ></span>return patchColorAndCache(this._asyncColorByCategory,category,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >category.color)</span>;}</span>
<span class="cstat-no" title="statement not covered" >if(type===entryTypes.Frame)</span>
<span class="cstat-no" title="statement not covered" >return'white';<span class="cstat-no" title="statement not covered" >i</span>f(type===entryTypes.InteractionRecord)</span>
<span class="cstat-no" title="statement not covered" >return'transparent';<span class="cstat-no" title="statement not covered" >i</span>f(type===entryTypes.ExtensionEvent){const event=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >return this._extensionColorGenerator.colorForID(event.name);}</span></span>
<span class="cstat-no" title="statement not covered" >return'';}</span>
<span class="fstat-no" title="function not covered" >_g</span>enericTraceEventColor(event){const key=<span class="cstat-no" title="statement not covered" >event.categoriesString||event.name;<span class="cstat-no" title="statement not covered" ></span>return key?`hsl(${String.hashCode(key) % 300 + 30}, 40%, 70%)`:'#ccc';}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawFrame(entryIndex,context,text,barX,barY,barWidth,barHeight){const hPadding=<span class="cstat-no" title="statement not covered" >1;</span>const frame=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >barX+=hPadding;<span class="cstat-no" title="statement not covered" >b</span>arWidth-=2*hPadding;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=frame.idle?'white':(frame.hasWarnings()?'#fad1d1':'#d7f0d1');<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(barX,barY,barWidth,barHeight);c</span>onst frameDurationText=<span class="cstat-no" title="statement not covered" >Number.preciseMillisToString(frame.duration,1);</span>const textWidth=<span class="cstat-no" title="statement not covered" >context.measureText(frameDurationText).width;<span class="cstat-no" title="statement not covered" ></span>if(textWidth&lt;=barWidth){<span class="cstat-no" title="statement not covered" >context.fillStyle=this.textColor(entryIndex);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillText(frameDurationText,barX+(barWidth-textWidth)/2,barY+barHeight-4);}</span>}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _drawScreenshot(entryIndex,context,barX,barY,barWidth,barHeight){const screenshot=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >if(!this._screenshotImageCache.has(screenshot)){<span class="cstat-no" title="statement not covered" >this._screenshotImageCache.set(screenshot,null);c</span>onst data=<span class="cstat-no" title="statement not covered" >await screenshot.imageDataPromise();</span>const image=<span class="cstat-no" title="statement not covered" >await UI.loadImageFromData(data);<span class="cstat-no" title="statement not covered" ></span>this._screenshotImageCache.set(screenshot,image);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Timeline.TimelineFlameChartDataProvider.Events.DataChanged);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const image=<span class="cstat-no" title="statement not covered" >this._screenshotImageCache.get(screenshot);<span class="cstat-no" title="statement not covered" ></span>if(!image)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst imageX=<span class="cstat-no" title="statement not covered" >barX+1;</span>const imageY=<span class="cstat-no" title="statement not covered" >barY+1;</span>const imageHeight=<span class="cstat-no" title="statement not covered" >barHeight-2;</span>const scale=<span class="cstat-no" title="statement not covered" >imageHeight/image.naturalHeight;</span>const imageWidth=<span class="cstat-no" title="statement not covered" >Math.floor(image.naturalWidth*scale);<span class="cstat-no" title="statement not covered" ></span>context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.rect(barX,barY,barWidth,barHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.clip();<span class="cstat-no" title="statement not covered" >c</span>ontext.drawImage(image,imageX,imageY,imageWidth,imageHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='#ccc';<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeRect(imageX-0.5,imageY-0.5,Math.min(barWidth-1,imageWidth+1),imageHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();}</span>
<span class="fstat-no" title="function not covered" >de</span>corateEntry(entryIndex,context,text,barX,barY,barWidth,barHeight,unclippedBarX,timeToPixels){const data=<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex];</span>const type=<span class="cstat-no" title="statement not covered" >this._entryType(entryIndex);</span>const entryTypes=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType;<span class="cstat-no" title="statement not covered" ></span>if(type===entryTypes.Frame){<span class="cstat-no" title="statement not covered" >this._drawFrame(entryIndex,context,text,barX,barY,barWidth,barHeight);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >if(type===entryTypes.Screenshot){<span class="cstat-no" title="statement not covered" >this._drawScreenshot(entryIndex,context,barX,barY,barWidth,barHeight);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >if(type===entryTypes.InteractionRecord){const color=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.interactionPhaseColor((data));<span class="cstat-no" title="statement not covered" ></span>context.fillStyle=color;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(barX,barY,barWidth-1,2);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(barX,barY-3,2,3);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(barX+barWidth-3,barY-3,2,3);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span></span>
<span class="cstat-no" title="statement not covered" >if(type===entryTypes.Event){const event=(<span class="cstat-no" title="statement not covered" >data)</span>;<span class="cstat-no" title="statement not covered" >if(event.hasCategory(TimelineModel.TimelineModel.Category.LatencyInfo)){const timeWaitingForMainThread=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).timeWaitingForMainThread;<span class="cstat-no" title="statement not covered" ></span>if(timeWaitingForMainThread){<span class="cstat-no" title="statement not covered" >context.fillStyle='hsla(0, 70%, 60%, 1)';c</span>onst width=<span class="cstat-no" title="statement not covered" >Math.floor(unclippedBarX-barX+timeWaitingForMainThread*timeToPixels);<span class="cstat-no" title="statement not covered" ></span>context.fillRect(barX,barY+barHeight-3,width,2);}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(TimelineModel.TimelineData.forEvent(event).warning)</span>
<span class="cstat-no" title="statement not covered" >paintWarningDecoration(barX,barWidth-1.5);}</span>
function <span class="fstat-no" title="function not covered" >paintWarningDecoration(</span>x,width){const triangleSize=<span class="cstat-no" title="statement not covered" >8;<span class="cstat-no" title="statement not covered" ></span>context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.rect(x,barY,width,barHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.clip();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='red';<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(x+width-triangleSize,barY);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(x+width,barY);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(x+width,barY+triangleSize);<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();}</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rceDecoration(entryIndex){const entryTypes=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType;</span>const type=<span class="cstat-no" title="statement not covered" >this._entryType(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(type===entryTypes.Frame)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span>f(type===entryTypes.Screenshot)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span>f(type===entryTypes.Event){const event=(<span class="cstat-no" title="statement not covered" >this._entryData[entryIndex])</span>;<span class="cstat-no" title="statement not covered" >return!!TimelineModel.TimelineData.forEvent(event).warning;}</span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendExtensionEvents(entry){<span class="cstat-no" title="statement not covered" >this._extensionInfo.push(entry);<span class="cstat-no" title="statement not covered" >i</span>f(this._timelineData)</span>
<span class="cstat-no" title="statement not covered" >this._innerAppendExtensionEvents(this._extensionInfo.length-1);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nnerAppendExtensionEvents(index){const entry=<span class="cstat-no" title="statement not covered" >this._extensionInfo[index];</span>const entryType=<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.EntryType.ExtensionEvent;</span>const allThreads=<span class="cstat-no" title="statement not covered" >[].concat(...entry.model.sortedProcesses().map(<span class="fstat-no" title="function not covered" >pr</span>ocess=&gt;<span class="cstat-no" title="statement not covered" >process.sortedThreads())</span>);<span class="cstat-no" title="statement not covered" ></span>if(!allThreads.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst singleTrack=<span class="cstat-no" title="statement not covered" >allThreads.length===1&amp;&amp;(!allThreads[0].events().length||!allThreads[0].asyncEvents().length);<span class="cstat-no" title="statement not covered" ></span>if(!singleTrack)</span>
<span class="cstat-no" title="statement not covered" >this._appendHeader(entry.title,this._headerLevel1,false);c</span>onst style=<span class="cstat-no" title="statement not covered" >singleTrack?this._headerLevel2:this._headerLevel1;</span>let threadIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const thread of allThreads){const title=<span class="cstat-no" title="statement not covered" >singleTrack?entry.title:thread.name()||ls`Thread ${++threadIndex}`;<span class="cstat-no" title="statement not covered" ></span>this._appendAsyncEventsGroup(null,title,thread.asyncEvents(),style,entryType,false);<span class="cstat-no" title="statement not covered" >t</span>his._appendSyncEvents(null,thread.events(),title,style,entryType,false);}</span>}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendHeader(title,style,selectable){const group=<span class="cstat-no" title="statement not covered" >{startLevel:this._currentLevel,name:title,style:style,selectable:selectable};<span class="cstat-no" title="statement not covered" ></span>this._timelineData.groups.push(group);<span class="cstat-no" title="statement not covered" >r</span>eturn group;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendEvent(event,level){const index=<span class="cstat-no" title="statement not covered" >this._entryData.length;<span class="cstat-no" title="statement not covered" ></span>this._entryData.push(event);<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryLevels[index]=level;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryTotalTimes[index]=event.duration||Timeline.TimelineFlameChartDataProvider.InstantEventVisibleDurationMs;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryStartTimes[index]=event.startTime;<span class="cstat-no" title="statement not covered" >e</span>vent[Timeline.TimelineFlameChartDataProvider._indexSymbol]=index;<span class="cstat-no" title="statement not covered" >r</span>eturn index;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendAsyncEvent(asyncEvent,level){<span class="cstat-no" title="statement not covered" >if(SDK.TracingModel.isNestableAsyncPhase(asyncEvent.phase)){<span class="cstat-no" title="statement not covered" >this._appendEvent(asyncEvent,level);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const steps=<span class="cstat-no" title="statement not covered" >asyncEvent.steps;</span>const eventOffset=<span class="cstat-no" title="statement not covered" >steps.length&gt;1&amp;&amp;steps[1].phase===SDK.TracingModel.Phase.AsyncStepPast?1:0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;steps.length-1;++i){const index=<span class="cstat-no" title="statement not covered" >this._entryData.length;<span class="cstat-no" title="statement not covered" ></span>this._entryData.push(steps[i+eventOffset]);c</span>onst startTime=<span class="cstat-no" title="statement not covered" >steps[i].startTime;<span class="cstat-no" title="statement not covered" ></span>this._timelineData.entryLevels[index]=level;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryTotalTimes[index]=steps[i+1].startTime-startTime;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryStartTimes[index]=startTime;}</span>}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendFlowEvent(event,level){const timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData;</span>function <span class="fstat-no" title="function not covered" >pushStartFlow(</span>event){const flowIndex=<span class="cstat-no" title="statement not covered" >timelineData.flowStartTimes.length;<span class="cstat-no" title="statement not covered" ></span>timelineData.flowStartTimes.push(event.startTime);<span class="cstat-no" title="statement not covered" >t</span>imelineData.flowStartLevels.push(level);<span class="cstat-no" title="statement not covered" >r</span>eturn flowIndex;}</span>
function <span class="fstat-no" title="function not covered" >pushEndFlow(</span>event,flowIndex){<span class="cstat-no" title="statement not covered" >timelineData.flowEndTimes[flowIndex]=event.startTime;<span class="cstat-no" title="statement not covered" >t</span>imelineData.flowEndLevels[flowIndex]=level;}</span>
<span class="cstat-no" title="statement not covered" >switch(event.phase){case SDK.TracingModel.Phase.FlowBegin:<span class="cstat-no" title="statement not covered" >this._flowEventIndexById.set(event.id,pushStartFlow(event));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase SDK.TracingModel.Phase.FlowStep:<span class="cstat-no" title="statement not covered" >pushEndFlow(event,this._flowEventIndexById.get(event.id));<span class="cstat-no" title="statement not covered" >t</span>his._flowEventIndexById.set(event.id,pushStartFlow(event));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase SDK.TracingModel.Phase.FlowEnd:<span class="cstat-no" title="statement not covered" >pushEndFlow(event,this._flowEventIndexById.get(event.id));<span class="cstat-no" title="statement not covered" >t</span>his._flowEventIndexById.delete(event.id);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendFrame(frame){const index=<span class="cstat-no" title="statement not covered" >this._entryData.length;<span class="cstat-no" title="statement not covered" ></span>this._entryData.push(frame);<span class="cstat-no" title="statement not covered" >t</span>his._entryIndexToTitle[index]=Number.millisToString(frame.duration,true);<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryLevels[index]=this._currentLevel;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryTotalTimes[index]=frame.duration;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryStartTimes[index]=frame.startTime;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSelection(entryIndex){const type=<span class="cstat-no" title="statement not covered" >this._entryType(entryIndex);</span>let timelineSelection=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(type===Timeline.TimelineFlameChartDataProvider.EntryType.Event){<span class="cstat-no" title="statement not covered" >timelineSelection=Timeline.TimelineSelection.fromTraceEvent((this._entryData[entryIndex]));}</span>else <span class="cstat-no" title="statement not covered" >if(type===Timeline.TimelineFlameChartDataProvider.EntryType.Frame){<span class="cstat-no" title="statement not covered" >timelineSelection=Timeline.TimelineSelection.fromFrame((this._entryData[entryIndex]));}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(timelineSelection)</span>
<span class="cstat-no" title="statement not covered" >this._lastSelection=new Timeline.TimelineFlameChartView.Selection(timelineSelection,entryIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn timelineSelection;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Number.preciseMillisToString(value,precision);}</span>
<span class="fstat-no" title="function not covered" >ca</span>nJumpToEntry(entryIndex){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryIndexForSelection(selection){<span class="cstat-no" title="statement not covered" >if(!selection||selection.type()===Timeline.TimelineSelection.Type.Range)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(this._lastSelection&amp;&amp;this._lastSelection.timelineSelection.object()===selection.object())</span>
<span class="cstat-no" title="statement not covered" >return this._lastSelection.entryIndex;c</span>onst index=<span class="cstat-no" title="statement not covered" >this._entryData.indexOf((selection.object()));<span class="cstat-no" title="statement not covered" ></span>if(index!==-1)</span>
<span class="cstat-no" title="statement not covered" >this._lastSelection=new Timeline.TimelineFlameChartView.Selection(selection,index);<span class="cstat-no" title="statement not covered" >r</span>eturn index;}</span>
<span class="fstat-no" title="function not covered" >bu</span>ildFlowForInitiator(entryIndex){<span class="cstat-no" title="statement not covered" >if(this._lastInitiatorEntry===entryIndex)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his._lastInitiatorEntry=entryIndex;l</span>et event=<span class="cstat-no" title="statement not covered" >this.eventByIndex(entryIndex);</span>const td=<span class="cstat-no" title="statement not covered" >this._timelineData;<span class="cstat-no" title="statement not covered" ></span>td.flowStartTimes=[];<span class="cstat-no" title="statement not covered" >t</span>d.flowStartLevels=[];<span class="cstat-no" title="statement not covered" >t</span>d.flowEndTimes=[];<span class="cstat-no" title="statement not covered" >t</span>d.flowEndLevels=[];<span class="cstat-no" title="statement not covered" >w</span>hile(event){let initiator;<span class="cstat-no" title="statement not covered" >for(;event;event=this._eventParent(event)){<span class="cstat-no" title="statement not covered" >initiator=TimelineModel.TimelineData.forEvent(event).initiator();<span class="cstat-no" title="statement not covered" >i</span>f(initiator)</span></span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>
<span class="cstat-no" title="statement not covered" >if(!initiator)</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst eventIndex=<span class="cstat-no" title="statement not covered" >event[Timeline.TimelineFlameChartDataProvider._indexSymbol];</span>const initiatorIndex=<span class="cstat-no" title="statement not covered" >initiator[Timeline.TimelineFlameChartDataProvider._indexSymbol];<span class="cstat-no" title="statement not covered" ></span>td.flowStartTimes.push(initiator.endTime||initiator.startTime);<span class="cstat-no" title="statement not covered" >t</span>d.flowStartLevels.push(td.entryLevels[initiatorIndex]);<span class="cstat-no" title="statement not covered" >t</span>d.flowEndTimes.push(event.startTime);<span class="cstat-no" title="statement not covered" >t</span>d.flowEndLevels.push(td.entryLevels[eventIndex]);<span class="cstat-no" title="statement not covered" >e</span>vent=initiator;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_e</span>ventParent(event){<span class="cstat-no" title="statement not covered" >return this._entryParent[event[Timeline.TimelineFlameChartDataProvider._indexSymbol]]||null;}</span>
<span class="fstat-no" title="function not covered" >ev</span>entByIndex(entryIndex){<span class="cstat-no" title="statement not covered" >return entryIndex&gt;=0&amp;&amp;this._entryType(entryIndex)===Timeline.TimelineFlameChartDataProvider.EntryType.Event?(this._entryData[entryIndex]):null;}</span>
<span class="fstat-no" title="function not covered" >se</span>tEventColorMapping(colorForEvent){<span class="cstat-no" title="statement not covered" >this._colorForEvent=colorForEvent;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartDataProvider.InstantEventVisibleDurationMs=0.001;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineFlameChartDataProvider._indexSymbol=Symbol('index');<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineFlameChartDataProvider.Events={DataChanged:Symbol('DataChanged')};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineFlameChartDataProvider.EntryType={Frame:Symbol('Frame'),Event:Symbol('Event'),InteractionRecord:Symbol('InteractionRecord'),ExtensionEvent:Symbol('ExtensionEvent'),Screenshot:Symbol('Screenshot'),};;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineFlameChartNetworkDataProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._font='11px '+Host.fontFamily();<span class="cstat-no" title="statement not covered" >t</span>his.setModel(null);<span class="cstat-no" title="statement not covered" >t</span>his._style={padding:4,height:17,collapsible:true,color:UI.themeSupport.patchColorText('#222',UI.ThemeSupport.ColorUsage.Foreground),font:this._font,backgroundColor:UI.themeSupport.patchColorText('white',UI.ThemeSupport.ColorUsage.Background),nestingLevel:0,useFirstLineForOverview:false,useDecoratorsForOverview:true,shareHeaderLine:false};<span class="cstat-no" title="statement not covered" >t</span>his._group={startLevel:0,name:Common.UIString('Network'),expanded:false,style:this._style};<span class="cstat-no" title="statement not covered" >t</span>his._minimumBoundary=0;<span class="cstat-no" title="statement not covered" >t</span>his._maximumBoundary=0;<span class="cstat-no" title="statement not covered" >t</span>his._timeSpan=0;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tModel(performanceModel){<span class="cstat-no" title="statement not covered" >this._model=performanceModel&amp;&amp;performanceModel.timelineModel();<span class="cstat-no" title="statement not covered" >t</span>his._maxLevel=0;<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=null;<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >this.timelineData();<span class="cstat-no" title="statement not covered" >r</span>eturn!this._requests.length;}</span>
<span class="fstat-no" title="function not covered" >ma</span>xStackDepth(){<span class="cstat-no" title="statement not covered" >return this._maxLevel;}</span>
<span class="fstat-no" title="function not covered" >ti</span>melineData(){<span class="cstat-no" title="statement not covered" >if(this._timelineData)</span>
<span class="cstat-no" title="statement not covered" >return this._timelineData;<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._timelineData=new PerfUI.FlameChart.TimelineData([],[],[],[]);<span class="cstat-no" title="statement not covered" >i</span>f(this._model)</span>
<span class="cstat-no" title="statement not covered" >this._appendTimelineData();<span class="cstat-no" title="statement not covered" >r</span>eturn this._timelineData;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundary;}</span>
<span class="fstat-no" title="function not covered" >to</span>talTime(){<span class="cstat-no" title="statement not covered" >return this._timeSpan;}</span>
<span class="fstat-no" title="function not covered" >se</span>tWindowTimes(startTime,endTime){<span class="cstat-no" title="statement not covered" >this._startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._endTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimelineData();}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateSelection(index){<span class="cstat-no" title="statement not covered" >if(index===-1)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst request=<span class="cstat-no" title="statement not covered" >this._requests[index];<span class="cstat-no" title="statement not covered" ></span>this._lastSelection=new Timeline.TimelineFlameChartView.Selection(Timeline.TimelineSelection.fromNetworkRequest(request),index);<span class="cstat-no" title="statement not covered" >r</span>eturn this._lastSelection.timelineSelection;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryIndexForSelection(selection){<span class="cstat-no" title="statement not covered" >if(!selection)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(this._lastSelection&amp;&amp;this._lastSelection.timelineSelection.object()===selection.object())</span>
<span class="cstat-no" title="statement not covered" >return this._lastSelection.entryIndex;<span class="cstat-no" title="statement not covered" >i</span>f(selection.type()!==Timeline.TimelineSelection.Type.NetworkRequest)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst request=(<span class="cstat-no" title="statement not covered" >selection.object())</span>;const index=<span class="cstat-no" title="statement not covered" >this._requests.indexOf(request);<span class="cstat-no" title="statement not covered" ></span>if(index!==-1){<span class="cstat-no" title="statement not covered" >this._lastSelection=new Timeline.TimelineFlameChartView.Selection(Timeline.TimelineSelection.fromNetworkRequest(request),index);}</span></span>
<span class="cstat-no" title="statement not covered" >return index;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryColor(index){const request=(<span class="cstat-no" title="statement not covered" >this._requests[index])</span>;const category=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.networkRequestCategory(request);<span class="cstat-no" title="statement not covered" ></span>return Timeline.TimelineUIUtils.networkCategoryColor(category);}</span>
<span class="fstat-no" title="function not covered" >te</span>xtColor(index){<span class="cstat-no" title="statement not covered" >return Timeline.FlameChartStyle.textColor;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryTitle(index){const request=(<span class="cstat-no" title="statement not covered" >this._requests[index])</span>;const parsedURL=<span class="cstat-no" title="statement not covered" >new Common.ParsedURL(request.url||'');<span class="cstat-no" title="statement not covered" ></span>return parsedURL.isValid?`${parsedURL.displayName} (${parsedURL.host})`:request.url||null;}</span>
<span class="fstat-no" title="function not covered" >en</span>tryFont(index){<span class="cstat-no" title="statement not covered" >return this._font;}</span>
<span class="fstat-no" title="function not covered" >de</span>corateEntry(index,context,text,barX,barY,barWidth,barHeight,unclippedBarX,timeToPixelRatio){const request=(<span class="cstat-no" title="statement not covered" >this._requests[index])</span>;<span class="cstat-no" title="statement not covered" >if(!request.timing)</span>
<span class="cstat-no" title="statement not covered" >return false;f</span>unction <span class="fstat-no" title="function not covered" >timeToPixel(</span>time){<span class="cstat-no" title="statement not covered" >return Math.floor(unclippedBarX+(time-beginTime)*timeToPixelRatio);}</span>
const minBarWidthPx=<span class="cstat-no" title="statement not covered" >2;</span>const beginTime=<span class="cstat-no" title="statement not covered" >request.beginTime();</span>const startTime=<span class="cstat-no" title="statement not covered" >request.startTime;</span>const endTime=<span class="cstat-no" title="statement not covered" >request.endTime;</span>const requestTime=<span class="cstat-no" title="statement not covered" >request.timing.requestTime*1000;</span>const sendStart=<span class="cstat-no" title="statement not covered" >Math.max(timeToPixel(requestTime+request.timing.sendStart),unclippedBarX);</span>const headersEnd=<span class="cstat-no" title="statement not covered" >Math.max(timeToPixel(requestTime+request.timing.receiveHeadersEnd),sendStart);</span>const finish=<span class="cstat-no" title="statement not covered" >Math.max(timeToPixel(request.finishTime||endTime),headersEnd+minBarWidthPx);</span>const start=<span class="cstat-no" title="statement not covered" >timeToPixel(startTime);</span>const end=<span class="cstat-no" title="statement not covered" >Math.max(timeToPixel(endTime),finish);<span class="cstat-no" title="statement not covered" ></span>context.fillStyle='hsla(0, 100%, 100%, 0.8)';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(sendStart+0.5,barY+0.5,headersEnd-sendStart-0.5,barHeight-2);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=UI.themeSupport.patchColorText('white',UI.ThemeSupport.ColorUsage.Background);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(barX,barY-0.5,sendStart-barX,barHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(finish,barY-0.5,barX+barWidth-finish,barHeight);<span class="cstat-no" title="statement not covered" >i</span>f(request.timing.pushStart){const pushStart=<span class="cstat-no" title="statement not covered" >timeToPixel(request.timing.pushStart*1000);</span>const pushEnd=<span class="cstat-no" title="statement not covered" >timeToPixel(request.timing.pushEnd*1000);</span>const dentSize=<span class="cstat-no" title="statement not covered" >Number.constrain(pushEnd-pushStart-2,0,4);</span>const padding=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(pushStart+dentSize,barY+barHeight/2);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(pushStart,barY+padding);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(pushEnd-dentSize,barY+padding);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(pushEnd,barY+barHeight/2);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(pushEnd-dentSize,barY+barHeight-padding);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(pushStart,barY+barHeight-padding);<span class="cstat-no" title="statement not covered" >c</span>ontext.closePath();<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=this.entryColor(index);<span class="cstat-no" title="statement not covered" >c</span>ontext.globalAlpha=0.3;<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();}</span></span>
function <span class="fstat-no" title="function not covered" >drawTick(</span>begin,end,y){const tickHeightPx=<span class="cstat-no" title="statement not covered" >6;<span class="cstat-no" title="statement not covered" ></span>context.moveTo(begin,y-tickHeightPx/2);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(begin,y+tickHeightPx/2);<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(begin,y);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(end,y);}</span>
<span class="cstat-no" title="statement not covered" >context.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=1;<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='#ccc';c</span>onst lineY=<span class="cstat-no" title="statement not covered" >Math.floor(barY+barHeight/2)+0.5;</span>const leftTick=<span class="cstat-no" title="statement not covered" >start+0.5;</span>const rightTick=<span class="cstat-no" title="statement not covered" >end-0.5;<span class="cstat-no" title="statement not covered" ></span>drawTick(leftTick,sendStart,lineY);<span class="cstat-no" title="statement not covered" >d</span>rawTick(rightTick,finish,lineY);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >i</span>f(typeof request.priority==='string'){const color=<span class="cstat-no" title="statement not covered" >this._colorForPriority(request.priority);<span class="cstat-no" title="statement not covered" ></span>if(color){<span class="cstat-no" title="statement not covered" >context.fillStyle=color;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(sendStart+0.5,barY+0.5,3.5,3.5);}</span>}</span></span>
const textStart=<span class="cstat-no" title="statement not covered" >Math.max(sendStart,0);</span>const textWidth=<span class="cstat-no" title="statement not covered" >finish-textStart;</span>const minTextWidthPx=<span class="cstat-no" title="statement not covered" >20;<span class="cstat-no" title="statement not covered" ></span>if(textWidth&gt;=minTextWidthPx){<span class="cstat-no" title="statement not covered" >text=this.entryTitle(index)||'';<span class="cstat-no" title="statement not covered" >i</span>f(request.fromServiceWorker)</span></span>
<span class="cstat-no" title="statement not covered" >text='⚙ '+text;<span class="cstat-no" title="statement not covered" >i</span>f(text){const textPadding=<span class="cstat-no" title="statement not covered" >4;</span>const textBaseline=<span class="cstat-no" title="statement not covered" >5;</span>const textBaseHeight=<span class="cstat-no" title="statement not covered" >barHeight-textBaseline;</span>const trimmedText=<span class="cstat-no" title="statement not covered" >UI.trimTextEnd(context,text,textWidth-2*textPadding);<span class="cstat-no" title="statement not covered" ></span>context.fillStyle='#333';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillText(trimmedText,textStart+textPadding,barY+textBaseHeight);}</span>}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rceDecoration(index){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >pr</span>epareHighlightedEntryInfo(index){const maxURLChars=<span class="cstat-no" title="statement not covered" >80;</span>const request=(<span class="cstat-no" title="statement not covered" >this._requests[index])</span>;<span class="cstat-no" title="statement not covered" >if(!request.url)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst element=<span class="cstat-no" title="statement not covered" >createElement('div');</span>const root=<span class="cstat-no" title="statement not covered" >UI.createShadowRootWithCoreStyles(element,'timeline/timelineFlamechartPopover.css');</span>const contents=<span class="cstat-no" title="statement not covered" >root.createChild('div','timeline-flamechart-popover');</span>const duration=<span class="cstat-no" title="statement not covered" >request.endTime-request.startTime;<span class="cstat-no" title="statement not covered" ></span>if(request.startTime&amp;&amp;isFinite(duration))</span>
<span class="cstat-no" title="statement not covered" >contents.createChild('span','timeline-info-network-time').textContent=Number.millisToString(duration);<span class="cstat-no" title="statement not covered" >i</span>f(typeof request.priority==='string'){const div=<span class="cstat-no" title="statement not covered" >contents.createChild('span');<span class="cstat-no" title="statement not covered" ></span>div.textContent=PerfUI.uiLabelForNetworkPriority((request.priority));<span class="cstat-no" title="statement not covered" >d</span>iv.style.color=this._colorForPriority(request.priority)||'black';}</span></span>
<span class="cstat-no" title="statement not covered" >contents.createChild('span').textContent=request.url.trimMiddle(maxURLChars);<span class="cstat-no" title="statement not covered" >r</span>eturn element;}</span>
<span class="fstat-no" title="function not covered" >_c</span>olorForPriority(priority){<span class="cstat-no" title="statement not covered" >if(!this._priorityToValue){const priorities=<span class="cstat-no" title="statement not covered" >Protocol.Network.ResourcePriority;<span class="cstat-no" title="statement not covered" ></span>this._priorityToValue=new Map([[priorities.VeryLow,1],[priorities.Low,2],[priorities.Medium,3],[priorities.High,4],[priorities.VeryHigh,5]]);}</span></span>
const value=<span class="cstat-no" title="statement not covered" >this._priorityToValue.get(priority);<span class="cstat-no" title="statement not covered" ></span>return value?`hsla(214, 80%, 50%, ${value / 5})`:null;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendTimelineData(){<span class="cstat-no" title="statement not covered" >this._minimumBoundary=this._model.minimumRecordTime();<span class="cstat-no" title="statement not covered" >t</span>his._maximumBoundary=this._model.maximumRecordTime();<span class="cstat-no" title="statement not covered" >t</span>his._timeSpan=this._model.isEmpty()?1000:this._maximumBoundary-this._minimumBoundary;<span class="cstat-no" title="statement not covered" >t</span>his._model.networkRequests().forEach(this._appendEntry.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._updateTimelineData();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateTimelineData(){<span class="cstat-no" title="statement not covered" >if(!this._timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst lastTimeByLevel=<span class="cstat-no" title="statement not covered" >[];</span>let maxLevel=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._requests.length;++i){const r=<span class="cstat-no" title="statement not covered" >this._requests[i];</span>const beginTime=<span class="cstat-no" title="statement not covered" >r.beginTime();</span>const visible=<span class="cstat-no" title="statement not covered" >beginTime&lt;this._endTime&amp;&amp;r.endTime&gt;this._startTime;<span class="cstat-no" title="statement not covered" ></span>if(!visible){<span class="cstat-no" title="statement not covered" >this._timelineData.entryLevels[i]=-1;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(lastTimeByLevel.length&amp;&amp;lastTimeByLevel.peekLast()&lt;=beginTime)</span>
<span class="cstat-no" title="statement not covered" >lastTimeByLevel.pop();<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryLevels[i]=lastTimeByLevel.length;<span class="cstat-no" title="statement not covered" >l</span>astTimeByLevel.push(r.endTime);<span class="cstat-no" title="statement not covered" >m</span>axLevel=Math.max(maxLevel,lastTimeByLevel.length);}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._requests.length;++i){<span class="cstat-no" title="statement not covered" >if(this._timelineData.entryLevels[i]===-1)</span></span>
<span class="cstat-no" title="statement not covered" >this._timelineData.entryLevels[i]=maxLevel;}</span>
<span class="cstat-no" title="statement not covered" >this._timelineData=new PerfUI.FlameChart.TimelineData(this._timelineData.entryLevels,this._timelineData.entryTotalTimes,this._timelineData.entryStartTimes,[this._group]);<span class="cstat-no" title="statement not covered" >t</span>his._maxLevel=maxLevel;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendEntry(request){<span class="cstat-no" title="statement not covered" >this._requests.push(request);<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryStartTimes.push(request.beginTime());<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryTotalTimes.push(request.endTime-request.beginTime());<span class="cstat-no" title="statement not covered" >t</span>his._timelineData.entryLevels.push(this._requests.length-1);}</span>
<span class="fstat-no" title="function not covered" >pr</span>eferredHeight(){<span class="cstat-no" title="statement not covered" >return this._style.height*(this._group.expanded?Number.constrain(this._maxLevel+1,4,8.5):1);}</span>
<span class="fstat-no" title="function not covered" >is</span>Expanded(){<span class="cstat-no" title="statement not covered" >return this._group.expanded;}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Number.preciseMillisToString(value,precision);}</span>
<span class="fstat-no" title="function not covered" >ca</span>nJumpToEntry(entryIndex){<span class="cstat-no" title="statement not covered" >return false;}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(delegate){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('timeline-flamechart');<span class="cstat-no" title="statement not covered" >t</span>his._delegate=delegate;<span class="cstat-no" title="statement not covered" >t</span>his._model=null;<span class="cstat-no" title="statement not covered" >t</span>his._searchResults;<span class="cstat-no" title="statement not covered" >t</span>his._eventListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._showMemoryGraphSetting=Common.settings.createSetting('timelineShowMemory',false);<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget=new UI.SplitWidget(false,false,'timelineFlamechartMainView',150);c</span>onst mainViewGroupExpansionSetting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting('timelineFlamechartMainViewGroupExpansion',{});<span class="cstat-no" title="statement not covered" ></span>this._mainDataProvider=new Timeline.TimelineFlameChartDataProvider();<span class="cstat-no" title="statement not covered" >t</span>his._mainDataProvider.addEventListener(Timeline.TimelineFlameChartDataProvider.Events.DataChanged,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._mainFlameChart.scheduleUpdate())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart=new PerfUI.FlameChart(this._mainDataProvider,this,mainViewGroupExpansionSetting);<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.alwaysShowVerticalScroll();<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.enableRuler(false);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChartGroupExpansionSetting=Common.settings.createSetting('timelineFlamechartNetworkViewGroupExpansion',{});<span class="cstat-no" title="statement not covered" >t</span>his._networkDataProvider=new Timeline.TimelineFlameChartNetworkDataProvider();<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart=new PerfUI.FlameChart(this._networkDataProvider,this,this._networkFlameChartGroupExpansionSetting);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.alwaysShowVerticalScroll();<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.disableRangeSelection();<span class="cstat-no" title="statement not covered" >t</span>his._networkPane=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._networkPane.setMinimumSize(23,23);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.show(this._networkPane.element);<span class="cstat-no" title="statement not covered" >t</span>his._splitResizer=this._networkPane.element.createChild('div','timeline-flamechart-resizer');<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.hideDefaultResizer(true);<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.installResizer(this._splitResizer);<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.setMainWidget(this._mainFlameChart);<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.setSidebarWidget(this._networkPane);<span class="cstat-no" title="statement not covered" >t</span>his._chartSplitWidget=new UI.SplitWidget(false,true,'timelineCountersSplitViewState');<span class="cstat-no" title="statement not covered" >t</span>his._countersView=new Timeline.CountersGraph(this._delegate);<span class="cstat-no" title="statement not covered" >t</span>his._chartSplitWidget.setMainWidget(this._networkSplitWidget);<span class="cstat-no" title="statement not covered" >t</span>his._chartSplitWidget.setSidebarWidget(this._countersView);<span class="cstat-no" title="statement not covered" >t</span>his._chartSplitWidget.hideDefaultResizer();<span class="cstat-no" title="statement not covered" >t</span>his._chartSplitWidget.installResizer((this._countersView.resizerElement()));<span class="cstat-no" title="statement not covered" >t</span>his._updateCountersGraphToggle();<span class="cstat-no" title="statement not covered" >t</span>his._detailsSplitWidget=new UI.SplitWidget(false,true,'timelinePanelDetailsSplitViewState');<span class="cstat-no" title="statement not covered" >t</span>his._detailsSplitWidget.element.classList.add('timeline-details-split');<span class="cstat-no" title="statement not covered" >t</span>his._detailsView=new Timeline.TimelineDetailsView(delegate);<span class="cstat-no" title="statement not covered" >t</span>his._detailsSplitWidget.installResizer(this._detailsView.headerElement());<span class="cstat-no" title="statement not covered" >t</span>his._detailsSplitWidget.setMainWidget(this._chartSplitWidget);<span class="cstat-no" title="statement not covered" >t</span>his._detailsSplitWidget.setSidebarWidget(this._detailsView);<span class="cstat-no" title="statement not covered" >t</span>his._detailsSplitWidget.show(this.element);<span class="cstat-no" title="statement not covered" >t</span>his._onMainEntrySelected=this._onEntrySelected.bind(this,this._mainDataProvider);<span class="cstat-no" title="statement not covered" >t</span>his._onNetworkEntrySelected=this._onEntrySelected.bind(this,this._networkDataProvider);<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.addEventListener(PerfUI.FlameChart.Events.EntrySelected,this._onMainEntrySelected,this);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.addEventListener(PerfUI.FlameChart.Events.EntrySelected,this._onNetworkEntrySelected,this);<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.addEventListener(PerfUI.FlameChart.Events.EntryHighlighted,this._onEntryHighlighted,this);<span class="cstat-no" title="statement not covered" >t</span>his._nextExtensionIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._boundRefresh=this._refresh.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._selectedTrack=null;<span class="cstat-no" title="statement not covered" >t</span>his._mainDataProvider.setEventColorMapping(Timeline.TimelineUIUtils.eventColor);<span class="cstat-no" title="statement not covered" >t</span>his._groupBySetting=Common.settings.createSetting('timelineTreeGroupBy',Timeline.AggregatedTimelineTreeView.GroupBy.None);<span class="cstat-no" title="statement not covered" >t</span>his._groupBySetting.addChangeListener(this._updateColorMapper,this);<span class="cstat-no" title="statement not covered" >t</span>his._updateColorMapper();<span class="cstat-no" title="statement not covered" >P</span>roductRegistry.instance().then(<span class="fstat-no" title="function not covered" >re</span>gistry=&gt;<span class="cstat-no" title="statement not covered" >this._productRegistry=registry)</span>;}</span></span>
<span class="fstat-no" title="function not covered" >_u</span>pdateColorMapper(){<span class="cstat-no" title="statement not covered" >this._urlToColorCache=new Map();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst colorByProduct=<span class="cstat-no" title="statement not covered" >this._groupBySetting.get()===Timeline.AggregatedTimelineTreeView.GroupBy.Product;<span class="cstat-no" title="statement not covered" ></span>this._mainDataProvider.setEventColorMapping(colorByProduct?this._colorByProductForEvent.bind(this):Timeline.TimelineUIUtils.eventColor);<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.update();}</span>
<span class="fstat-no" title="function not covered" >_c</span>olorByProductForEvent(event){<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.eventColorByProduct(this._productRegistry,this._model.timelineModel(),this._urlToColorCache,event);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(event){const window=(<span class="cstat-no" title="statement not covered" >event.data.window)</span>;const animate=<span class="cstat-no" title="statement not covered" >!!event.data.animate;<span class="cstat-no" title="statement not covered" ></span>this._mainFlameChart.setWindowTimes(window.left,window.right,animate);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.setWindowTimes(window.left,window.right,animate);<span class="cstat-no" title="statement not covered" >t</span>his._networkDataProvider.setWindowTimes(window.left,window.right);<span class="cstat-no" title="statement not covered" >t</span>his._updateSearchResults(false,false);}</span>
<span class="fstat-no" title="function not covered" >wi</span>ndowChanged(windowStartTime,windowEndTime,animate){<span class="cstat-no" title="statement not covered" >this._model.setWindow({left:windowStartTime,right:windowEndTime},animate);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateRangeSelection(startTime,endTime){<span class="cstat-no" title="statement not covered" >this._delegate.select(Timeline.TimelineSelection.fromRange(startTime,endTime));}</span>
<span class="fstat-no" title="function not covered" >up</span>dateSelectedGroup(flameChart,group){<span class="cstat-no" title="statement not covered" >if(flameChart!==this._mainFlameChart)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst track=<span class="cstat-no" title="statement not covered" >group?this._mainDataProvider.groupTrack(group):null;<span class="cstat-no" title="statement not covered" ></span>this._selectedTrack=track;<span class="cstat-no" title="statement not covered" >t</span>his._updateTrack();}</span>
<span class="fstat-no" title="function not covered" >se</span>tModel(model){<span class="cstat-no" title="statement not covered" >if(model===this._model)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >C</span>ommon.EventTarget.removeEventListeners(this._eventListeners);<span class="cstat-no" title="statement not covered" >t</span>his._model=model;<span class="cstat-no" title="statement not covered" >t</span>his._selectedTrack=null;<span class="cstat-no" title="statement not covered" >t</span>his._mainDataProvider.setModel(this._model);<span class="cstat-no" title="statement not covered" >t</span>his._networkDataProvider.setModel(this._model);<span class="cstat-no" title="statement not covered" >i</span>f(this._model){<span class="cstat-no" title="statement not covered" >this._eventListeners=[this._model.addEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onWindowChanged,this),this._model.addEventListener(Timeline.PerformanceModel.Events.ExtensionDataAdded,this._appendExtensionData,this)];c</span>onst window=<span class="cstat-no" title="statement not covered" >model.window();<span class="cstat-no" title="statement not covered" ></span>this._mainFlameChart.setWindowTimes(window.left,window.right);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.setWindowTimes(window.left,window.right);<span class="cstat-no" title="statement not covered" >t</span>his._networkDataProvider.setWindowTimes(window.left,window.right);<span class="cstat-no" title="statement not covered" >t</span>his._updateSearchResults(false,false);}</span></span>
<span class="cstat-no" title="statement not covered" >this._updateColorMapper();<span class="cstat-no" title="statement not covered" >t</span>his._updateTrack();<span class="cstat-no" title="statement not covered" >t</span>his._nextExtensionIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._appendExtensionData();<span class="cstat-no" title="statement not covered" >t</span>his._refresh();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateTrack(){<span class="cstat-no" title="statement not covered" >this._countersView.setModel(this._model,this._selectedTrack);<span class="cstat-no" title="statement not covered" >t</span>his._detailsView.setModel(this._model,this._selectedTrack);}</span>
<span class="fstat-no" title="function not covered" >_r</span>efresh(){<span class="cstat-no" title="statement not covered" >if(this._networkDataProvider.isEmpty()){<span class="cstat-no" title="statement not covered" >this._mainFlameChart.enableRuler(true);<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.hideSidebar();}</span>else{<span class="cstat-no" title="statement not covered" >this._mainFlameChart.enableRuler(false);<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.showBoth();<span class="cstat-no" title="statement not covered" >t</span>his.resizeToPreferredHeights();}</span></span>
<span class="cstat-no" title="statement not covered" >this._mainFlameChart.reset();<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.reset();<span class="cstat-no" title="statement not covered" >t</span>his._updateSearchResults(false,false);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendExtensionData(){<span class="cstat-no" title="statement not covered" >if(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst extensions=<span class="cstat-no" title="statement not covered" >this._model.extensionInfo();<span class="cstat-no" title="statement not covered" ></span>while(this._nextExtensionIndex&lt;extensions.length)</span>
<span class="cstat-no" title="statement not covered" >this._mainDataProvider.appendExtensionEvents(extensions[this._nextExtensionIndex++]);<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nEntryHighlighted(commonEvent){<span class="cstat-no" title="statement not covered" >SDK.OverlayModel.hideDOMNodeHighlight();c</span>onst entryIndex=(<span class="cstat-no" title="statement not covered" >commonEvent.data)</span>;const event=<span class="cstat-no" title="statement not covered" >this._mainDataProvider.eventByIndex(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(!event)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst target=<span class="cstat-no" title="statement not covered" >this._model&amp;&amp;this._model.timelineModel().targetByEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(!target)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);</span>const backendNodeId=<span class="cstat-no" title="statement not covered" >timelineData.backendNodeId;<span class="cstat-no" title="statement not covered" ></span>if(!backendNodeId)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span>ew SDK.DeferredDOMNode(target,backendNodeId).highlight();}</span>
<span class="fstat-no" title="function not covered" >hi</span>ghlightEvent(event){const entryIndex=<span class="cstat-no" title="statement not covered" >event?this._mainDataProvider.entryIndexForSelection(Timeline.TimelineSelection.fromTraceEvent(event)):-1;<span class="cstat-no" title="statement not covered" ></span>if(entryIndex&gt;=0)</span>
<span class="cstat-no" title="statement not covered" >this._mainFlameChart.highlightEntry(entryIndex);e</span>lse
<span class="cstat-no" title="statement not covered" >this._mainFlameChart.hideHighlight();}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >this._networkFlameChartGroupExpansionSetting.removeChangeListener(this.resizeToPreferredHeights,this);<span class="cstat-no" title="statement not covered" >t</span>his._showMemoryGraphSetting.removeChangeListener(this._updateCountersGraphToggle,this);<span class="cstat-no" title="statement not covered" >B</span>indings.blackboxManager.removeChangeListener(this._boundRefresh);}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >this._networkFlameChartGroupExpansionSetting.addChangeListener(this.resizeToPreferredHeights,this);<span class="cstat-no" title="statement not covered" >t</span>his._showMemoryGraphSetting.addChangeListener(this._updateCountersGraphToggle,this);<span class="cstat-no" title="statement not covered" >B</span>indings.blackboxManager.addChangeListener(this._boundRefresh);<span class="cstat-no" title="statement not covered" >i</span>f(this._needsResizeToPreferredHeights)</span>
<span class="cstat-no" title="statement not covered" >this.resizeToPreferredHeights();<span class="cstat-no" title="statement not covered" >t</span>his._mainFlameChart.scheduleUpdate();<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateCountersGraphToggle(){<span class="cstat-no" title="statement not covered" >if(this._showMemoryGraphSetting.get())</span>
<span class="cstat-no" title="statement not covered" >this._chartSplitWidget.showBoth();e</span>lse
<span class="cstat-no" title="statement not covered" >this._chartSplitWidget.hideSidebar();}</span>
<span class="fstat-no" title="function not covered" >se</span>tSelection(selection){let index=<span class="cstat-no" title="statement not covered" >this._mainDataProvider.entryIndexForSelection(selection);<span class="cstat-no" title="statement not covered" ></span>this._mainFlameChart.setSelectedEntry(index);<span class="cstat-no" title="statement not covered" >i</span>ndex=this._networkDataProvider.entryIndexForSelection(selection);<span class="cstat-no" title="statement not covered" >t</span>his._networkFlameChart.setSelectedEntry(index);<span class="cstat-no" title="statement not covered" >i</span>f(this._detailsView)</span>
<span class="cstat-no" title="statement not covered" >this._detailsView.setSelection(selection);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nEntrySelected(dataProvider,event){const entryIndex=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >if(Runtime.experiments.isEnabled('timelineEventInitiators')&amp;&amp;dataProvider===this._mainDataProvider){<span class="cstat-no" title="statement not covered" >if(this._mainDataProvider.buildFlowForInitiator(entryIndex))</span></span>
<span class="cstat-no" title="statement not covered" >this._mainFlameChart.scheduleUpdate();}</span>
<span class="cstat-no" title="statement not covered" >this._delegate.select(dataProvider.createSelection(entryIndex));}</span>
<span class="fstat-no" title="function not covered" >re</span>sizeToPreferredHeights(){<span class="cstat-no" title="statement not covered" >if(!this.isShowing()){<span class="cstat-no" title="statement not covered" >this._needsResizeToPreferredHeights=true;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._needsResizeToPreferredHeights=false;<span class="cstat-no" title="statement not covered" >t</span>his._networkPane.element.classList.toggle('timeline-network-resizer-disabled',!this._networkDataProvider.isExpanded());<span class="cstat-no" title="statement not covered" >t</span>his._networkSplitWidget.setSidebarSize(this._networkDataProvider.preferredHeight()+this._splitResizer.clientHeight+PerfUI.FlameChart.HeaderHeight+</span>
2);}
<span class="fstat-no" title="function not covered" >se</span>tSearchableView(searchableView){<span class="cstat-no" title="statement not covered" >this._searchableView=searchableView;}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToNextSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults||!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst index=<span class="cstat-no" title="statement not covered" >typeof this._selectedSearchResult!=='undefined'?this._searchResults.indexOf(this._selectedSearchResult):-1;<span class="cstat-no" title="statement not covered" ></span>this._selectSearchResult(mod(index+1,this._searchResults.length));}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToPreviousSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults||!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst index=<span class="cstat-no" title="statement not covered" >typeof this._selectedSearchResult!=='undefined'?this._searchResults.indexOf(this._selectedSearchResult):0;<span class="cstat-no" title="statement not covered" ></span>this._selectSearchResult(mod(index-1,this._searchResults.length));}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsCaseSensitiveSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsRegexSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_s</span>electSearchResult(index){<span class="cstat-no" title="statement not covered" >this._searchableView.updateCurrentMatchIndex(index);<span class="cstat-no" title="statement not covered" >t</span>his._selectedSearchResult=this._searchResults[index];<span class="cstat-no" title="statement not covered" >t</span>his._delegate.select(this._mainDataProvider.createSelection(this._selectedSearchResult));}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateSearchResults(shouldJump,jumpBackwards){const oldSelectedSearchResult=<span class="cstat-no" title="statement not covered" >this._selectedSearchResult;<span class="cstat-no" title="statement not covered" ></span>delete this._selectedSearchResult;<span class="cstat-no" title="statement not covered" >t</span>his._searchResults=[];<span class="cstat-no" title="statement not covered" >i</span>f(!this._searchRegex||!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst regExpFilter=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineFilters.RegExp(this._searchRegex);</span>const window=<span class="cstat-no" title="statement not covered" >this._model.window();<span class="cstat-no" title="statement not covered" ></span>this._searchResults=this._mainDataProvider.search(window.left,window.right,regExpFilter);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateSearchMatchesCount(this._searchResults.length);<span class="cstat-no" title="statement not covered" >i</span>f(!shouldJump||!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et selectedIndex=<span class="cstat-no" title="statement not covered" >this._searchResults.indexOf(oldSelectedSearchResult);<span class="cstat-no" title="statement not covered" ></span>if(selectedIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >selectedIndex=jumpBackwards?this._searchResults.length-1:0;<span class="cstat-no" title="statement not covered" >t</span>his._selectSearchResult(selectedIndex);}</span>
<span class="fstat-no" title="function not covered" >se</span>archCanceled(){<span class="cstat-no" title="statement not covered" >if(typeof this._selectedSearchResult!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >this._delegate.select(null);<span class="cstat-no" title="statement not covered" >d</span>elete this._searchResults;<span class="cstat-no" title="statement not covered" >d</span>elete this._selectedSearchResult;<span class="cstat-no" title="statement not covered" >d</span>elete this._searchRegex;}</span>
<span class="fstat-no" title="function not covered" >pe</span>rformSearch(searchConfig,shouldJump,jumpBackwards){<span class="cstat-no" title="statement not covered" >this._searchRegex=searchConfig.toSearchRegex();<span class="cstat-no" title="statement not covered" >t</span>his._updateSearchResults(shouldJump,jumpBackwards);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartView.Selection=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(selection,entryIndex){<span class="cstat-no" title="statement not covered" >this.timelineSelection=selection;<span class="cstat-no" title="statement not covered" >t</span>his.entryIndex=entryIndex;}</span>};<span class="cstat-no" title="statement not covered" >T</span>imeline.FlameChartStyle={textColor:'#333'};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineFlameChartMarker=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(startTime,startOffset,style){<span class="cstat-no" title="statement not covered" >this._startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._startOffset=startOffset;<span class="cstat-no" title="statement not covered" >t</span>his._style=style;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>artTime(){<span class="cstat-no" title="statement not covered" >return this._startTime;}</span>
<span class="fstat-no" title="function not covered" >co</span>lor(){<span class="cstat-no" title="statement not covered" >return this._style.color;}</span>
<span class="fstat-no" title="function not covered" >ti</span>tle(){<span class="cstat-no" title="statement not covered" >if(this._style.lowPriority)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst startTime=<span class="cstat-no" title="statement not covered" >Number.millisToString(this._startOffset);<span class="cstat-no" title="statement not covered" ></span>return ls`${this._style.title} at ${startTime}`;}</span>
<span class="fstat-no" title="function not covered" >dr</span>aw(context,x,height,pixelsPerMillisecond){const lowPriorityVisibilityThresholdInPixelsPerMs=<span class="cstat-no" title="statement not covered" >4;<span class="cstat-no" title="statement not covered" ></span>if(this._style.lowPriority&amp;&amp;pixelsPerMillisecond&lt;lowPriorityVisibilityThresholdInPixelsPerMs)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>ontext.save();<span class="cstat-no" title="statement not covered" >i</span>f(this._style.tall){<span class="cstat-no" title="statement not covered" >context.strokeStyle=this._style.color;<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=this._style.lineWidth;<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(this._style.lineWidth&lt;1||(this._style.lineWidth&amp;1)?0.5:0,0.5);<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(x,0);<span class="cstat-no" title="statement not covered" >c</span>ontext.setLineDash(this._style.dashStyle);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(x,context.canvas.height);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();}</span></span>
<span class="cstat-no" title="statement not covered" >context.restore();}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineFlameChartView._ColorBy={URL:'URL',Product:'Product'};;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineHistoryManager=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._recordings=[];<span class="cstat-no" title="statement not covered" >t</span>his._action=(UI.actionRegistry.action('timeline.show-history'));<span class="cstat-no" title="statement not covered" >t</span>his._nextNumberByDomain=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._button=new Timeline.TimelineHistoryManager.ToolbarButton(this._action);<span class="cstat-no" title="statement not covered" >t</span>his.clear();<span class="cstat-no" title="statement not covered" >t</span>his._allOverviews=[{constructor:Timeline.TimelineEventOverviewResponsiveness,height:3},{constructor:Timeline.TimelineEventOverviewFrames,height:16},{constructor:Timeline.TimelineEventOverviewCPUActivity,height:20},{constructor:Timeline.TimelineEventOverviewNetwork,height:8}];<span class="cstat-no" title="statement not covered" >t</span>his._totalHeight=this._allOverviews.reduce(<span class="fstat-no" title="function not covered" >(a</span>cc,entry)=&gt;<span class="cstat-no" title="statement not covered" >acc+entry.height,</span>0);<span class="cstat-no" title="statement not covered" >t</span>his._enabled=true;<span class="cstat-no" title="statement not covered" >t</span>his._lastActiveModel=null;}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dRecording(performanceModel){<span class="cstat-no" title="statement not covered" >this._lastActiveModel=performanceModel;<span class="cstat-no" title="statement not covered" >t</span>his._recordings.unshift(performanceModel);<span class="cstat-no" title="statement not covered" >t</span>his._buildPreview(performanceModel);<span class="cstat-no" title="statement not covered" >t</span>his._button.setText(this._title(performanceModel));<span class="cstat-no" title="statement not covered" >t</span>his._updateState();<span class="cstat-no" title="statement not covered" >i</span>f(this._recordings.length&lt;=Timeline.TimelineHistoryManager._maxRecordings)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst lruModel=<span class="cstat-no" title="statement not covered" >this._recordings.reduce(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >lastUsedTime(a)&lt;lastUsedTime(b)?a:b)</span>;<span class="cstat-no" title="statement not covered" ></span>this._recordings.splice(this._recordings.indexOf(lruModel),1);<span class="cstat-no" title="statement not covered" >l</span>ruModel.dispose();f</span>unction <span class="fstat-no" title="function not covered" >lastUsedTime(</span>model){<span class="cstat-no" title="statement not covered" >return Timeline.TimelineHistoryManager._dataForModel(model).lastUsed;}</span>}
<span class="fstat-no" title="function not covered" >se</span>tEnabled(enabled){<span class="cstat-no" title="statement not covered" >this._enabled=enabled;<span class="cstat-no" title="statement not covered" >t</span>his._updateState();}</span>
<span class="fstat-no" title="function not covered" >bu</span>tton(){<span class="cstat-no" title="statement not covered" >return this._button;}</span>
<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >this._recordings.forEach(<span class="fstat-no" title="function not covered" >mo</span>del=&gt;<span class="cstat-no" title="statement not covered" >model.dispose())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._recordings=[];<span class="cstat-no" title="statement not covered" >t</span>his._lastActiveModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._updateState();<span class="cstat-no" title="statement not covered" >t</span>his._button.setText(Common.UIString('(no recordings)'));<span class="cstat-no" title="statement not covered" >t</span>his._nextNumberByDomain.clear();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync showHistoryDropDown(){<span class="cstat-no" title="statement not covered" >if(this._recordings.length&lt;2||!this._enabled)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst model=<span class="cstat-no" title="statement not covered" >await Timeline.TimelineHistoryManager.DropDown.show(this._recordings,(this._lastActiveModel),this._button.element);<span class="cstat-no" title="statement not covered" ></span>if(!model)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst index=<span class="cstat-no" title="statement not covered" >this._recordings.indexOf(model);<span class="cstat-no" title="statement not covered" ></span>if(index&lt;0){<span class="cstat-no" title="statement not covered" >console.assert(false,`selected recording not found`);<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span></span>
<span class="cstat-no" title="statement not covered" >this._setCurrentModel(model);<span class="cstat-no" title="statement not covered" >r</span>eturn model;}</span>
<span class="fstat-no" title="function not covered" >ca</span>ncelIfShowing(){<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager.DropDown.cancelIfShowing();}</span>
<span class="fstat-no" title="function not covered" >na</span>vigate(direction){<span class="cstat-no" title="statement not covered" >if(!this._enabled||!this._lastActiveModel)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst index=<span class="cstat-no" title="statement not covered" >this._recordings.indexOf(this._lastActiveModel);<span class="cstat-no" title="statement not covered" ></span>if(index&lt;0)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst newIndex=<span class="cstat-no" title="statement not covered" >Number.constrain(index+direction,0,this._recordings.length-1);</span>const model=<span class="cstat-no" title="statement not covered" >this._recordings[newIndex];<span class="cstat-no" title="statement not covered" ></span>this._setCurrentModel(model);<span class="cstat-no" title="statement not covered" >r</span>eturn model;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etCurrentModel(model){<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager._dataForModel(model).lastUsed=Date.now();<span class="cstat-no" title="statement not covered" >t</span>his._lastActiveModel=model;<span class="cstat-no" title="statement not covered" >t</span>his._button.setText(this._title(model));}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateState(){<span class="cstat-no" title="statement not covered" >this._action.setEnabled(this._recordings.length&gt;1&amp;&amp;this._enabled);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _previewElement(performanceModel){const data=<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager._dataForModel(performanceModel);</span>const startedAt=<span class="cstat-no" title="statement not covered" >performanceModel.recordStartTime();<span class="cstat-no" title="statement not covered" ></span>data.time.textContent=startedAt?Common.UIString('(%s ago)',Timeline.TimelineHistoryManager._coarseAge(startedAt)):'';<span class="cstat-no" title="statement not covered" >r</span>eturn data.preview;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _coarseAge(time){const seconds=<span class="cstat-no" title="statement not covered" >Math.round((Date.now()-time)/1000);<span class="cstat-no" title="statement not covered" ></span>if(seconds&lt;50)</span>
<span class="cstat-no" title="statement not covered" >return Common.UIString('moments');c</span>onst minutes=<span class="cstat-no" title="statement not covered" >Math.round(seconds/60);<span class="cstat-no" title="statement not covered" ></span>if(minutes&lt;50)</span>
<span class="cstat-no" title="statement not covered" >return Common.UIString('%s m',minutes);c</span>onst hours=<span class="cstat-no" title="statement not covered" >Math.round(minutes/60);<span class="cstat-no" title="statement not covered" ></span>return Common.UIString('%s h',hours);}</span>
<span class="fstat-no" title="function not covered" >_t</span>itle(performanceModel){<span class="cstat-no" title="statement not covered" >return Timeline.TimelineHistoryManager._dataForModel(performanceModel).title;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildPreview(performanceModel){const parsedURL=<span class="cstat-no" title="statement not covered" >performanceModel.timelineModel().pageURL().asParsedURL();</span>const domain=<span class="cstat-no" title="statement not covered" >parsedURL?parsedURL.host:'';</span>const sequenceNumber=<span class="cstat-no" title="statement not covered" >this._nextNumberByDomain.get(domain)||1;</span>const title=<span class="cstat-no" title="statement not covered" >Common.UIString('%s #%d',domain,sequenceNumber);<span class="cstat-no" title="statement not covered" ></span>this._nextNumberByDomain.set(domain,sequenceNumber+1);c</span>onst timeElement=<span class="cstat-no" title="statement not covered" >createElement('span');</span>const preview=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','preview-item vbox');</span>const data=<span class="cstat-no" title="statement not covered" >{preview:preview,title:title,time:timeElement,lastUsed:Date.now()};<span class="cstat-no" title="statement not covered" ></span>performanceModel[Timeline.TimelineHistoryManager._previewDataSymbol]=data;<span class="cstat-no" title="statement not covered" >p</span>review.appendChild(this._buildTextDetails(performanceModel,title,timeElement));c</span>onst screenshotAndOverview=<span class="cstat-no" title="statement not covered" >preview.createChild('div','hbox');<span class="cstat-no" title="statement not covered" ></span>screenshotAndOverview.appendChild(this._buildScreenshotThumbnail(performanceModel));<span class="cstat-no" title="statement not covered" >s</span>creenshotAndOverview.appendChild(this._buildOverview(performanceModel));<span class="cstat-no" title="statement not covered" >r</span>eturn data.preview;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildTextDetails(performanceModel,title,timeElement){const container=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','text-details hbox');<span class="cstat-no" title="statement not covered" ></span>container.createChild('span','name').textContent=title;c</span>onst tracingModel=<span class="cstat-no" title="statement not covered" >performanceModel.tracingModel();</span>const duration=<span class="cstat-no" title="statement not covered" >Number.millisToString(tracingModel.maximumRecordTime()-tracingModel.minimumRecordTime(),false);</span>const timeContainer=<span class="cstat-no" title="statement not covered" >container.createChild('span','time');<span class="cstat-no" title="statement not covered" ></span>timeContainer.appendChild(createTextNode(duration));<span class="cstat-no" title="statement not covered" >t</span>imeContainer.appendChild(timeElement);<span class="cstat-no" title="statement not covered" >r</span>eturn container;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildScreenshotThumbnail(performanceModel){const container=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','screenshot-thumb');</span>const thumbnailAspectRatio=<span class="cstat-no" title="statement not covered" >3/2;<span class="cstat-no" title="statement not covered" ></span>container.style.width=this._totalHeight*thumbnailAspectRatio+'px';<span class="cstat-no" title="statement not covered" >c</span>ontainer.style.height=this._totalHeight+'px';c</span>onst filmStripModel=<span class="cstat-no" title="statement not covered" >performanceModel.filmStripModel();</span>const lastFrame=<span class="cstat-no" title="statement not covered" >filmStripModel.frames().peekLast();<span class="cstat-no" title="statement not covered" ></span>if(!lastFrame)</span>
<span class="cstat-no" title="statement not covered" >return container;<span class="cstat-no" title="statement not covered" >l</span>astFrame.imageDataPromise().then(<span class="fstat-no" title="function not covered" >da</span>ta=&gt;<span class="cstat-no" title="statement not covered" >UI.loadImageFromData(data))</span>.then(<span class="fstat-no" title="function not covered" >im</span>age=&gt;<span class="cstat-no" title="statement not covered" >image&amp;&amp;container.appendChild(image))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn container;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildOverview(performanceModel){const container=<span class="cstat-no" title="statement not covered" >createElement('div');<span class="cstat-no" title="statement not covered" ></span>container.style.width=Timeline.TimelineHistoryManager._previewWidth+'px';<span class="cstat-no" title="statement not covered" >c</span>ontainer.style.height=this._totalHeight+'px';c</span>onst canvas=<span class="cstat-no" title="statement not covered" >container.createChild('canvas');<span class="cstat-no" title="statement not covered" ></span>canvas.width=window.devicePixelRatio*Timeline.TimelineHistoryManager._previewWidth;<span class="cstat-no" title="statement not covered" >c</span>anvas.height=window.devicePixelRatio*this._totalHeight;c</span>onst ctx=<span class="cstat-no" title="statement not covered" >canvas.getContext('2d');</span>let yOffset=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const overview of this._allOverviews){const timelineOverview=<span class="cstat-no" title="statement not covered" >new overview.constructor();<span class="cstat-no" title="statement not covered" ></span>timelineOverview.setCanvasSize(Timeline.TimelineHistoryManager._previewWidth,overview.height);<span class="cstat-no" title="statement not covered" >t</span>imelineOverview.setModel(performanceModel);<span class="cstat-no" title="statement not covered" >t</span>imelineOverview.update();c</span>onst sourceContext=<span class="cstat-no" title="statement not covered" >timelineOverview.context();</span>const imageData=<span class="cstat-no" title="statement not covered" >sourceContext.getImageData(0,0,sourceContext.canvas.width,sourceContext.canvas.height);<span class="cstat-no" title="statement not covered" ></span>ctx.putImageData(imageData,0,yOffset);<span class="cstat-no" title="statement not covered" >y</span>Offset+=overview.height*window.devicePixelRatio;}</span></span>
<span class="cstat-no" title="statement not covered" >return container;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _dataForModel(model){<span class="cstat-no" title="statement not covered" >return model[Timeline.TimelineHistoryManager._previewDataSymbol]||null;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager.PreviewData;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager._maxRecordings=5;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager._previewWidth=450;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager._previewDataSymbol=Symbol('previewData');<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager.DropDown=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(models){<span class="cstat-no" title="statement not covered" >this._glassPane=new UI.GlassPane();<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setSizeBehavior(UI.GlassPane.SizeBehavior.MeasureContent);<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setOutsideClickCallback(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._close(null))</span>;<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setPointerEventsBehavior(UI.GlassPane.PointerEventsBehavior.BlockedByGlassPane);<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setAnchorBehavior(UI.GlassPane.AnchorBehavior.PreferBottom);c</span>onst shadowRoot=<span class="cstat-no" title="statement not covered" >UI.createShadowRootWithCoreStyles(this._glassPane.contentElement,'timeline/timelineHistoryManager.css');</span>const contentElement=<span class="cstat-no" title="statement not covered" >shadowRoot.createChild('div','drop-down');</span>const listModel=<span class="cstat-no" title="statement not covered" >new UI.ListModel();<span class="cstat-no" title="statement not covered" ></span>this._listControl=new UI.ListControl(listModel,this,UI.ListMode.NonViewport);<span class="cstat-no" title="statement not covered" >t</span>his._listControl.element.addEventListener('mousemove',this._onMouseMove.bind(this),false);<span class="cstat-no" title="statement not covered" >l</span>istModel.replaceAll(models);<span class="cstat-no" title="statement not covered" >c</span>ontentElement.appendChild(this._listControl.element);<span class="cstat-no" title="statement not covered" >c</span>ontentElement.addEventListener('keydown',this._onKeyDown.bind(this),false);<span class="cstat-no" title="statement not covered" >c</span>ontentElement.addEventListener('click',this._onClick.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._selectionDone=null;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic show(models,currentModel,anchor){<span class="cstat-no" title="statement not covered" >if(Timeline.TimelineHistoryManager.DropDown._instance)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve((null));c</span>onst instance=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineHistoryManager.DropDown(models);<span class="cstat-no" title="statement not covered" ></span>return instance._show(anchor,currentModel);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic cancelIfShowing(){<span class="cstat-no" title="statement not covered" >if(!Timeline.TimelineHistoryManager.DropDown._instance)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager.DropDown._instance._close(null);}</span>
<span class="fstat-no" title="function not covered" >_s</span>how(anchor,currentModel){<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager.DropDown._instance=this;<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setContentAnchorBox(anchor.boxInWindow());<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.show((this._glassPane.contentElement.ownerDocument));<span class="cstat-no" title="statement not covered" >t</span>his._listControl.element.focus();<span class="cstat-no" title="statement not covered" >t</span>his._listControl.selectItem(currentModel);<span class="cstat-no" title="statement not covered" >r</span>eturn new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfill=&gt;<span class="cstat-no" title="statement not covered" >this._selectionDone=fulfill)</span>;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){const node=<span class="cstat-no" title="statement not covered" >event.target.enclosingNodeOrSelfWithClass('preview-item');</span>const listItem=<span class="cstat-no" title="statement not covered" >node&amp;&amp;this._listControl.itemForNode(node);<span class="cstat-no" title="statement not covered" ></span>if(!listItem)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._listControl.selectItem(listItem);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nClick(event){<span class="cstat-no" title="statement not covered" >if(!event.target.enclosingNodeOrSelfWithClass('preview-item'))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._close(this._listControl.selectedItem());}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyDown(event){<span class="cstat-no" title="statement not covered" >switch(event.key){case'Escape':<span class="cstat-no" title="statement not covered" >this._close(null);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'Enter':<span class="cstat-no" title="statement not covered" >this._close(this._listControl.selectedItem());<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >return;}</span></span>
<span class="cstat-no" title="statement not covered" >event.consume(true);}</span>
<span class="fstat-no" title="function not covered" >_c</span>lose(model){<span class="cstat-no" title="statement not covered" >this._selectionDone(model);<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.hide();<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager.DropDown._instance=null;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateElementForItem(item){const element=<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager._previewElement(item);<span class="cstat-no" title="statement not covered" ></span>element.classList.remove('selected');<span class="cstat-no" title="statement not covered" >r</span>eturn element;}</span>
<span class="fstat-no" title="function not covered" >he</span>ightForItem(item){<span class="cstat-no" title="statement not covered" >console.assert(false,'Should not be called');<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>
<span class="fstat-no" title="function not covered" >is</span>ItemSelectable(item){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >se</span>lectedItemChanged(from,to,fromElement,toElement){<span class="cstat-no" title="statement not covered" >if(fromElement)</span>
<span class="cstat-no" title="statement not covered" >fromElement.classList.remove('selected');<span class="cstat-no" title="statement not covered" >i</span>f(toElement)</span>
<span class="cstat-no" title="statement not covered" >toElement.classList.add('selected');}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineHistoryManager.DropDown._instance=null;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineHistoryManager.ToolbarButton=class extends UI.ToolbarItem{<span class="fstat-no" title="function not covered" >co</span>nstructor(action){<span class="cstat-no" title="statement not covered" >super(createElementWithClass('button','history-dropdown-button'));<span class="cstat-no" title="statement not covered" >U</span>I.appendStyle(this.element,'timeline/historyToolbarButton.css');<span class="cstat-no" title="statement not covered" >t</span>his._contentElement=this.element.createChild('span','content');c</span>onst dropdownArrowIcon=<span class="cstat-no" title="statement not covered" >UI.Icon.create('smallicon-triangle-down');<span class="cstat-no" title="statement not covered" ></span>this.element.appendChild(dropdownArrowIcon);<span class="cstat-no" title="statement not covered" >t</span>his.element.addEventListener('click',<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >void action.execute(),</span>false);<span class="cstat-no" title="statement not covered" >t</span>his.setEnabled(action.enabled());<span class="cstat-no" title="statement not covered" >a</span>ction.addEventListener(UI.Action.Events.Enabled,<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >this.setEnabled((event.data)))</span>;<span class="cstat-no" title="statement not covered" >t</span>his.setTitle(action.title());}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tText(text){<span class="cstat-no" title="statement not covered" >this._contentElement.textContent=text;}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.TimelineTreeView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._model=null;<span class="cstat-no" title="statement not covered" >t</span>his._track=null;<span class="cstat-no" title="statement not covered" >t</span>his._tree=null;<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('timeline-tree-view');}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic eventNameForSorting(event){<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.RecordType.JSFrame){const data=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>return data['functionName']+'@'+(data['scriptId']||data['url']||'');}</span></span>
<span class="cstat-no" title="statement not covered" >return event.name+':@'+TimelineModel.TimelineProfileTree.eventURL(event);}</span>
<span class="fstat-no" title="function not covered" >se</span>tSearchableView(searchableView){<span class="cstat-no" title="statement not covered" >this._searchableView=searchableView;}</span>
<span class="fstat-no" title="function not covered" >se</span>tModel(model,track){<span class="cstat-no" title="statement not covered" >this._model=model;<span class="cstat-no" title="statement not covered" >t</span>his._track=track;<span class="cstat-no" title="statement not covered" >t</span>his.refreshTree();}</span>
<span class="fstat-no" title="function not covered" >mo</span>del(){<span class="cstat-no" title="statement not covered" >return this._model;}</span>
<span class="fstat-no" title="function not covered" >in</span>it(){<span class="cstat-no" title="statement not covered" >this._linkifier=new Components.Linkifier();<span class="cstat-no" title="statement not covered" >t</span>his._textFilter=new Timeline.TimelineFilters.RegExp();<span class="cstat-no" title="statement not covered" >t</span>his._currentThreadSetting=Common.settings.createSetting('timelineTreeCurrentThread',0);<span class="cstat-no" title="statement not covered" >t</span>his._currentThreadSetting.addChangeListener(this.refreshTree,this);c</span>onst columns=(<span class="cstat-no" title="statement not covered" >[])</span>;<span class="cstat-no" title="statement not covered" >this.populateColumns(columns);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget=new UI.SplitWidget(true,true,'timelineTreeViewDetailsSplitWidget');c</span>onst mainView=<span class="cstat-no" title="statement not covered" >new UI.VBox();</span>const toolbar=<span class="cstat-no" title="statement not covered" >new UI.Toolbar('',mainView.element);<span class="cstat-no" title="statement not covered" ></span>this.populateToolbar(toolbar);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid=new DataGrid.SortableDataGrid(columns);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.addEventListener(DataGrid.DataGrid.Events.SortingChanged,this._sortingChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.element.addEventListener('mousemove',this._onMouseMove.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.setResizeMethod(DataGrid.DataGrid.ResizeMethod.Last);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.setRowContextMenuCallback(this._onContextMenu.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.asWidget().show(mainView.element);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._updateDetailsForSelection,this);<span class="cstat-no" title="statement not covered" >t</span>his._detailsView=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._detailsView.element.classList.add('timeline-details-view','timeline-details-view-body');<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.setMainWidget(mainView);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.setSidebarWidget(this._detailsView);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.hideSidebar();<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.show(this.element);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.addEventListener(UI.SplitWidget.Events.ShowModeChanged,this._onShowModeChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._lastSelectedNode;}</span>
<span class="fstat-no" title="function not covered" >la</span>stSelectedNode(){<span class="cstat-no" title="statement not covered" >return this._lastSelectedNode;}</span>
<span class="fstat-no" title="function not covered" >up</span>dateContents(selection){<span class="cstat-no" title="statement not covered" >this.setRange(selection.startTime(),selection.endTime());}</span>
<span class="fstat-no" title="function not covered" >se</span>tRange(startTime,endTime){<span class="cstat-no" title="statement not covered" >this._startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._endTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his.refreshTree();}</span>
<span class="fstat-no" title="function not covered" >fi</span>lters(){<span class="cstat-no" title="statement not covered" >return[this._textFilter,...this._model.filters()];}</span>
<span class="fstat-no" title="function not covered" >_e</span>xposePercentages(){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateToolbar(toolbar){<span class="cstat-no" title="statement not covered" >this._textFilterUI=new UI.ToolbarInput(Common.UIString('Filter'));<span class="cstat-no" title="statement not covered" >t</span>his._textFilterUI.addEventListener(UI.ToolbarInput.Event.TextChanged,textFilterChanged,this);<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(this._textFilterUI);f</span>unction <span class="fstat-no" title="function not covered" >textFilterChanged(</span>){const searchQuery=<span class="cstat-no" title="statement not covered" >this._textFilterUI.value();<span class="cstat-no" title="statement not covered" ></span>this._textFilter.setRegExp(searchQuery?createPlainTextSearchRegex(searchQuery,'i'):null);<span class="cstat-no" title="statement not covered" >t</span>his.refreshTree();}</span>}
<span class="fstat-no" title="function not covered" >_m</span>odelEvents(){<span class="cstat-no" title="statement not covered" >return this._track?this._track.syncEvents():[];}</span>
<span class="fstat-no" title="function not covered" >_o</span>nHover(node){}
<span class="fstat-no" title="function not covered" >_a</span>ppendContextMenuItems(contextMenu,node){}
<span class="fstat-no" title="function not covered" >_l</span>inkifyLocation(event){const target=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().targetByEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(!target)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst frame=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventStackFrame(event);<span class="cstat-no" title="statement not covered" ></span>if(!frame)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this._linkifier.maybeLinkifyConsoleCallFrame(target,frame);}</span>
<span class="fstat-no" title="function not covered" >se</span>lectProfileNode(treeNode,suppressSelectedEvent){const pathToRoot=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let node=treeNode;node;node=node.parent)</span>
<span class="cstat-no" title="statement not covered" >pathToRoot.push(node);<span class="cstat-no" title="statement not covered" >f</span>or(let i=pathToRoot.length-1;i&gt;0;--i){const gridNode=<span class="cstat-no" title="statement not covered" >this.dataGridNodeForTreeNode(pathToRoot[i]);<span class="cstat-no" title="statement not covered" ></span>if(gridNode&amp;&amp;gridNode.dataGrid)</span></span>
<span class="cstat-no" title="statement not covered" >gridNode.expand();}</span>
const gridNode=<span class="cstat-no" title="statement not covered" >this.dataGridNodeForTreeNode(treeNode);<span class="cstat-no" title="statement not covered" ></span>if(gridNode.dataGrid){<span class="cstat-no" title="statement not covered" >gridNode.reveal();<span class="cstat-no" title="statement not covered" >g</span>ridNode.select(suppressSelectedEvent);}</span>}</span>
<span class="fstat-no" title="function not covered" >re</span>freshTree(){<span class="cstat-no" title="statement not covered" >this._linkifier.reset();<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.rootNode().removeChildren();<span class="cstat-no" title="statement not covered" >i</span>f(!this._model){<span class="cstat-no" title="statement not covered" >this._updateDetailsForSelection();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._root=this._buildTree();c</span>onst children=<span class="cstat-no" title="statement not covered" >this._root.children();</span>let maxSelfTime=<span class="cstat-no" title="statement not covered" >0;</span>let maxTotalTime=<span class="cstat-no" title="statement not covered" >0;</span>const totalUsedTime=<span class="cstat-no" title="statement not covered" >this._root.totalTime-this._root.selfTime;<span class="cstat-no" title="statement not covered" ></span>for(const child of children.values()){<span class="cstat-no" title="statement not covered" >maxSelfTime=Math.max(maxSelfTime,child.selfTime);<span class="cstat-no" title="statement not covered" >m</span>axTotalTime=Math.max(maxTotalTime,child.totalTime);}</span></span>
<span class="cstat-no" title="statement not covered" >for(const child of children.values()){const gridNode=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineTreeView.TreeGridNode(child,totalUsedTime,maxSelfTime,maxTotalTime,this);<span class="cstat-no" title="statement not covered" ></span>this._dataGrid.insertChild(gridNode);}</span></span>
<span class="cstat-no" title="statement not covered" >this._sortingChanged();<span class="cstat-no" title="statement not covered" >t</span>his._updateDetailsForSelection();<span class="cstat-no" title="statement not covered" >i</span>f(this._searchableView)</span>
<span class="cstat-no" title="statement not covered" >this._searchableView.refreshSearch();}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildTree(){<span class="cstat-no" title="statement not covered" >throw new Error('Not Implemented');}</span>
<span class="fstat-no" title="function not covered" >bu</span>ildTopDownTree(doNotAggregate,groupIdCallback){<span class="cstat-no" title="statement not covered" >return new TimelineModel.TimelineProfileTree.TopDownRootNode(this._modelEvents(),this.filters(),this._startTime,this._endTime,doNotAggregate,groupIdCallback);}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateColumns(columns){<span class="cstat-no" title="statement not covered" >columns.push({id:'self',title:Common.UIString('Self Time'),width:'120px',fixedWidth:true,sortable:true});<span class="cstat-no" title="statement not covered" >c</span>olumns.push({id:'total',title:Common.UIString('Total Time'),width:'120px',fixedWidth:true,sortable:true});<span class="cstat-no" title="statement not covered" >c</span>olumns.push({id:'activity',title:Common.UIString('Activity'),disclosure:true,sortable:true});}</span>
<span class="fstat-no" title="function not covered" >_s</span>ortingChanged(){const columnId=<span class="cstat-no" title="statement not covered" >this._dataGrid.sortColumnId();<span class="cstat-no" title="statement not covered" ></span>if(!columnId)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et sortFunction;<span class="cstat-no" title="statement not covered" >switch(columnId){case'startTime':<span class="cstat-no" title="statement not covered" >sortFunction=compareStartTime;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'self':<span class="cstat-no" title="statement not covered" >sortFunction=compareNumericField.bind(null,'selfTime');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'total':<span class="cstat-no" title="statement not covered" >sortFunction=compareNumericField.bind(null,'totalTime');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'activity':<span class="cstat-no" title="statement not covered" >sortFunction=compareName;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >console.assert(false,'Unknown sort field: '+columnId);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._dataGrid.sortNodes(sortFunction,!this._dataGrid.isSortOrderAscending());f</span>unction <span class="fstat-no" title="function not covered" >compareNumericField(</span>field,a,b){const nodeA=(<span class="cstat-no" title="statement not covered" >a)</span>;const nodeB=(<span class="cstat-no" title="statement not covered" >b)</span>;<span class="cstat-no" title="statement not covered" >return nodeA._profileNode[field]-nodeB._profileNode[field];}</span>
function <span class="fstat-no" title="function not covered" >compareStartTime(</span>a,b){const nodeA=(<span class="cstat-no" title="statement not covered" >a)</span>;const nodeB=(<span class="cstat-no" title="statement not covered" >b)</span>;<span class="cstat-no" title="statement not covered" >return nodeA._profileNode.event.startTime-nodeB._profileNode.event.startTime;}</span>
function <span class="fstat-no" title="function not covered" >compareName(</span>a,b){const nodeA=(<span class="cstat-no" title="statement not covered" >a)</span>;const nodeB=(<span class="cstat-no" title="statement not covered" >b)</span>;const nameA=<span class="cstat-no" title="statement not covered" >Timeline.TimelineTreeView.eventNameForSorting(nodeA._profileNode.event);</span>const nameB=<span class="cstat-no" title="statement not covered" >Timeline.TimelineTreeView.eventNameForSorting(nodeB._profileNode.event);<span class="cstat-no" title="statement not covered" ></span>return nameA.localeCompare(nameB);}</span>}
<span class="fstat-no" title="function not covered" >_o</span>nShowModeChanged(){<span class="cstat-no" title="statement not covered" >if(this._splitWidget.showMode()===UI.SplitWidget.ShowMode.OnlyMain)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._lastSelectedNode=undefined;<span class="cstat-no" title="statement not covered" >t</span>his._updateDetailsForSelection();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateDetailsForSelection(){const selectedNode=<span class="cstat-no" title="statement not covered" >this._dataGrid.selectedNode?(this._dataGrid.selectedNode)._profileNode:null;<span class="cstat-no" title="statement not covered" ></span>if(selectedNode===this._lastSelectedNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._lastSelectedNode=selectedNode;<span class="cstat-no" title="statement not covered" >i</span>f(this._splitWidget.showMode()===UI.SplitWidget.ShowMode.OnlyMain)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._detailsView.detachChildWidgets();<span class="cstat-no" title="statement not covered" >t</span>his._detailsView.element.removeChildren();<span class="cstat-no" title="statement not covered" >i</span>f(selectedNode&amp;&amp;this._showDetailsForNode(selectedNode))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst banner=<span class="cstat-no" title="statement not covered" >this._detailsView.element.createChild('div','full-widget-dimmed-banner');<span class="cstat-no" title="statement not covered" ></span>banner.createTextChild(Common.UIString('Select item for details.'));}</span>
<span class="fstat-no" title="function not covered" >_s</span>howDetailsForNode(node){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){const gridNode=<span class="cstat-no" title="statement not covered" >event.target&amp;&amp;(event.target instanceof Node)?(this._dataGrid.dataGridNodeFromNode((event.target))):null;</span>const profileNode=<span class="cstat-no" title="statement not covered" >gridNode&amp;&amp;gridNode._profileNode;<span class="cstat-no" title="statement not covered" ></span>if(profileNode===this._lastHoveredProfileNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._lastHoveredProfileNode=profileNode;<span class="cstat-no" title="statement not covered" >t</span>his._onHover(profileNode);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nContextMenu(contextMenu,gridNode){const profileNode=<span class="cstat-no" title="statement not covered" >gridNode._profileNode;<span class="cstat-no" title="statement not covered" ></span>if(!profileNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._appendContextMenuItems(contextMenu,profileNode);}</span>
<span class="fstat-no" title="function not covered" >da</span>taGridNodeForTreeNode(treeNode){<span class="cstat-no" title="statement not covered" >return treeNode[Timeline.TimelineTreeView.TreeGridNode._gridNodeSymbol]||null;}</span>
<span class="fstat-no" title="function not covered" >se</span>archCanceled(){<span class="cstat-no" title="statement not covered" >this._searchResults=[];<span class="cstat-no" title="statement not covered" >t</span>his._currentResult=0;}</span>
<span class="fstat-no" title="function not covered" >pe</span>rformSearch(searchConfig,shouldJump,jumpBackwards){<span class="cstat-no" title="statement not covered" >this._searchResults=[];<span class="cstat-no" title="statement not covered" >t</span>his._currentResult=0;<span class="cstat-no" title="statement not covered" >i</span>f(!this._root)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst searchRegex=<span class="cstat-no" title="statement not covered" >searchConfig.toSearchRegex();<span class="cstat-no" title="statement not covered" ></span>this._searchResults=this._root.searchTree(<span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.testContentMatching(event,searchRegex))</span>;<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.updateSearchMatchesCount(this._searchResults.length);}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToNextSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.selectProfileNode(this._searchResults[this._currentResult],false);<span class="cstat-no" title="statement not covered" >t</span>his._currentResult=mod(this._currentResult+1,this._searchResults.length);}</span>
<span class="fstat-no" title="function not covered" >ju</span>mpToPreviousSearchResult(){<span class="cstat-no" title="statement not covered" >if(!this._searchResults.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.selectProfileNode(this._searchResults[this._currentResult],false);<span class="cstat-no" title="statement not covered" >t</span>his._currentResult=mod(this._currentResult-1,this._searchResults.length);}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsCaseSensitiveSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportsRegexSearch(){<span class="cstat-no" title="statement not covered" >return true;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineTreeView.GridNode=class extends DataGrid.SortableDataGridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileNode,grandTotalTime,maxSelfTime,maxTotalTime,treeView){<span class="cstat-no" title="statement not covered" >super(null,false);<span class="cstat-no" title="statement not covered" >t</span>his._populated=false;<span class="cstat-no" title="statement not covered" >t</span>his._profileNode=profileNode;<span class="cstat-no" title="statement not covered" >t</span>his._treeView=treeView;<span class="cstat-no" title="statement not covered" >t</span>his._grandTotalTime=grandTotalTime;<span class="cstat-no" title="statement not covered" >t</span>his._maxSelfTime=maxSelfTime;<span class="cstat-no" title="statement not covered" >t</span>his._maxTotalTime=maxTotalTime;}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateCell(columnId){<span class="cstat-no" title="statement not covered" >if(columnId==='activity')</span>
<span class="cstat-no" title="statement not covered" >return this._createNameCell(columnId);<span class="cstat-no" title="statement not covered" >r</span>eturn this._createValueCell(columnId)||super.createCell(columnId);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateNameCell(columnId){const cell=<span class="cstat-no" title="statement not covered" >this.createTD(columnId);</span>const container=<span class="cstat-no" title="statement not covered" >cell.createChild('div','name-container');</span>const iconContainer=<span class="cstat-no" title="statement not covered" >container.createChild('div','activity-icon-container');</span>const icon=<span class="cstat-no" title="statement not covered" >iconContainer.createChild('div','activity-icon');</span>const name=<span class="cstat-no" title="statement not covered" >container.createChild('div','activity-name');</span>const event=<span class="cstat-no" title="statement not covered" >this._profileNode.event;<span class="cstat-no" title="statement not covered" ></span>if(this._profileNode.isGroupNode()){const treeView=(<span class="cstat-no" title="statement not covered" >this._treeView)</span>;const info=<span class="cstat-no" title="statement not covered" >treeView._displayInfoForGroupNode(this._profileNode);<span class="cstat-no" title="statement not covered" ></span>name.textContent=info.name;<span class="cstat-no" title="statement not covered" >i</span>con.style.backgroundColor=info.color;<span class="cstat-no" title="statement not covered" >i</span>f(info.icon)</span></span>
<span class="cstat-no" title="statement not covered" >iconContainer.insertBefore(info.icon,icon);}</span>else <span class="cstat-no" title="statement not covered" >if(event){const data=<span class="cstat-no" title="statement not covered" >event.args['data'];</span>const deoptReason=<span class="cstat-no" title="statement not covered" >data&amp;&amp;data['deoptReason'];<span class="cstat-no" title="statement not covered" ></span>if(deoptReason)</span></span>
<span class="cstat-no" title="statement not covered" >container.createChild('div','activity-warning').title=Common.UIString('Not optimized: %s',deoptReason);<span class="cstat-no" title="statement not covered" >n</span>ame.textContent=Timeline.TimelineUIUtils.eventTitle(event);c</span>onst link=<span class="cstat-no" title="statement not covered" >this._treeView._linkifyLocation(event);<span class="cstat-no" title="statement not covered" ></span>if(link)</span>
<span class="cstat-no" title="statement not covered" >container.createChild('div','activity-link').appendChild(link);<span class="cstat-no" title="statement not covered" >i</span>con.style.backgroundColor=Timeline.TimelineUIUtils.eventColor(event);}</span>
<span class="cstat-no" title="statement not covered" >return cell;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateValueCell(columnId){<span class="cstat-no" title="statement not covered" >if(columnId!=='self'&amp;&amp;columnId!=='total'&amp;&amp;columnId!=='startTime')</span>
<span class="cstat-no" title="statement not covered" >return null;l</span>et showPercents=<span class="cstat-no" title="statement not covered" >false;</span>let value;let maxTime;<span class="cstat-no" title="statement not covered" >switch(columnId){case'startTime':<span class="cstat-no" title="statement not covered" >value=this._profileNode.event.startTime-this._treeView._model.timelineModel().minimumRecordTime();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'self':<span class="cstat-no" title="statement not covered" >value=this._profileNode.selfTime;<span class="cstat-no" title="statement not covered" >m</span>axTime=this._maxSelfTime;<span class="cstat-no" title="statement not covered" >s</span>howPercents=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'total':<span class="cstat-no" title="statement not covered" >value=this._profileNode.totalTime;<span class="cstat-no" title="statement not covered" >m</span>axTime=this._maxTotalTime;<span class="cstat-no" title="statement not covered" >s</span>howPercents=true;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span></span>
const cell=<span class="cstat-no" title="statement not covered" >this.createTD(columnId);<span class="cstat-no" title="statement not covered" ></span>cell.className='numeric-column';c</span>onst textDiv=<span class="cstat-no" title="statement not covered" >cell.createChild('div');<span class="cstat-no" title="statement not covered" ></span>textDiv.createChild('span').textContent=Common.UIString('%.1f\xa0ms',value);<span class="cstat-no" title="statement not covered" >i</span>f(showPercents&amp;&amp;this._treeView._exposePercentages()){<span class="cstat-no" title="statement not covered" >textDiv.createChild('span','percent-column').textContent=Common.UIString('%.1f\xa0%%',value/this._grandTotalTime*100);}</span></span>
<span class="cstat-no" title="statement not covered" >if(maxTime){<span class="cstat-no" title="statement not covered" >textDiv.classList.add('background-percent-bar');<span class="cstat-no" title="statement not covered" >c</span>ell.createChild('div','background-bar-container').createChild('div','background-bar').style.width=(value*100/maxTime).toFixed(1)+'%';}</span></span>
<span class="cstat-no" title="statement not covered" >return cell;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineTreeView.TreeGridNode=class extends Timeline.TimelineTreeView.GridNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(profileNode,grandTotalTime,maxSelfTime,maxTotalTime,treeView){<span class="cstat-no" title="statement not covered" >super(profileNode,grandTotalTime,maxSelfTime,maxTotalTime,treeView);<span class="cstat-no" title="statement not covered" >t</span>his.setHasChildren(this._profileNode.hasChildren());<span class="cstat-no" title="statement not covered" >p</span>rofileNode[Timeline.TimelineTreeView.TreeGridNode._gridNodeSymbol]=this;}</span></span>
<span class="fstat-no" title="function not covered" >po</span>pulate(){<span class="cstat-no" title="statement not covered" >if(this._populated)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._populated=true;<span class="cstat-no" title="statement not covered" >i</span>f(!this._profileNode.children)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const node of this._profileNode.children().values()){const gridNode=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineTreeView.TreeGridNode(node,this._grandTotalTime,this._maxSelfTime,this._maxTotalTime,this._treeView);<span class="cstat-no" title="statement not covered" ></span>this.insertChildOrdered(gridNode);}</span>}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineTreeView.TreeGridNode._gridNodeSymbol=Symbol('treeGridNode');<span class="cstat-no" title="statement not covered" >T</span>imeline.AggregatedTimelineTreeView=class extends Timeline.TimelineTreeView{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._groupBySetting=Common.settings.createSetting('timelineTreeGroupBy',Timeline.AggregatedTimelineTreeView.GroupBy.None);<span class="cstat-no" title="statement not covered" >t</span>his._groupBySetting.addChangeListener(this.refreshTree.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his.init();<span class="cstat-no" title="statement not covered" >t</span>his._stackView=new Timeline.TimelineStackView(this);<span class="cstat-no" title="statement not covered" >t</span>his._stackView.addEventListener(Timeline.TimelineStackView.Events.SelectionChanged,this._onStackViewSelectionChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._badgePool=new ProductRegistry.BadgePool(true);<span class="cstat-no" title="statement not covered" >t</span>his._productByURLCache=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._colorByURLCache=new Map();<span class="cstat-no" title="statement not covered" >P</span>roductRegistry.instance().then(<span class="fstat-no" title="function not covered" >re</span>gistry=&gt;{<span class="cstat-no" title="statement not covered" >this._productRegistry=registry;<span class="cstat-no" title="statement not covered" >t</span>his.refreshTree();}</span>);}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tModel(model,track){<span class="cstat-no" title="statement not covered" >this._badgePool.reset();<span class="cstat-no" title="statement not covered" >s</span>uper.setModel(model,track);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateContents(selection){<span class="cstat-no" title="statement not covered" >this._updateExtensionResolver();<span class="cstat-no" title="statement not covered" >s</span>uper.updateContents(selection);c</span>onst rootNode=<span class="cstat-no" title="statement not covered" >this._dataGrid.rootNode();<span class="cstat-no" title="statement not covered" ></span>if(rootNode.children.length)</span>
<span class="cstat-no" title="statement not covered" >rootNode.children[0].revealAndSelect();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateExtensionResolver(){<span class="cstat-no" title="statement not covered" >this._executionContextNamesByOrigin=new Map();<span class="cstat-no" title="statement not covered" >f</span>or(const runtimeModel of SDK.targetManager.models(SDK.RuntimeModel)){<span class="cstat-no" title="statement not covered" >for(const context of runtimeModel.executionContexts())</span></span>
<span class="cstat-no" title="statement not covered" >this._executionContextNamesByOrigin.set(context.origin,context.name);}</span>}
<span class="fstat-no" title="function not covered" >_b</span>eautifyDomainName(name){<span class="cstat-no" title="statement not covered" >if(Timeline.AggregatedTimelineTreeView._isExtensionInternalURL(name))</span>
<span class="cstat-no" title="statement not covered" >name=Common.UIString('[Chrome extensions overhead]');e</span>lse <span class="cstat-no" title="statement not covered" >if(Timeline.AggregatedTimelineTreeView._isV8NativeURL(name))</span>
<span class="cstat-no" title="statement not covered" >name=Common.UIString('[V8 Runtime]');e</span>lse <span class="cstat-no" title="statement not covered" >if(name.startsWith('chrome-extension'))</span>
<span class="cstat-no" title="statement not covered" >name=this._executionContextNamesByOrigin.get(name)||name;<span class="cstat-no" title="statement not covered" >r</span>eturn name;}</span>
<span class="fstat-no" title="function not covered" >_d</span>isplayInfoForGroupNode(node){const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.categories();</span>let color=<span class="cstat-no" title="statement not covered" >node.id?Timeline.TimelineUIUtils.eventColor((node.event)):categories['other'].color;</span>const unattributed=<span class="cstat-no" title="statement not covered" >Common.UIString('[unattributed]');<span class="cstat-no" title="statement not covered" ></span>switch(this._groupBySetting.get()){case Timeline.AggregatedTimelineTreeView.GroupBy.Category:{const category=<span class="cstat-no" title="statement not covered" >categories[node.id]||categories['other'];<span class="cstat-no" title="statement not covered" ></span>return{name:category.title,color:category.color};}</span></span>
case Timeline.AggregatedTimelineTreeView.GroupBy.Domain:case Timeline.AggregatedTimelineTreeView.GroupBy.Subdomain:{let domainName=<span class="cstat-no" title="statement not covered" >this._beautifyDomainName(node.id);<span class="cstat-no" title="statement not covered" ></span>if(domainName){const productName=<span class="cstat-no" title="statement not covered" >this._productByEvent((node.event));<span class="cstat-no" title="statement not covered" ></span>if(productName)</span></span>
<span class="cstat-no" title="statement not covered" >domainName+=' \u2014 '+productName;}</span>
<span class="cstat-no" title="statement not covered" >return{name:domainName||unattributed,color:color};}</span>
case Timeline.AggregatedTimelineTreeView.GroupBy.EventName:{const name=<span class="cstat-no" title="statement not covered" >node.event.name===TimelineModel.TimelineModel.RecordType.JSFrame?Common.UIString('JavaScript'):Timeline.TimelineUIUtils.eventTitle(node.event);<span class="cstat-no" title="statement not covered" ></span>return{name:name,color:node.event.name===TimelineModel.TimelineModel.RecordType.JSFrame?Timeline.TimelineUIUtils.eventStyle(node.event).category.color:color};}</span>
case Timeline.AggregatedTimelineTreeView.GroupBy.Product:{const event=(<span class="cstat-no" title="statement not covered" >node.event)</span>;const info=<span class="cstat-no" title="statement not covered" >this._productAndBadgeByEvent(event);</span>const name=<span class="cstat-no" title="statement not covered" >info&amp;&amp;info.name||unattributed;<span class="cstat-no" title="statement not covered" ></span>color=Timeline.TimelineUIUtils.eventColorByProduct(this._productRegistry,this._model.timelineModel(),this._colorByURLCache,event);<span class="cstat-no" title="statement not covered" >r</span>eturn{name:name,color:color,icon:info&amp;&amp;info.badge||undefined};}</span>
case Timeline.AggregatedTimelineTreeView.GroupBy.URL:<span class="cstat-no" title="statement not covered" >break;c</span>ase Timeline.AggregatedTimelineTreeView.GroupBy.Frame:{const frame=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().pageFrameById(node.id);</span>const frameName=<span class="cstat-no" title="statement not covered" >frame?Timeline.TimelineUIUtils.displayNameForFrame(frame,80):Common.UIString('Page');<span class="cstat-no" title="statement not covered" ></span>return{name:frameName,color:color};}</span>
default:<span class="cstat-no" title="statement not covered" >console.assert(false,'Unexpected grouping type');}</span>
<span class="cstat-no" title="statement not covered" >return{name:node.id||unattributed,color:color};}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateToolbar(toolbar){<span class="cstat-no" title="statement not covered" >super.populateToolbar(toolbar);c</span>onst groupBy=<span class="cstat-no" title="statement not covered" >Timeline.AggregatedTimelineTreeView.GroupBy;</span>const options=<span class="cstat-no" title="statement not covered" >[{label:Common.UIString('No Grouping'),value:groupBy.None},{label:Common.UIString('Group by Activity'),value:groupBy.EventName},{label:Common.UIString('Group by Category'),value:groupBy.Category},{label:Common.UIString('Group by Domain'),value:groupBy.Domain},{label:Common.UIString('Group by Frame'),value:groupBy.Frame},{label:Common.UIString('Group by Product'),value:groupBy.Product},{label:Common.UIString('Group by Subdomain'),value:groupBy.Subdomain},{label:Common.UIString('Group by URL'),value:groupBy.URL},];<span class="cstat-no" title="statement not covered" ></span>toolbar.appendToolbarItem(new UI.ToolbarSettingComboBox(options,this._groupBySetting));<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendSpacer();<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(this._splitWidget.createShowHideSidebarButton(Common.UIString('heaviest stack')));}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildHeaviestStack(treeNode){<span class="cstat-no" title="statement not covered" >console.assert(!!treeNode.parent,'Attempt to build stack for tree root');l</span>et result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let node=treeNode;node&amp;&amp;node.parent;node=node.parent)</span>
<span class="cstat-no" title="statement not covered" >result.push(node);<span class="cstat-no" title="statement not covered" >r</span>esult=result.reverse();<span class="cstat-no" title="statement not covered" >f</span>or(let node=treeNode;node&amp;&amp;node.children()&amp;&amp;node.children().size;){const children=<span class="cstat-no" title="statement not covered" >Array.from(node.children().values());<span class="cstat-no" title="statement not covered" ></span>node=children.reduce(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a.totalTime&gt;b.totalTime?a:b)</span>;<span class="cstat-no" title="statement not covered" >r</span>esult.push(node);}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >_e</span>xposePercentages(){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nStackViewSelectionChanged(){const treeNode=<span class="cstat-no" title="statement not covered" >this._stackView.selectedTreeNode();<span class="cstat-no" title="statement not covered" ></span>if(treeNode)</span>
<span class="cstat-no" title="statement not covered" >this.selectProfileNode(treeNode,true);}</span>
<span class="fstat-no" title="function not covered" >_s</span>howDetailsForNode(node){const stack=<span class="cstat-no" title="statement not covered" >this._buildHeaviestStack(node);<span class="cstat-no" title="statement not covered" ></span>this._stackView.setStack(stack,node);<span class="cstat-no" title="statement not covered" >t</span>his._stackView.show(this._detailsView.element);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_g</span>roupingFunction(groupBy){const GroupBy=<span class="cstat-no" title="statement not covered" >Timeline.AggregatedTimelineTreeView.GroupBy;<span class="cstat-no" title="statement not covered" ></span>switch(groupBy){case GroupBy.None:<span class="cstat-no" title="statement not covered" >return null;c</span>ase GroupBy.EventName:<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(event).title;</span>c</span>ase GroupBy.Category:<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(event).category.name;</span>c</span>ase GroupBy.Subdomain:<span class="cstat-no" title="statement not covered" >return this._domainByEvent.bind(this,false);c</span>ase GroupBy.Domain:<span class="cstat-no" title="statement not covered" >return this._domainByEvent.bind(this,true);c</span>ase GroupBy.Product:<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >this._productByEvent(event)||this._domainByEvent(true,event)||'';</span>c</span>ase GroupBy.URL:<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventURL(event)||'';</span>c</span>ase GroupBy.Frame:<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).frameId;</span>d</span>efault:<span class="cstat-no" title="statement not covered" >console.assert(false,`Unexpected aggregation setting: ${groupBy}`);<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>}</span>
<span class="fstat-no" title="function not covered" >_d</span>omainByEvent(groupSubdomains,event){const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventURL(event);<span class="cstat-no" title="statement not covered" ></span>if(!url)</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(Timeline.AggregatedTimelineTreeView._isExtensionInternalURL(url))</span>
<span class="cstat-no" title="statement not covered" >return Timeline.AggregatedTimelineTreeView._extensionInternalPrefix;<span class="cstat-no" title="statement not covered" >i</span>f(Timeline.AggregatedTimelineTreeView._isV8NativeURL(url))</span>
<span class="cstat-no" title="statement not covered" >return Timeline.AggregatedTimelineTreeView._v8NativePrefix;c</span>onst parsedURL=<span class="cstat-no" title="statement not covered" >url.asParsedURL();<span class="cstat-no" title="statement not covered" ></span>if(!parsedURL)</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(parsedURL.scheme==='chrome-extension')</span>
<span class="cstat-no" title="statement not covered" >return parsedURL.scheme+'://'+parsedURL.host;<span class="cstat-no" title="statement not covered" >i</span>f(!groupSubdomains)</span>
<span class="cstat-no" title="statement not covered" >return parsedURL.host;<span class="cstat-no" title="statement not covered" >i</span>f(/^[.0-9]+$/.test(parsedURL.host))</span>
<span class="cstat-no" title="statement not covered" >return parsedURL.host;c</span>onst domainMatch=<span class="cstat-no" title="statement not covered" >/([^.]*\.)?[^.]*$/.exec(parsedURL.host);<span class="cstat-no" title="statement not covered" ></span>return domainMatch&amp;&amp;domainMatch[0]||'';}</span>
<span class="fstat-no" title="function not covered" >_p</span>roductByEvent(event){const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventURL(event);<span class="cstat-no" title="statement not covered" ></span>if(!url)</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(this._productByURLCache.has(url))</span>
<span class="cstat-no" title="statement not covered" >return this._productByURLCache.get(url);<span class="cstat-no" title="statement not covered" >i</span>f(!this._productRegistry)</span>
<span class="cstat-no" title="statement not covered" >return'';c</span>onst parsedURL=<span class="cstat-no" title="statement not covered" >url.asParsedURL();</span>const name=<span class="cstat-no" title="statement not covered" >parsedURL&amp;&amp;this._productRegistry.nameForUrl(parsedURL)||'';<span class="cstat-no" title="statement not covered" ></span>this._productByURLCache.set(url,name);<span class="cstat-no" title="statement not covered" >r</span>eturn name;}</span>
<span class="fstat-no" title="function not covered" >_p</span>roductAndBadgeByEvent(event){const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineProfileTree.eventURL(event);<span class="cstat-no" title="statement not covered" ></span>if(!url||!this._productRegistry)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst parsedURL=<span class="cstat-no" title="statement not covered" >url.asParsedURL();</span>const name=<span class="cstat-no" title="statement not covered" >parsedURL&amp;&amp;this._productRegistry.nameForUrl(parsedURL)||this._domainByEvent(true,event);<span class="cstat-no" title="statement not covered" ></span>if(!name)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst icon=<span class="cstat-no" title="statement not covered" >parsedURL&amp;&amp;this._badgePool.badgeForURL(parsedURL);<span class="cstat-no" title="statement not covered" ></span>return{name:this._beautifyDomainName(name),badge:icon};}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendContextMenuItems(contextMenu,node){<span class="cstat-no" title="statement not covered" >if(this._groupBySetting.get()!==Timeline.AggregatedTimelineTreeView.GroupBy.Frame)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!node.isGroupNode())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst frame=<span class="cstat-no" title="statement not covered" >this._model.timelineModel().pageFrameById(node.id);<span class="cstat-no" title="statement not covered" ></span>if(!frame||!frame.ownerNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>ontextMenu.appendApplicableItems(frame.ownerNode);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _isExtensionInternalURL(url){<span class="cstat-no" title="statement not covered" >return url.startsWith(Timeline.AggregatedTimelineTreeView._extensionInternalPrefix);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _isV8NativeURL(url){<span class="cstat-no" title="statement not covered" >return url.startsWith(Timeline.AggregatedTimelineTreeView._v8NativePrefix);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.AggregatedTimelineTreeView._extensionInternalPrefix='extensions::';<span class="cstat-no" title="statement not covered" >T</span>imeline.AggregatedTimelineTreeView._v8NativePrefix='native ';<span class="cstat-no" title="statement not covered" >T</span>imeline.AggregatedTimelineTreeView.GroupBy={None:'None',EventName:'EventName',Category:'Category',Domain:'Domain',Subdomain:'Subdomain',Product:'Product',URL:'URL',Frame:'Frame'};<span class="cstat-no" title="statement not covered" >T</span>imeline.CallTreeTimelineTreeView=class extends Timeline.AggregatedTimelineTreeView{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.markColumnAsSortedBy('total',DataGrid.DataGrid.Order.Descending);}</span></span>
<span class="fstat-no" title="function not covered" >_b</span>uildTree(){const grouping=<span class="cstat-no" title="statement not covered" >this._groupBySetting.get();<span class="cstat-no" title="statement not covered" ></span>return this.buildTopDownTree(false,this._groupingFunction(grouping));}</span>};<span class="cstat-no" title="statement not covered" >Timeline.BottomUpTimelineTreeView=class extends Timeline.AggregatedTimelineTreeView{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.markColumnAsSortedBy('self',DataGrid.DataGrid.Order.Descending);}</span></span>
<span class="fstat-no" title="function not covered" >_b</span>uildTree(){<span class="cstat-no" title="statement not covered" >return new TimelineModel.TimelineProfileTree.BottomUpRootNode(this._modelEvents(),this.filters(),this._startTime,this._endTime,this._groupingFunction(this._groupBySetting.get()));}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineStackView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(treeView){<span class="cstat-no" title="statement not covered" >super();c</span>onst header=<span class="cstat-no" title="statement not covered" >this.element.createChild('div','timeline-stack-view-header');<span class="cstat-no" title="statement not covered" ></span>header.textContent=Common.UIString('Heaviest stack');<span class="cstat-no" title="statement not covered" >t</span>his._treeView=treeView;c</span>onst columns=(<span class="cstat-no" title="statement not covered" >[{id:'total',title:Common.UIString('Total Time'),fixedWidth:true,width:'110px'},{id:'activity',title:Common.UIString('Activity')}])</span>;<span class="cstat-no" title="statement not covered" >this._dataGrid=new DataGrid.ViewportDataGrid(columns);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.setResizeMethod(DataGrid.DataGrid.ResizeMethod.Last);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.addEventListener(DataGrid.DataGrid.Events.SelectedNode,this._onSelectionChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.asWidget().show(this.element);}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tStack(stack,selectedNode){const rootNode=<span class="cstat-no" title="statement not covered" >this._dataGrid.rootNode();<span class="cstat-no" title="statement not covered" ></span>rootNode.removeChildren();l</span>et nodeToReveal=<span class="cstat-no" title="statement not covered" >null;</span>const totalTime=<span class="cstat-no" title="statement not covered" >Math.max.apply(Math,stack.map(<span class="fstat-no" title="function not covered" >no</span>de=&gt;<span class="cstat-no" title="statement not covered" >node.totalTime)</span>);<span class="cstat-no" title="statement not covered" ></span>for(const node of stack){const gridNode=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineTreeView.GridNode(node,totalTime,totalTime,totalTime,this._treeView);<span class="cstat-no" title="statement not covered" ></span>rootNode.appendChild(gridNode);<span class="cstat-no" title="statement not covered" >i</span>f(node===selectedNode)</span></span>
<span class="cstat-no" title="statement not covered" >nodeToReveal=gridNode;}</span>
<span class="cstat-no" title="statement not covered" >nodeToReveal.revealAndSelect();}</span>
<span class="fstat-no" title="function not covered" >se</span>lectedTreeNode(){const selectedNode=<span class="cstat-no" title="statement not covered" >this._dataGrid.selectedNode;<span class="cstat-no" title="statement not covered" ></span>return selectedNode&amp;&amp;(selectedNode)._profileNode;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nSelectionChanged(){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Timeline.TimelineStackView.Events.SelectionChanged);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineStackView.Events={SelectionChanged:Symbol('SelectionChanged')};;<span class="cstat-no" title="statement not covered" ></span>Timeline.EventsTimelineTreeView=class extends Timeline.TimelineTreeView{<span class="fstat-no" title="function not covered" >co</span>nstructor(delegate){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._filtersControl=new Timeline.EventsTimelineTreeView.Filters();<span class="cstat-no" title="statement not covered" >t</span>his._filtersControl.addEventListener(Timeline.EventsTimelineTreeView.Filters.Events.FilterChanged,this._onFilterChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his.init();<span class="cstat-no" title="statement not covered" >t</span>his._delegate=delegate;<span class="cstat-no" title="statement not covered" >t</span>his._badgePool=new ProductRegistry.BadgePool(true);<span class="cstat-no" title="statement not covered" >t</span>his._dataGrid.markColumnAsSortedBy('startTime',DataGrid.DataGrid.Order.Ascending);<span class="cstat-no" title="statement not covered" >t</span>his._splitWidget.showBoth();}</span></span>
<span class="fstat-no" title="function not covered" >fi</span>lters(){<span class="cstat-no" title="statement not covered" >return[...super.filters(),...this._filtersControl.filters()];}</span>
<span class="fstat-no" title="function not covered" >up</span>dateContents(selection){<span class="cstat-no" title="statement not covered" >this._badgePool.reset();<span class="cstat-no" title="statement not covered" >s</span>uper.updateContents(selection);<span class="cstat-no" title="statement not covered" >i</span>f(selection.type()===Timeline.TimelineSelection.Type.TraceEvent){const event=(<span class="cstat-no" title="statement not covered" >selection.object())</span>;<span class="cstat-no" title="statement not covered" >this._selectEvent(event,true);}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildTree(){<span class="cstat-no" title="statement not covered" >this._currentTree=this.buildTopDownTree(true,null);<span class="cstat-no" title="statement not covered" >r</span>eturn this._currentTree;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nFilterChanged(){const selectedEvent=<span class="cstat-no" title="statement not covered" >this.lastSelectedNode()&amp;&amp;this.lastSelectedNode().event;<span class="cstat-no" title="statement not covered" ></span>this.refreshTree();<span class="cstat-no" title="statement not covered" >i</span>f(selectedEvent)</span>
<span class="cstat-no" title="statement not covered" >this._selectEvent(selectedEvent,false);}</span>
<span class="fstat-no" title="function not covered" >_f</span>indNodeWithEvent(event){const iterators=<span class="cstat-no" title="statement not covered" >[this._currentTree.children().values()];<span class="cstat-no" title="statement not covered" ></span>while(iterators.length){const iterator=<span class="cstat-no" title="statement not covered" >iterators.peekLast().next();<span class="cstat-no" title="statement not covered" ></span>if(iterator.done){<span class="cstat-no" title="statement not covered" >iterators.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
const child=(<span class="cstat-no" title="statement not covered" >iterator.value)</span>;<span class="cstat-no" title="statement not covered" >if(child.event===event)</span>
<span class="cstat-no" title="statement not covered" >return child;<span class="cstat-no" title="statement not covered" >i</span>terators.push(child.children().values());}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >_s</span>electEvent(event,expand){const node=<span class="cstat-no" title="statement not covered" >this._findNodeWithEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(!node)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.selectProfileNode(node,false);<span class="cstat-no" title="statement not covered" >i</span>f(expand)</span>
<span class="cstat-no" title="statement not covered" >this.dataGridNodeForTreeNode(node).expand();}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateColumns(columns){<span class="cstat-no" title="statement not covered" >columns.push({id:'startTime',title:Common.UIString('Start Time'),width:'80px',fixedWidth:true,sortable:true});<span class="cstat-no" title="statement not covered" >s</span>uper.populateColumns(columns);<span class="cstat-no" title="statement not covered" >c</span>olumns.filter(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >c.fixedWidth)</span>.forEach(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >c.width='80px')</span>;}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateToolbar(toolbar){<span class="cstat-no" title="statement not covered" >super.populateToolbar(toolbar);<span class="cstat-no" title="statement not covered" >t</span>his._filtersControl.populateToolbar(toolbar);}</span>
<span class="fstat-no" title="function not covered" >_s</span>howDetailsForNode(node){const traceEvent=<span class="cstat-no" title="statement not covered" >node.event;<span class="cstat-no" title="statement not covered" ></span>if(!traceEvent)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils.buildTraceEventDetails(traceEvent,this.model().timelineModel(),this._linkifier,this._badgePool,false).then(<span class="fstat-no" title="function not covered" >fr</span>agment=&gt;<span class="cstat-no" title="statement not covered" >this._detailsView.element.appendChild(fragment))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nHover(node){<span class="cstat-no" title="statement not covered" >this._delegate.highlightEvent(node&amp;&amp;node.event);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.EventsTimelineTreeView.Filters=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._categoryFilter=new Timeline.TimelineFilters.Category();<span class="cstat-no" title="statement not covered" >t</span>his._durationFilter=new Timeline.TimelineFilters.IsLong();<span class="cstat-no" title="statement not covered" >t</span>his._filters=[this._categoryFilter,this._durationFilter];}</span></span>
<span class="fstat-no" title="function not covered" >fi</span>lters(){<span class="cstat-no" title="statement not covered" >return this._filters;}</span>
<span class="fstat-no" title="function not covered" >po</span>pulateToolbar(toolbar){const durationFilterUI=<span class="cstat-no" title="statement not covered" >new UI.ToolbarComboBox(durationFilterChanged.bind(this));<span class="cstat-no" title="statement not covered" ></span>for(const durationMs of Timeline.EventsTimelineTreeView.Filters._durationFilterPresetsMs){<span class="cstat-no" title="statement not covered" >durationFilterUI.addOption(durationFilterUI.createOption(durationMs?Common.UIString('\u2265 %d\xa0ms',durationMs):Common.UIString('All'),durationMs?Common.UIString('Hide records shorter than %d\xa0ms',durationMs):Common.UIString('Show all records'),String(durationMs)));}</span></span>
<span class="cstat-no" title="statement not covered" >toolbar.appendToolbarItem(durationFilterUI);c</span>onst categoryFiltersUI=<span class="cstat-no" title="statement not covered" >{};</span>const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.categories();<span class="cstat-no" title="statement not covered" ></span>for(const categoryName in categories){const category=<span class="cstat-no" title="statement not covered" >categories[categoryName];<span class="cstat-no" title="statement not covered" ></span>if(!category.visible)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst checkbox=<span class="cstat-no" title="statement not covered" >new UI.ToolbarCheckbox(category.title,undefined,categoriesFilterChanged.bind(this,categoryName));<span class="cstat-no" title="statement not covered" ></span>checkbox.setChecked(true);<span class="cstat-no" title="statement not covered" >c</span>heckbox.inputElement.style.backgroundColor=category.color;<span class="cstat-no" title="statement not covered" >c</span>ategoryFiltersUI[category.name]=checkbox;<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(checkbox);}</span>
function <span class="fstat-no" title="function not covered" >durationFilterChanged(</span>){const duration=<span class="cstat-no" title="statement not covered" >durationFilterUI.selectedOption().value;</span>const minimumRecordDuration=<span class="cstat-no" title="statement not covered" >parseInt(duration,10);<span class="cstat-no" title="statement not covered" ></span>this._durationFilter.setMinimumRecordDuration(minimumRecordDuration);<span class="cstat-no" title="statement not covered" >t</span>his._notifyFiltersChanged();}</span>
function <span class="fstat-no" title="function not covered" >categoriesFilterChanged(</span>name){const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.categories();<span class="cstat-no" title="statement not covered" ></span>categories[name].hidden=!categoryFiltersUI[name].checked();<span class="cstat-no" title="statement not covered" >t</span>his._notifyFiltersChanged();}</span>}
<span class="fstat-no" title="function not covered" >_n</span>otifyFiltersChanged(){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(Timeline.EventsTimelineTreeView.Filters.Events.FilterChanged);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.EventsTimelineTreeView.Filters._durationFilterPresetsMs=[0,1,15];<span class="cstat-no" title="statement not covered" >T</span>imeline.EventsTimelineTreeView.Filters.Events={FilterChanged:Symbol('FilterChanged')};;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineUIUtils=class{<span class="fstat-no" title="function not covered" >st</span>atic _initEventStyles(){<span class="cstat-no" title="statement not covered" >if(Timeline.TimelineUIUtils._eventStylesMap)</span></span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils._eventStylesMap;c</span>onst recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.categories();</span>const eventStyles=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>eventStyles[recordTypes.Task]=new Timeline.TimelineRecordStyle(Common.UIString('Task'),categories['other']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.Program]=new Timeline.TimelineRecordStyle(Common.UIString('Other'),categories['other']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.Animation]=new Timeline.TimelineRecordStyle(Common.UIString('Animation'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.EventDispatch]=new Timeline.TimelineRecordStyle(Common.UIString('Event'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.RequestMainThreadFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Request Main Thread Frame'),categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.BeginFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Frame Start'),categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.BeginMainThreadFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Frame Start (main thread)'),categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.DrawFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Draw Frame'),categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.HitTest]=new Timeline.TimelineRecordStyle(Common.UIString('Hit Test'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ScheduleStyleRecalculation]=new Timeline.TimelineRecordStyle(Common.UIString('Schedule Style Recalculation'),categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.RecalculateStyles]=new Timeline.TimelineRecordStyle(Common.UIString('Recalculate Style'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.UpdateLayoutTree]=new Timeline.TimelineRecordStyle(Common.UIString('Recalculate Style'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.InvalidateLayout]=new Timeline.TimelineRecordStyle(Common.UIString('Invalidate Layout'),categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.Layout]=new Timeline.TimelineRecordStyle(Common.UIString('Layout'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.PaintSetup]=new Timeline.TimelineRecordStyle(Common.UIString('Paint Setup'),categories['painting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.PaintImage]=new Timeline.TimelineRecordStyle(Common.UIString('Paint Image'),categories['painting'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.UpdateLayer]=new Timeline.TimelineRecordStyle(Common.UIString('Update Layer'),categories['painting'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.UpdateLayerTree]=new Timeline.TimelineRecordStyle(Common.UIString('Update Layer Tree'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.Paint]=new Timeline.TimelineRecordStyle(Common.UIString('Paint'),categories['painting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.RasterTask]=new Timeline.TimelineRecordStyle(Common.UIString('Rasterize Paint'),categories['painting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ScrollLayer]=new Timeline.TimelineRecordStyle(Common.UIString('Scroll'),categories['rendering']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CompositeLayers]=new Timeline.TimelineRecordStyle(Common.UIString('Composite Layers'),categories['painting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ParseHTML]=new Timeline.TimelineRecordStyle(Common.UIString('Parse HTML'),categories['loading']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ParseAuthorStyleSheet]=new Timeline.TimelineRecordStyle(Common.UIString('Parse Stylesheet'),categories['loading']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.TimerInstall]=new Timeline.TimelineRecordStyle(Common.UIString('Install Timer'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.TimerRemove]=new Timeline.TimelineRecordStyle(Common.UIString('Remove Timer'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.TimerFire]=new Timeline.TimelineRecordStyle(Common.UIString('Timer Fired'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.XHRReadyStateChange]=new Timeline.TimelineRecordStyle(Common.UIString('XHR Ready State Change'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.XHRLoad]=new Timeline.TimelineRecordStyle(Common.UIString('XHR Load'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CompileScript]=new Timeline.TimelineRecordStyle(Common.UIString('Compile Script'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.EvaluateScript]=new Timeline.TimelineRecordStyle(Common.UIString('Evaluate Script'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CompileModule]=new Timeline.TimelineRecordStyle(Common.UIString('Compile Module'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.EvaluateModule]=new Timeline.TimelineRecordStyle(Common.UIString('Evaluate Module'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ParseScriptOnBackground]=new Timeline.TimelineRecordStyle(Common.UIString('Parse Script'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.FrameStartedLoading]=new Timeline.TimelineRecordStyle(ls`Frame Started Loading`,categories['loading'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MarkLoad]=new Timeline.TimelineRecordStyle(ls`Onload Event`,categories['scripting'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MarkDOMContent]=new Timeline.TimelineRecordStyle(ls`DOMContentLoaded Event`,categories['scripting'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MarkFirstPaint]=new Timeline.TimelineRecordStyle(ls`First Paint`,categories['painting'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MarkFCP]=new Timeline.TimelineRecordStyle(ls`First Contentful Paint`,categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MarkFMP]=new Timeline.TimelineRecordStyle(ls`First Meaningful Paint`,categories['rendering'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.TimeStamp]=new Timeline.TimelineRecordStyle(Common.UIString('Timestamp'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ConsoleTime]=new Timeline.TimelineRecordStyle(Common.UIString('Console Time'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.UserTiming]=new Timeline.TimelineRecordStyle(Common.UIString('User Timing'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ResourceSendRequest]=new Timeline.TimelineRecordStyle(Common.UIString('Send Request'),categories['loading']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ResourceReceiveResponse]=new Timeline.TimelineRecordStyle(Common.UIString('Receive Response'),categories['loading']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ResourceFinish]=new Timeline.TimelineRecordStyle(Common.UIString('Finish Loading'),categories['loading']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ResourceReceivedData]=new Timeline.TimelineRecordStyle(Common.UIString('Receive Data'),categories['loading']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.RunMicrotasks]=new Timeline.TimelineRecordStyle(Common.UIString('Run Microtasks'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.FunctionCall]=new Timeline.TimelineRecordStyle(Common.UIString('Function Call'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.GCEvent]=new Timeline.TimelineRecordStyle(Common.UIString('GC Event'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MajorGC]=new Timeline.TimelineRecordStyle(Common.UIString('Major GC'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.MinorGC]=new Timeline.TimelineRecordStyle(Common.UIString('Minor GC'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.JSFrame]=new Timeline.TimelineRecordStyle(Common.UIString('JS Frame'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.RequestAnimationFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Request Animation Frame'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CancelAnimationFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Cancel Animation Frame'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.FireAnimationFrame]=new Timeline.TimelineRecordStyle(Common.UIString('Animation Frame Fired'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.RequestIdleCallback]=new Timeline.TimelineRecordStyle(Common.UIString('Request Idle Callback'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CancelIdleCallback]=new Timeline.TimelineRecordStyle(Common.UIString('Cancel Idle Callback'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.FireIdleCallback]=new Timeline.TimelineRecordStyle(Common.UIString('Fire Idle Callback'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.WebSocketCreate]=new Timeline.TimelineRecordStyle(Common.UIString('Create WebSocket'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.WebSocketSendHandshakeRequest]=new Timeline.TimelineRecordStyle(Common.UIString('Send WebSocket Handshake'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.WebSocketReceiveHandshakeResponse]=new Timeline.TimelineRecordStyle(Common.UIString('Receive WebSocket Handshake'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.WebSocketDestroy]=new Timeline.TimelineRecordStyle(Common.UIString('Destroy WebSocket'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.EmbedderCallback]=new Timeline.TimelineRecordStyle(Common.UIString('Embedder Callback'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.DecodeImage]=new Timeline.TimelineRecordStyle(Common.UIString('Image Decode'),categories['painting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.ResizeImage]=new Timeline.TimelineRecordStyle(Common.UIString('Image Resize'),categories['painting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.GPUTask]=new Timeline.TimelineRecordStyle(Common.UIString('GPU'),categories['gpu']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.LatencyInfo]=new Timeline.TimelineRecordStyle(Common.UIString('Input Latency'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.GCCollectGarbage]=new Timeline.TimelineRecordStyle(Common.UIString('DOM GC'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoEncrypt]=new Timeline.TimelineRecordStyle(Common.UIString('Encrypt'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoEncryptReply]=new Timeline.TimelineRecordStyle(Common.UIString('Encrypt Reply'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoDecrypt]=new Timeline.TimelineRecordStyle(Common.UIString('Decrypt'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoDecryptReply]=new Timeline.TimelineRecordStyle(Common.UIString('Decrypt Reply'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoDigest]=new Timeline.TimelineRecordStyle(Common.UIString('Digest'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoDigestReply]=new Timeline.TimelineRecordStyle(Common.UIString('Digest Reply'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoSign]=new Timeline.TimelineRecordStyle(Common.UIString('Sign'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoSignReply]=new Timeline.TimelineRecordStyle(Common.UIString('Sign Reply'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoVerify]=new Timeline.TimelineRecordStyle(Common.UIString('Verify'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.CryptoDoVerifyReply]=new Timeline.TimelineRecordStyle(Common.UIString('Verify Reply'),categories['scripting']);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[recordTypes.AsyncTask]=new Timeline.TimelineRecordStyle(Common.UIString('Async Task'),categories['async']);<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils._eventStylesMap=eventStyles;<span class="cstat-no" title="statement not covered" >r</span>eturn eventStyles;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic inputEventDisplayName(inputEventType){<span class="cstat-no" title="statement not covered" >if(!Timeline.TimelineUIUtils._inputEventToDisplayName){const inputEvent=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineIRModel.InputEvents;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineUIUtils._inputEventToDisplayName=new Map([[inputEvent.Char,Common.UIString('Key Character')],[inputEvent.KeyDown,Common.UIString('Key Down')],[inputEvent.KeyDownRaw,Common.UIString('Key Down')],[inputEvent.KeyUp,Common.UIString('Key Up')],[inputEvent.Click,Common.UIString('Click')],[inputEvent.ContextMenu,Common.UIString('Context Menu')],[inputEvent.MouseDown,Common.UIString('Mouse Down')],[inputEvent.MouseMove,Common.UIString('Mouse Move')],[inputEvent.MouseUp,Common.UIString('Mouse Up')],[inputEvent.MouseWheel,Common.UIString('Mouse Wheel')],[inputEvent.ScrollBegin,Common.UIString('Scroll Begin')],[inputEvent.ScrollEnd,Common.UIString('Scroll End')],[inputEvent.ScrollUpdate,Common.UIString('Scroll Update')],[inputEvent.FlingStart,Common.UIString('Fling Start')],[inputEvent.FlingCancel,Common.UIString('Fling Halt')],[inputEvent.Tap,Common.UIString('Tap')],[inputEvent.TapCancel,Common.UIString('Tap Halt')],[inputEvent.ShowPress,Common.UIString('Tap Begin')],[inputEvent.TapDown,Common.UIString('Tap Down')],[inputEvent.TouchCancel,Common.UIString('Touch Cancel')],[inputEvent.TouchEnd,Common.UIString('Touch End')],[inputEvent.TouchMove,Common.UIString('Touch Move')],[inputEvent.TouchStart,Common.UIString('Touch Start')],[inputEvent.PinchBegin,Common.UIString('Pinch Begin')],[inputEvent.PinchEnd,Common.UIString('Pinch End')],[inputEvent.PinchUpdate,Common.UIString('Pinch Update')]]);}</span></span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils._inputEventToDisplayName.get(inputEventType)||null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic frameDisplayName(frame){<span class="cstat-no" title="statement not covered" >if(!TimelineModel.TimelineJSProfileProcessor.isNativeRuntimeFrame(frame))</span>
<span class="cstat-no" title="statement not covered" >return UI.beautifyFunctionName(frame.functionName);c</span>onst nativeGroup=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineJSProfileProcessor.nativeGroup(frame.functionName);</span>const groups=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineJSProfileProcessor.NativeGroups;<span class="cstat-no" title="statement not covered" ></span>switch(nativeGroup){case groups.Compile:<span class="cstat-no" title="statement not covered" >return Common.UIString('Compile');c</span>ase groups.Parse:<span class="cstat-no" title="statement not covered" >return Common.UIString('Parse');}</span></span>
<span class="cstat-no" title="statement not covered" >return frame.functionName;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic testContentMatching(traceEvent,regExp){const title=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(traceEvent).title;</span>const tokens=<span class="cstat-no" title="statement not covered" >[title];</span>const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(traceEvent).url;<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >tokens.push(url);<span class="cstat-no" title="statement not covered" >a</span>ppendObjectProperties(traceEvent.args,2);<span class="cstat-no" title="statement not covered" >r</span>eturn regExp.test(tokens.join('|'));f</span>unction <span class="fstat-no" title="function not covered" >appendObjectProperties(</span>object,depth){<span class="cstat-no" title="statement not covered" >if(!depth)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const key in object){const value=<span class="cstat-no" title="statement not covered" >object[key];</span>const type=<span class="cstat-no" title="statement not covered" >typeof value;<span class="cstat-no" title="statement not covered" ></span>if(type==='string')</span></span>
<span class="cstat-no" title="statement not covered" >tokens.push(value);e</span>lse <span class="cstat-no" title="statement not covered" >if(type==='number')</span>
<span class="cstat-no" title="statement not covered" >tokens.push(String(value));e</span>lse <span class="cstat-no" title="statement not covered" >if(type==='object')</span>
<span class="cstat-no" title="statement not covered" >appendObjectProperties(value,depth-1);}</span>}}
<span class="fstat-no" title="function not covered" >st</span>atic eventURL(event){const data=<span class="cstat-no" title="statement not covered" >event.args['data']||event.args['beginData'];</span>const url=<span class="cstat-no" title="statement not covered" >data&amp;&amp;data.url;<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >return url;c</span>onst stackTrace=<span class="cstat-no" title="statement not covered" >data&amp;&amp;data['stackTrace'];</span>const frame=<span class="cstat-no" title="statement not covered" >stackTrace&amp;&amp;stackTrace.length&amp;&amp;stackTrace[0]||TimelineModel.TimelineData.forEvent(event).topFrame();<span class="cstat-no" title="statement not covered" ></span>return frame&amp;&amp;frame.url||null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventStyle(event){const eventStyles=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._initEventStyles();<span class="cstat-no" title="statement not covered" ></span>if(event.hasCategory(TimelineModel.TimelineModel.Category.Console)||event.hasCategory(TimelineModel.TimelineModel.Category.UserTiming))</span>
<span class="cstat-no" title="statement not covered" >return{title:event.name,category:Timeline.TimelineUIUtils.categories()['scripting']};<span class="cstat-no" title="statement not covered" >i</span>f(event.hasCategory(TimelineModel.TimelineModel.Category.LatencyInfo)){const prefix=<span class="cstat-no" title="statement not covered" >'InputLatency::';</span>const inputEventType=<span class="cstat-no" title="statement not covered" >event.name.startsWith(prefix)?event.name.substr(prefix.length):event.name;</span>const displayName=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.inputEventDisplayName((inputEventType));<span class="cstat-no" title="statement not covered" ></span>return{title:displayName||inputEventType,category:Timeline.TimelineUIUtils.categories()['scripting']};}</span></span>
let result=<span class="cstat-no" title="statement not covered" >eventStyles[event.name];<span class="cstat-no" title="statement not covered" ></span>if(!result){<span class="cstat-no" title="statement not covered" >result=new Timeline.TimelineRecordStyle(event.name,Timeline.TimelineUIUtils.categories()['other'],true);<span class="cstat-no" title="statement not covered" >e</span>ventStyles[event.name]=result;}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventColor(event){<span class="cstat-no" title="statement not covered" >if(event.name===TimelineModel.TimelineModel.RecordType.JSFrame){const frame=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>if(Timeline.TimelineUIUtils.isUserFrame(frame))</span></span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.colorForId(frame.url);}</span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.eventStyle(event).category.color;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventColorByProduct(productRegistry,model,urlToColorCache,event){const url=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventURL(event)||'';</span>let color=<span class="cstat-no" title="statement not covered" >urlToColorCache.get(url);<span class="cstat-no" title="statement not covered" ></span>if(color)</span>
<span class="cstat-no" title="statement not covered" >return color;c</span>onst defaultColor=<span class="cstat-no" title="statement not covered" >'#f2ecdc';</span>const parsedURL=<span class="cstat-no" title="statement not covered" >url.asParsedURL();<span class="cstat-no" title="statement not covered" ></span>if(!parsedURL)</span>
<span class="cstat-no" title="statement not covered" >return defaultColor;l</span>et name=<span class="cstat-no" title="statement not covered" >productRegistry&amp;&amp;productRegistry.nameForUrl(parsedURL);<span class="cstat-no" title="statement not covered" ></span>if(!name){<span class="cstat-no" title="statement not covered" >name=parsedURL.host;c</span>onst rootFrames=<span class="cstat-no" title="statement not covered" >model.rootFrames();<span class="cstat-no" title="statement not covered" ></span>if(rootFrames.some(<span class="fstat-no" title="function not covered" >pa</span>geFrame=&gt;<span class="cstat-no" title="statement not covered" >new Common.ParsedURL(pageFrame.url).host===name)</span>)</span></span>
<span class="cstat-no" title="statement not covered" >color=defaultColor;}</span>
<span class="cstat-no" title="statement not covered" >if(!color)</span>
<span class="cstat-no" title="statement not covered" >color=name?ProductRegistry.BadgePool.colorForEntryName(name):defaultColor;<span class="cstat-no" title="statement not covered" >u</span>rlToColorCache.set(url,color);<span class="cstat-no" title="statement not covered" >r</span>eturn color;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventTitle(event){const recordType=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>if(event.name===recordType.JSFrame)</span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.frameDisplayName(eventData);c</span>onst title=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(event).title;<span class="cstat-no" title="statement not covered" ></span>if(event.hasCategory(TimelineModel.TimelineModel.Category.Console))</span>
<span class="cstat-no" title="statement not covered" >return title;<span class="cstat-no" title="statement not covered" >i</span>f(event.name===recordType.TimeStamp)</span>
<span class="cstat-no" title="statement not covered" >return Common.UIString('%s: %s',title,eventData['message']);<span class="cstat-no" title="statement not covered" >i</span>f(event.name===recordType.Animation&amp;&amp;eventData&amp;&amp;eventData['name'])</span>
<span class="cstat-no" title="statement not covered" >return Common.UIString('%s: %s',title,eventData['name']);<span class="cstat-no" title="statement not covered" >r</span>eturn title;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _interactionPhaseStyles(){let map=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._interactionPhaseStylesMap;<span class="cstat-no" title="statement not covered" ></span>if(!map){<span class="cstat-no" title="statement not covered" >map=new Map([[TimelineModel.TimelineIRModel.Phases.Idle,{color:'white',label:'Idle'}],[TimelineModel.TimelineIRModel.Phases.Response,{color:'hsl(43, 83%, 64%)',label:Common.UIString('Response')}],[TimelineModel.TimelineIRModel.Phases.Scroll,{color:'hsl(256, 67%, 70%)',label:Common.UIString('Scroll')}],[TimelineModel.TimelineIRModel.Phases.Fling,{color:'hsl(256, 67%, 70%)',label:Common.UIString('Fling')}],[TimelineModel.TimelineIRModel.Phases.Drag,{color:'hsl(256, 67%, 70%)',label:Common.UIString('Drag')}],[TimelineModel.TimelineIRModel.Phases.Animation,{color:'hsl(256, 67%, 70%)',label:Common.UIString('Animation')}],[TimelineModel.TimelineIRModel.Phases.Uncategorized,{color:'hsl(0, 0%, 87%)',label:Common.UIString('Uncategorized')}]]);<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils._interactionPhaseStylesMap=map;}</span></span>
<span class="cstat-no" title="statement not covered" >return map;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic interactionPhaseColor(phase){<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils._interactionPhaseStyles().get(phase).color;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic interactionPhaseLabel(phase){<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils._interactionPhaseStyles().get(phase).label;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic isUserFrame(frame){<span class="cstat-no" title="statement not covered" >return frame.scriptId!=='0'&amp;&amp;!(frame.url&amp;&amp;frame.url.startsWith('native '));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic networkRequestCategory(request){const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.NetworkCategory;<span class="cstat-no" title="statement not covered" ></span>switch(request.mimeType){case'text/html':<span class="cstat-no" title="statement not covered" >return categories.HTML;c</span>ase'application/javascript':case'application/x-javascript':case'text/javascript':<span class="cstat-no" title="statement not covered" >return categories.Script;c</span>ase'text/css':<span class="cstat-no" title="statement not covered" >return categories.Style;c</span>ase'audio/ogg':case'image/gif':case'image/jpeg':case'image/png':case'image/svg+xml':case'image/webp':case'image/x-icon':case'font/opentype':case'font/woff2':case'application/font-woff':<span class="cstat-no" title="statement not covered" >return categories.Media;d</span>efault:<span class="cstat-no" title="statement not covered" >return categories.Other;}</span>}</span>
<span class="fstat-no" title="function not covered" >st</span>atic networkCategoryColor(category){const categories=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.NetworkCategory;<span class="cstat-no" title="statement not covered" ></span>switch(category){case categories.HTML:<span class="cstat-no" title="statement not covered" >return'hsl(214, 67%, 66%)';c</span>ase categories.Script:<span class="cstat-no" title="statement not covered" >return'hsl(43, 83%, 64%)';c</span>ase categories.Style:<span class="cstat-no" title="statement not covered" >return'hsl(256, 67%, 70%)';c</span>ase categories.Media:<span class="cstat-no" title="statement not covered" >return'hsl(109, 33%, 55%)';d</span>efault:<span class="cstat-no" title="statement not covered" >return'hsl(0, 0%, 70%)';}</span>}</span>
<span class="fstat-no" title="function not covered" >st</span>atic buildDetailsTextForTraceEvent(event,target){const recordType=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>let detailsText;const eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>switch(event.name){case recordType.GCEvent:case recordType.MajorGC:case recordType.MinorGC:{const delta=<span class="cstat-no" title="statement not covered" >event.args['usedHeapSizeBefore']-event.args['usedHeapSizeAfter'];<span class="cstat-no" title="statement not covered" ></span>detailsText=Common.UIString('%s collected',Number.bytesToString(delta));<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
case recordType.FunctionCall:<span class="cstat-no" title="statement not covered" >if(eventData){<span class="cstat-no" title="statement not covered" >detailsText=linkifyLocationAsText(eventData['scriptId'],eventData['lineNumber'],eventData['columnNumber']);}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase recordType.JSFrame:<span class="cstat-no" title="statement not covered" >detailsText=Timeline.TimelineUIUtils.frameDisplayName(eventData);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.EventDispatch:<span class="cstat-no" title="statement not covered" >detailsText=eventData?eventData['type']:null;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.Paint:{const width=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.quadWidth(eventData.clip);</span>const height=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.quadHeight(eventData.clip);<span class="cstat-no" title="statement not covered" ></span>if(width&amp;&amp;height)</span>
<span class="cstat-no" title="statement not covered" >detailsText=Common.UIString('%d\xa0\u00d7\xa0%d',width,height);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.ParseHTML:{const endLine=<span class="cstat-no" title="statement not covered" >event.args['endData']&amp;&amp;event.args['endData']['endLine'];</span>const url=<span class="cstat-no" title="statement not covered" >Bindings.displayNameForURL(event.args['beginData']['url']);<span class="cstat-no" title="statement not covered" ></span>detailsText=Common.UIString('%s [%s\u2026%s]',url,event.args['beginData']['startLine']+1,endLine&gt;=0?endLine+1:'');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.CompileModule:<span class="cstat-no" title="statement not covered" >detailsText=Bindings.displayNameForURL(event.args['fileName']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.CompileScript:case recordType.EvaluateScript:{const url=<span class="cstat-no" title="statement not covered" >eventData&amp;&amp;eventData['url'];<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >detailsText=Bindings.displayNameForURL(url)+':'+(eventData['lineNumber']+1);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.ParseScriptOnBackground:case recordType.XHRReadyStateChange:case recordType.XHRLoad:{const url=<span class="cstat-no" title="statement not covered" >eventData['url'];<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >detailsText=Bindings.displayNameForURL(url);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.TimeStamp:<span class="cstat-no" title="statement not covered" >detailsText=eventData['message'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.WebSocketCreate:case recordType.WebSocketSendHandshakeRequest:case recordType.WebSocketReceiveHandshakeResponse:case recordType.WebSocketDestroy:case recordType.ResourceSendRequest:case recordType.ResourceReceivedData:case recordType.ResourceReceiveResponse:case recordType.ResourceFinish:case recordType.PaintImage:case recordType.DecodeImage:case recordType.ResizeImage:case recordType.DecodeLazyPixelRef:{const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).url;<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >detailsText=Bindings.displayNameForURL(url);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.EmbedderCallback:<span class="cstat-no" title="statement not covered" >detailsText=eventData['callbackName'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.Animation:<span class="cstat-no" title="statement not covered" >detailsText=eventData&amp;&amp;eventData['name'];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.AsyncTask:<span class="cstat-no" title="statement not covered" >detailsText=eventData?eventData['name']:null;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >if(event.hasCategory(TimelineModel.TimelineModel.Category.Console))</span>
<span class="cstat-no" title="statement not covered" >detailsText=null;e</span>lse
<span class="cstat-no" title="statement not covered" >detailsText=linkifyTopCallFrameAsText();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >return detailsText;f</span>unction <span class="fstat-no" title="function not covered" >linkifyLocationAsText(</span>scriptId,lineNumber,columnNumber){const debuggerModel=<span class="cstat-no" title="statement not covered" >target?target.model(SDK.DebuggerModel):null;<span class="cstat-no" title="statement not covered" ></span>if(!target||target.isDisposed()||!scriptId||!debuggerModel)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst rawLocation=<span class="cstat-no" title="statement not covered" >debuggerModel.createRawLocationByScriptId(scriptId,lineNumber,columnNumber);<span class="cstat-no" title="statement not covered" ></span>if(!rawLocation)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst uiLocation=<span class="cstat-no" title="statement not covered" >Bindings.debuggerWorkspaceBinding.rawLocationToUILocation(rawLocation);<span class="cstat-no" title="statement not covered" ></span>return uiLocation?uiLocation.linkText():null;}</span>
function <span class="fstat-no" title="function not covered" >linkifyTopCallFrameAsText(</span>){const frame=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).topFrame();<span class="cstat-no" title="statement not covered" ></span>if(!frame)</span>
<span class="cstat-no" title="statement not covered" >return null;l</span>et text=<span class="cstat-no" title="statement not covered" >linkifyLocationAsText(frame.scriptId,frame.lineNumber,frame.columnNumber);<span class="cstat-no" title="statement not covered" ></span>if(!text){<span class="cstat-no" title="statement not covered" >text=frame.url;<span class="cstat-no" title="statement not covered" >i</span>f(typeof frame.lineNumber==='number')</span></span>
<span class="cstat-no" title="statement not covered" >text+=':'+(frame.lineNumber+1);}</span>
<span class="cstat-no" title="statement not covered" >return text;}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic buildDetailsNodeForTraceEvent(event,target,linkifier){const recordType=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>let details=<span class="cstat-no" title="statement not covered" >null;</span>let detailsText;const eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>switch(event.name){case recordType.GCEvent:case recordType.MajorGC:case recordType.MinorGC:case recordType.EventDispatch:case recordType.Paint:case recordType.Animation:case recordType.EmbedderCallback:case recordType.ParseHTML:case recordType.WebSocketCreate:case recordType.WebSocketSendHandshakeRequest:case recordType.WebSocketReceiveHandshakeResponse:case recordType.WebSocketDestroy:<span class="cstat-no" title="statement not covered" >detailsText=Timeline.TimelineUIUtils.buildDetailsTextForTraceEvent(event,target);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.PaintImage:case recordType.DecodeImage:case recordType.ResizeImage:case recordType.DecodeLazyPixelRef:case recordType.XHRReadyStateChange:case recordType.XHRLoad:case recordType.ResourceSendRequest:case recordType.ResourceReceivedData:case recordType.ResourceReceiveResponse:case recordType.ResourceFinish:{const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).url;<span class="cstat-no" title="statement not covered" ></span>if(url)</span></span>
<span class="cstat-no" title="statement not covered" >details=Components.Linkifier.linkifyURL(url);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.FunctionCall:case recordType.JSFrame:<span class="cstat-no" title="statement not covered" >details=createElement('span');<span class="cstat-no" title="statement not covered" >d</span>etails.createTextChild(Timeline.TimelineUIUtils.frameDisplayName(eventData));c</span>onst location=<span class="cstat-no" title="statement not covered" >linkifyLocation(eventData['scriptId'],eventData['url'],eventData['lineNumber'],eventData['columnNumber']);<span class="cstat-no" title="statement not covered" ></span>if(location){<span class="cstat-no" title="statement not covered" >details.createTextChild(' @ ');<span class="cstat-no" title="statement not covered" >d</span>etails.appendChild(location);}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase recordType.CompileModule:<span class="cstat-no" title="statement not covered" >details=linkifyLocation('',event.args['fileName'],0,0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordType.CompileScript:case recordType.EvaluateScript:{const url=<span class="cstat-no" title="statement not covered" >eventData['url'];<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >details=linkifyLocation('',url,eventData['lineNumber'],0);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordType.ParseScriptOnBackground:{const url=<span class="cstat-no" title="statement not covered" >eventData['url'];<span class="cstat-no" title="statement not covered" ></span>if(url)</span>
<span class="cstat-no" title="statement not covered" >details=linkifyLocation('',url,0,0);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
default:<span class="cstat-no" title="statement not covered" >if(event.hasCategory(TimelineModel.TimelineModel.Category.Console))</span>
<span class="cstat-no" title="statement not covered" >detailsText=null;e</span>lse
<span class="cstat-no" title="statement not covered" >details=linkifyTopCallFrame();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >if(!details&amp;&amp;detailsText)</span>
<span class="cstat-no" title="statement not covered" >details=createTextNode(detailsText);<span class="cstat-no" title="statement not covered" >r</span>eturn details;f</span>unction <span class="fstat-no" title="function not covered" >linkifyLocation(</span>scriptId,url,lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >return linkifier.linkifyScriptLocation(target,scriptId,url,lineNumber,columnNumber,'timeline-details');}</span>
function <span class="fstat-no" title="function not covered" >linkifyTopCallFrame(</span>){const frame=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).topFrame();<span class="cstat-no" title="statement not covered" ></span>return frame?linkifier.maybeLinkifyConsoleCallFrame(target,frame,'timeline-details'):null;}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic async buildTraceEventDetails(event,model,linkifier,badgePool,detailed){const maybeTarget=<span class="cstat-no" title="statement not covered" >model.targetByEvent(event);</span>let relatedNodesMap=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(maybeTarget){const target=(<span class="cstat-no" title="statement not covered" >maybeTarget)</span>;<span class="cstat-no" title="statement not covered" >if(typeof event[Timeline.TimelineUIUtils._previewElementSymbol]==='undefined'){let previewElement=<span class="cstat-no" title="statement not covered" >null;</span>const url=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).url;<span class="cstat-no" title="statement not covered" ></span>if(url)</span></span></span>
<span class="cstat-no" title="statement not covered" >previewElement=await Components.ImagePreview.build(target,url,false);e</span>lse <span class="cstat-no" title="statement not covered" >if(TimelineModel.TimelineData.forEvent(event).picture)</span>
<span class="cstat-no" title="statement not covered" >previewElement=await Timeline.TimelineUIUtils.buildPicturePreviewContent(event,target);<span class="cstat-no" title="statement not covered" >e</span>vent[Timeline.TimelineUIUtils._previewElementSymbol]=previewElement;}</span>
const nodeIdsToResolve=<span class="cstat-no" title="statement not covered" >new Set();</span>const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(timelineData.backendNodeId)</span>
<span class="cstat-no" title="statement not covered" >nodeIdsToResolve.add(timelineData.backendNodeId);c</span>onst invalidationTrackingEvents=<span class="cstat-no" title="statement not covered" >TimelineModel.InvalidationTracker.invalidationEventsFor(event);<span class="cstat-no" title="statement not covered" ></span>if(invalidationTrackingEvents)</span>
<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._collectInvalidationNodeIds(nodeIdsToResolve,invalidationTrackingEvents);<span class="cstat-no" title="statement not covered" >i</span>f(nodeIdsToResolve.size){const domModel=<span class="cstat-no" title="statement not covered" >target.model(SDK.DOMModel);<span class="cstat-no" title="statement not covered" ></span>if(domModel)</span></span>
<span class="cstat-no" title="statement not covered" >relatedNodesMap=await domModel.pushNodesByBackendIdsToFrontend(nodeIdsToResolve);}</span>}
const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>let relatedNodeLabel;const contentHelper=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineDetailsContentHelper(model.targetByEvent(event),linkifier);</span>const color=<span class="cstat-no" title="statement not covered" >model.isMarkerEvent(event)?Timeline.TimelineUIUtils.markerStyleForEvent(event).color:Timeline.TimelineUIUtils.eventStyle(event).category.color;<span class="cstat-no" title="statement not covered" ></span>contentHelper.addSection(Timeline.TimelineUIUtils.eventTitle(event),color);c</span>onst eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];</span>const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);</span>const initiator=<span class="cstat-no" title="statement not covered" >timelineData.initiator();</span>let url=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(timelineData.warning)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendWarningRow(event);<span class="cstat-no" title="statement not covered" >i</span>f(event.name===recordTypes.JSFrame&amp;&amp;eventData['deoptReason'])</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendWarningRow(event,TimelineModel.TimelineModel.WarningType.V8Deopt);<span class="cstat-no" title="statement not covered" >i</span>f(detailed&amp;&amp;!Number.isNaN(event.duration+0)){<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Total Time`,Number.millisToString(event.duration,true));<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Self Time`,Number.millisToString(event.selfTime,true));}</span></span>
<span class="cstat-no" title="statement not covered" >if(model.isGenericTrace()){<span class="cstat-no" title="statement not covered" >for(const key in event.args){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(key,JSON.stringify(event.args[key]));}</span>catch(e){<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(key,`&lt;${typeof event.args[key]}&gt;`);}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >return contentHelper.fragment;}</span>
<span class="cstat-no" title="statement not covered" >switch(event.name){case recordTypes.GCEvent:case recordTypes.MajorGC:case recordTypes.MinorGC:const delta=<span class="cstat-no" title="statement not covered" >event.args['usedHeapSizeBefore']-event.args['usedHeapSizeAfter'];<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(ls`Collected`,Number.bytesToString(delta));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.JSFrame:case recordTypes.FunctionCall:const detailsNode=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.buildDetailsNodeForTraceEvent(event,model.targetByEvent(event),linkifier);<span class="cstat-no" title="statement not covered" ></span>if(detailsNode)</span></span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(ls`Function`,detailsNode);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.TimerFire:case recordTypes.TimerInstall:case recordTypes.TimerRemove:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Timer ID`,eventData['timerId']);<span class="cstat-no" title="statement not covered" >i</span>f(event.name===recordTypes.TimerInstall){<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Timeout`,Number.millisToString(eventData['timeout']));<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Repeats`,!eventData['singleShot']);}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase recordTypes.FireAnimationFrame:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Callback ID`,eventData['id']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.ResourceSendRequest:case recordTypes.ResourceReceiveResponse:case recordTypes.ResourceReceivedData:case recordTypes.ResourceFinish:<span class="cstat-no" title="statement not covered" >url=timelineData.url;<span class="cstat-no" title="statement not covered" >i</span>f(url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(ls`Resource`,Components.Linkifier.linkifyURL(url));<span class="cstat-no" title="statement not covered" >i</span>f(eventData['requestMethod'])</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Request Method`,eventData['requestMethod']);<span class="cstat-no" title="statement not covered" >i</span>f(typeof eventData['statusCode']==='number')</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Status Code`,eventData['statusCode']);<span class="cstat-no" title="statement not covered" >i</span>f(eventData['mimeType'])</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`MIME Type`,eventData['mimeType']);<span class="cstat-no" title="statement not covered" >i</span>f('priority'in eventData){const priority=<span class="cstat-no" title="statement not covered" >PerfUI.uiLabelForNetworkPriority(eventData['priority']);<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(ls`Priority`,priority);}</span></span>
<span class="cstat-no" title="statement not covered" >if(eventData['encodedDataLength'])</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Encoded Data`,ls`${eventData['encodedDataLength']} Bytes`);<span class="cstat-no" title="statement not covered" >i</span>f(eventData['decodedBodyLength'])</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Decoded Body`,ls`${eventData['decodedBodyLength']} Bytes`);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.CompileModule:<span class="cstat-no" title="statement not covered" >contentHelper.appendLocationRow(ls`Module`,event.args['fileName'],0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.CompileScript:<span class="cstat-no" title="statement not covered" >url=eventData&amp;&amp;eventData['url'];<span class="cstat-no" title="statement not covered" >i</span>f(url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendLocationRow(ls`Script`,url,eventData['lineNumber'],eventData['columnNumber']);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Streamed`,eventData['streamed']);c</span>onst cacheProduceOptions=<span class="cstat-no" title="statement not covered" >eventData&amp;&amp;eventData['cacheProduceOptions'];<span class="cstat-no" title="statement not covered" ></span>if(cacheProduceOptions){<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Cache Produce Options`,cacheProduceOptions);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Produced Cache Size`,eventData['producedCacheSize']);}</span></span>
const cacheConsumeOptions=<span class="cstat-no" title="statement not covered" >eventData&amp;&amp;eventData['cacheConsumeOptions'];<span class="cstat-no" title="statement not covered" ></span>if(cacheConsumeOptions){<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Cache Consume Options`,cacheConsumeOptions);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Consumed Cache Size`,eventData['consumedCacheSize']);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Cache Rejected`,eventData['cacheRejected']);}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase recordTypes.EvaluateScript:<span class="cstat-no" title="statement not covered" >url=eventData&amp;&amp;eventData['url'];<span class="cstat-no" title="statement not covered" >i</span>f(url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendLocationRow(ls`Script`,url,eventData['lineNumber'],eventData['columnNumber']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.Paint:const clip=<span class="cstat-no" title="statement not covered" >eventData['clip'];<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(ls`Location`,ls`(${clip[0]}, ${clip[1]})`);c</span>onst clipWidth=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.quadWidth(clip);</span>const clipHeight=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.quadHeight(clip);<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(ls`Dimensions`,ls`${clipWidth} × ${clipHeight}`);c</span>ase recordTypes.PaintSetup:case recordTypes.Rasterize:case recordTypes.ScrollLayer:<span class="cstat-no" title="statement not covered" >relatedNodeLabel=ls`Layer Root`;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.PaintImage:case recordTypes.DecodeLazyPixelRef:case recordTypes.DecodeImage:case recordTypes.ResizeImage:case recordTypes.DrawLazyPixelRef:<span class="cstat-no" title="statement not covered" >relatedNodeLabel=ls`Owner Element`;<span class="cstat-no" title="statement not covered" >u</span>rl=timelineData.url;<span class="cstat-no" title="statement not covered" >i</span>f(url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(ls`Image URL`,Components.Linkifier.linkifyURL(url));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.ParseAuthorStyleSheet:<span class="cstat-no" title="statement not covered" >url=eventData['styleSheetUrl'];<span class="cstat-no" title="statement not covered" >i</span>f(url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(ls`Stylesheet URL`,Components.Linkifier.linkifyURL(url));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.UpdateLayoutTree:case recordTypes.RecalculateStyles:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Elements Affected`,event.args['elementCount']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.Layout:const beginData=<span class="cstat-no" title="statement not covered" >event.args['beginData'];<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(ls`Nodes That Need Layout`,ls`${beginData['dirtyObjects']} of ${beginData['totalObjects']}`);<span class="cstat-no" title="statement not covered" >r</span>elatedNodeLabel=ls`Layout root`;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.ConsoleTime:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Message`,event.name);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.WebSocketCreate:case recordTypes.WebSocketSendHandshakeRequest:case recordTypes.WebSocketReceiveHandshakeResponse:case recordTypes.WebSocketDestroy:const initiatorData=<span class="cstat-no" title="statement not covered" >initiator?initiator.args['data']:eventData;<span class="cstat-no" title="statement not covered" ></span>if(typeof initiatorData['webSocketURL']!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`URL`,initiatorData['webSocketURL']);<span class="cstat-no" title="statement not covered" >i</span>f(typeof initiatorData['webSocketProtocol']!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`WebSocket Protocol`,initiatorData['webSocketProtocol']);<span class="cstat-no" title="statement not covered" >i</span>f(typeof eventData['message']!=='undefined')</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Message`,eventData['message']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.EmbedderCallback:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Callback Function`,eventData['callbackName']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.Animation:<span class="cstat-no" title="statement not covered" >if(event.phase===SDK.TracingModel.Phase.NestableAsyncInstant)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`State`,eventData['state']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.ParseHTML:{const beginData=<span class="cstat-no" title="statement not covered" >event.args['beginData'];</span>const startLine=<span class="cstat-no" title="statement not covered" >beginData['startLine']-1;</span>const endLine=<span class="cstat-no" title="statement not covered" >event.args['endData']?event.args['endData']['endLine']-1:undefined;<span class="cstat-no" title="statement not covered" ></span>url=beginData['url'];<span class="cstat-no" title="statement not covered" >i</span>f(url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendLocationRange(ls`Range`,url,startLine,endLine);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case recordTypes.FireIdleCallback:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Allotted Time`,Number.millisToString(eventData['allottedMilliseconds']));<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(ls`Invoked by Timeout`,eventData['timedOut']);c</span>ase recordTypes.RequestIdleCallback:case recordTypes.CancelIdleCallback:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Callback ID`,eventData['id']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.EventDispatch:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Type`,eventData['type']);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkFCP:case recordTypes.MarkFMP:case recordTypes.MarkLoad:case recordTypes.MarkDOMContent:<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Timestamp`,Number.preciseMillisToString(event.startTime-model.minimumRecordTime(),1));c</span>onst learnMoreLink=<span class="cstat-no" title="statement not covered" >UI.XLink.create('https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#user-centric_performance_metrics',ls`Learn more`);</span>const linkDiv=<span class="cstat-no" title="statement not covered" >UI.html`&lt;div&gt;${learnMoreLink} about page performance metrics.&lt;/div&gt;`;<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendElementRow(ls`Details`,linkDiv);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:{const detailsNode=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.buildDetailsNodeForTraceEvent(event,model.targetByEvent(event),linkifier);<span class="cstat-no" title="statement not covered" ></span>if(detailsNode)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(ls`Details`,detailsNode);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}
<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._maybeAppendProductToDetails(contentHelper,badgePool,url||eventData&amp;&amp;eventData['url']);<span class="cstat-no" title="statement not covered" >i</span>f(timelineData.timeWaitingForMainThread){<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(ls`Time Waiting for Main Thread`,Number.millisToString(timelineData.timeWaitingForMainThread,true));}</span></span>
const relatedNode=<span class="cstat-no" title="statement not covered" >relatedNodesMap&amp;&amp;relatedNodesMap.get(timelineData.backendNodeId);<span class="cstat-no" title="statement not covered" ></span>if(relatedNode){const nodeSpan=<span class="cstat-no" title="statement not covered" >await Common.Linkifier.linkify(relatedNode);<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendElementRow(relatedNodeLabel||ls`Related Node`,nodeSpan);}</span></span>
<span class="cstat-no" title="statement not covered" >if(event[Timeline.TimelineUIUtils._previewElementSymbol]){<span class="cstat-no" title="statement not covered" >contentHelper.addSection(ls`Preview`);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendElementRow('',event[Timeline.TimelineUIUtils._previewElementSymbol]);}</span></span>
<span class="cstat-no" title="statement not covered" >if(initiator||timelineData.stackTraceForSelfOrInitiator()||TimelineModel.InvalidationTracker.invalidationEventsFor(event))</span>
<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._generateCauses(event,model.targetByEvent(event),relatedNodesMap,contentHelper);c</span>onst stats=<span class="cstat-no" title="statement not covered" >{};</span>const showPieChart=<span class="cstat-no" title="statement not covered" >detailed&amp;&amp;Timeline.TimelineUIUtils._aggregatedStatsForTraceEvent(stats,model,event);<span class="cstat-no" title="statement not covered" ></span>if(showPieChart){<span class="cstat-no" title="statement not covered" >contentHelper.addSection(ls`Aggregated Time`);c</span>onst pieChart=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.generatePieChart(stats,Timeline.TimelineUIUtils.eventStyle(event).category,event.selfTime);<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendElementRow('',pieChart);}</span></span>
<span class="cstat-no" title="statement not covered" >return contentHelper.fragment;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _maybeAppendProductToDetails(contentHelper,badgePool,url){const parsedURL=<span class="cstat-no" title="statement not covered" >url?url.asParsedURL():null;<span class="cstat-no" title="statement not covered" ></span>if(parsedURL)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow('',badgePool.badgeForURL(parsedURL));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic statsForTimeRange(events,startTime,endTime){<span class="cstat-no" title="statement not covered" >if(!events.length)</span>
<span class="cstat-no" title="statement not covered" >return{'idle':endTime-startTime};<span class="cstat-no" title="statement not covered" >b</span>uildRangeStatsCacheIfNeeded(events);c</span>onst aggregatedStats=<span class="cstat-no" title="statement not covered" >subtractStats(aggregatedStatsAtTime(endTime),aggregatedStatsAtTime(startTime));</span>const aggregatedTotal=<span class="cstat-no" title="statement not covered" >Object.values(aggregatedStats).reduce(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a+b,</span>0);<span class="cstat-no" title="statement not covered" ></span>aggregatedStats['idle']=Math.max(0,endTime-startTime-aggregatedTotal);<span class="cstat-no" title="statement not covered" >r</span>eturn aggregatedStats;f</span>unction <span class="fstat-no" title="function not covered" >aggregatedStatsAtTime(</span>time){const stats=<span class="cstat-no" title="statement not covered" >{};</span>const cache=<span class="cstat-no" title="statement not covered" >events[Timeline.TimelineUIUtils._categoryBreakdownCacheSymbol];<span class="cstat-no" title="statement not covered" ></span>for(const category in cache){const categoryCache=<span class="cstat-no" title="statement not covered" >cache[category];</span>const index=<span class="cstat-no" title="statement not covered" >categoryCache.time.upperBound(time);</span>let value;<span class="cstat-no" title="statement not covered" >if(index===0){<span class="cstat-no" title="statement not covered" >value=0;}</span>else <span class="cstat-no" title="statement not covered" >if(index===categoryCache.time.length){<span class="cstat-no" title="statement not covered" >value=categoryCache.value.peekLast();}</span>else{const t0=<span class="cstat-no" title="statement not covered" >categoryCache.time[index-1];</span>const t1=<span class="cstat-no" title="statement not covered" >categoryCache.time[index];</span>const v0=<span class="cstat-no" title="statement not covered" >categoryCache.value[index-1];</span>const v1=<span class="cstat-no" title="statement not covered" >categoryCache.value[index];<span class="cstat-no" title="statement not covered" ></span>value=v0+(v1-v0)*(time-t0)/(t1-t0);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >stats[category]=value;}</span>
<span class="cstat-no" title="statement not covered" >return stats;}</span>
function <span class="fstat-no" title="function not covered" >subtractStats(</span>a,b){const result=<span class="cstat-no" title="statement not covered" >Object.assign({},a);<span class="cstat-no" title="statement not covered" ></span>for(const key in b)</span>
<span class="cstat-no" title="statement not covered" >result[key]-=b[key];<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
function <span class="fstat-no" title="function not covered" >buildRangeStatsCacheIfNeeded(</span>events){<span class="cstat-no" title="statement not covered" >if(events[Timeline.TimelineUIUtils._categoryBreakdownCacheSymbol])</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst aggregatedStats=<span class="cstat-no" title="statement not covered" >{};</span>const categoryStack=<span class="cstat-no" title="statement not covered" >[];</span>let lastTime=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>TimelineModel.TimelineModel.forEachEvent(events,onStartEvent,onEndEvent,undefined,undefined,undefined,filterForStats());f</span>unction <span class="fstat-no" title="function not covered" >filterForStats(</span>){const visibleEventsFilter=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.visibleEventsFilter();<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >ev</span>ent=&gt;<span class="cstat-no" title="statement not covered" >visibleEventsFilter.accept(event)||SDK.TracingModel.isTopLevelEvent(event);</span>}</span>
function <span class="fstat-no" title="function not covered" >updateCategory(</span>category,time){let statsArrays=<span class="cstat-no" title="statement not covered" >aggregatedStats[category];<span class="cstat-no" title="statement not covered" ></span>if(!statsArrays){<span class="cstat-no" title="statement not covered" >statsArrays={time:[],value:[]};<span class="cstat-no" title="statement not covered" >a</span>ggregatedStats[category]=statsArrays;}</span></span>
<span class="cstat-no" title="statement not covered" >if(statsArrays.time.length&amp;&amp;statsArrays.time.peekLast()===time)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst lastValue=<span class="cstat-no" title="statement not covered" >statsArrays.value.length?statsArrays.value.peekLast():0;<span class="cstat-no" title="statement not covered" ></span>statsArrays.value.push(lastValue+time-lastTime);<span class="cstat-no" title="statement not covered" >s</span>tatsArrays.time.push(time);}</span>
function <span class="fstat-no" title="function not covered" >categoryChange(</span>from,to,time){<span class="cstat-no" title="statement not covered" >if(from)</span>
<span class="cstat-no" title="statement not covered" >updateCategory(from,time);<span class="cstat-no" title="statement not covered" >l</span>astTime=time;<span class="cstat-no" title="statement not covered" >i</span>f(to)</span>
<span class="cstat-no" title="statement not covered" >updateCategory(to,time);}</span>
function <span class="fstat-no" title="function not covered" >onStartEvent(</span>e){const category=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(e).category.name;</span>const parentCategory=<span class="cstat-no" title="statement not covered" >categoryStack.length?categoryStack.peekLast():null;<span class="cstat-no" title="statement not covered" ></span>if(category!==parentCategory)</span>
<span class="cstat-no" title="statement not covered" >categoryChange(parentCategory,category,e.startTime);<span class="cstat-no" title="statement not covered" >c</span>ategoryStack.push(category);}</span>
function <span class="fstat-no" title="function not covered" >onEndEvent(</span>e){const category=<span class="cstat-no" title="statement not covered" >categoryStack.pop();</span>const parentCategory=<span class="cstat-no" title="statement not covered" >categoryStack.length?categoryStack.peekLast():null;<span class="cstat-no" title="statement not covered" ></span>if(category!==parentCategory)</span>
<span class="cstat-no" title="statement not covered" >categoryChange(category,parentCategory,e.endTime);}</span>
const obj=(<span class="cstat-no" title="statement not covered" >events)</span>;<span class="cstat-no" title="statement not covered" >obj[Timeline.TimelineUIUtils._categoryBreakdownCacheSymbol]=aggregatedStats;}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic async buildNetworkRequestDetails(request,model,linkifier,badgePool){const target=<span class="cstat-no" title="statement not covered" >model.targetByEvent(request.children[0]);</span>const contentHelper=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineDetailsContentHelper(target,linkifier);</span>const category=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.networkRequestCategory(request);</span>const color=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.networkCategoryColor(category);<span class="cstat-no" title="statement not covered" ></span>contentHelper.addSection(Common.UIString('Network request'),color);c</span>onst duration=<span class="cstat-no" title="statement not covered" >request.endTime-(request.startTime||-Infinity);<span class="cstat-no" title="statement not covered" ></span>if(request.url)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(Common.UIString('URL'),Components.Linkifier.linkifyURL(request.url));<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils._maybeAppendProductToDetails(contentHelper,badgePool,request.url);<span class="cstat-no" title="statement not covered" >i</span>f(isFinite(duration))</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(Common.UIString('Duration'),Number.millisToString(duration,true));<span class="cstat-no" title="statement not covered" >i</span>f(request.requestMethod)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(Common.UIString('Request Method'),request.requestMethod);<span class="cstat-no" title="statement not covered" >i</span>f(typeof request.priority==='string'){const priority=<span class="cstat-no" title="statement not covered" >PerfUI.uiLabelForNetworkPriority((request.priority));<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(Common.UIString('Priority'),priority);}</span></span>
<span class="cstat-no" title="statement not covered" >if(request.mimeType)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(Common.UIString('Mime Type'),request.mimeType);l</span>et lengthText=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(request.fromCache)</span>
<span class="cstat-no" title="statement not covered" >lengthText+=Common.UIString(' (from cache)');<span class="cstat-no" title="statement not covered" >i</span>f(request.fromServiceWorker)</span>
<span class="cstat-no" title="statement not covered" >lengthText+=Common.UIString(' (from service worker)');<span class="cstat-no" title="statement not covered" >i</span>f(request.encodedDataLength||!lengthText)</span>
<span class="cstat-no" title="statement not covered" >lengthText=`${Number.bytesToString(request.encodedDataLength)}${lengthText}`;<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(Common.UIString('Encoded Data'),lengthText);<span class="cstat-no" title="statement not covered" >i</span>f(request.decodedBodyLength)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendTextRow(Common.UIString('Decoded Body'),Number.bytesToString(request.decodedBodyLength));c</span>onst title=<span class="cstat-no" title="statement not covered" >Common.UIString('Initiator');</span>const sendRequest=<span class="cstat-no" title="statement not covered" >request.children[0];</span>const topFrame=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(sendRequest).topFrame();<span class="cstat-no" title="statement not covered" ></span>if(topFrame){const link=<span class="cstat-no" title="statement not covered" >linkifier.maybeLinkifyConsoleCallFrame(target,topFrame);<span class="cstat-no" title="statement not covered" ></span>if(link)</span></span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(title,link);}</span>else{const initiator=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(sendRequest).initiator();<span class="cstat-no" title="statement not covered" ></span>if(initiator){const initiatorURL=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(initiator).url;<span class="cstat-no" title="statement not covered" ></span>if(initiatorURL){const link=<span class="cstat-no" title="statement not covered" >linkifier.maybeLinkifyScriptLocation(target,null,initiatorURL,0);<span class="cstat-no" title="statement not covered" ></span>if(link)</span></span></span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(title,link);}</span>}}
<span class="cstat-no" title="statement not covered" >if(!request.previewElement&amp;&amp;request.url&amp;&amp;target)</span>
<span class="cstat-no" title="statement not covered" >request.previewElement=await Components.ImagePreview.build(target,request.url,false);<span class="cstat-no" title="statement not covered" >i</span>f(request.previewElement)</span>
<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(Common.UIString('Preview'),request.previewElement);<span class="cstat-no" title="statement not covered" >r</span>eturn contentHelper.fragment;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _stackTraceFromCallFrames(callFrames){<span class="cstat-no" title="statement not covered" >return({callFrames:callFrames});}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _generateCauses(event,target,relatedNodesMap,contentHelper){const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>let callSiteStackLabel;let stackLabel;<span class="cstat-no" title="statement not covered" >switch(event.name){case recordTypes.TimerFire:<span class="cstat-no" title="statement not covered" >callSiteStackLabel=Common.UIString('Timer Installed');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.FireAnimationFrame:<span class="cstat-no" title="statement not covered" >callSiteStackLabel=Common.UIString('Animation Frame Requested');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.FireIdleCallback:<span class="cstat-no" title="statement not covered" >callSiteStackLabel=Common.UIString('Idle Callback Requested');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.UpdateLayoutTree:case recordTypes.RecalculateStyles:<span class="cstat-no" title="statement not covered" >stackLabel=Common.UIString('Recalculation Forced');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.Layout:<span class="cstat-no" title="statement not covered" >callSiteStackLabel=Common.UIString('First Layout Invalidation');<span class="cstat-no" title="statement not covered" >s</span>tackLabel=Common.UIString('Layout Forced');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(timelineData.stackTrace&amp;&amp;timelineData.stackTrace.length){<span class="cstat-no" title="statement not covered" >contentHelper.addSection(Common.UIString('Call Stacks'));<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendStackTrace(stackLabel||Common.UIString('Stack Trace'),Timeline.TimelineUIUtils._stackTraceFromCallFrames(timelineData.stackTrace));}</span></span>
const initiator=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event).initiator();<span class="cstat-no" title="statement not covered" ></span>if(TimelineModel.InvalidationTracker.invalidationEventsFor(event)&amp;&amp;target){<span class="cstat-no" title="statement not covered" >contentHelper.addSection(Common.UIString('Invalidations'));<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils._generateInvalidations(event,target,relatedNodesMap,contentHelper);}</span>else <span class="cstat-no" title="statement not covered" >if(initiator){const delay=<span class="cstat-no" title="statement not covered" >event.startTime-initiator.startTime;<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(Common.UIString('Pending for'),Number.preciseMillisToString(delay,1));c</span>onst link=<span class="cstat-no" title="statement not covered" >createElementWithClass('span','devtools-link');<span class="cstat-no" title="statement not covered" ></span>link.textContent=Common.UIString('reveal');<span class="cstat-no" title="statement not covered" >l</span>ink.addEventListener('click',<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel.instance().select(Timeline.TimelineSelection.fromTraceEvent((initiator)));}</span>);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendElementRow(Common.UIString('Initiator'),link);c</span>onst initiatorStackTrace=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(initiator).stackTrace;<span class="cstat-no" title="statement not covered" ></span>if(initiatorStackTrace){<span class="cstat-no" title="statement not covered" >contentHelper.appendStackTrace(callSiteStackLabel||Common.UIString('First Invalidated'),Timeline.TimelineUIUtils._stackTraceFromCallFrames(initiatorStackTrace));}</span>}</span>}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _generateInvalidations(event,target,relatedNodesMap,contentHelper){const invalidationTrackingEvents=<span class="cstat-no" title="statement not covered" >TimelineModel.InvalidationTracker.invalidationEventsFor(event);</span>const invalidations=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>invalidationTrackingEvents.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(invalidation){<span class="cstat-no" title="statement not covered" >if(!invalidations[invalidation.type])</span></span>
<span class="cstat-no" title="statement not covered" >invalidations[invalidation.type]=[invalidation];e</span>lse
<span class="cstat-no" title="statement not covered" >invalidations[invalidation.type].push(invalidation);}</span>);<span class="cstat-no" title="statement not covered" >Object.keys(invalidations).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(type){<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._generateInvalidationsForType(type,target,invalidations[type],relatedNodesMap,contentHelper);}</span>);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _generateInvalidationsForType(type,target,invalidations,relatedNodesMap,contentHelper){let title;<span class="cstat-no" title="statement not covered" >switch(type){case TimelineModel.TimelineModel.RecordType.StyleRecalcInvalidationTracking:<span class="cstat-no" title="statement not covered" >title=Common.UIString('Style Invalidations');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase TimelineModel.TimelineModel.RecordType.LayoutInvalidationTracking:<span class="cstat-no" title="statement not covered" >title=Common.UIString('Layout Invalidations');<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >title=Common.UIString('Other Invalidations');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
const invalidationsTreeOutline=<span class="cstat-no" title="statement not covered" >new UI.TreeOutlineInShadow();<span class="cstat-no" title="statement not covered" ></span>invalidationsTreeOutline.registerRequiredCSS('timeline/invalidationsTree.css');<span class="cstat-no" title="statement not covered" >i</span>nvalidationsTreeOutline.element.classList.add('invalidations-tree');c</span>onst invalidationGroups=<span class="cstat-no" title="statement not covered" >groupInvalidationsByCause(invalidations);<span class="cstat-no" title="statement not covered" ></span>invalidationGroups.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(group){const groupElement=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineUIUtils.InvalidationsGroupElement(target,relatedNodesMap,contentHelper,group);<span class="cstat-no" title="statement not covered" ></span>invalidationsTreeOutline.appendChild(groupElement);}</span>);<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendElementRow(title,invalidationsTreeOutline.element,false,true);f</span>unction <span class="fstat-no" title="function not covered" >groupInvalidationsByCause(</span>invalidations){const causeToInvalidationMap=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(let index=0;index&lt;invalidations.length;index++){const invalidation=<span class="cstat-no" title="statement not covered" >invalidations[index];</span>let causeKey=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(invalidation.cause.reason)</span></span>
<span class="cstat-no" title="statement not covered" >causeKey+=invalidation.cause.reason+'.';<span class="cstat-no" title="statement not covered" >i</span>f(invalidation.cause.stackTrace){<span class="cstat-no" title="statement not covered" >invalidation.cause.stackTrace.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(stackFrame){<span class="cstat-no" title="statement not covered" >causeKey+=stackFrame['functionName']+'.';<span class="cstat-no" title="statement not covered" >c</span>auseKey+=stackFrame['scriptId']+'.';<span class="cstat-no" title="statement not covered" >c</span>auseKey+=stackFrame['url']+'.';<span class="cstat-no" title="statement not covered" >c</span>auseKey+=stackFrame['lineNumber']+'.';<span class="cstat-no" title="statement not covered" >c</span>auseKey+=stackFrame['columnNumber']+'.';}</span>);}</span></span>
<span class="cstat-no" title="statement not covered" >if(causeToInvalidationMap.has(causeKey))</span>
<span class="cstat-no" title="statement not covered" >causeToInvalidationMap.get(causeKey).push(invalidation);e</span>lse
<span class="cstat-no" title="statement not covered" >causeToInvalidationMap.set(causeKey,[invalidation]);}</span>
<span class="cstat-no" title="statement not covered" >return causeToInvalidationMap.valuesArray();}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic _collectInvalidationNodeIds(nodeIds,invalidations){<span class="cstat-no" title="statement not covered" >nodeIds.addAll(invalidations.map(<span class="fstat-no" title="function not covered" >in</span>validation=&gt;<span class="cstat-no" title="statement not covered" >invalidation.nodeId)</span>.filter(<span class="fstat-no" title="function not covered" >id</span>=&gt;<span class="cstat-no" title="statement not covered" >id)</span>);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _aggregatedStatsForTraceEvent(total,model,event){const events=<span class="cstat-no" title="statement not covered" >model.inspectedTargetEvents();</span>function <span class="fstat-no" title="function not covered" >eventComparator(</span>startTime,e){<span class="cstat-no" title="statement not covered" >return startTime-e.startTime;}</span>
const index=<span class="cstat-no" title="statement not covered" >events.binaryIndexOf(event.startTime,eventComparator);<span class="cstat-no" title="statement not covered" ></span>if(index&lt;0)</span>
<span class="cstat-no" title="statement not covered" >return false;l</span>et hasChildren=<span class="cstat-no" title="statement not covered" >false;</span>const endTime=<span class="cstat-no" title="statement not covered" >event.endTime;<span class="cstat-no" title="statement not covered" ></span>if(endTime){<span class="cstat-no" title="statement not covered" >for(let i=index;i&lt;events.length;i++){const nextEvent=<span class="cstat-no" title="statement not covered" >events[i];<span class="cstat-no" title="statement not covered" ></span>if(nextEvent.startTime&gt;=endTime)</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(!nextEvent.selfTime)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(nextEvent.thread!==event.thread)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(i&gt;index)</span>
<span class="cstat-no" title="statement not covered" >hasChildren=true;c</span>onst categoryName=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventStyle(nextEvent).category.name;<span class="cstat-no" title="statement not covered" ></span>total[categoryName]=(total[categoryName]||0)+nextEvent.selfTime;}</span>}
<span class="cstat-no" title="statement not covered" >if(SDK.TracingModel.isAsyncPhase(event.phase)){<span class="cstat-no" title="statement not covered" >if(event.endTime){let aggregatedTotal=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const categoryName in total)</span></span></span>
<span class="cstat-no" title="statement not covered" >aggregatedTotal+=total[categoryName];<span class="cstat-no" title="statement not covered" >t</span>otal['idle']=Math.max(0,event.endTime-event.startTime-aggregatedTotal);}</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return hasChildren;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic async buildPicturePreviewContent(event,target){const snapshotWithRect=<span class="cstat-no" title="statement not covered" >await new TimelineModel.LayerPaintEvent(event,target).snapshotPromise();<span class="cstat-no" title="statement not covered" ></span>if(!snapshotWithRect)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst imageURLPromise=<span class="cstat-no" title="statement not covered" >snapshotWithRect.snapshot.replay();<span class="cstat-no" title="statement not covered" ></span>snapshotWithRect.snapshot.release();c</span>onst imageURL=<span class="cstat-no" title="statement not covered" >await imageURLPromise;<span class="cstat-no" title="statement not covered" ></span>if(!imageURL)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst container=<span class="cstat-no" title="statement not covered" >createElement('div');<span class="cstat-no" title="statement not covered" ></span>UI.appendStyle(container,'components/imagePreview.css');<span class="cstat-no" title="statement not covered" >c</span>ontainer.classList.add('image-preview-container','vbox','link');c</span>onst img=<span class="cstat-no" title="statement not covered" >container.createChild('img');<span class="cstat-no" title="statement not covered" ></span>img.src=imageURL;c</span>onst paintProfilerButton=<span class="cstat-no" title="statement not covered" >container.createChild('a');<span class="cstat-no" title="statement not covered" ></span>paintProfilerButton.textContent=Common.UIString('Paint Profiler');<span class="cstat-no" title="statement not covered" >c</span>ontainer.addEventListener('click',<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel.instance().select(Timeline.TimelineSelection.fromTraceEvent(event)),</span>false);<span class="cstat-no" title="statement not covered" >r</span>eturn container;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic createEventDivider(event,zeroTime){const eventDivider=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','resources-event-divider');</span>const startTime=<span class="cstat-no" title="statement not covered" >Number.millisToString(event.startTime-zeroTime);<span class="cstat-no" title="statement not covered" ></span>eventDivider.title=Common.UIString('%s at %s',Timeline.TimelineUIUtils.eventTitle(event),startTime);c</span>onst style=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.markerStyleForEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(style.tall)</span>
<span class="cstat-no" title="statement not covered" >eventDivider.style.backgroundColor=style.color;<span class="cstat-no" title="statement not covered" >r</span>eturn eventDivider;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _visibleTypes(){const eventStyles=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._initEventStyles();</span>const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const name in eventStyles){<span class="cstat-no" title="statement not covered" >if(!eventStyles[name].hidden)</span></span>
<span class="cstat-no" title="statement not covered" >result.push(name);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic visibleEventsFilter(){<span class="cstat-no" title="statement not covered" >return new TimelineModel.TimelineVisibleEventsFilter(Timeline.TimelineUIUtils._visibleTypes());}</span>
<span class="fstat-no" title="function not covered" >st</span>atic categories(){<span class="cstat-no" title="statement not covered" >if(Timeline.TimelineUIUtils._categories)</span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils._categories;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils._categories={loading:new Timeline.TimelineCategory('loading',Common.UIString('Loading'),true,'hsl(214, 67%, 74%)','hsl(214, 67%, 66%)'),scripting:new Timeline.TimelineCategory('scripting',Common.UIString('Scripting'),true,'hsl(43, 83%, 72%)','hsl(43, 83%, 64%) '),rendering:new Timeline.TimelineCategory('rendering',Common.UIString('Rendering'),true,'hsl(256, 67%, 76%)','hsl(256, 67%, 70%)'),painting:new Timeline.TimelineCategory('painting',Common.UIString('Painting'),true,'hsl(109, 33%, 64%)','hsl(109, 33%, 55%)'),gpu:new Timeline.TimelineCategory('gpu',Common.UIString('GPU'),false,'hsl(109, 33%, 64%)','hsl(109, 33%, 55%)'),async:new Timeline.TimelineCategory('async',Common.UIString('Async'),false,'hsl(0, 100%, 50%)','hsl(0, 100%, 40%)'),other:new Timeline.TimelineCategory('other',Common.UIString('Other'),false,'hsl(0, 0%, 87%)','hsl(0, 0%, 79%)'),idle:new Timeline.TimelineCategory('idle',Common.UIString('Idle'),false,'hsl(0, 0%, 98%)','hsl(0, 0%, 98%)')};<span class="cstat-no" title="statement not covered" >r</span>eturn Timeline.TimelineUIUtils._categories;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic generatePieChart(aggregatedStats,selfCategory,selfTime){let total=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const categoryName in aggregatedStats)</span>
<span class="cstat-no" title="statement not covered" >total+=aggregatedStats[categoryName];c</span>onst element=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','timeline-details-view-pie-chart-wrapper hbox');</span>const pieChart=<span class="cstat-no" title="statement not covered" >new PerfUI.PieChart(110,<span class="fstat-no" title="function not covered" >va</span>lue=&gt;<span class="cstat-no" title="statement not covered" >Number.preciseMillisToString(value),</span>true);<span class="cstat-no" title="statement not covered" ></span>pieChart.element.classList.add('timeline-details-view-pie-chart');<span class="cstat-no" title="statement not covered" >p</span>ieChart.setTotal(total);c</span>onst pieChartContainer=<span class="cstat-no" title="statement not covered" >element.createChild('div','vbox');<span class="cstat-no" title="statement not covered" ></span>pieChartContainer.appendChild(pieChart.element);c</span>onst footerElement=<span class="cstat-no" title="statement not covered" >element.createChild('div','timeline-aggregated-info-legend');</span>function <span class="fstat-no" title="function not covered" >appendLegendRow(</span>name,title,value,color){<span class="cstat-no" title="statement not covered" >if(!value)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span>ieChart.addSlice(value,color);c</span>onst rowElement=<span class="cstat-no" title="statement not covered" >footerElement.createChild('div');<span class="cstat-no" title="statement not covered" ></span>rowElement.createChild('span','timeline-aggregated-legend-value').textContent=Number.preciseMillisToString(value,1);<span class="cstat-no" title="statement not covered" >r</span>owElement.createChild('span','timeline-aggregated-legend-swatch').style.backgroundColor=color;<span class="cstat-no" title="statement not covered" >r</span>owElement.createChild('span','timeline-aggregated-legend-title').textContent=title;}</span>
<span class="cstat-no" title="statement not covered" >if(selfCategory){<span class="cstat-no" title="statement not covered" >if(selfTime){<span class="cstat-no" title="statement not covered" >appendLegendRow(selfCategory.name,Common.UIString('%s (self)',selfCategory.title),selfTime,selfCategory.color);}</span></span></span>
const categoryTime=<span class="cstat-no" title="statement not covered" >aggregatedStats[selfCategory.name];</span>const value=<span class="cstat-no" title="statement not covered" >categoryTime-selfTime;<span class="cstat-no" title="statement not covered" ></span>if(value&gt;0){<span class="cstat-no" title="statement not covered" >appendLegendRow(selfCategory.name,Common.UIString('%s (children)',selfCategory.title),value,selfCategory.childColor);}</span>}</span>
<span class="cstat-no" title="statement not covered" >for(const categoryName in Timeline.TimelineUIUtils.categories()){const category=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.categories()[categoryName];<span class="cstat-no" title="statement not covered" ></span>if(category===selfCategory)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >a</span>ppendLegendRow(category.name,category.title,aggregatedStats[category.name],category.childColor);}</span>
<span class="cstat-no" title="statement not covered" >return element;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic generateDetailsContentForFrame(frame,filmStripFrame){const contentHelper=<span class="cstat-no" title="statement not covered" >new Timeline.TimelineDetailsContentHelper(null,null);<span class="cstat-no" title="statement not covered" ></span>contentHelper.addSection(Common.UIString('Frame'));c</span>onst duration=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.frameDuration(frame);<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendElementRow(Common.UIString('Duration'),duration,frame.hasWarnings());c</span>onst durationInMillis=<span class="cstat-no" title="statement not covered" >frame.endTime-frame.startTime;<span class="cstat-no" title="statement not covered" ></span>contentHelper.appendTextRow(Common.UIString('FPS'),Math.floor(1000/durationInMillis));<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendTextRow(Common.UIString('CPU time'),Number.millisToString(frame.cpuTime,true));<span class="cstat-no" title="statement not covered" >i</span>f(filmStripFrame){const filmStripPreview=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','timeline-filmstrip-preview');<span class="cstat-no" title="statement not covered" ></span>filmStripFrame.imageDataPromise().then(<span class="fstat-no" title="function not covered" >da</span>ta=&gt;<span class="cstat-no" title="statement not covered" >UI.loadImageFromData(data))</span>.then(<span class="fstat-no" title="function not covered" >im</span>age=&gt;<span class="cstat-no" title="statement not covered" >image&amp;&amp;filmStripPreview.appendChild(image))</span>;<span class="cstat-no" title="statement not covered" >c</span>ontentHelper.appendElementRow('',filmStripPreview);<span class="cstat-no" title="statement not covered" >f</span>ilmStripPreview.addEventListener('click',frameClicked.bind(null,filmStripFrame),false);}</span></span>
<span class="cstat-no" title="statement not covered" >if(frame.layerTree){<span class="cstat-no" title="statement not covered" >contentHelper.appendElementRow(Common.UIString('Layer tree'),Components.Linkifier.linkifyRevealable(frame.layerTree,Common.UIString('show')));}</span></span>
function <span class="fstat-no" title="function not covered" >frameClicked(</span>filmStripFrame){<span class="cstat-no" title="statement not covered" >new PerfUI.FilmStripView.Dialog(filmStripFrame,0);}</span>
<span class="cstat-no" title="statement not covered" >return contentHelper.fragment;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic frameDuration(frame){const durationText=<span class="cstat-no" title="statement not covered" >Common.UIString('%s (at %s)',Number.millisToString(frame.endTime-frame.startTime,true),Number.millisToString(frame.startTimeOffset,true));</span>const element=<span class="cstat-no" title="statement not covered" >createElement('span');<span class="cstat-no" title="statement not covered" ></span>element.createTextChild(durationText);<span class="cstat-no" title="statement not covered" >i</span>f(!frame.hasWarnings())</span>
<span class="cstat-no" title="statement not covered" >return element;<span class="cstat-no" title="statement not covered" >e</span>lement.createTextChild(Common.UIString('. Long frame times are an indication of '));<span class="cstat-no" title="statement not covered" >e</span>lement.appendChild(UI.XLink.create('https://developers.google.com/web/fundamentals/performance/rendering/',Common.UIString('jank')));<span class="cstat-no" title="statement not covered" >e</span>lement.createTextChild('.');<span class="cstat-no" title="statement not covered" >r</span>eturn element;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic createFillStyle(context,width,height,color0,color1,color2){const gradient=<span class="cstat-no" title="statement not covered" >context.createLinearGradient(0,0,width,height);<span class="cstat-no" title="statement not covered" ></span>gradient.addColorStop(0,color0);<span class="cstat-no" title="statement not covered" >g</span>radient.addColorStop(0.25,color1);<span class="cstat-no" title="statement not covered" >g</span>radient.addColorStop(0.75,color1);<span class="cstat-no" title="statement not covered" >g</span>radient.addColorStop(1,color2);<span class="cstat-no" title="statement not covered" >r</span>eturn gradient;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic quadWidth(quad){<span class="cstat-no" title="statement not covered" >return Math.round(Math.sqrt(Math.pow(quad[0]-quad[2],2)+Math.pow(quad[1]-quad[3],2)));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic quadHeight(quad){<span class="cstat-no" title="statement not covered" >return Math.round(Math.sqrt(Math.pow(quad[0]-quad[6],2)+Math.pow(quad[1]-quad[7],2)));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventDispatchDesciptors(){<span class="cstat-no" title="statement not covered" >if(Timeline.TimelineUIUtils._eventDispatchDesciptors)</span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils._eventDispatchDesciptors;c</span>onst lightOrange=<span class="cstat-no" title="statement not covered" >'hsl(40,100%,80%)';</span>const orange=<span class="cstat-no" title="statement not covered" >'hsl(40,100%,50%)';</span>const green=<span class="cstat-no" title="statement not covered" >'hsl(90,100%,40%)';</span>const purple=<span class="cstat-no" title="statement not covered" >'hsl(256,100%,75%)';<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineUIUtils._eventDispatchDesciptors=[new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(1,lightOrange,['mousemove','mouseenter','mouseleave','mouseout','mouseover']),new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(1,lightOrange,['pointerover','pointerout','pointerenter','pointerleave','pointermove']),new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(2,green,['wheel']),new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(3,orange,['click','mousedown','mouseup']),new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(3,orange,['touchstart','touchend','touchmove','touchcancel']),new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(3,orange,['pointerdown','pointerup','pointercancel','gotpointercapture','lostpointercapture']),new Timeline.TimelineUIUtils.EventDispatchTypeDescriptor(3,purple,['keydown','keyup','keypress'])];<span class="cstat-no" title="statement not covered" >r</span>eturn Timeline.TimelineUIUtils._eventDispatchDesciptors;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic markerShortTitle(event){const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;<span class="cstat-no" title="statement not covered" ></span>switch(event.name){case recordTypes.MarkDOMContent:<span class="cstat-no" title="statement not covered" >return ls`DCL`;c</span>ase recordTypes.MarkLoad:<span class="cstat-no" title="statement not covered" >return ls`L`;c</span>ase recordTypes.MarkFirstPaint:<span class="cstat-no" title="statement not covered" >return ls`FP`;c</span>ase recordTypes.MarkFCP:<span class="cstat-no" title="statement not covered" >return ls`FCP`;c</span>ase recordTypes.MarkFMP:<span class="cstat-no" title="statement not covered" >return ls`FMP`;}</span></span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic markerStyleForEvent(event){const tallMarkerDashStyle=<span class="cstat-no" title="statement not covered" >[6,4];</span>const title=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventTitle(event);<span class="cstat-no" title="statement not covered" ></span>if(event.hasCategory(TimelineModel.TimelineModel.Category.Console)||event.hasCategory(TimelineModel.TimelineModel.Category.UserTiming)){<span class="cstat-no" title="statement not covered" >return{title:title,dashStyle:tallMarkerDashStyle,lineWidth:0.5,color:event.hasCategory(TimelineModel.TimelineModel.Category.UserTiming)?'purple':'orange',tall:false,lowPriority:false,};}</span></span>
const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>let tall=<span class="cstat-no" title="statement not covered" >false;</span>let color=<span class="cstat-no" title="statement not covered" >'grey';<span class="cstat-no" title="statement not covered" ></span>switch(event.name){case recordTypes.FrameStartedLoading:<span class="cstat-no" title="statement not covered" >color='green';<span class="cstat-no" title="statement not covered" >t</span>all=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkDOMContent:<span class="cstat-no" title="statement not covered" >color='#0867CB';<span class="cstat-no" title="statement not covered" >t</span>all=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkLoad:<span class="cstat-no" title="statement not covered" >color='#B31412';<span class="cstat-no" title="statement not covered" >t</span>all=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkFirstPaint:<span class="cstat-no" title="statement not covered" >color='hsl(180, 45%, 79%)';<span class="cstat-no" title="statement not covered" >t</span>all=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkFCP:<span class="cstat-no" title="statement not covered" >color='#208043';<span class="cstat-no" title="statement not covered" >t</span>all=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.MarkFMP:<span class="cstat-no" title="statement not covered" >color='#14522B';<span class="cstat-no" title="statement not covered" >t</span>all=true;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase recordTypes.TimeStamp:<span class="cstat-no" title="statement not covered" >color='orange';<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
<span class="cstat-no" title="statement not covered" >return{title:title,dashStyle:tallMarkerDashStyle,lineWidth:0.5,color:color,tall:tall,lowPriority:false,};}</span>
<span class="fstat-no" title="function not covered" >st</span>atic markerStyleForFrame(){<span class="cstat-no" title="statement not covered" >return{title:Common.UIString('Frame'),color:'rgba(100, 100, 100, 0.4)',lineWidth:3,dashStyle:[3],tall:true,lowPriority:true};}</span>
<span class="fstat-no" title="function not covered" >st</span>atic colorForId(id){<span class="cstat-no" title="statement not covered" >if(!Timeline.TimelineUIUtils.colorForId._colorGenerator){<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.colorForId._colorGenerator=new Common.Color.Generator({min:30,max:330},{min:50,max:80,count:3},85);<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils.colorForId._colorGenerator.setColorForID('','#f2ecdc');}</span></span>
<span class="cstat-no" title="statement not covered" >return Timeline.TimelineUIUtils.colorForId._colorGenerator.colorForID(id);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic eventWarning(event,warningType){const timelineData=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(event);</span>const warning=<span class="cstat-no" title="statement not covered" >warningType||timelineData.warning;<span class="cstat-no" title="statement not covered" ></span>if(!warning)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst warnings=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.WarningType;</span>const span=<span class="cstat-no" title="statement not covered" >createElement('span');</span>const eventData=<span class="cstat-no" title="statement not covered" >event.args['data'];<span class="cstat-no" title="statement not covered" ></span>switch(warning){case warnings.ForcedStyle:case warnings.ForcedLayout:<span class="cstat-no" title="statement not covered" >span.appendChild(UI.createDocumentationLink('../../fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts',Common.UIString('Forced reflow')));<span class="cstat-no" title="statement not covered" >s</span>pan.createTextChild(Common.UIString(' is a likely performance bottleneck.'));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase warnings.IdleDeadlineExceeded:<span class="cstat-no" title="statement not covered" >span.textContent=Common.UIString('Idle callback execution extended beyond deadline by '+</span></span>
Number.millisToString(event.duration-eventData['allottedMilliseconds'],true));<span class="cstat-no" title="statement not covered" >break;c</span>ase warnings.LongHandler:<span class="cstat-no" title="statement not covered" >span.textContent=Common.UIString('Handler took %s',Number.millisToString(event.duration,true));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase warnings.LongRecurringHandler:<span class="cstat-no" title="statement not covered" >span.textContent=Common.UIString('Recurring handler took %s',Number.millisToString(event.duration,true));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase warnings.V8Deopt:<span class="cstat-no" title="statement not covered" >span.appendChild(UI.XLink.create('https://github.com/GoogleChrome/devtools-docs/issues/53',Common.UIString('Not optimized')));<span class="cstat-no" title="statement not covered" >s</span>pan.createTextChild(Common.UIString(': %s',eventData['deoptReason']));<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >console.assert(false,'Unhandled TimelineModel.WarningType');}</span>
<span class="cstat-no" title="statement not covered" >return span;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic displayNameForFrame(frame,trimAt){const url=<span class="cstat-no" title="statement not covered" >frame.url;<span class="cstat-no" title="statement not covered" ></span>if(!trimAt)</span>
<span class="cstat-no" title="statement not covered" >trimAt=30;<span class="cstat-no" title="statement not covered" >r</span>eturn url.startsWith('about:')?`"${frame.name.trimMiddle(trimAt)}"`:frame.url.trimEnd(trimAt);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineRecordStyle=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(title,category,hidden){<span class="cstat-no" title="statement not covered" >this.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.category=category;<span class="cstat-no" title="statement not covered" >t</span>his.hidden=!!hidden;}</span>};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils.NetworkCategory={HTML:Symbol('HTML'),Script:Symbol('Script'),Style:Symbol('Style'),Media:Symbol('Media'),Other:Symbol('Other')};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils._aggregatedStatsKey=Symbol('aggregatedStats');<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils.InvalidationsGroupElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(target,relatedNodesMap,contentHelper,invalidations){<span class="cstat-no" title="statement not covered" >super('',true);<span class="cstat-no" title="statement not covered" >t</span>his.listItemElement.classList.add('header');<span class="cstat-no" title="statement not covered" >t</span>his.selectable=false;<span class="cstat-no" title="statement not covered" >t</span>his.toggleOnClick=true;<span class="cstat-no" title="statement not covered" >t</span>his._relatedNodesMap=relatedNodesMap;<span class="cstat-no" title="statement not covered" >t</span>his._contentHelper=contentHelper;<span class="cstat-no" title="statement not covered" >t</span>his._invalidations=invalidations;<span class="cstat-no" title="statement not covered" >t</span>his.title=this._createTitle(target);}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>reateTitle(target){const first=<span class="cstat-no" title="statement not covered" >this._invalidations[0];</span>const reason=<span class="cstat-no" title="statement not covered" >first.cause.reason;</span>const topFrame=<span class="cstat-no" title="statement not covered" >first.cause.stackTrace&amp;&amp;first.cause.stackTrace[0];</span>const title=<span class="cstat-no" title="statement not covered" >createElement('span');<span class="cstat-no" title="statement not covered" ></span>if(reason)</span>
<span class="cstat-no" title="statement not covered" >title.createTextChild(Common.UIString('%s for ',reason));e</span>lse
<span class="cstat-no" title="statement not covered" >title.createTextChild(Common.UIString('Unknown cause for '));<span class="cstat-no" title="statement not covered" >t</span>his._appendTruncatedNodeList(title,this._invalidations);<span class="cstat-no" title="statement not covered" >i</span>f(topFrame&amp;&amp;this._contentHelper.linkifier()){<span class="cstat-no" title="statement not covered" >title.createTextChild(Common.UIString('. '));c</span>onst stack=<span class="cstat-no" title="statement not covered" >title.createChild('span','monospace');<span class="cstat-no" title="statement not covered" ></span>stack.createChild('span').textContent=Timeline.TimelineUIUtils.frameDisplayName(topFrame);c</span>onst link=<span class="cstat-no" title="statement not covered" >this._contentHelper.linkifier().maybeLinkifyConsoleCallFrame(target,topFrame);<span class="cstat-no" title="statement not covered" ></span>if(link){<span class="cstat-no" title="statement not covered" >stack.createChild('span').textContent=' @ ';<span class="cstat-no" title="statement not covered" >s</span>tack.createChild('span').appendChild(link);}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return title;}</span>
<span class="fstat-no" title="function not covered" >on</span>populate(){const content=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','content');</span>const first=<span class="cstat-no" title="statement not covered" >this._invalidations[0];<span class="cstat-no" title="statement not covered" ></span>if(first.cause.stackTrace){const stack=<span class="cstat-no" title="statement not covered" >content.createChild('div');<span class="cstat-no" title="statement not covered" ></span>stack.createTextChild(Common.UIString('Stack trace:'));<span class="cstat-no" title="statement not covered" >t</span>his._contentHelper.createChildStackTraceElement(stack,Timeline.TimelineUIUtils._stackTraceFromCallFrames(first.cause.stackTrace));}</span></span>
<span class="cstat-no" title="statement not covered" >content.createTextChild(this._invalidations.length&gt;1?Common.UIString('Nodes:'):Common.UIString('Node:'));c</span>onst nodeList=<span class="cstat-no" title="statement not covered" >content.createChild('div','node-list');</span>let firstNode=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._invalidations.length;i++){const invalidation=<span class="cstat-no" title="statement not covered" >this._invalidations[i];</span>const invalidationNode=<span class="cstat-no" title="statement not covered" >this._createInvalidationNode(invalidation,true);<span class="cstat-no" title="statement not covered" ></span>if(invalidationNode){<span class="cstat-no" title="statement not covered" >if(!firstNode)</span></span></span>
<span class="cstat-no" title="statement not covered" >nodeList.createTextChild(Common.UIString(', '));<span class="cstat-no" title="statement not covered" >f</span>irstNode=false;<span class="cstat-no" title="statement not covered" >n</span>odeList.appendChild(invalidationNode);c</span>onst extraData=<span class="cstat-no" title="statement not covered" >invalidation.extraData?', '+invalidation.extraData:'';<span class="cstat-no" title="statement not covered" ></span>if(invalidation.changedId){<span class="cstat-no" title="statement not covered" >nodeList.createTextChild(Common.UIString('(changed id to "%s"%s)',invalidation.changedId,extraData));}</span>else <span class="cstat-no" title="statement not covered" >if(invalidation.changedClass){<span class="cstat-no" title="statement not covered" >nodeList.createTextChild(Common.UIString('(changed class to "%s"%s)',invalidation.changedClass,extraData));}</span>else <span class="cstat-no" title="statement not covered" >if(invalidation.changedAttribute){<span class="cstat-no" title="statement not covered" >nodeList.createTextChild(Common.UIString('(changed attribute to "%s"%s)',invalidation.changedAttribute,extraData));}</span>else <span class="cstat-no" title="statement not covered" >if(invalidation.changedPseudo){<span class="cstat-no" title="statement not covered" >nodeList.createTextChild(Common.UIString('(changed pesudo to "%s"%s)',invalidation.changedPseudo,extraData));}</span>else <span class="cstat-no" title="statement not covered" >if(invalidation.selectorPart){<span class="cstat-no" title="statement not covered" >nodeList.createTextChild(Common.UIString('(changed "%s"%s)',invalidation.selectorPart,extraData));}</span>}</span></span></span></span></span>}
const contentTreeElement=<span class="cstat-no" title="statement not covered" >new UI.TreeElement(content,false);<span class="cstat-no" title="statement not covered" ></span>contentTreeElement.selectable=false;<span class="cstat-no" title="statement not covered" >t</span>his.appendChild(contentTreeElement);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendTruncatedNodeList(parentElement,invalidations){const invalidationNodes=<span class="cstat-no" title="statement not covered" >[];</span>const invalidationNodeIdMap=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;invalidations.length;i++){const invalidation=<span class="cstat-no" title="statement not covered" >invalidations[i];</span>const invalidationNode=<span class="cstat-no" title="statement not covered" >this._createInvalidationNode(invalidation,false);<span class="cstat-no" title="statement not covered" ></span>invalidationNode.addEventListener('click',<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.consume(),</span>false);<span class="cstat-no" title="statement not covered" >i</span>f(invalidationNode&amp;&amp;!invalidationNodeIdMap[invalidation.nodeId]){<span class="cstat-no" title="statement not covered" >invalidationNodes.push(invalidationNode);<span class="cstat-no" title="statement not covered" >i</span>nvalidationNodeIdMap[invalidation.nodeId]=true;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(invalidationNodes.length===1){<span class="cstat-no" title="statement not covered" >parentElement.appendChild(invalidationNodes[0]);}</span>else <span class="cstat-no" title="statement not covered" >if(invalidationNodes.length===2){<span class="cstat-no" title="statement not covered" >parentElement.appendChild(invalidationNodes[0]);<span class="cstat-no" title="statement not covered" >p</span>arentElement.createTextChild(Common.UIString(' and '));<span class="cstat-no" title="statement not covered" >p</span>arentElement.appendChild(invalidationNodes[1]);}</span>else <span class="cstat-no" title="statement not covered" >if(invalidationNodes.length&gt;=3){<span class="cstat-no" title="statement not covered" >parentElement.appendChild(invalidationNodes[0]);<span class="cstat-no" title="statement not covered" >p</span>arentElement.createTextChild(Common.UIString(', '));<span class="cstat-no" title="statement not covered" >p</span>arentElement.appendChild(invalidationNodes[1]);<span class="cstat-no" title="statement not covered" >p</span>arentElement.createTextChild(Common.UIString(', and %s others',invalidationNodes.length-2));}</span>}</span></span></span>
<span class="fstat-no" title="function not covered" >_c</span>reateInvalidationNode(invalidation,showUnknownNodes){const node=<span class="cstat-no" title="statement not covered" >(invalidation.nodeId&amp;&amp;this._relatedNodesMap)?this._relatedNodesMap.get(invalidation.nodeId):null;<span class="cstat-no" title="statement not covered" ></span>if(node){const nodeSpan=<span class="cstat-no" title="statement not covered" >createElement('span');<span class="cstat-no" title="statement not covered" ></span>Common.Linkifier.linkify(node).then(<span class="fstat-no" title="function not covered" >li</span>nk=&gt;<span class="cstat-no" title="statement not covered" >nodeSpan.appendChild(link))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn nodeSpan;}</span></span>
<span class="cstat-no" title="statement not covered" >if(invalidation.nodeName){const nodeSpan=<span class="cstat-no" title="statement not covered" >createElement('span');<span class="cstat-no" title="statement not covered" ></span>nodeSpan.textContent=Common.UIString('[ %s ]',invalidation.nodeName);<span class="cstat-no" title="statement not covered" >r</span>eturn nodeSpan;}</span></span>
<span class="cstat-no" title="statement not covered" >if(showUnknownNodes){const nodeSpan=<span class="cstat-no" title="statement not covered" >createElement('span');<span class="cstat-no" title="statement not covered" ></span>return nodeSpan.createTextChild(Common.UIString('[ unknown node ]'));}</span>}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._previewElementSymbol=Symbol('previewElement');<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineUIUtils.EventDispatchTypeDescriptor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(priority,color,eventTypes){<span class="cstat-no" title="statement not covered" >this.priority=priority;<span class="cstat-no" title="statement not covered" >t</span>his.color=color;<span class="cstat-no" title="statement not covered" >t</span>his.eventTypes=eventTypes;}</span>};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineCategory=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(name,title,visible,childColor,color){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.visible=visible;<span class="cstat-no" title="statement not covered" >t</span>his.childColor=childColor;<span class="cstat-no" title="statement not covered" >t</span>his.color=color;<span class="cstat-no" title="statement not covered" >t</span>his.hidden=false;}</span></span>
<span class="fstat-no" title="function not covered" >ge</span>t hidden(){<span class="cstat-no" title="statement not covered" >return this._hidden;}</span>
<span class="fstat-no" title="function not covered" >se</span>t hidden(hidden){<span class="cstat-no" title="statement not covered" >this._hidden=hidden;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(Timeline.TimelineCategory.Events.VisibilityChanged,this);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineCategory.Events={VisibilityChanged:Symbol('VisibilityChanged')};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineMarkerStyle;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePopupContentHelper=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(title){<span class="cstat-no" title="statement not covered" >this._contentTable=createElement('table');c</span>onst titleCell=<span class="cstat-no" title="statement not covered" >this._createCell(Common.UIString('%s - Details',title),'timeline-details-title');<span class="cstat-no" title="statement not covered" ></span>titleCell.colSpan=2;c</span>onst titleRow=<span class="cstat-no" title="statement not covered" >createElement('tr');<span class="cstat-no" title="statement not covered" ></span>titleRow.appendChild(titleCell);<span class="cstat-no" title="statement not covered" >t</span>his._contentTable.appendChild(titleRow);}</span></span>
<span class="fstat-no" title="function not covered" >co</span>ntentTable(){<span class="cstat-no" title="statement not covered" >return this._contentTable;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateCell(content,styleName){const text=<span class="cstat-no" title="statement not covered" >createElement('label');<span class="cstat-no" title="statement not covered" ></span>text.createTextChild(String(content));c</span>onst cell=<span class="cstat-no" title="statement not covered" >createElement('td');<span class="cstat-no" title="statement not covered" ></span>cell.className='timeline-details';<span class="cstat-no" title="statement not covered" >i</span>f(styleName)</span>
<span class="cstat-no" title="statement not covered" >cell.className+=' '+styleName;<span class="cstat-no" title="statement not covered" >c</span>ell.textContent=content;<span class="cstat-no" title="statement not covered" >r</span>eturn cell;}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendTextRow(title,content){const row=<span class="cstat-no" title="statement not covered" >createElement('tr');<span class="cstat-no" title="statement not covered" ></span>row.appendChild(this._createCell(title,'timeline-details-row-title'));<span class="cstat-no" title="statement not covered" >r</span>ow.appendChild(this._createCell(content,'timeline-details-row-data'));<span class="cstat-no" title="statement not covered" >t</span>his._contentTable.appendChild(row);}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendElementRow(title,content){const row=<span class="cstat-no" title="statement not covered" >createElement('tr');</span>const titleCell=<span class="cstat-no" title="statement not covered" >this._createCell(title,'timeline-details-row-title');<span class="cstat-no" title="statement not covered" ></span>row.appendChild(titleCell);c</span>onst cell=<span class="cstat-no" title="statement not covered" >createElement('td');<span class="cstat-no" title="statement not covered" ></span>cell.className='details';<span class="cstat-no" title="statement not covered" >i</span>f(content instanceof Node)</span>
<span class="cstat-no" title="statement not covered" >cell.appendChild(content);e</span>lse
<span class="cstat-no" title="statement not covered" >cell.createTextChild(content||'');<span class="cstat-no" title="statement not covered" >r</span>ow.appendChild(cell);<span class="cstat-no" title="statement not covered" >t</span>his._contentTable.appendChild(row);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineDetailsContentHelper=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(target,linkifier){<span class="cstat-no" title="statement not covered" >this.fragment=createDocumentFragment();<span class="cstat-no" title="statement not covered" >t</span>his._linkifier=linkifier;<span class="cstat-no" title="statement not covered" >t</span>his._target=target;<span class="cstat-no" title="statement not covered" >t</span>his.element=createElementWithClass('div','timeline-details-view-block');<span class="cstat-no" title="statement not covered" >t</span>his._tableElement=this.element.createChild('div','vbox timeline-details-chip-body');<span class="cstat-no" title="statement not covered" >t</span>his.fragment.appendChild(this.element);}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dSection(title,swatchColor){<span class="cstat-no" title="statement not covered" >if(!this._tableElement.hasChildNodes()){<span class="cstat-no" title="statement not covered" >this.element.removeChildren();}</span>else{<span class="cstat-no" title="statement not covered" >this.element=createElementWithClass('div','timeline-details-view-block');<span class="cstat-no" title="statement not covered" >t</span>his.fragment.appendChild(this.element);}</span></span>
<span class="cstat-no" title="statement not covered" >if(title){const titleElement=<span class="cstat-no" title="statement not covered" >this.element.createChild('div','timeline-details-chip-title');<span class="cstat-no" title="statement not covered" ></span>if(swatchColor)</span></span>
<span class="cstat-no" title="statement not covered" >titleElement.createChild('div').style.backgroundColor=swatchColor;<span class="cstat-no" title="statement not covered" >t</span>itleElement.createTextChild(title);}</span>
<span class="cstat-no" title="statement not covered" >this._tableElement=this.element.createChild('div','vbox timeline-details-chip-body');<span class="cstat-no" title="statement not covered" >t</span>his.fragment.appendChild(this.element);}</span>
<span class="fstat-no" title="function not covered" >li</span>nkifier(){<span class="cstat-no" title="statement not covered" >return this._linkifier;}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendTextRow(title,value){const rowElement=<span class="cstat-no" title="statement not covered" >this._tableElement.createChild('div','timeline-details-view-row');<span class="cstat-no" title="statement not covered" ></span>rowElement.createChild('div','timeline-details-view-row-title').textContent=title;<span class="cstat-no" title="statement not covered" >r</span>owElement.createChild('div','timeline-details-view-row-value').textContent=value;}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendElementRow(title,content,isWarning,isStacked){const rowElement=<span class="cstat-no" title="statement not covered" >this._tableElement.createChild('div','timeline-details-view-row');<span class="cstat-no" title="statement not covered" ></span>if(isWarning)</span>
<span class="cstat-no" title="statement not covered" >rowElement.classList.add('timeline-details-warning');<span class="cstat-no" title="statement not covered" >i</span>f(isStacked)</span>
<span class="cstat-no" title="statement not covered" >rowElement.classList.add('timeline-details-stack-values');c</span>onst titleElement=<span class="cstat-no" title="statement not covered" >rowElement.createChild('div','timeline-details-view-row-title');<span class="cstat-no" title="statement not covered" ></span>titleElement.textContent=title;c</span>onst valueElement=<span class="cstat-no" title="statement not covered" >rowElement.createChild('div','timeline-details-view-row-value');<span class="cstat-no" title="statement not covered" ></span>if(content instanceof Node)</span>
<span class="cstat-no" title="statement not covered" >valueElement.appendChild(content);e</span>lse
<span class="cstat-no" title="statement not covered" >valueElement.createTextChild(content||'');}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendLocationRow(title,url,startLine,startColumn){<span class="cstat-no" title="statement not covered" >if(!this._linkifier||!this._target)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst link=<span class="cstat-no" title="statement not covered" >this._linkifier.maybeLinkifyScriptLocation(this._target,null,url,startLine,startColumn);<span class="cstat-no" title="statement not covered" ></span>if(!link)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.appendElementRow(title,link);}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendLocationRange(title,url,startLine,endLine){<span class="cstat-no" title="statement not covered" >if(!this._linkifier||!this._target)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst locationContent=<span class="cstat-no" title="statement not covered" >createElement('span');</span>const link=<span class="cstat-no" title="statement not covered" >this._linkifier.maybeLinkifyScriptLocation(this._target,null,url,startLine);<span class="cstat-no" title="statement not covered" ></span>if(!link)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >l</span>ocationContent.appendChild(link);<span class="cstat-no" title="statement not covered" >l</span>ocationContent.createTextChild(String.sprintf(' [%s\u2026%s]',startLine+1,endLine+1||''));<span class="cstat-no" title="statement not covered" >t</span>his.appendElementRow(title,locationContent);}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendStackTrace(title,stackTrace){<span class="cstat-no" title="statement not covered" >if(!this._linkifier||!this._target)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst rowElement=<span class="cstat-no" title="statement not covered" >this._tableElement.createChild('div','timeline-details-view-row');<span class="cstat-no" title="statement not covered" ></span>rowElement.createChild('div','timeline-details-view-row-title').textContent=title;<span class="cstat-no" title="statement not covered" >t</span>his.createChildStackTraceElement(rowElement,stackTrace);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateChildStackTraceElement(parentElement,stackTrace){<span class="cstat-no" title="statement not covered" >if(!this._linkifier||!this._target)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span>arentElement.classList.add('timeline-details-stack-values');c</span>onst stackTraceElement=<span class="cstat-no" title="statement not covered" >parentElement.createChild('div','timeline-details-view-row-value timeline-details-view-row-stack-trace');</span>const callFrameContents=<span class="cstat-no" title="statement not covered" >Components.JSPresentationUtils.buildStackTracePreviewContents(this._target,this._linkifier,stackTrace);<span class="cstat-no" title="statement not covered" ></span>stackTraceElement.appendChild(callFrameContents.element);}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendWarningRow(event,warningType){const warning=<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils.eventWarning(event,warningType);<span class="cstat-no" title="statement not covered" ></span>if(warning)</span>
<span class="cstat-no" title="statement not covered" >this.appendElementRow(Common.UIString('Warning'),warning,true);}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineUIUtils._categoryBreakdownCacheSymbol=Symbol('categoryBreakdownCache');;<span class="cstat-no" title="statement not covered" ></span>Timeline.TimelineLayersView=class extends UI.SplitWidget{<span class="fstat-no" title="function not covered" >co</span>nstructor(model,showPaintProfilerCallback){<span class="cstat-no" title="statement not covered" >super(true,false,'timelineLayersView');<span class="cstat-no" title="statement not covered" >t</span>his._model=model;<span class="cstat-no" title="statement not covered" >t</span>his._showPaintProfilerCallback=showPaintProfilerCallback;<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('timeline-layers-view');<span class="cstat-no" title="statement not covered" >t</span>his._rightSplitWidget=new UI.SplitWidget(true,true,'timelineLayersViewDetails');<span class="cstat-no" title="statement not covered" >t</span>his._rightSplitWidget.element.classList.add('timeline-layers-view-properties');<span class="cstat-no" title="statement not covered" >t</span>his.setMainWidget(this._rightSplitWidget);c</span>onst vbox=<span class="cstat-no" title="statement not covered" >new UI.VBox();<span class="cstat-no" title="statement not covered" ></span>this.setSidebarWidget(vbox);<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost=new LayerViewer.LayerViewHost();c</span>onst layerTreeOutline=<span class="cstat-no" title="statement not covered" >new LayerViewer.LayerTreeOutline(this._layerViewHost);<span class="cstat-no" title="statement not covered" ></span>vbox.element.appendChild(layerTreeOutline.element);<span class="cstat-no" title="statement not covered" >t</span>his._layers3DView=new LayerViewer.Layers3DView(this._layerViewHost);<span class="cstat-no" title="statement not covered" >t</span>his._layers3DView.addEventListener(LayerViewer.Layers3DView.Events.PaintProfilerRequested,this._onPaintProfilerRequested,this);<span class="cstat-no" title="statement not covered" >t</span>his._rightSplitWidget.setMainWidget(this._layers3DView);c</span>onst layerDetailsView=<span class="cstat-no" title="statement not covered" >new LayerViewer.LayerDetailsView(this._layerViewHost);<span class="cstat-no" title="statement not covered" ></span>this._rightSplitWidget.setSidebarWidget(layerDetailsView);<span class="cstat-no" title="statement not covered" >l</span>ayerDetailsView.addEventListener(LayerViewer.LayerDetailsView.Events.PaintProfilerRequested,this._onPaintProfilerRequested,this);}</span></span>
<span class="fstat-no" title="function not covered" >sh</span>owLayerTree(frameLayerTree){<span class="cstat-no" title="statement not covered" >this._frameLayerTree=frameLayerTree;<span class="cstat-no" title="statement not covered" >i</span>f(this.isShowing())</span>
<span class="cstat-no" title="statement not covered" >this._update();e</span>lse
<span class="cstat-no" title="statement not covered" >this._updateWhenVisible=true;}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >if(this._updateWhenVisible){<span class="cstat-no" title="statement not covered" >this._updateWhenVisible=false;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>}</span>
<span class="fstat-no" title="function not covered" >_o</span>nPaintProfilerRequested(event){const selection=(<span class="cstat-no" title="statement not covered" >event.data)</span>;<span class="cstat-no" title="statement not covered" >this._layers3DView.snapshotForSelection(selection).then(<span class="fstat-no" title="function not covered" >sn</span>apshotWithRect=&gt;{<span class="cstat-no" title="statement not covered" >if(snapshotWithRect)</span></span>
<span class="cstat-no" title="statement not covered" >this._showPaintProfilerCallback(snapshotWithRect.snapshot);}</span>);}
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >this._frameLayerTree.layerTreePromise().then(<span class="fstat-no" title="function not covered" >la</span>yerTree=&gt;<span class="cstat-no" title="statement not covered" >this._layerViewHost.setLayerTree(layerTree))</span>;}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.TimelinePaintProfilerView=class extends UI.SplitWidget{<span class="fstat-no" title="function not covered" >co</span>nstructor(frameModel){<span class="cstat-no" title="statement not covered" >super(false,false);<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('timeline-paint-profiler-view');<span class="cstat-no" title="statement not covered" >t</span>his.setSidebarSize(60);<span class="cstat-no" title="statement not covered" >t</span>his.setResizable(false);<span class="cstat-no" title="statement not covered" >t</span>his._frameModel=frameModel;<span class="cstat-no" title="statement not covered" >t</span>his._logAndImageSplitWidget=new UI.SplitWidget(true,false);<span class="cstat-no" title="statement not covered" >t</span>his._logAndImageSplitWidget.element.classList.add('timeline-paint-profiler-log-split');<span class="cstat-no" title="statement not covered" >t</span>his.setMainWidget(this._logAndImageSplitWidget);<span class="cstat-no" title="statement not covered" >t</span>his._imageView=new Timeline.TimelinePaintImageView();<span class="cstat-no" title="statement not covered" >t</span>his._logAndImageSplitWidget.setMainWidget(this._imageView);<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerView=new LayerViewer.PaintProfilerView(this._imageView.showImage.bind(this._imageView));<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerView.addEventListener(LayerViewer.PaintProfilerView.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his.setSidebarWidget(this._paintProfilerView);<span class="cstat-no" title="statement not covered" >t</span>his._logTreeView=new LayerViewer.PaintProfilerCommandLogView();<span class="cstat-no" title="statement not covered" >t</span>his._logAndImageSplitWidget.setSidebarWidget(this._logTreeView);<span class="cstat-no" title="statement not covered" >t</span>his._needsUpdateWhenVisible=false;<span class="cstat-no" title="statement not covered" >t</span>his._pendingSnapshot=null;<span class="cstat-no" title="statement not covered" >t</span>his._event=null;<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastLoadedSnapshot=null;}</span></span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >if(this._needsUpdateWhenVisible){<span class="cstat-no" title="statement not covered" >this._needsUpdateWhenVisible=false;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>}</span>
<span class="fstat-no" title="function not covered" >se</span>tSnapshot(snapshot){<span class="cstat-no" title="statement not covered" >this._releaseSnapshot();<span class="cstat-no" title="statement not covered" >t</span>his._pendingSnapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._event=null;<span class="cstat-no" title="statement not covered" >t</span>his._updateWhenVisible();}</span>
<span class="fstat-no" title="function not covered" >se</span>tEvent(paintProfilerModel,event){<span class="cstat-no" title="statement not covered" >this._releaseSnapshot();<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerModel=paintProfilerModel;<span class="cstat-no" title="statement not covered" >t</span>his._pendingSnapshot=null;<span class="cstat-no" title="statement not covered" >t</span>his._event=event;<span class="cstat-no" title="statement not covered" >t</span>his._updateWhenVisible();<span class="cstat-no" title="statement not covered" >i</span>f(this._event.name===TimelineModel.TimelineModel.RecordType.Paint)</span>
<span class="cstat-no" title="statement not covered" >return!!TimelineModel.TimelineData.forEvent(event).picture;<span class="cstat-no" title="statement not covered" >i</span>f(this._event.name===TimelineModel.TimelineModel.RecordType.RasterTask)</span>
<span class="cstat-no" title="statement not covered" >return this._frameModel.hasRasterTile(this._event);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateWhenVisible(){<span class="cstat-no" title="statement not covered" >if(this.isShowing())</span>
<span class="cstat-no" title="statement not covered" >this._update();e</span>lse
<span class="cstat-no" title="statement not covered" >this._needsUpdateWhenVisible=true;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >this._logTreeView.setCommandLog([]);<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerView.setSnapshotAndLog(null,[],null);l</span>et snapshotPromise;<span class="cstat-no" title="statement not covered" >if(this._pendingSnapshot){<span class="cstat-no" title="statement not covered" >snapshotPromise=Promise.resolve({rect:null,snapshot:this._pendingSnapshot});}</span>else <span class="cstat-no" title="statement not covered" >if(this._event.name===TimelineModel.TimelineModel.RecordType.Paint){const picture=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineData.forEvent(this._event).picture;<span class="cstat-no" title="statement not covered" ></span>snapshotPromise=picture.objectPromise().then(<span class="fstat-no" title="function not covered" >da</span>ta=&gt;<span class="cstat-no" title="statement not covered" >this._paintProfilerModel.loadSnapshot(data['skp64']))</span>.then(<span class="fstat-no" title="function not covered" >sn</span>apshot=&gt;<span class="cstat-no" title="statement not covered" >snapshot&amp;&amp;{rect:null,snapshot:snapshot})</span>;}</span>else <span class="cstat-no" title="statement not covered" >if(this._event.name===TimelineModel.TimelineModel.RecordType.RasterTask){<span class="cstat-no" title="statement not covered" >snapshotPromise=this._frameModel.rasterTilePromise(this._event);}</span>else{<span class="cstat-no" title="statement not covered" >console.assert(false,'Unexpected event type or no snapshot');<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >snapshotPromise.then(<span class="fstat-no" title="function not covered" >sn</span>apshotWithRect=&gt;{<span class="cstat-no" title="statement not covered" >this._releaseSnapshot();<span class="cstat-no" title="statement not covered" >i</span>f(!snapshotWithRect){<span class="cstat-no" title="statement not covered" >this._imageView.showImage();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
const snapshot=<span class="cstat-no" title="statement not covered" >snapshotWithRect.snapshot;<span class="cstat-no" title="statement not covered" ></span>this._lastLoadedSnapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._imageView.setMask(snapshotWithRect.rect);<span class="cstat-no" title="statement not covered" >s</span>napshot.commandLog().then(<span class="fstat-no" title="function not covered" >lo</span>g=&gt;<span class="cstat-no" title="statement not covered" >onCommandLogDone.call(this,snapshot,snapshotWithRect.rect,log))</span>;}</span>);function <span class="fstat-no" title="function not covered" >onCommandLogDone(</span>snapshot,clipRect,log){<span class="cstat-no" title="statement not covered" >this._logTreeView.setCommandLog(log||[]);<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerView.setSnapshotAndLog(snapshot,log||[],clipRect);}</span>}
<span class="fstat-no" title="function not covered" >_r</span>eleaseSnapshot(){<span class="cstat-no" title="statement not covered" >if(!this._lastLoadedSnapshot)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._lastLoadedSnapshot.release();<span class="cstat-no" title="statement not covered" >t</span>his._lastLoadedSnapshot=null;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(){<span class="cstat-no" title="statement not covered" >this._logTreeView.updateWindow(this._paintProfilerView.selectionWindow());}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelinePaintImageView=class extends UI.Widget{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('timeline/timelinePaintProfiler.css');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.add('fill','paint-profiler-image-view');<span class="cstat-no" title="statement not covered" >t</span>his._imageContainer=this.contentElement.createChild('div','paint-profiler-image-container');<span class="cstat-no" title="statement not covered" >t</span>his._imageElement=this._imageContainer.createChild('img');<span class="cstat-no" title="statement not covered" >t</span>his._maskElement=this._imageContainer.createChild('div');<span class="cstat-no" title="statement not covered" >t</span>his._imageElement.addEventListener('load',this._updateImagePosition.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._transformController=new LayerViewer.TransformController(this.contentElement,true);<span class="cstat-no" title="statement not covered" >t</span>his._transformController.addEventListener(LayerViewer.TransformController.Events.TransformChanged,this._updateImagePosition,this);}</span></span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >if(this._imageElement.src)</span>
<span class="cstat-no" title="statement not covered" >this._updateImagePosition();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateImagePosition(){const width=<span class="cstat-no" title="statement not covered" >this._imageElement.naturalWidth;</span>const height=<span class="cstat-no" title="statement not covered" >this._imageElement.naturalHeight;</span>const clientWidth=<span class="cstat-no" title="statement not covered" >this.contentElement.clientWidth;</span>const clientHeight=<span class="cstat-no" title="statement not covered" >this.contentElement.clientHeight;</span>const paddingFraction=<span class="cstat-no" title="statement not covered" >0.1;</span>const paddingX=<span class="cstat-no" title="statement not covered" >clientWidth*paddingFraction;</span>const paddingY=<span class="cstat-no" title="statement not covered" >clientHeight*paddingFraction;</span>const scaleX=<span class="cstat-no" title="statement not covered" >(clientWidth-paddingX)/width;</span>const scaleY=<span class="cstat-no" title="statement not covered" >(clientHeight-paddingY)/height;</span>const scale=<span class="cstat-no" title="statement not covered" >Math.min(scaleX,scaleY);<span class="cstat-no" title="statement not covered" ></span>if(this._maskRectangle){const style=<span class="cstat-no" title="statement not covered" >this._maskElement.style;<span class="cstat-no" title="statement not covered" ></span>style.width=width+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.height=height+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.borderLeftWidth=this._maskRectangle.x+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.borderTopWidth=this._maskRectangle.y+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.borderRightWidth=(width-this._maskRectangle.x-this._maskRectangle.width)+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.borderBottomWidth=(height-this._maskRectangle.y-this._maskRectangle.height)+'px';}</span></span>
<span class="cstat-no" title="statement not covered" >this._transformController.setScaleConstraints(0.5,10/scale);l</span>et matrix=<span class="cstat-no" title="statement not covered" >new WebKitCSSMatrix().scale(this._transformController.scale(),this._transformController.scale()).translate(clientWidth/2,clientHeight/2).scale(scale,scale).translate(-width/2,-height/2);</span>const bounds=<span class="cstat-no" title="statement not covered" >UI.Geometry.boundsForTransformedPoints(matrix,[0,0,0,width,height,0]);<span class="cstat-no" title="statement not covered" ></span>this._transformController.clampOffsets(paddingX-bounds.maxX,clientWidth-paddingX-bounds.minX,paddingY-bounds.maxY,clientHeight-paddingY-bounds.minY);<span class="cstat-no" title="statement not covered" >m</span>atrix=new WebKitCSSMatrix().translate(this._transformController.offsetX(),this._transformController.offsetY()).multiply(matrix);<span class="cstat-no" title="statement not covered" >t</span>his._imageContainer.style.webkitTransform=matrix.toString();}</span>
<span class="fstat-no" title="function not covered" >sh</span>owImage(imageURL){<span class="cstat-no" title="statement not covered" >this._imageContainer.classList.toggle('hidden',!imageURL);<span class="cstat-no" title="statement not covered" >i</span>f(imageURL)</span>
<span class="cstat-no" title="statement not covered" >this._imageElement.src=imageURL;}</span>
<span class="fstat-no" title="function not covered" >se</span>tMask(maskRectangle){<span class="cstat-no" title="statement not covered" >this._maskRectangle=maskRectangle;<span class="cstat-no" title="statement not covered" >t</span>his._maskElement.classList.toggle('hidden',!maskRectangle);}</span>};;<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel=class extends UI.Panel{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super('timeline');<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('timeline/timelinePanel.css');<span class="cstat-no" title="statement not covered" >t</span>his.element.addEventListener('contextmenu',this._contextMenu.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._dropTarget=new UI.DropTarget(this.element,[UI.DropTarget.Type.File,UI.DropTarget.Type.URI],Common.UIString('Drop timeline file or URL here'),this._handleDrop.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._recordingOptionUIControls=[];<span class="cstat-no" title="statement not covered" >t</span>his._state=Timeline.TimelinePanel.State.Idle;<span class="cstat-no" title="statement not covered" >t</span>his._recordingPageReload=false;<span class="cstat-no" title="statement not covered" >t</span>his._millisecondsToRecordAfterLoadEvent=3000;<span class="cstat-no" title="statement not covered" >t</span>his._toggleRecordAction=(UI.actionRegistry.action('timeline.toggle-recording'));<span class="cstat-no" title="statement not covered" >t</span>his._recordReloadAction=(UI.actionRegistry.action('timeline.record-reload'));<span class="cstat-no" title="statement not covered" >t</span>his._historyManager=new Timeline.TimelineHistoryManager();<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=null;<span class="cstat-no" title="statement not covered" >t</span>his._viewModeSetting=Common.settings.createSetting('timelineViewMode',Timeline.TimelinePanel.ViewMode.FlameChart);<span class="cstat-no" title="statement not covered" >t</span>his._disableCaptureJSProfileSetting=Common.settings.createSetting('timelineDisableJSSampling',false);<span class="cstat-no" title="statement not covered" >t</span>his._disableCaptureJSProfileSetting.setTitle(Common.UIString('Disable JavaScript samples'));<span class="cstat-no" title="statement not covered" >t</span>his._captureLayersAndPicturesSetting=Common.settings.createSetting('timelineCaptureLayersAndPictures',false);<span class="cstat-no" title="statement not covered" >t</span>his._captureLayersAndPicturesSetting.setTitle(Common.UIString('Enable advanced paint instrumentation (slow)'));<span class="cstat-no" title="statement not covered" >t</span>his._showScreenshotsSetting=Common.settings.createSetting('timelineShowScreenshots',true);<span class="cstat-no" title="statement not covered" >t</span>his._showScreenshotsSetting.setTitle(Common.UIString('Screenshots'));<span class="cstat-no" title="statement not covered" >t</span>his._showScreenshotsSetting.addChangeListener(this._updateOverviewControls,this);<span class="cstat-no" title="statement not covered" >t</span>his._showMemorySetting=Common.settings.createSetting('timelineShowMemory',false);<span class="cstat-no" title="statement not covered" >t</span>his._showMemorySetting.setTitle(Common.UIString('Memory'));<span class="cstat-no" title="statement not covered" >t</span>his._showMemorySetting.addChangeListener(this._onModeChanged,this);c</span>onst timelineToolbarContainer=<span class="cstat-no" title="statement not covered" >this.element.createChild('div','timeline-toolbar-container');<span class="cstat-no" title="statement not covered" ></span>this._panelToolbar=new UI.Toolbar('timeline-main-toolbar',timelineToolbarContainer);<span class="cstat-no" title="statement not covered" >t</span>his._panelRightToolbar=new UI.Toolbar('',timelineToolbarContainer);<span class="cstat-no" title="statement not covered" >t</span>his._createSettingsPane();<span class="cstat-no" title="statement not covered" >t</span>his._updateShowSettingsToolbarButton();<span class="cstat-no" title="statement not covered" >t</span>his._timelinePane=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._timelinePane.show(this.element);c</span>onst topPaneElement=<span class="cstat-no" title="statement not covered" >this._timelinePane.element.createChild('div','hbox');<span class="cstat-no" title="statement not covered" ></span>topPaneElement.id='timeline-overview-panel';<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane=new PerfUI.TimelineOverviewPane('timeline');<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.addEventListener(PerfUI.TimelineOverviewPane.Events.WindowChanged,this._onOverviewWindowChanged.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.show(topPaneElement);<span class="cstat-no" title="statement not covered" >t</span>his._overviewControls=[];<span class="cstat-no" title="statement not covered" >t</span>his._statusPaneContainer=this._timelinePane.element.createChild('div','status-pane-container fill');<span class="cstat-no" title="statement not covered" >t</span>his._createFileSelector();<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addModelListener(SDK.ResourceTreeModel,SDK.ResourceTreeModel.Events.Load,this._loadEventFired,this);<span class="cstat-no" title="statement not covered" >t</span>his._flameChart=new Timeline.TimelineFlameChartView(this);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView=new UI.SearchableView(this._flameChart);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.setMinimumSize(0,100);<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.element.classList.add('searchable-view');<span class="cstat-no" title="statement not covered" >t</span>his._searchableView.show(this._timelinePane.element);<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.show(this._searchableView.element);<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.setSearchableView(this._searchableView);<span class="cstat-no" title="statement not covered" >t</span>his._onModeChanged();<span class="cstat-no" title="statement not covered" >t</span>his._populateToolbar();<span class="cstat-no" title="statement not covered" >t</span>his._showLandingPage();<span class="cstat-no" title="statement not covered" >t</span>his._updateTimelineControls();<span class="cstat-no" title="statement not covered" >E</span>xtensions.extensionServer.addEventListener(Extensions.ExtensionServer.Events.TraceProviderAdded,this._appendExtensionsToToolbar,this);<span class="cstat-no" title="statement not covered" >S</span>DK.targetManager.addEventListener(SDK.TargetManager.Events.SuspendStateChanged,this._onSuspendStateChanged,this);}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic instance(){<span class="cstat-no" title="statement not covered" >return(self.runtime.sharedInstance(Timeline.TimelinePanel));}</span>
<span class="fstat-no" title="function not covered" >se</span>archableView(){<span class="cstat-no" title="statement not covered" >return this._searchableView;}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >UI.context.setFlavor(Timeline.TimelinePanel,this);}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >UI.context.setFlavor(Timeline.TimelinePanel,null);<span class="cstat-no" title="statement not covered" >t</span>his._historyManager.cancelIfShowing();}</span>
<span class="fstat-no" title="function not covered" >lo</span>adFromEvents(events){<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelinePanel.State.Idle)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._prepareToLoadTimeline();<span class="cstat-no" title="statement not covered" >t</span>his._loader=Timeline.TimelineLoader.loadFromEvents(events,this);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nOverviewWindowChanged(event){const left=<span class="cstat-no" title="statement not covered" >event.data.startTime;</span>const right=<span class="cstat-no" title="statement not covered" >event.data.endTime;<span class="cstat-no" title="statement not covered" ></span>this._performanceModel.setWindow({left,right},true);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nModelWindowChanged(event){const window=(<span class="cstat-no" title="statement not covered" >event.data.window)</span>;<span class="cstat-no" title="statement not covered" >this._overviewPane.setWindowTimes(window.left,window.right);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etState(state){<span class="cstat-no" title="statement not covered" >this._state=state;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimelineControls();}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateSettingCheckbox(setting,tooltip){const checkboxItem=<span class="cstat-no" title="statement not covered" >new UI.ToolbarSettingCheckbox(setting,tooltip);<span class="cstat-no" title="statement not covered" ></span>this._recordingOptionUIControls.push(checkboxItem);<span class="cstat-no" title="statement not covered" >r</span>eturn checkboxItem;}</span>
<span class="fstat-no" title="function not covered" >_p</span>opulateToolbar(){<span class="cstat-no" title="statement not covered" >this._panelToolbar.appendToolbarItem(UI.Toolbar.createActionButton(this._toggleRecordAction));<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(UI.Toolbar.createActionButton(this._recordReloadAction));<span class="cstat-no" title="statement not covered" >t</span>his._clearButton=new UI.ToolbarButton(Common.UIString('Clear'),'largeicon-clear');<span class="cstat-no" title="statement not covered" >t</span>his._clearButton.addEventListener(UI.ToolbarButton.Events.Click,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._onClearButton())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(this._clearButton);<span class="cstat-no" title="statement not covered" >t</span>his._loadButton=new UI.ToolbarButton(Common.UIString('Load profile...'),'largeicon-load');<span class="cstat-no" title="statement not covered" >t</span>his._loadButton.addEventListener(UI.ToolbarButton.Events.Click,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._selectFileToLoad())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._saveButton=new UI.ToolbarButton(Common.UIString('Save profile...'),'largeicon-download');<span class="cstat-no" title="statement not covered" >t</span>his._saveButton.addEventListener(UI.ToolbarButton.Events.Click,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._saveToFile())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendSeparator();<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(this._loadButton);<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(this._saveButton);<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendSeparator();<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(this._historyManager.button());<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendSeparator();<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendSeparator();<span class="cstat-no" title="statement not covered" >t</span>his._showScreenshotsToolbarCheckbox=this._createSettingCheckbox(this._showScreenshotsSetting,Common.UIString('Capture screenshots'));<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(this._showScreenshotsToolbarCheckbox);<span class="cstat-no" title="statement not covered" >t</span>his._showMemoryToolbarCheckbox=this._createSettingCheckbox(this._showMemorySetting,Common.UIString('Show memory timeline'));<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(this._showMemoryToolbarCheckbox);<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.appendToolbarItem(UI.Toolbar.createActionButtonForId('components.collect-garbage'));<span class="cstat-no" title="statement not covered" >t</span>his._panelRightToolbar.appendSeparator();<span class="cstat-no" title="statement not covered" >t</span>his._panelRightToolbar.appendToolbarItem(this._showSettingsPaneButton);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateSettingsPane(){<span class="cstat-no" title="statement not covered" >this._showSettingsPaneSetting=Common.settings.createSetting('timelineShowSettingsToolbar',false);<span class="cstat-no" title="statement not covered" >t</span>his._showSettingsPaneButton=new UI.ToolbarSettingToggle(this._showSettingsPaneSetting,'largeicon-settings-gear',Common.UIString('Capture settings'));<span class="cstat-no" title="statement not covered" >S</span>DK.multitargetNetworkManager.addEventListener(SDK.MultitargetNetworkManager.Events.ConditionsChanged,this._updateShowSettingsToolbarButton,this);<span class="cstat-no" title="statement not covered" >M</span>obileThrottling.throttlingManager().addEventListener(MobileThrottling.ThrottlingManager.Events.RateChanged,this._updateShowSettingsToolbarButton,this);<span class="cstat-no" title="statement not covered" >t</span>his._disableCaptureJSProfileSetting.addChangeListener(this._updateShowSettingsToolbarButton,this);<span class="cstat-no" title="statement not covered" >t</span>his._captureLayersAndPicturesSetting.addChangeListener(this._updateShowSettingsToolbarButton,this);<span class="cstat-no" title="statement not covered" >t</span>his._settingsPane=new UI.HBox();<span class="cstat-no" title="statement not covered" >t</span>his._settingsPane.element.classList.add('timeline-settings-pane');<span class="cstat-no" title="statement not covered" >t</span>his._settingsPane.show(this.element);c</span>onst captureToolbar=<span class="cstat-no" title="statement not covered" >new UI.Toolbar('',this._settingsPane.element);<span class="cstat-no" title="statement not covered" ></span>captureToolbar.element.classList.add('flex-auto');<span class="cstat-no" title="statement not covered" >c</span>aptureToolbar.makeVertical();<span class="cstat-no" title="statement not covered" >c</span>aptureToolbar.appendToolbarItem(this._createSettingCheckbox(this._disableCaptureJSProfileSetting,Common.UIString('Disables JavaScript sampling, reduces overhead when running against mobile devices')));<span class="cstat-no" title="statement not covered" >c</span>aptureToolbar.appendToolbarItem(this._createSettingCheckbox(this._captureLayersAndPicturesSetting,Common.UIString('Captures advanced paint instrumentation, introduces significant performance overhead')));c</span>onst throttlingPane=<span class="cstat-no" title="statement not covered" >new UI.VBox();<span class="cstat-no" title="statement not covered" ></span>throttlingPane.element.classList.add('flex-auto');<span class="cstat-no" title="statement not covered" >t</span>hrottlingPane.show(this._settingsPane.element);c</span>onst networkThrottlingToolbar=<span class="cstat-no" title="statement not covered" >new UI.Toolbar('',throttlingPane.element);<span class="cstat-no" title="statement not covered" ></span>networkThrottlingToolbar.appendText(Common.UIString('Network:'));<span class="cstat-no" title="statement not covered" >t</span>his._networkThrottlingSelect=this._createNetworkConditionsSelect();<span class="cstat-no" title="statement not covered" >n</span>etworkThrottlingToolbar.appendToolbarItem(this._networkThrottlingSelect);c</span>onst cpuThrottlingToolbar=<span class="cstat-no" title="statement not covered" >new UI.Toolbar('',throttlingPane.element);<span class="cstat-no" title="statement not covered" ></span>cpuThrottlingToolbar.appendText(Common.UIString('CPU:'));<span class="cstat-no" title="statement not covered" >t</span>his._cpuThrottlingSelect=MobileThrottling.throttlingManager().createCPUThrottlingSelector();<span class="cstat-no" title="statement not covered" >c</span>puThrottlingToolbar.appendToolbarItem(this._cpuThrottlingSelect);<span class="cstat-no" title="statement not covered" >t</span>his._showSettingsPaneSetting.addChangeListener(this._updateSettingsPaneVisibility.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._updateSettingsPaneVisibility();}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendExtensionsToToolbar(event){const provider=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const setting=<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel._settingForTraceProvider(provider);</span>const checkbox=<span class="cstat-no" title="statement not covered" >this._createSettingCheckbox(setting,provider.longDisplayName());<span class="cstat-no" title="statement not covered" ></span>this._panelToolbar.appendToolbarItem(checkbox);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _settingForTraceProvider(traceProvider){let setting=<span class="cstat-no" title="statement not covered" >traceProvider[Timeline.TimelinePanel._traceProviderSettingSymbol];<span class="cstat-no" title="statement not covered" ></span>if(!setting){const providerId=<span class="cstat-no" title="statement not covered" >traceProvider.persistentIdentifier();<span class="cstat-no" title="statement not covered" ></span>setting=Common.settings.createSetting(providerId,false);<span class="cstat-no" title="statement not covered" >s</span>etting.setTitle(traceProvider.shortDisplayName());<span class="cstat-no" title="statement not covered" >t</span>raceProvider[Timeline.TimelinePanel._traceProviderSettingSymbol]=setting;}</span></span>
<span class="cstat-no" title="statement not covered" >return setting;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateNetworkConditionsSelect(){const toolbarItem=<span class="cstat-no" title="statement not covered" >new UI.ToolbarComboBox(null);<span class="cstat-no" title="statement not covered" ></span>toolbarItem.setMaxWidth(140);<span class="cstat-no" title="statement not covered" >M</span>obileThrottling.throttlingManager().decorateSelectWithNetworkThrottling(toolbarItem.selectElement());<span class="cstat-no" title="statement not covered" >r</span>eturn toolbarItem;}</span>
<span class="fstat-no" title="function not covered" >_p</span>repareToLoadTimeline(){<span class="cstat-no" title="statement not covered" >console.assert(this._state===Timeline.TimelinePanel.State.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._setState(Timeline.TimelinePanel.State.Loading);<span class="cstat-no" title="statement not covered" >i</span>f(this._performanceModel){<span class="cstat-no" title="statement not covered" >this._performanceModel.dispose();<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=null;}</span>}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateFileSelector(){<span class="cstat-no" title="statement not covered" >if(this._fileSelectorElement)</span>
<span class="cstat-no" title="statement not covered" >this._fileSelectorElement.remove();<span class="cstat-no" title="statement not covered" >t</span>his._fileSelectorElement=UI.createFileSelectorElement(this._loadFromFile.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._timelinePane.element.appendChild(this._fileSelectorElement);}</span>
<span class="fstat-no" title="function not covered" >_c</span>ontextMenu(event){const contextMenu=<span class="cstat-no" title="statement not covered" >new UI.ContextMenu(event);<span class="cstat-no" title="statement not covered" ></span>contextMenu.appendItemsAtLocation('timelineMenu');<span class="cstat-no" title="statement not covered" >c</span>ontextMenu.show();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _saveToFile(){<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelinePanel.State.Idle)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst performanceModel=<span class="cstat-no" title="statement not covered" >this._performanceModel;<span class="cstat-no" title="statement not covered" ></span>if(!performanceModel)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst now=<span class="cstat-no" title="statement not covered" >new Date();</span>const fileName=<span class="cstat-no" title="statement not covered" >'Profile-'+now.toISO8601Compact()+'.json';</span>const stream=<span class="cstat-no" title="statement not covered" >new Bindings.FileOutputStream();</span>const accepted=<span class="cstat-no" title="statement not covered" >await stream.open(fileName);<span class="cstat-no" title="statement not covered" ></span>if(!accepted)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst error=<span class="cstat-no" title="statement not covered" >await performanceModel.save(stream);<span class="cstat-no" title="statement not covered" ></span>if(!error)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >C</span>ommon.console.error(Common.UIString('Failed to save timeline: %s (%s, %s)',error.message,error.name,error.code));}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _showHistory(){const model=<span class="cstat-no" title="statement not covered" >await this._historyManager.showHistoryDropDown();<span class="cstat-no" title="statement not covered" ></span>if(model&amp;&amp;model!==this._performanceModel)</span>
<span class="cstat-no" title="statement not covered" >this._setModel(model);}</span>
<span class="fstat-no" title="function not covered" >_n</span>avigateHistory(direction){const model=<span class="cstat-no" title="statement not covered" >this._historyManager.navigate(direction);<span class="cstat-no" title="statement not covered" ></span>if(model&amp;&amp;model!==this._performanceModel)</span>
<span class="cstat-no" title="statement not covered" >this._setModel(model);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_s</span>electFileToLoad(){<span class="cstat-no" title="statement not covered" >this._fileSelectorElement.click();}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadFromFile(file){<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelinePanel.State.Idle)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._prepareToLoadTimeline();<span class="cstat-no" title="statement not covered" >t</span>his._loader=Timeline.TimelineLoader.loadFromFile(file,this);<span class="cstat-no" title="statement not covered" >t</span>his._createFileSelector();}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadFromURL(url){<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelinePanel.State.Idle)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._prepareToLoadTimeline();<span class="cstat-no" title="statement not covered" >t</span>his._loader=Timeline.TimelineLoader.loadFromURL(url,this);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateOverviewControls(){<span class="cstat-no" title="statement not covered" >this._overviewControls=[];<span class="cstat-no" title="statement not covered" >t</span>his._overviewControls.push(new Timeline.TimelineEventOverviewResponsiveness());<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.experiments.isEnabled('inputEventsOnTimelineOverview'))</span>
<span class="cstat-no" title="statement not covered" >this._overviewControls.push(new Timeline.TimelineEventOverviewInput());<span class="cstat-no" title="statement not covered" >t</span>his._overviewControls.push(new Timeline.TimelineEventOverviewFrames());<span class="cstat-no" title="statement not covered" >t</span>his._overviewControls.push(new Timeline.TimelineEventOverviewCPUActivity());<span class="cstat-no" title="statement not covered" >t</span>his._overviewControls.push(new Timeline.TimelineEventOverviewNetwork());<span class="cstat-no" title="statement not covered" >i</span>f(this._showScreenshotsSetting.get()&amp;&amp;this._performanceModel&amp;&amp;this._performanceModel.filmStripModel().frames().length)</span>
<span class="cstat-no" title="statement not covered" >this._overviewControls.push(new Timeline.TimelineFilmStripOverview());<span class="cstat-no" title="statement not covered" >i</span>f(this._showMemorySetting.get())</span>
<span class="cstat-no" title="statement not covered" >this._overviewControls.push(new Timeline.TimelineEventOverviewMemory());<span class="cstat-no" title="statement not covered" >f</span>or(const control of this._overviewControls)</span>
<span class="cstat-no" title="statement not covered" >control.setModel(this._performanceModel);<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.setOverviewControls(this._overviewControls);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nModeChanged(){<span class="cstat-no" title="statement not covered" >this._updateOverviewControls();<span class="cstat-no" title="statement not covered" >t</span>his.doResize();<span class="cstat-no" title="statement not covered" >t</span>his.select(null);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateSettingsPaneVisibility(){<span class="cstat-no" title="statement not covered" >if(this._showSettingsPaneSetting.get())</span>
<span class="cstat-no" title="statement not covered" >this._settingsPane.showWidget();e</span>lse
<span class="cstat-no" title="statement not covered" >this._settingsPane.hideWidget();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateShowSettingsToolbarButton(){const messages=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(MobileThrottling.throttlingManager().cpuThrottlingRate()!==1)</span>
<span class="cstat-no" title="statement not covered" >messages.push(Common.UIString('- CPU throttling is enabled'));<span class="cstat-no" title="statement not covered" >i</span>f(SDK.multitargetNetworkManager.isThrottling())</span>
<span class="cstat-no" title="statement not covered" >messages.push(Common.UIString('- Network throttling is enabled'));<span class="cstat-no" title="statement not covered" >i</span>f(this._captureLayersAndPicturesSetting.get())</span>
<span class="cstat-no" title="statement not covered" >messages.push(Common.UIString('- Significant overhead due to paint instrumentation'));<span class="cstat-no" title="statement not covered" >i</span>f(this._disableCaptureJSProfileSetting.get())</span>
<span class="cstat-no" title="statement not covered" >messages.push(Common.UIString('- JavaScript sampling is disabled'));<span class="cstat-no" title="statement not covered" >t</span>his._showSettingsPaneButton.setDefaultWithRedColor(messages.length);<span class="cstat-no" title="statement not covered" >t</span>his._showSettingsPaneButton.setToggleWithRedColor(messages.length);<span class="cstat-no" title="statement not covered" >i</span>f(messages.length){const tooltipElement=<span class="cstat-no" title="statement not covered" >createElement('div');<span class="cstat-no" title="statement not covered" ></span>messages.forEach(<span class="fstat-no" title="function not covered" >me</span>ssage=&gt;{<span class="cstat-no" title="statement not covered" >tooltipElement.createChild('div').textContent=message;}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._showSettingsPaneButton.setTitle(tooltipElement);}</span>else{<span class="cstat-no" title="statement not covered" >this._showSettingsPaneButton.setTitle(Common.UIString('Capture settings'));}</span>}</span>
<span class="fstat-no" title="function not covered" >_s</span>etUIControlsEnabled(enabled){<span class="cstat-no" title="statement not covered" >this._recordingOptionUIControls.forEach(<span class="fstat-no" title="function not covered" >co</span>ntrol=&gt;<span class="cstat-no" title="statement not covered" >control.setEnabled(enabled))</span>;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _startRecording(){<span class="cstat-no" title="statement not covered" >console.assert(!this._statusPane,'Status pane is already opened.');<span class="cstat-no" title="statement not covered" >t</span>his._setState(Timeline.TimelinePanel.State.StartPending);<span class="cstat-no" title="statement not covered" >t</span>his._showRecordingStarted();c</span>onst enabledTraceProviders=<span class="cstat-no" title="statement not covered" >Extensions.extensionServer.traceProviders().filter(<span class="fstat-no" title="function not covered" >pr</span>ovider=&gt;<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel._settingForTraceProvider(provider).get())</span>;</span>const recordingOptions=<span class="cstat-no" title="statement not covered" >{enableJSSampling:!this._disableCaptureJSProfileSetting.get(),capturePictures:this._captureLayersAndPicturesSetting.get(),captureFilmStrip:this._showScreenshotsSetting.get()};</span>const mainTarget=(<span class="cstat-no" title="statement not covered" >SDK.targetManager.mainTarget())</span>;<span class="cstat-no" title="statement not covered" >this._controller=new Timeline.TimelineController(mainTarget,this);<span class="cstat-no" title="statement not covered" >t</span>his._setUIControlsEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his._hideLandingPage();<span class="cstat-no" title="statement not covered" >a</span>wait this._controller.startRecording(recordingOptions,enabledTraceProviders);<span class="cstat-no" title="statement not covered" >t</span>his._recordingStarted();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _stopRecording(){<span class="cstat-no" title="statement not covered" >if(this._statusPane){<span class="cstat-no" title="statement not covered" >this._statusPane.finish();<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.updateStatus(Common.UIString('Stopping timeline\u2026'));<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.updateProgressBar(Common.UIString('Received'),0);}</span></span>
<span class="cstat-no" title="statement not covered" >this._setState(Timeline.TimelinePanel.State.StopPending);<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel=await this._controller.stopRecording();<span class="cstat-no" title="statement not covered" >t</span>his._setUIControlsEnabled(true);<span class="cstat-no" title="statement not covered" >t</span>his._controller.dispose();<span class="cstat-no" title="statement not covered" >t</span>his._controller=null;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nSuspendStateChanged(){<span class="cstat-no" title="statement not covered" >this._updateTimelineControls();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateTimelineControls(){const state=<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel.State;<span class="cstat-no" title="statement not covered" ></span>this._toggleRecordAction.setToggled(this._state===state.Recording);<span class="cstat-no" title="statement not covered" >t</span>his._toggleRecordAction.setEnabled(this._state===state.Recording||this._state===state.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._recordReloadAction.setEnabled(this._state===state.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._historyManager.setEnabled(this._state===state.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._clearButton.setEnabled(this._state===state.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._panelToolbar.setEnabled(this._state!==state.Loading);<span class="cstat-no" title="statement not covered" >t</span>his._panelRightToolbar.setEnabled(this._state!==state.Loading);<span class="cstat-no" title="statement not covered" >t</span>his._dropTarget.setEnabled(this._state===state.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._loadButton.setEnabled(this._state===state.Idle);<span class="cstat-no" title="statement not covered" >t</span>his._saveButton.setEnabled(this._state===state.Idle&amp;&amp;!!this._performanceModel);}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleRecording(){<span class="cstat-no" title="statement not covered" >if(this._state===Timeline.TimelinePanel.State.Idle){<span class="cstat-no" title="statement not covered" >this._recordingPageReload=false;<span class="cstat-no" title="statement not covered" >t</span>his._startRecording();<span class="cstat-no" title="statement not covered" >H</span>ost.userMetrics.actionTaken(Host.UserMetrics.Action.TimelineStarted);}</span>else <span class="cstat-no" title="statement not covered" >if(this._state===Timeline.TimelinePanel.State.Recording){<span class="cstat-no" title="statement not covered" >this._stopRecording();}</span>}</span></span>
<span class="fstat-no" title="function not covered" >_r</span>ecordReload(){<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelinePanel.State.Idle)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._recordingPageReload=true;<span class="cstat-no" title="statement not covered" >t</span>his._startRecording();<span class="cstat-no" title="statement not covered" >H</span>ost.userMetrics.actionTaken(Host.UserMetrics.Action.TimelinePageReloadStarted);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nClearButton(){<span class="cstat-no" title="statement not covered" >this._historyManager.clear();<span class="cstat-no" title="statement not covered" >t</span>his._clear();}</span>
<span class="fstat-no" title="function not covered" >_c</span>lear(){<span class="cstat-no" title="statement not covered" >this._showLandingPage();<span class="cstat-no" title="statement not covered" >t</span>his._reset();}</span>
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile.instance().reset();<span class="cstat-no" title="statement not covered" >t</span>his._setModel(null);}</span>
<span class="fstat-no" title="function not covered" >_a</span>pplyFilters(model){<span class="cstat-no" title="statement not covered" >if(model.timelineModel().isGenericTrace()||Runtime.experiments.isEnabled('timelineShowAllEvents'))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >m</span>odel.setFilters([Timeline.TimelineUIUtils.visibleEventsFilter(),new TimelineModel.ExcludeTopLevelFilter()]);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etModel(model){<span class="cstat-no" title="statement not covered" >if(this._performanceModel){<span class="cstat-no" title="statement not covered" >this._performanceModel.removeEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onModelWindowChanged,this);}</span></span>
<span class="cstat-no" title="statement not covered" >this._performanceModel=model;<span class="cstat-no" title="statement not covered" >i</span>f(model)</span>
<span class="cstat-no" title="statement not covered" >this._applyFilters(model);<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.setModel(model);<span class="cstat-no" title="statement not covered" >t</span>his._updateOverviewControls();<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.reset();<span class="cstat-no" title="statement not covered" >i</span>f(model){<span class="cstat-no" title="statement not covered" >this._performanceModel.addEventListener(Timeline.PerformanceModel.Events.WindowChanged,this._onModelWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.setBounds(model.timelineModel().minimumRecordTime(),model.timelineModel().maximumRecordTime());<span class="cstat-no" title="statement not covered" >f</span>or(const profile of model.timelineModel().cpuProfiles())</span></span>
<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile.instance().appendCPUProfile(profile);<span class="cstat-no" title="statement not covered" >t</span>his._setMarkers(model.timelineModel());<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.setSelection(null);<span class="cstat-no" title="statement not covered" >t</span>his._overviewPane.setWindowTimes(model.window().left,model.window().right);}</span>
<span class="cstat-no" title="statement not covered" >for(const control of this._overviewControls)</span>
<span class="cstat-no" title="statement not covered" >control.setModel(model);<span class="cstat-no" title="statement not covered" >i</span>f(this._flameChart)</span>
<span class="cstat-no" title="statement not covered" >this._flameChart.resizeToPreferredHeights();<span class="cstat-no" title="statement not covered" >t</span>his._updateTimelineControls();}</span>
<span class="fstat-no" title="function not covered" >_r</span>ecordingStarted(){<span class="cstat-no" title="statement not covered" >if(this._recordingPageReload){const target=<span class="cstat-no" title="statement not covered" >this._controller.mainTarget();</span>const resourceModel=<span class="cstat-no" title="statement not covered" >target.model(SDK.ResourceTreeModel);<span class="cstat-no" title="statement not covered" ></span>if(resourceModel)</span></span>
<span class="cstat-no" title="statement not covered" >resourceModel.reloadPage();}</span>
<span class="cstat-no" title="statement not covered" >this._reset();<span class="cstat-no" title="statement not covered" >t</span>his._setState(Timeline.TimelinePanel.State.Recording);<span class="cstat-no" title="statement not covered" >t</span>his._showRecordingStarted();<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.updateStatus(Common.UIString('Profiling\u2026'));<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.updateProgressBar(Common.UIString('Buffer usage'),0);<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.startTimer();<span class="cstat-no" title="statement not covered" >t</span>his._hideLandingPage();}</span>
<span class="fstat-no" title="function not covered" >re</span>cordingProgress(usage){<span class="cstat-no" title="statement not covered" >this._statusPane.updateProgressBar(Common.UIString('Buffer usage'),usage*100);}</span>
<span class="fstat-no" title="function not covered" >_s</span>howLandingPage(){<span class="cstat-no" title="statement not covered" >if(this._landingPage){<span class="cstat-no" title="statement not covered" >this._landingPage.show(this._statusPaneContainer);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
function <span class="fstat-no" title="function not covered" >encloseWithTag(</span>tagName,contents){const e=<span class="cstat-no" title="statement not covered" >createElement(tagName);<span class="cstat-no" title="statement not covered" ></span>e.textContent=contents;<span class="cstat-no" title="statement not covered" >r</span>eturn e;}</span>
const learnMoreNode=<span class="cstat-no" title="statement not covered" >UI.XLink.create('https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/',Common.UIString('Learn\xa0more'));</span>const recordKey=<span class="cstat-no" title="statement not covered" >encloseWithTag('b',UI.shortcutRegistry.shortcutDescriptorsForAction('timeline.toggle-recording')[0].name);</span>const reloadKey=<span class="cstat-no" title="statement not covered" >encloseWithTag('b',UI.shortcutRegistry.shortcutDescriptorsForAction('timeline.record-reload')[0].name);</span>const navigateNode=<span class="cstat-no" title="statement not covered" >encloseWithTag('b',Common.UIString('WASD'));<span class="cstat-no" title="statement not covered" ></span>this._landingPage=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._landingPage.contentElement.classList.add('timeline-landing-page','fill');c</span>onst centered=<span class="cstat-no" title="statement not covered" >this._landingPage.contentElement.createChild('div');</span>const recordButton=<span class="cstat-no" title="statement not covered" >UI.createInlineButton(UI.Toolbar.createActionButton(this._toggleRecordAction));</span>const reloadButton=<span class="cstat-no" title="statement not covered" >UI.createInlineButton(UI.Toolbar.createActionButtonForId('timeline.record-reload'));<span class="cstat-no" title="statement not covered" ></span>centered.createChild('p').appendChild(UI.formatLocalized('Click the record button %s or hit %s to start a new recording.\n'+'Click the reload button %s or hit %s to record the page load.',[recordButton,recordKey,reloadButton,reloadKey]));<span class="cstat-no" title="statement not covered" >c</span>entered.createChild('p').appendChild(UI.formatLocalized('After recording, select an area of interest in the overview by dragging.\n'+'Then, zoom and pan the timeline with the mousewheel or %s keys.\n%s',[navigateNode,learnMoreNode]));<span class="cstat-no" title="statement not covered" >t</span>his._landingPage.show(this._statusPaneContainer);}</span>
<span class="fstat-no" title="function not covered" >_h</span>ideLandingPage(){<span class="cstat-no" title="statement not covered" >this._landingPage.detach();}</span>
<span class="fstat-no" title="function not covered" >lo</span>adingStarted(){<span class="cstat-no" title="statement not covered" >this._hideLandingPage();<span class="cstat-no" title="statement not covered" >i</span>f(this._statusPane)</span>
<span class="cstat-no" title="statement not covered" >this._statusPane.hide();<span class="cstat-no" title="statement not covered" >t</span>his._statusPane=new Timeline.TimelinePanel.StatusPane(false,this._cancelLoading.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.showPane(this._statusPaneContainer);<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.updateStatus(Common.UIString('Loading profile\u2026'));<span class="cstat-no" title="statement not covered" >i</span>f(!this._loader)</span>
<span class="cstat-no" title="statement not covered" >this._statusPane.finish();<span class="cstat-no" title="statement not covered" >t</span>his.loadingProgress(0);}</span>
<span class="fstat-no" title="function not covered" >lo</span>adingProgress(progress){<span class="cstat-no" title="statement not covered" >if(typeof progress==='number')</span>
<span class="cstat-no" title="statement not covered" >this._statusPane.updateProgressBar(Common.UIString('Received'),progress*100);}</span>
<span class="fstat-no" title="function not covered" >pr</span>ocessingStarted(){<span class="cstat-no" title="statement not covered" >this._statusPane.updateStatus(Common.UIString('Processing profile\u2026'));}</span>
<span class="fstat-no" title="function not covered" >lo</span>adingComplete(tracingModel){<span class="cstat-no" title="statement not covered" >delete this._loader;<span class="cstat-no" title="statement not covered" >t</span>his._setState(Timeline.TimelinePanel.State.Idle);<span class="cstat-no" title="statement not covered" >i</span>f(this._statusPane)</span>
<span class="cstat-no" title="statement not covered" >this._statusPane.hide();<span class="cstat-no" title="statement not covered" >d</span>elete this._statusPane;<span class="cstat-no" title="statement not covered" >i</span>f(!tracingModel){<span class="cstat-no" title="statement not covered" >this._clear();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!this._performanceModel)</span>
<span class="cstat-no" title="statement not covered" >this._performanceModel=new Timeline.PerformanceModel();<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel.setTracingModel(tracingModel);<span class="cstat-no" title="statement not covered" >t</span>his._setModel(this._performanceModel);<span class="cstat-no" title="statement not covered" >t</span>his._historyManager.addRecording(this._performanceModel);}</span>
<span class="fstat-no" title="function not covered" >_s</span>howRecordingStarted(){<span class="cstat-no" title="statement not covered" >if(this._statusPane)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._statusPane=new Timeline.TimelinePanel.StatusPane(true,this._stopRecording.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.showPane(this._statusPaneContainer);<span class="cstat-no" title="statement not covered" >t</span>his._statusPane.updateStatus(Common.UIString('Initializing profiler\u2026'));}</span>
<span class="fstat-no" title="function not covered" >_c</span>ancelLoading(){<span class="cstat-no" title="statement not covered" >if(this._loader)</span>
<span class="cstat-no" title="statement not covered" >this._loader.cancel();}</span>
<span class="fstat-no" title="function not covered" >_s</span>etMarkers(timelineModel){const markers=<span class="cstat-no" title="statement not covered" >new Map();</span>const recordTypes=<span class="cstat-no" title="statement not covered" >TimelineModel.TimelineModel.RecordType;</span>const zeroTime=<span class="cstat-no" title="statement not covered" >timelineModel.minimumRecordTime();<span class="cstat-no" title="statement not covered" ></span>for(const event of timelineModel.timeMarkerEvents()){<span class="cstat-no" title="statement not covered" >if(event.name===recordTypes.TimeStamp||event.name===recordTypes.ConsoleTime)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >m</span>arkers.set(event.startTime,Timeline.TimelineUIUtils.createEventDivider(event,zeroTime));}</span>
<span class="cstat-no" title="statement not covered" >this._overviewPane.setMarkers(markers);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _loadEventFired(event){<span class="cstat-no" title="statement not covered" >if(this._state!==Timeline.TimelinePanel.State.Recording||!this._recordingPageReload||this._controller.mainTarget()!==event.data.resourceTreeModel.target())</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst controller=<span class="cstat-no" title="statement not covered" >this._controller;<span class="cstat-no" title="statement not covered" ></span>await new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >setTimeout(r,this._millisecondsToRecordAfterLoadEvent))</span>;<span class="cstat-no" title="statement not covered" >i</span>f(controller!==this._controller||this._state!==Timeline.TimelinePanel.State.Recording)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._stopRecording();}</span>
<span class="fstat-no" title="function not covered" >_f</span>rameForSelection(selection){<span class="cstat-no" title="statement not covered" >switch(selection.type()){case Timeline.TimelineSelection.Type.Frame:<span class="cstat-no" title="statement not covered" >return(selection.object());c</span>ase Timeline.TimelineSelection.Type.Range:<span class="cstat-no" title="statement not covered" >return null;c</span>ase Timeline.TimelineSelection.Type.TraceEvent:<span class="cstat-no" title="statement not covered" >return this._performanceModel.frameModel().frames(selection._endTime,selection._endTime)[0];d</span>efault:<span class="cstat-no" title="statement not covered" >console.assert(false,'Should never be reached');<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>}</span>
<span class="fstat-no" title="function not covered" >_j</span>umpToFrame(offset){const currentFrame=<span class="cstat-no" title="statement not covered" >this._selection&amp;&amp;this._frameForSelection(this._selection);<span class="cstat-no" title="statement not covered" ></span>if(!currentFrame)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst frames=<span class="cstat-no" title="statement not covered" >this._performanceModel.frames();</span>let index=<span class="cstat-no" title="statement not covered" >frames.indexOf(currentFrame);<span class="cstat-no" title="statement not covered" ></span>console.assert(index&gt;=0,'Can\'t find current frame in the frame list');<span class="cstat-no" title="statement not covered" >i</span>ndex=Number.constrain(index+offset,0,frames.length-1);c</span>onst frame=<span class="cstat-no" title="statement not covered" >frames[index];<span class="cstat-no" title="statement not covered" ></span>this._revealTimeRange(frame.startTime,frame.endTime);<span class="cstat-no" title="statement not covered" >t</span>his.select(Timeline.TimelineSelection.fromFrame(frame));<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >se</span>lect(selection){<span class="cstat-no" title="statement not covered" >this._selection=selection;<span class="cstat-no" title="statement not covered" >t</span>his._flameChart.setSelection(selection);}</span>
<span class="fstat-no" title="function not covered" >se</span>lectEntryAtTime(events,time){<span class="cstat-no" title="statement not covered" >if(!events)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(let index=events.upperBound(time,(time,event)=&gt;time-event.startTime)-1;index&gt;=0;--index){const event=<span class="cstat-no" title="statement not covered" >events[index];</span>const endTime=<span class="cstat-no" title="statement not covered" >event.endTime||event.startTime;<span class="cstat-no" title="statement not covered" ></span>if(SDK.TracingModel.isTopLevelEvent(event)&amp;&amp;endTime&lt;time)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(this._performanceModel.isVisible(event)&amp;&amp;endTime&gt;=time){<span class="cstat-no" title="statement not covered" >this.select(Timeline.TimelineSelection.fromTraceEvent(event));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}</span>
<span class="cstat-no" title="statement not covered" >this.select(null);}</span>
<span class="fstat-no" title="function not covered" >hi</span>ghlightEvent(event){<span class="cstat-no" title="statement not covered" >this._flameChart.highlightEvent(event);}</span>
<span class="fstat-no" title="function not covered" >_r</span>evealTimeRange(startTime,endTime){const window=<span class="cstat-no" title="statement not covered" >this._performanceModel.window();</span>let offset=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(window.right&lt;endTime)</span>
<span class="cstat-no" title="statement not covered" >offset=endTime-window.right;e</span>lse <span class="cstat-no" title="statement not covered" >if(window.left&gt;startTime)</span>
<span class="cstat-no" title="statement not covered" >offset=startTime-window.left;<span class="cstat-no" title="statement not covered" >t</span>his._performanceModel.setWindow({left:window.left+offset,right:window.right+offset},true);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleDrop(dataTransfer){const items=<span class="cstat-no" title="statement not covered" >dataTransfer.items;<span class="cstat-no" title="statement not covered" ></span>if(!items.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst item=<span class="cstat-no" title="statement not covered" >items[0];<span class="cstat-no" title="statement not covered" ></span>if(item.kind==='string'){const url=<span class="cstat-no" title="statement not covered" >dataTransfer.getData('text/uri-list');<span class="cstat-no" title="statement not covered" ></span>if(new Common.ParsedURL(url).isValid)</span></span>
<span class="cstat-no" title="statement not covered" >this._loadFromURL(url);}</span>else <span class="cstat-no" title="statement not covered" >if(item.kind==='file'){const entry=<span class="cstat-no" title="statement not covered" >items[0].webkitGetAsEntry();<span class="cstat-no" title="statement not covered" ></span>if(!entry.isFile)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span>ntry.file(this._loadFromFile.bind(this));}</span>}};<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel.State={Idle:Symbol('Idle'),StartPending:Symbol('StartPending'),Recording:Symbol('Recording'),StopPending:Symbol('StopPending'),Loading:Symbol('Loading')};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePanel.ViewMode={FlameChart:'FlameChart',BottomUp:'BottomUp',CallTree:'CallTree',EventLog:'EventLog'};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePanel.rowHeight=18;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePanel.headerHeight=20;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePanel.ModelSelectionData;<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineSelection=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(type,startTime,endTime,object){<span class="cstat-no" title="statement not covered" >this._type=type;<span class="cstat-no" title="statement not covered" >t</span>his._startTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._endTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._object=object||null;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic fromFrame(frame){<span class="cstat-no" title="statement not covered" >return new Timeline.TimelineSelection(Timeline.TimelineSelection.Type.Frame,frame.startTime,frame.endTime,frame);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromNetworkRequest(request){<span class="cstat-no" title="statement not covered" >return new Timeline.TimelineSelection(Timeline.TimelineSelection.Type.NetworkRequest,request.startTime,request.endTime||request.startTime,request);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromTraceEvent(event){<span class="cstat-no" title="statement not covered" >return new Timeline.TimelineSelection(Timeline.TimelineSelection.Type.TraceEvent,event.startTime,event.endTime||(event.startTime+1),event);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromRange(startTime,endTime){<span class="cstat-no" title="statement not covered" >return new Timeline.TimelineSelection(Timeline.TimelineSelection.Type.Range,startTime,endTime);}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._type;}</span>
<span class="fstat-no" title="function not covered" >ob</span>ject(){<span class="cstat-no" title="statement not covered" >return this._object;}</span>
<span class="fstat-no" title="function not covered" >st</span>artTime(){<span class="cstat-no" title="statement not covered" >return this._startTime;}</span>
<span class="fstat-no" title="function not covered" >en</span>dTime(){<span class="cstat-no" title="statement not covered" >return this._endTime;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelineSelection.Type={Frame:'Frame',NetworkRequest:'NetworkRequest',TraceEvent:'TraceEvent',Range:'Range'};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineModeViewDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelineModeViewDelegate.prototype={select(selection){},selectEntryAtTime(events,time){},highlightEvent(event){},};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePanel.StatusPane=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(showTimer,stopCallback){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('timeline/timelineStatusDialog.css');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.add('timeline-status-dialog');c</span>onst statusLine=<span class="cstat-no" title="statement not covered" >this.contentElement.createChild('div','status-dialog-line status');<span class="cstat-no" title="statement not covered" ></span>statusLine.createChild('div','label').textContent=Common.UIString('Status');<span class="cstat-no" title="statement not covered" >t</span>his._status=statusLine.createChild('div','content');<span class="cstat-no" title="statement not covered" >i</span>f(showTimer){const timeLine=<span class="cstat-no" title="statement not covered" >this.contentElement.createChild('div','status-dialog-line time');<span class="cstat-no" title="statement not covered" ></span>timeLine.createChild('div','label').textContent=Common.UIString('Time');<span class="cstat-no" title="statement not covered" >t</span>his._time=timeLine.createChild('div','content');}</span></span></span>
const progressLine=<span class="cstat-no" title="statement not covered" >this.contentElement.createChild('div','status-dialog-line progress');<span class="cstat-no" title="statement not covered" ></span>this._progressLabel=progressLine.createChild('div','label');<span class="cstat-no" title="statement not covered" >t</span>his._progressBar=progressLine.createChild('div','indicator-container').createChild('div','indicator');<span class="cstat-no" title="statement not covered" >t</span>his._stopButton=UI.createTextButton(Common.UIString('Stop'),stopCallback,'',true);<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.createChild('div','stop-button').appendChild(this._stopButton);}</span>
<span class="fstat-no" title="function not covered" >fi</span>nish(){<span class="cstat-no" title="statement not covered" >this._stopTimer();<span class="cstat-no" title="statement not covered" >t</span>his._stopButton.disabled=true;}</span>
<span class="fstat-no" title="function not covered" >hi</span>de(){<span class="cstat-no" title="statement not covered" >this.element.parentNode.classList.remove('tinted');<span class="cstat-no" title="statement not covered" >t</span>his.element.remove();}</span>
<span class="fstat-no" title="function not covered" >sh</span>owPane(parent){<span class="cstat-no" title="statement not covered" >this.show(parent);<span class="cstat-no" title="statement not covered" >p</span>arent.classList.add('tinted');<span class="cstat-no" title="statement not covered" >t</span>his._stopButton.focus();}</span>
<span class="fstat-no" title="function not covered" >up</span>dateStatus(text){<span class="cstat-no" title="statement not covered" >this._status.textContent=text;}</span>
<span class="fstat-no" title="function not covered" >up</span>dateProgressBar(activity,percent){<span class="cstat-no" title="statement not covered" >this._progressLabel.textContent=activity;<span class="cstat-no" title="statement not covered" >t</span>his._progressBar.style.width=percent.toFixed(1)+'%';<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer();}</span>
<span class="fstat-no" title="function not covered" >st</span>artTimer(){<span class="cstat-no" title="statement not covered" >this._startTime=Date.now();<span class="cstat-no" title="statement not covered" >t</span>his._timeUpdateTimer=setInterval(this._updateTimer.bind(this,false),1000);<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer();}</span>
<span class="fstat-no" title="function not covered" >_s</span>topTimer(){<span class="cstat-no" title="statement not covered" >if(!this._timeUpdateTimer)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>learInterval(this._timeUpdateTimer);<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer(true);<span class="cstat-no" title="statement not covered" >d</span>elete this._timeUpdateTimer;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateTimer(precise){<span class="cstat-no" title="statement not covered" >if(!this._timeUpdateTimer)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst elapsed=<span class="cstat-no" title="statement not covered" >(Date.now()-this._startTime)/1000;<span class="cstat-no" title="statement not covered" ></span>this._time.textContent=Common.UIString('%s\xa0sec',elapsed.toFixed(precise?1:0));}</span>};<span class="cstat-no" title="statement not covered" >Timeline.LoadTimelineHandler=class{<span class="fstat-no" title="function not covered" >ha</span>ndleQueryParam(value){<span class="cstat-no" title="statement not covered" >UI.viewManager.showView('timeline').then(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel.instance()._loadFromURL(window.decodeURIComponent(value));}</span>);}</span>};<span class="cstat-no" title="statement not covered" >T</span>imeline.TimelinePanel.ActionDelegate=class{<span class="fstat-no" title="function not covered" >ha</span>ndleAction(context,actionId){const panel=<span class="cstat-no" title="statement not covered" >UI.context.flavor(Timeline.TimelinePanel);<span class="cstat-no" title="statement not covered" ></span>console.assert(panel&amp;&amp;panel instanceof Timeline.TimelinePanel);<span class="cstat-no" title="statement not covered" >s</span>witch(actionId){case'timeline.toggle-recording':<span class="cstat-no" title="statement not covered" >panel._toggleRecording();<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.record-reload':<span class="cstat-no" title="statement not covered" >panel._recordReload();<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.save-to-file':<span class="cstat-no" title="statement not covered" >panel._saveToFile();<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.load-from-file':<span class="cstat-no" title="statement not covered" >panel._selectFileToLoad();<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.jump-to-previous-frame':<span class="cstat-no" title="statement not covered" >panel._jumpToFrame(-1);<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.jump-to-next-frame':<span class="cstat-no" title="statement not covered" >panel._jumpToFrame(1);<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.show-history':<span class="cstat-no" title="statement not covered" >panel._showHistory();<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.previous-recording':<span class="cstat-no" title="statement not covered" >panel._navigateHistory(1);<span class="cstat-no" title="statement not covered" >r</span>eturn true;c</span>ase'timeline.next-recording':<span class="cstat-no" title="statement not covered" >panel._navigateHistory(-1);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>};<span class="cstat-no" title="statement not covered" >Timeline.TimelinePanel._traceProviderSettingSymbol=Symbol('traceProviderSetting');;<span class="cstat-no" title="statement not covered" ></span>Runtime.cachedResources["timeline/historyToolbarButton.css"]="/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.history-dropdown-button {\n  width: 160px;\n  height: 26px;\n  text-align: left;\n  display: flex;\n}\n\n.history-dropdown-button[disabled] {\n  opacity: .5;\n}\n\n.history-dropdown-button &gt; .content {\n  padding-right: 5px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex: 1 1;\n  min-width: 35px;\n}\n\n/*# sourceURL=timeline/historyToolbarButton.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["timeline/invalidationsTree.css"]="/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.header, .children, .content {\n    min-height: initial;\n    line-height: initial;\n}\n\n/* This TreeElement is always expanded and has no arrow.   */\n/* FIXME(crbug.com/475618): Implement this in TreeElement. */\n.children li::before {\n    display: none;\n}\n\n.content {\n    margin-bottom: 4px;\n}\n\n.content .stack-preview-container {\n    margin-left: 8px;\n}\n\n.content .node-list {\n    margin-left: 10px;\n}\n\n/*# sourceURL=timeline/invalidationsTree.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["timeline/timelineFlamechartPopover.css"]="/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.timeline-flamechart-popover {\n    overflow: hidden;\n}\n\n.timeline-flamechart-popover span {\n    margin-right: 5px;\n}\n\n.timeline-flamechart-popover span.timeline-info-network-time {\n    color: #009;\n}\n\n.timeline-flamechart-popover span.timeline-info-time {\n    color: #282;\n}\n\n.timeline-flamechart-popover span.timeline-info-warning {\n    color: #e44;\n}\n\n.timeline-flamechart-popover span.timeline-info-warning * {\n    color: inherit;\n}\n\n/*# sourceURL=timeline/timelineFlamechartPopover.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["timeline/timelineHistoryManager.css"]="/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.drop-down {\n  padding: 1px;\n  box-shadow: var(--drop-shadow);\n  background: white;\n}\n\n.preview-item {\n  border-color: transparent;\n  border-style: solid;\n  border-width: 1px 5px;\n  padding: 2px 0px;\n  margin: 2px 1px;\n}\n\n.preview-item.selected {\n  border-color: var(--selection-bg-color);\n}\n\n.preview-item canvas {\n  width: 100%;\n  height: 100%;\n}\n\n.text-details {\n  font-size: 11px;\n  padding: 3px;\n}\n\n.text-details span {\n  flex: 1 0;\n  padding-left: 8px;\n  padding-right: 8px;\n}\n\n.text-details .name {\n  font-weight: bold;\n}\n\n.text-details span.time {\n  color: #555;\n  text-align: right;\n}\n\n.screenshot-thumb {\n  display: flex;\n  border: 1px solid #ccc;\n  margin: 2px 4px;\n}\n\n.screenshot-thumb img {\n  margin: auto;\n  max-width: 100%;\n  max-height: 100%;\n}\n\n/*# sourceURL=timeline/timelineHistoryManager.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["timeline/timelinePanel.css"]="/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud &lt;rik@webkit.org&gt;\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.timeline-toolbar-container {\n    display: flex;\n    flex: none;\n}\n\n.timeline-toolbar-container &gt; .toolbar {\n    background-color: var(--toolbar-bg-color);\n    border-bottom: var(--divider-border);\n}\n\n.timeline-main-toolbar {\n    flex: 1 1 auto;\n}\n\n.timeline-settings-pane {\n    flex: none;\n    background-color: var(--toolbar-bg-color);\n    border-bottom: var(--divider-border);\n}\n\n#timeline-overview-panel {\n    flex: none;\n    position: relative;\n    border-bottom: 1px solid #bbb;\n}\n\n#timeline-overview-panel .timeline-graph-bar {\n    pointer-events: none;\n}\n\n#timeline-overview-grid {\n    background-color: rgb(255, 255, 255);\n}\n\n#timeline-overview-grid .timeline-grid-header {\n    height: 12px;\n}\n\n#timeline-overview-grid .resources-dividers-label-bar {\n    pointer-events: auto;\n    height: 12px;\n}\n\n#timeline-overview-grid .resources-divider-label {\n    top: 1px;\n}\n\n.timeline-details-split {\n    flex: auto;\n}\n\n.timeline-view-stack {\n    flex: auto;\n    display: flex;\n}\n\n#timeline-container .devtools-link {\n    color: inherit;\n}\n\n.timeline-graph-side.hovered {\n    background-color: rgba(0, 0, 0, 0.05) !important;\n}\n\n.timeline.panel .status-pane-container {\n    z-index: 1000;\n    display: flex;\n    align-items: center;\n    pointer-events: none;\n}\n\n.timeline.panel .status-pane-container.tinted {\n    background-color: lightgray;\n    pointer-events: auto;\n}\n\n.timeline.panel .status-pane-container &gt; div {\n    pointer-events: auto;\n}\n\n#timeline-overview-panel .overview-strip {\n    margin-top: 2px;\n    justify-content: center;\n}\n\n#timeline-overview-panel .overview-strip .timeline-overview-strip-title {\n    color: #666;\n    font-size: 10px;\n    font-weight: bold;\n    z-index: 100;\n    background-color: rgba(255, 255, 255, 0.7);\n    padding: 0 4px;\n    position: absolute;\n    top: -2px;\n    right: 0;\n}\n\n#timeline-overview-cpu-activity {\n    flex-basis: 20px;\n}\n\n#timeline-overview-network {\n    flex-basis: 8px;\n}\n\n#timeline-overview-framerate {\n    flex-basis: 16px;\n    margin-top: 0 !important;\n}\n\n#timeline-overview-filmstrip {\n    flex-basis: 30px;\n}\n\n#timeline-overview-memory {\n    flex-basis: 20px;\n}\n\n#timeline-overview-framerate::before,\n#timeline-overview-network::before,\n#timeline-overview-cpu-activity::before {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    border-bottom: 1px solid hsla(0, 0%, 0%, 0.06);\n    z-index: -200;\n}\n\n.overview-strip .background {\n    z-index: -10;\n}\n\n#timeline-overview-responsiveness {\n    flex-basis: 5px;\n    margin-top: 0 !important;\n}\n\n#timeline-overview-input {\n    flex-basis: 6px;\n}\n\n#timeline-overview-pane {\n    flex: auto;\n    position: relative;\n    overflow: hidden;\n}\n\n#timeline-overview-container {\n    display: flex;\n    flex-direction: column;\n    flex: none;\n    position: relative;\n    overflow: hidden;\n}\n\n#timeline-overview-container canvas {\n    width: 100%;\n    height: 100%;\n}\n\n#timeline-graphs {\n    position: absolute;\n    left: 0;\n    right: 0;\n    max-height: 100%;\n    top: 20px;\n}\n\n.timeline-aggregated-legend-title {\n    display: inline-block;\n}\n\n.timeline-aggregated-legend-value {\n    display: inline-block;\n    width: 70px;\n    text-align: right;\n}\n\n.timeline-aggregated-legend-swatch {\n    display: inline-block;\n    width: 11px;\n    height: 11px;\n    margin: 0 6px;\n    position: relative;\n    top: 1px;\n    border: 1px solid rgba(0, 0, 0, 0.2);\n}\n\n.popover ul {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n}\n\n#resources-container-content {\n    overflow: hidden;\n    min-height: 100%;\n}\n\n.memory-graph-label {\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    font-size: 9px;\n    color: #888;\n    white-space: nowrap;\n    padding: 0 4px;\n    background-color: hsla(0, 0%, 100%, 0.8);\n}\n\n#memory-graphs-canvas-container {\n    overflow: hidden;\n    flex: auto;\n    position: relative;\n}\n\n#memory-counters-graph {\n    flex: auto;\n}\n\n#memory-graphs-canvas-container .memory-counter-marker {\n    position: absolute;\n    border-radius: 3px;\n    width: 5px;\n    height: 5px;\n    margin-left: -3px;\n    margin-top: -2px;\n}\n\n#memory-graphs-container .timeline-memory-header {\n    flex: 0 0 26px;\n    background-color: #eee;\n    border-bottom: 1px solid #ddd;\n    justify-content: space-between;\n}\n\n#memory-graphs-container .timeline-memory-header::after {\n    content: \"\";\n    background-image: url(Images/toolbarResizerVertical.png);\n    background-repeat: no-repeat;\n    background-position: right center, center;\n    flex: 20px 0 0;\n    margin: 0 4px;\n}\n\n.timeline-memory-toolbar {\n    flex-shrink: 1;\n}\n\n.memory-counter-selector-info {\n    flex: 0 0 auto;\n    margin-left: 5px;\n    white-space: nowrap;\n}\n\n.memory-counter-selector-info .range {\n    margin: 0 4px;\n    align-items: center;\n    display: inline-flex;\n}\n\n.memory-counter-value {\n    margin: 8px;\n}\n\n#counter-values-bar {\n    flex: 0 0 20px;\n    border-top: solid 1px lightgray;\n    width: 100%;\n    overflow: hidden;\n    line-height: 18px;\n}\n\n.timeline-filters-header {\n    overflow: hidden;\n    flex: none;\n}\n\n.timeline-details {\n    vertical-align: top;\n}\n\n.timeline-details-title {\n    border-bottom: 1px solid #B8B8B8;\n    font-weight: bold;\n    padding-bottom: 5px;\n    padding-top: 0;\n    white-space: nowrap;\n}\n\n.timeline-details-row-title {\n    font-weight: bold;\n    text-align: right;\n    white-space: nowrap;\n}\n\n.timeline-details-row-data {\n    white-space: nowrap;\n}\n\n.timeline-details-view {\n    color: #333;\n    overflow: hidden;\n}\n\n.timeline-details-view-body {\n    flex: auto;\n    overflow: auto;\n    position: relative;\n    background-color: var(--toolbar-bg-color);\n    -webkit-user-select: text;\n}\n\n.timeline-details-view-body &gt; div {\n    overflow: hidden;\n}\n\n.timeline-details-view-block {\n    flex: none;\n    display: flex;\n    background-color: white;\n    flex-direction: column;\n    padding-bottom: 5px;\n    border-bottom: var(--divider-border);\n}\n\n.timeline-details-view-row {\n    padding-left: 10px;\n    flex-direction: row;\n    display: flex;\n    line-height: 20px;\n}\n\n.timeline-details-view-block .timeline-details-stack-values {\n    flex-direction: column !important;\n}\n\n.timeline-details-chip-title {\n    font-size: 13px;\n    padding: 8px;\n    display: flex;\n    align-items: center;\n}\n\n.timeline-details-chip-title &gt; div {\n    width: 12px;\n    height: 12px;\n    border: 1px solid rgba(0, 0, 0, 0.2);\n    display: inline-block;\n    margin-right: 4px;\n    content: \" \";\n}\n\n.timeline-details-view-row-title:not(:empty) {\n    color: rgb(152, 152, 152);\n    overflow: hidden;\n    padding-right: 10px;\n}\n\n.timeline-details-warning {\n    background-color: rgba(250, 209, 209, 0.48);\n}\n\n.timeline-details-warning .timeline-details-view-row-title {\n    color: red;\n}\n\n.timeline-details-warning .timeline-details-view-row-value {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.timeline-details-view-row-value {\n    -webkit-user-select: text;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.timeline-details-view-row-value .stack-preview-container {\n    line-height: 11px;\n}\n\n.timeline-details-view-row-value .timeline-details-warning-marker {\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.timeline-details-view-pie-chart-wrapper {\n    margin: 4px 0;\n}\n\n.timeline-details-view-pie-chart {\n    margin-top: 5px;\n}\n\n.timeline-details-view-row-stack-trace {\n    padding: 4px 0;\n    line-height: inherit;\n}\n\n.timeline-details-view-row-stack-trace div {\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    line-height: 12px;\n}\n\n.timeline-aggregated-info-legend &gt; div {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n}\n\n.timeline-flamechart {\n    overflow: hidden;\n}\n\n.timeline-flamechart-resizer {\n    flex: 8px 0 0;\n    background-color: var(--toolbar-bg-color);\n    border: 1px #a3a3a3;\n    border-style: solid none;\n    display: flex;\n    flex-direction: row;\n    align-items: flex-end;\n    justify-content: center;\n}\n\n.timeline-network-resizer-disabled &gt; .timeline-flamechart-resizer {\n    display: none;\n}\n\n.timeline-flamechart-resizer:after {\n    content: \"...\";\n    font-size: 14px;\n    margin-bottom: -1px;\n}\n\n.timeline-status-pane.full-widget-dimmed-banner {\n    text-align: left !important;\n}\n\n.timeline-layers-view &gt; div:last-child,\n.timeline-layers-view-properties &gt; div:last-child {\n    background-color: #eee;\n}\n\n.timeline-layers-view-properties table {\n    width: 100%;\n    border-collapse: collapse;\n}\n\n.timeline-layers-view-properties td {\n    border: 1px solid #e1e1e1;\n    line-height: 22px;\n}\n\n.timeline-paint-profiler-log-split &gt; div:last-child {\n    background-color: #eee;\n    z-index: 0;\n}\n\n.timeline-gap {\n    flex: none;\n}\n\n.timeline-filmstrip-preview &gt; img {\n    margin-top: 5px;\n    max-width: 500px;\n    max-height: 300px;\n    cursor: pointer;\n    border: 1px solid #ddd;\n}\n\n.timeline-tree-view {\n    display: flex;\n    overflow: hidden;\n}\n\n.timeline-tree-view .toolbar {\n    background-color: var(--toolbar-bg-color);\n    border-bottom: var(--divider-border);\n}\n\n.timeline-tree-view .data-grid {\n    border: none;\n    flex: auto;\n}\n\n.timeline-tree-view .data-grid .data-container {\n    overflow-y: scroll;\n}\n\n.timeline-tree-view .data-grid.data-grid-fits-viewport .corner {\n    display: table-cell;\n}\n\n.timeline-tree-view .data-grid table.data {\n    background: white;\n}\n\n.timeline-tree-view .data-grid tr:not(.selected) .highlight {\n    background-color: rgb(255, 230, 179);\n}\n\n.timeline-tree-view .data-grid tr:hover td:not(.bottom-filler-td) {\n    background-color: rgba(0, 0, 0, 0.1);\n}\n\n.timeline-tree-view .data-grid td.numeric-column {\n    text-align: right;\n    position: relative;\n}\n\n.timeline-tree-view .data-grid div.background-percent-bar {\n    float: right;\n}\n\n.timeline-tree-view .data-grid span.percent-column {\n    color: #888;\n    width: 45px;\n    display: inline-block;\n}\n\n.timeline-tree-view .data-grid tr.selected span {\n    color: inherit;\n}\n\n.timeline-tree-view .data-grid .name-container {\n    display: flex;\n    align-items: center;\n    padding-left: 2px;\n}\n\n.timeline-tree-view .data-grid .name-container div {\n    flex: none;\n}\n\n.timeline-tree-view .data-grid .name-container .activity-icon {\n    width: 12px;\n    height: 12px;\n    border: 1px solid rgba(0, 0, 0, 0.05);\n    margin: 3px 0;\n}\n\n.timeline-tree-view .data-grid .name-container .activity-icon-container {\n    margin-right: 3px;\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n    width: 18px;\n    height: 18px;\n    overflow: hidden;\n}\n\n.timeline-tree-view .data-grid .name-container .activity-warning::after {\n    content: \"[deopt]\";\n    margin: 0 4px;\n    line-height: 12px;\n    font-size: 10px;\n    color: #777;\n}\n\n.timeline-tree-view .data-grid tr.selected .name-container .activity-warning::after {\n    color: white;\n}\n\n.timeline-tree-view .data-grid .name-container .activity-link {\n    flex: auto;\n    text-align: right;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    margin-left: 5px;\n}\n\n.timeline-tree-view .data-grid .background-bar-container {\n    position: absolute;\n    left: 3px;\n    right: 0;\n}\n\n.timeline-tree-view .data-grid .background-bar {\n    float: right;\n    height: 18px;\n    background-color: hsla(43, 84%, 64%, 0.2);\n    border-bottom: 1px solid hsl(43, 84%, 64%);\n}\n\n.timeline-tree-view .data-grid .selected .background-bar {\n    background-color: rgba(255, 255, 255, 0.3);\n    border-bottom-color: rgba(255, 255, 255, 0.9);\n}\n\n.timeline-tree-view .timeline-details-view-body .full-widget-dimmed-banner {\n    background-color: inherit;\n}\n\n.timeline-details .filter-input-field {\n    width: 120px;\n}\n\n.timeline-tree-view .data-grid .header-container {\n    height: 21px;\n}\n\n.timeline-tree-view .data-grid .data-container {\n    top: 21px;\n}\n\n.timeline-stack-view-header {\n    height: 27px;\n    background-color: var(--toolbar-bg-color);\n    padding: 6px 10px;\n    color: #5a5a5a;\n    white-space: nowrap;\n    border-bottom: var(--divider-border);\n}\n\n.timeline-landing-page {\n    position: absolute;\n    background-color: white;\n    justify-content: center;\n    align-items: center;\n    overflow: auto;\n    font-size: 13px;\n    color: #777;\n}\n\n.timeline-landing-page &gt; div {\n    max-width: 450px;\n    margin: 10px;\n}\n\n.timeline-landing-page &gt; div &gt; p {\n    flex: none;\n    white-space: pre-line;\n}\n\n/*# sourceURL=timeline/timelinePanel.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["timeline/timelinePaintProfiler.css"]="/*\n * Copyright 2016 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.paint-profiler-image-view {\n    overflow: hidden;\n}\n\n.paint-profiler-image-view .paint-profiler-image-container {\n    -webkit-transform-origin: 0 0;\n}\n\n.paint-profiler-image-view .paint-profiler-image-container div {\n    border-color: rgba(100, 100, 100, 0.4);\n    border-style: solid;\n    z-index: 100;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n\n.paint-profiler-image-view img {\n    border: solid 1px black;\n}\n\n/*# sourceURL=timeline/timelinePaintProfiler.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["timeline/timelineStatusDialog.css"]="/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.timeline-status-dialog {\n    display: flex;\n    flex-direction: column;\n    padding: 16px 16px 12px 16px;\n    align-self: center;\n    background-color: white;\n    box-shadow: var(--drop-shadow);\n}\n\n.status-dialog-line {\n    margin: 2px;\n    height: 14px;\n    display: flex;\n    align-items: baseline;\n}\n\n.status-dialog-line .label {\n    display: inline-block;\n    width: 80px;\n    text-align: right;\n    color: #aaa;\n    margin-right: 10px;\n}\n\n.timeline-status-dialog .progress .indicator-container {\n    display: inline-block;\n    width: 200px;\n    height: 8px;\n    background-color: #f4f4f4;\n    display: inline-block;\n    margin: 0 10px 0 0;\n}\n\n.timeline-status-dialog .progress .indicator {\n    background-color: rgb(112, 166, 255);\n    height: 100%;\n    width: 0;\n    margin: 0;\n}\n\n.timeline-status-dialog .stop-button {\n    margin-top: 8px;\n    height: 100%;\n    align-self: center;\n}\n\n.timeline-status-dialog .stop-button button {\n    min-width: 80px;\n}\n\n/*# sourceURL=timeline/timelineStatusDialog.css */";</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:04:04 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
