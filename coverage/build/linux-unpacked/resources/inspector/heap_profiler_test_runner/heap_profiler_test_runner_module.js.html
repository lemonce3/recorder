<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/linux-unpacked/resources/inspector/heap_profiler_test_runner/heap_profiler_test_runner_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/linux-unpacked/resources/inspector/heap_profiler_test_runner</a> heap_profiler_test_runner_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/346</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/93</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/85</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/50</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.createHeapSnapshotMockFactories=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.createJSHeapSnapshotMockObject=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{_rootNodeIndex:0,_nodeTypeOffset:0,_nodeNameOffset:1,_nodeEdgeCountOffset:2,_nodeFieldCount:3,_edgeFieldsCount:3,_edgeTypeOffset:0,_edgeNameOffset:1,_edgeToNodeOffset:2,_nodeTypes:['hidden','object'],_edgeTypes:['element','property','shortcut'],_edgeShortcutType:-1,_edgeHiddenType:-1,_edgeElementType:0,_realNodesLength:18,nodes:new Uint32Array([0,0,2,1,1,2,1,2,2,1,3,1,1,4,0,1,5,0]),containmentEdges:new Uint32Array([2,6,3,1,7,6,0,1,6,1,8,9,1,9,9,1,10,12,1,11,15]),strings:['','A','B','C','D','E','a','b','ac','bc','bd','ce'],_firstEdgeIndexes:new Uint32Array([0,6,12,18,21,21,21]),createNode:HeapSnapshotWorker.JSHeapSnapshot.prototype.createNode,createEdge:HeapSnapshotWorker.JSHeapSnapshot.prototype.createEdge,createRetainingEdge:HeapSnapshotWorker.JSHeapSnapshot.prototype.createRetainingEdge};}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.createHeapSnapshotMockRaw=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{snapshot:{meta:{node_fields:['type','name','id','self_size','retained_size','dominator','edge_count'],node_types:[['hidden','object'],'','','','','',''],edge_fields:['type','name_or_index','to_node'],edge_types:[['element','property','shortcut'],'',''],location_fields:['object_index','script_id','line','column'],trace_function_info_fields:['function_id','name','script_name','script_id','line','column'],trace_node_fields:['id','function_info_index','count','size','children']},node_count:6,edge_count:7},nodes:[0,0,1,0,20,0,2,1,1,2,2,2,0,2,1,2,3,3,8,0,2,1,3,4,4,10,0,1,1,4,5,5,5,14,0,1,5,6,6,6,21,0],edges:[1,6,7,1,7,14,0,1,14,1,8,21,1,9,21,1,10,28,1,11,35],trace_function_infos:[0,2,1,0,0,0],trace_tree:[1,0,0,0,[]],locations:[0,1,2,3,18,2,3,4],strings:['','A','B','C','D','E','a','b','ac','bc','bd','ce']};}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._postprocessHeapSnapshotMock=<span class="fstat-no" title="function not covered" >fu</span>nction(mock){<span class="cstat-no" title="statement not covered" >mock.nodes=new Uint32Array(mock.nodes);<span class="cstat-no" title="statement not covered" >m</span>ock.edges=new Uint32Array(mock.edges);<span class="cstat-no" title="statement not covered" >r</span>eturn mock;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.createHeapSnapshotMock=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return HeapProfilerTestRunner._postprocessHeapSnapshotMock(HeapProfilerTestRunner.createHeapSnapshotMockRaw());}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.createHeapSnapshotMockWithDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return HeapProfilerTestRunner._postprocessHeapSnapshotMock({snapshot:{meta:{node_fields:['type','name','id','edge_count'],node_types:[['hidden','object','synthetic'],'','',''],edge_fields:['type','name_or_index','to_node'],edge_types:[['element','hidden','internal'],'',''],location_fields:['object_index','script_id','line','column']},node_count:13,edge_count:13},nodes:[2,0,1,4,1,11,2,2,1,11,3,3,2,5,4,0,2,6,5,1,1,1,6,0,1,2,7,1,1,4,8,2,1,8,9,0,1,7,10,0,1,3,11,0,1,10,12,0,1,9,13,0],edges:[0,1,4,0,2,8,0,3,12,0,4,16,0,1,20,0,2,24,0,1,24,0,2,28,1,3,32,0,1,36,0,1,40,2,12,44,2,1,48],locations:[0,2,1,1,6,2,2,2],strings:['','A','B','C','D','E','F','G','H','M','N','Window','native']});}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.HeapNode=<span class="fstat-no" title="function not covered" >fu</span>nction(name,selfSize,type,id){<span class="cstat-no" title="statement not covered" >this._type=type||HeapProfilerTestRunner.HeapNode.Type.object;<span class="cstat-no" title="statement not covered" >t</span>his._name=name;<span class="cstat-no" title="statement not covered" >t</span>his._selfSize=selfSize||0;<span class="cstat-no" title="statement not covered" >t</span>his._builder=null;<span class="cstat-no" title="statement not covered" >t</span>his._edges={};<span class="cstat-no" title="statement not covered" >t</span>his._edgesCount=0;<span class="cstat-no" title="statement not covered" >t</span>his._id=id;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.HeapNode.Type={'hidden':'hidden','array':'array','string':'string','object':'object','code':'code','closure':'closure','regexp':'regexp','number':'number','native':'native','synthetic':'synthetic','bigint':'bigint'};<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.HeapNode.prototype={linkNode:<span class="fstat-no" title="function not covered" >fu</span>nction(node,type,nameOrIndex){<span class="cstat-no" title="statement not covered" >if(!this._builder)</span></span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('parent node is not connected to a snapshot');<span class="cstat-no" title="statement not covered" >i</span>f(!node._builder)</span>
<span class="cstat-no" title="statement not covered" >node._setBuilder(this._builder);<span class="cstat-no" title="statement not covered" >i</span>f(nameOrIndex===undefined)</span>
<span class="cstat-no" title="statement not covered" >nameOrIndex=this._edgesCount;<span class="cstat-no" title="statement not covered" >+</span>+this._edgesCount;<span class="cstat-no" title="statement not covered" >i</span>f(nameOrIndex in this._edges){<span class="cstat-no" title="statement not covered" >throw new Error('Can\'t add edge with the same nameOrIndex. nameOrIndex: '+nameOrIndex+' oldNodeName: '+this._edges[nameOrIndex]._name+' newNodeName: '+node._name);}</span></span>
<span class="cstat-no" title="statement not covered" >this._edges[nameOrIndex]=new HeapProfilerTestRunner.HeapEdge(node,type,nameOrIndex);}</span>,_setBuilder:<span class="fstat-no" title="function not covered" >fu</span>nction(builder){<span class="cstat-no" title="statement not covered" >if(this._builder)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('node reusing is prohibited');<span class="cstat-no" title="statement not covered" >t</span>his._builder=builder;<span class="cstat-no" title="statement not covered" >t</span>his._ordinal=this._builder._registerNode(this);}</span>,_serialize:<span class="fstat-no" title="function not covered" >fu</span>nction(rawSnapshot){<span class="cstat-no" title="statement not covered" >rawSnapshot.nodes.push(this._builder.lookupNodeType(this._type));<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.nodes.push(this._builder.lookupOrAddString(this._name));<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.nodes.push(this._id||this._ordinal*2+1);<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.nodes.push(this._selfSize);<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.nodes.push(0);<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.nodes.push(0);<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.nodes.push(Object.keys(this._edges).length);<span class="cstat-no" title="statement not covered" >f</span>or(const i in this._edges)</span>
<span class="cstat-no" title="statement not covered" >this._edges[i]._serialize(rawSnapshot);}</span>};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.HeapEdge=<span class="fstat-no" title="function not covered" >fu</span>nction(targetNode,type,nameOrIndex){<span class="cstat-no" title="statement not covered" >this._targetNode=targetNode;<span class="cstat-no" title="statement not covered" >t</span>his._type=type;<span class="cstat-no" title="statement not covered" >t</span>his._nameOrIndex=nameOrIndex;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.HeapEdge.prototype={_serialize:<span class="fstat-no" title="function not covered" >fu</span>nction(rawSnapshot){<span class="cstat-no" title="statement not covered" >if(!this._targetNode._builder)</span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('Inconsistent state of node: '+this._name+' no builder assigned');c</span>onst builder=<span class="cstat-no" title="statement not covered" >this._targetNode._builder;<span class="cstat-no" title="statement not covered" ></span>rawSnapshot.edges.push(builder.lookupEdgeType(this._type));<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.edges.push((typeof this._nameOrIndex==='string'?builder.lookupOrAddString(this._nameOrIndex):this._nameOrIndex));<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.edges.push(this._targetNode._ordinal*builder.nodeFieldsCount);}</span>};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.HeapEdge.Type={'context':'context','element':'element','property':'property','internal':'internal','hidden':'hidden','shortcut':'shortcut','weak':'weak'};<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.HeapSnapshotBuilder=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._nodes=[];<span class="cstat-no" title="statement not covered" >t</span>his._string2id={};<span class="cstat-no" title="statement not covered" >t</span>his._strings=[];<span class="cstat-no" title="statement not covered" >t</span>his.nodeFieldsCount=7;<span class="cstat-no" title="statement not covered" >t</span>his._nodeTypesMap={};<span class="cstat-no" title="statement not covered" >t</span>his._nodeTypesArray=[];<span class="cstat-no" title="statement not covered" >f</span>or(const nodeType in HeapProfilerTestRunner.HeapNode.Type){<span class="cstat-no" title="statement not covered" >this._nodeTypesMap[nodeType]=this._nodeTypesArray.length;<span class="cstat-no" title="statement not covered" >t</span>his._nodeTypesArray.push(nodeType);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._edgeTypesMap={};<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypesArray=[];<span class="cstat-no" title="statement not covered" >f</span>or(const edgeType in HeapProfilerTestRunner.HeapEdge.Type){<span class="cstat-no" title="statement not covered" >this._edgeTypesMap[edgeType]=this._edgeTypesArray.length;<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypesArray.push(edgeType);}</span></span>
<span class="cstat-no" title="statement not covered" >this.rootNode=new HeapProfilerTestRunner.HeapNode('root',0,'object');<span class="cstat-no" title="statement not covered" >t</span>his.rootNode._setBuilder(this);}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.HeapSnapshotBuilder.prototype={generateSnapshot:<span class="fstat-no" title="function not covered" >fu</span>nction(){const rawSnapshot=<span class="cstat-no" title="statement not covered" >{'snapshot':{'meta':{'node_fields':['type','name','id','self_size','retained_size','dominator','edge_count'],'node_types':[this._nodeTypesArray,'string','number','number','number','number','number'],'edge_fields':['type','name_or_index','to_node'],'edge_types':[this._edgeTypesArray,'string_or_number','node']}},'nodes':[],'edges':[],'locations':[],'strings':[]};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._nodes.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this._nodes[i]._serialize(rawSnapshot);<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.strings=this._strings.slice();c</span>onst meta=<span class="cstat-no" title="statement not covered" >rawSnapshot.snapshot.meta;<span class="cstat-no" title="statement not covered" ></span>rawSnapshot.snapshot.edge_count=rawSnapshot.edges.length/meta.edge_fields.length;<span class="cstat-no" title="statement not covered" >r</span>awSnapshot.snapshot.node_count=rawSnapshot.nodes.length/meta.node_fields.length;<span class="cstat-no" title="statement not covered" >r</span>eturn rawSnapshot;}</span>,createJSHeapSnapshot:<span class="fstat-no" title="function not covered" >fu</span>nction(){const parsedSnapshot=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._postprocessHeapSnapshotMock(this.generateSnapshot());<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.JSHeapSnapshot(parsedSnapshot,new HeapSnapshotWorker.HeapSnapshotProgress());}</span>,_registerNode:<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this._nodes.push(node);<span class="cstat-no" title="statement not covered" >r</span>eturn this._nodes.length-1;}</span>,lookupNodeType:<span class="fstat-no" title="function not covered" >fu</span>nction(typeName){<span class="cstat-no" title="statement not covered" >if(typeName===undefined)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('wrong node type: '+typeName);<span class="cstat-no" title="statement not covered" >i</span>f(!(typeName in this._nodeTypesMap))</span>
<span class="cstat-no" title="statement not covered" >throw new Error('wrong node type name: '+typeName);<span class="cstat-no" title="statement not covered" >r</span>eturn this._nodeTypesMap[typeName];}</span>,lookupEdgeType:<span class="fstat-no" title="function not covered" >fu</span>nction(typeName){<span class="cstat-no" title="statement not covered" >if(!(typeName in this._edgeTypesMap))</span>
<span class="cstat-no" title="statement not covered" >throw new Error('wrong edge type name: '+typeName);<span class="cstat-no" title="statement not covered" >r</span>eturn this._edgeTypesMap[typeName];}</span>,lookupOrAddString:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >if(string in this._string2id)</span>
<span class="cstat-no" title="statement not covered" >return this._string2id[string];<span class="cstat-no" title="statement not covered" >t</span>his._string2id[string]=this._strings.length;<span class="cstat-no" title="statement not covered" >t</span>his._strings.push(string);<span class="cstat-no" title="statement not covered" >r</span>eturn this._strings.length-1;}</span>};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.createHeapSnapshot=<span class="fstat-no" title="function not covered" >fu</span>nction(instanceCount,firstId){let seed=<span class="cstat-no" title="statement not covered" >881669;</span>function <span class="fstat-no" title="function not covered" >pseudoRandom(</span>limit){<span class="cstat-no" title="statement not covered" >seed=seed*355109+153763&gt;&gt;2&amp;65535;<span class="cstat-no" title="statement not covered" >r</span>eturn seed%limit;}</span></span>
const builder=<span class="cstat-no" title="statement not covered" >new HeapProfilerTestRunner.HeapSnapshotBuilder();</span>const rootNode=<span class="cstat-no" title="statement not covered" >builder.rootNode;</span>const gcRootsNode=<span class="cstat-no" title="statement not covered" >new HeapProfilerTestRunner.HeapNode('(GC roots)',0,HeapProfilerTestRunner.HeapNode.Type.synthetic);<span class="cstat-no" title="statement not covered" ></span>rootNode.linkNode(gcRootsNode,HeapProfilerTestRunner.HeapEdge.Type.element);c</span>onst windowNode=<span class="cstat-no" title="statement not covered" >new HeapProfilerTestRunner.HeapNode('Window',20);<span class="cstat-no" title="statement not covered" ></span>rootNode.linkNode(windowNode,HeapProfilerTestRunner.HeapEdge.Type.shortcut);<span class="cstat-no" title="statement not covered" >g</span>cRootsNode.linkNode(windowNode,HeapProfilerTestRunner.HeapEdge.Type.element);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;instanceCount;++i){const sizeOfB=<span class="cstat-no" title="statement not covered" >pseudoRandom(20)+1;</span>const nodeB=<span class="cstat-no" title="statement not covered" >new HeapProfilerTestRunner.HeapNode('B',sizeOfB,undefined,firstId++);<span class="cstat-no" title="statement not covered" ></span>windowNode.linkNode(nodeB,HeapProfilerTestRunner.HeapEdge.Type.element);c</span>onst sizeOfA=<span class="cstat-no" title="statement not covered" >pseudoRandom(50)+1;</span>const nodeA=<span class="cstat-no" title="statement not covered" >new HeapProfilerTestRunner.HeapNode('A',sizeOfA,undefined,firstId++);<span class="cstat-no" title="statement not covered" ></span>nodeB.linkNode(nodeA,HeapProfilerTestRunner.HeapEdge.Type.property,'a');<span class="cstat-no" title="statement not covered" >n</span>odeA.linkNode(nodeA,HeapProfilerTestRunner.HeapEdge.Type.property,'a');}</span></span>
<span class="cstat-no" title="statement not covered" >return builder.generateSnapshot();}</span>;};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.createHeapSnapshotMockFactories();<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.startProfilerTest=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Profiler was enabled.');<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._panelReset=TestRunner.override(UI.panels.heap_profiler,'_reset',<span class="fstat-no" title="function not covered" >fu</span>nction(){},true);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(UI.panels.heap_profiler,'_addProfileHeader',HeapProfilerTestRunner._profileHeaderAdded,true);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(Profiler.ProfileView.prototype,'refresh',HeapProfilerTestRunner._profileViewRefresh,true);<span class="cstat-no" title="statement not covered" >T</span>estRunner.addSniffer(Profiler.HeapSnapshotView.prototype,'show',HeapProfilerTestRunner._snapshotViewShown,true);<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotContainmentDataGrid.prototype.defaultPopulateCount=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 10;}</span>;<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotConstructorsDataGrid.prototype.defaultPopulateCount=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 10;}</span>;<span class="cstat-no" title="statement not covered" >P</span>rofiler.HeapSnapshotDiffDataGrid.prototype.defaultPopulateCount=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 5;}</span>;<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Detailed heap profiles were enabled.');<span class="cstat-no" title="statement not covered" >T</span>estRunner.safeWrap(callback)();}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.completeProfilerTest=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Profiler was disabled.');<span class="cstat-no" title="statement not covered" >T</span>estRunner.completeTest();}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.runHeapSnapshotTestSuite=<span class="fstat-no" title="function not covered" >fu</span>nction(testSuite){const testSuiteTests=<span class="cstat-no" title="statement not covered" >testSuite.slice();</span>let completeTestStack;function <span class="fstat-no" title="function not covered" >runner(</span>){<span class="cstat-no" title="statement not covered" >if(!testSuiteTests.length){<span class="cstat-no" title="statement not covered" >if(completeTestStack)</span></span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('FAIL: test already completed at '+completeTestStack);<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.completeProfilerTest();<span class="cstat-no" title="statement not covered" >c</span>ompleteTestStack=new Error().stack;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
const nextTest=<span class="cstat-no" title="statement not covered" >testSuiteTests.shift();<span class="cstat-no" title="statement not covered" ></span>TestRunner.addResult('');<span class="cstat-no" title="statement not covered" >T</span>estRunner.addResult('Running: '+/function\s([^(]*)/.exec(nextTest)[1]);<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._panelReset.call(UI.panels.heap_profiler);<span class="cstat-no" title="statement not covered" >T</span>estRunner.safeWrap(nextTest)(runner,runner);}</span>
<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.startProfilerTest(runner);}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.assertColumnContentsEqual=<span class="fstat-no" title="function not covered" >fu</span>nction(reference,actual){const length=<span class="cstat-no" title="statement not covered" >Math.min(reference.length,actual.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >TestRunner.assertEquals(reference[i],actual[i],'row '+i);<span class="cstat-no" title="statement not covered" >i</span>f(reference.length&gt;length)</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('extra rows in reference array:\n'+reference.slice(length).join('\n'));e</span>lse <span class="cstat-no" title="statement not covered" >if(actual.length&gt;length)</span>
<span class="cstat-no" title="statement not covered" >TestRunner.addResult('extra rows in actual array:\n'+actual.slice(length).join('\n'));}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.checkArrayIsSorted=<span class="fstat-no" title="function not covered" >fu</span>nction(contents,sortType,sortOrder){function <span class="fstat-no" title="function not covered" >simpleComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return(a&lt;b?-1:(a&gt;b?1:0));}</span></span>
function <span class="fstat-no" title="function not covered" >parseSize(</span>size){<span class="cstat-no" title="statement not covered" >return parseInt(size.replace(/[\xa0,]/g,''),10);}</span>
const extractor=<span class="cstat-no" title="statement not covered" >{text:<span class="fstat-no" title="function not covered" >fu</span>nction(data){<span class="cstat-no" title="statement not covered" >data;}</span>,number:<span class="fstat-no" title="function not covered" >fu</span>nction(data){<span class="cstat-no" title="statement not covered" >return parseInt(data,10);}</span>,size:parseSize,name:<span class="fstat-no" title="function not covered" >fu</span>nction(data){<span class="cstat-no" title="statement not covered" >return data;}</span>,id:<span class="fstat-no" title="function not covered" >fu</span>nction(data){<span class="cstat-no" title="statement not covered" >return parseInt(data,10);}</span>}[sortType];<span class="cstat-no" title="statement not covered" ></span>if(!extractor){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Invalid sort type: '+sortType);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
let acceptableComparisonResult;<span class="cstat-no" title="statement not covered" >if(sortOrder===DataGrid.DataGrid.Order.Ascending){<span class="cstat-no" title="statement not covered" >acceptableComparisonResult=-1;}</span>else <span class="cstat-no" title="statement not covered" >if(sortOrder===DataGrid.DataGrid.Order.Descending){<span class="cstat-no" title="statement not covered" >acceptableComparisonResult=1;}</span>else{<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Invalid sort order: '+sortOrder);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;contents.length-1;++i){const a=<span class="cstat-no" title="statement not covered" >extractor(contents[i]);</span>const b=<span class="cstat-no" title="statement not covered" >extractor(contents[i+1]);</span>const result=<span class="cstat-no" title="statement not covered" >simpleComparator(a,b);<span class="cstat-no" title="statement not covered" ></span>if(result!==0&amp;&amp;result!==acceptableComparisonResult){<span class="cstat-no" title="statement not covered" >TestRunner.addResult('Elements '+i+' and '+(i+1)+' are out of order: '+a+' '+b+' ('+sortOrder+')');}</span>}</span>}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.clickColumn=<span class="fstat-no" title="function not covered" >fu</span>nction(column,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);c</span>onst cell=<span class="cstat-no" title="statement not covered" >this._currentGrid()._headerTableHeaders[column.id];</span>const event=<span class="cstat-no" title="statement not covered" >{target:{enclosingNodeOrSelfWithNodeName:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return cell;}</span>}};</span>function <span class="fstat-no" title="function not covered" >sortingComplete(</span>){<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._currentGrid().removeEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,sortingComplete,this);<span class="cstat-no" title="statement not covered" >T</span>estRunner.assertEquals(column.id,this._currentGrid().sortColumnId(),'unexpected sorting');<span class="cstat-no" title="statement not covered" >c</span>olumn.sort=this._currentGrid().sortOrder();f</span>unction <span class="fstat-no" title="function not covered" >callCallback(</span>){<span class="cstat-no" title="statement not covered" >callback(column);}</span></span>
<span class="cstat-no" title="statement not covered" >setTimeout(callCallback,0);}</span>
<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._currentGrid().addEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,sortingComplete,this);<span class="cstat-no" title="statement not covered" >t</span>his._currentGrid()._clickInHeaderCell(event);}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.clickRowAndGetRetainers=<span class="fstat-no" title="function not covered" >fu</span>nction(row,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);c</span>onst event=<span class="cstat-no" title="statement not covered" >{target:{enclosingNodeOrSelfWithNodeName:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return row._element;}</span>,selectedNode:row}};<span class="cstat-no" title="statement not covered" ></span>this._currentGrid()._mouseDownInDataTable(event);c</span>onst rootNode=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.currentProfileView()._retainmentDataGrid.rootNode();<span class="cstat-no" title="statement not covered" ></span>rootNode.once(Profiler.HeapSnapshotGridNode.Events.PopulateComplete).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >callback(rootNode))</span>;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.clickShowMoreButton=<span class="fstat-no" title="function not covered" >fu</span>nction(buttonName,row,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);c</span>onst parent=<span class="cstat-no" title="statement not covered" >row.parent;<span class="cstat-no" title="statement not covered" ></span>parent.once(Profiler.HeapSnapshotGridNode.Events.PopulateComplete).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >callback(parent),</span>0))</span>;<span class="cstat-no" title="statement not covered" >r</span>ow[buttonName].click();}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.columnContents=<span class="fstat-no" title="function not covered" >fu</span>nction(column,row){<span class="cstat-no" title="statement not covered" >this._currentGrid().updateVisibleNodes();c</span>onst columnOrdinal=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.viewColumns().indexOf(column);</span>const result=<span class="cstat-no" title="statement not covered" >[];</span>const parent=<span class="cstat-no" title="statement not covered" >row||this._currentGrid().rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let node=parent.children[0];node;node=node.traverseNextNode(true,parent,true)){<span class="cstat-no" title="statement not covered" >if(!node.selectable)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et content=<span class="cstat-no" title="statement not covered" >node.element().children[columnOrdinal];<span class="cstat-no" title="statement not covered" ></span>if(content.firstElementChild)</span>
<span class="cstat-no" title="statement not covered" >content=content.firstElementChild;<span class="cstat-no" title="statement not covered" >r</span>esult.push(content.textContent);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.countDataRows=<span class="fstat-no" title="function not covered" >fu</span>nction(row,filter){let result=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>filter=filter||<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >return node.selectable;}</span>;<span class="cstat-no" title="statement not covered" >f</span>or(let node=row.children[0];node;node=node.traverseNextNode(true,row,true)){<span class="cstat-no" title="statement not covered" >if(filter(node))</span></span></span>
<span class="cstat-no" title="statement not covered" >++result;}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.expandRow=<span class="fstat-no" title="function not covered" >fu</span>nction(row,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);<span class="cstat-no" title="statement not covered" >r</span>ow.once(Profiler.HeapSnapshotGridNode.Events.PopulateComplete).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >callback(row),</span>0))</span>;<span class="cstat-no" title="statement not covered" >(</span>function <span class="fstat-no" title="function not covered" >expand(</span>){<span class="cstat-no" title="statement not covered" >if(row.hasChildren())</span></span></span>
<span class="cstat-no" title="statement not covered" >row.expand();e</span>lse
<span class="cstat-no" title="statement not covered" >setTimeout(expand,0);}</span>)();};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.expandRowPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(row){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.expandRow(row,resolve))</span>;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.findAndExpandGCRoots=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.findAndExpandRow('(GC roots)',callback);}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.findAndExpandWindow=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.findAndExpandRow('Window',callback);}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.findAndExpandRow=<span class="fstat-no" title="function not covered" >as</span>ync function(name,callback){const row=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.findRow(name);<span class="cstat-no" title="statement not covered" ></span>TestRunner.assertEquals(true,!!row,`"${name}" row`);<span class="cstat-no" title="statement not covered" >a</span>wait HeapProfilerTestRunner.expandRowPromise(row);<span class="cstat-no" title="statement not covered" >T</span>estRunner.safeWrap(callback)(row);<span class="cstat-no" title="statement not covered" >r</span>eturn row;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.findButtonsNode=<span class="fstat-no" title="function not covered" >fu</span>nction(row,startNode){<span class="cstat-no" title="statement not covered" >for(let node=startNode||row.children[0];node;node=node.traverseNextNode(true,row,true)){<span class="cstat-no" title="statement not covered" >if(!node.selectable&amp;&amp;node.showNext)</span></span></span>
<span class="cstat-no" title="statement not covered" >return node;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.findRow=<span class="fstat-no" title="function not covered" >fu</span>nction(name,parent){<span class="cstat-no" title="statement not covered" >return HeapProfilerTestRunner.findMatchingRow(<span class="fstat-no" title="function not covered" >no</span>de=&gt;<span class="cstat-no" title="statement not covered" >node._name===name,</span>parent);}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.findMatchingRow=<span class="fstat-no" title="function not covered" >fu</span>nction(matcher,parent){<span class="cstat-no" title="statement not covered" >parent=parent||this._currentGrid().rootNode();<span class="cstat-no" title="statement not covered" >f</span>or(let node=parent.children[0];node;node=node.traverseNextNode(true,parent,true)){<span class="cstat-no" title="statement not covered" >if(matcher(node))</span></span></span>
<span class="cstat-no" title="statement not covered" >return node;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.switchToView=<span class="fstat-no" title="function not covered" >fu</span>nction(title,callback){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;{<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);c</span>onst view=<span class="cstat-no" title="statement not covered" >UI.panels.heap_profiler.visibleView;<span class="cstat-no" title="statement not covered" ></span>view._changePerspectiveAndWait(title).then(callback).then(resolve);<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._currentGrid().scrollContainer.style.height='10000px';}</span>);}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.takeAndOpenSnapshot=<span class="fstat-no" title="function not covered" >as</span>ync function(generator,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);c</span>onst snapshot=<span class="cstat-no" title="statement not covered" >generator();</span>const profileType=<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeRegistry.instance.heapSnapshotProfileType;</span>function <span class="fstat-no" title="function not covered" >pushGeneratedSnapshot(</span>reportProgress){<span class="cstat-no" title="statement not covered" >if(reportProgress){<span class="cstat-no" title="statement not covered" >profileType._reportHeapSnapshotProgress({data:{done:50,total:100,finished:false}});<span class="cstat-no" title="statement not covered" >p</span>rofileType._reportHeapSnapshotProgress({data:{done:100,total:100,finished:true}});}</span></span></span>
<span class="cstat-no" title="statement not covered" >snapshot.snapshot.typeId='HEAP';<span class="cstat-no" title="statement not covered" >p</span>rofileType._addHeapSnapshotChunk({data:JSON.stringify(snapshot)});<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span>
<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._takeAndOpenSnapshotCallback=callback;<span class="cstat-no" title="statement not covered" >T</span>estRunner.override(TestRunner.HeapProfilerAgent,'takeHeapSnapshot',pushGeneratedSnapshot);<span class="cstat-no" title="statement not covered" >i</span>f(!UI.context.flavor(SDK.HeapProfilerModel))</span>
<span class="cstat-no" title="statement not covered" >await new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >UI.context.addFlavorChangeListener(SDK.HeapProfilerModel,resolve))</span>;<span class="cstat-no" title="statement not covered" >p</span>rofileType._takeHeapSnapshot();}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.takeSnapshotPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;{const heapProfileType=<span class="cstat-no" title="statement not covered" >Profiler.ProfileTypeRegistry.instance.heapSnapshotProfileType;<span class="cstat-no" title="statement not covered" ></span>heapProfileType.addEventListener(Profiler.HeapSnapshotProfileType.SnapshotReceived,finishHeapSnapshot);<span class="cstat-no" title="statement not covered" >h</span>eapProfileType._takeHeapSnapshot();f</span>unction <span class="fstat-no" title="function not covered" >finishHeapSnapshot(</span>){const profiles=<span class="cstat-no" title="statement not covered" >heapProfileType.getProfiles();<span class="cstat-no" title="statement not covered" ></span>if(!profiles.length)</span></span></span>
<span class="cstat-no" title="statement not covered" >throw'FAILED: no profiles found.';<span class="cstat-no" title="statement not covered" >i</span>f(profiles.length&gt;1)</span>
<span class="cstat-no" title="statement not covered" >throw`FAILED: wrong number of recorded profiles was found. profiles.length = ${profiles.length}`;c</span>onst profile=<span class="cstat-no" title="statement not covered" >profiles[0];<span class="cstat-no" title="statement not covered" ></span>UI.panels.heap_profiler.showProfile(profile);c</span>onst dataGrid=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.currentProfileView()._dataGrid;<span class="cstat-no" title="statement not covered" ></span>dataGrid.addEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,sortingComplete,null);f</span>unction <span class="fstat-no" title="function not covered" >sortingComplete(</span>){<span class="cstat-no" title="statement not covered" >dataGrid.removeEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,sortingComplete,null);<span class="cstat-no" title="statement not covered" >r</span>esolve(profile);}</span>}});};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.viewColumns=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return HeapProfilerTestRunner._currentGrid()._columnsArray;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.currentProfileView=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return UI.panels.heap_profiler.visibleView;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._currentGrid=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.currentProfileView()._dataGrid;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._snapshotViewShown=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(HeapProfilerTestRunner._takeAndOpenSnapshotCallback){const callback=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._takeAndOpenSnapshotCallback;<span class="cstat-no" title="statement not covered" ></span>HeapProfilerTestRunner._takeAndOpenSnapshotCallback=null;c</span>onst dataGrid=<span class="cstat-no" title="statement not covered" >this._dataGrid;</span>function <span class="fstat-no" title="function not covered" >sortingComplete(</span>){<span class="cstat-no" title="statement not covered" >dataGrid.removeEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,sortingComplete,null);<span class="cstat-no" title="statement not covered" >c</span>allback();}</span></span></span>
<span class="cstat-no" title="statement not covered" >dataGrid.addEventListener(Profiler.HeapSnapshotSortableDataGrid.Events.SortingComplete,sortingComplete,null);}</span>};<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.showProfileWhenAdded=<span class="fstat-no" title="function not covered" >fu</span>nction(title){<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._showProfileWhenAdded=title;<span class="cstat-no" title="statement not covered" >r</span>eturn new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._waitUntilProfileViewIsShown(title,resolve))</span>;}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner._profileHeaderAdded=<span class="fstat-no" title="function not covered" >fu</span>nction(profile){<span class="cstat-no" title="statement not covered" >if(HeapProfilerTestRunner._showProfileWhenAdded===profile.title)</span></span>
<span class="cstat-no" title="statement not covered" >UI.panels.heap_profiler.showProfile(profile);}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._waitUntilProfileViewIsShown=<span class="fstat-no" title="function not covered" >fu</span>nction(title,callback){<span class="cstat-no" title="statement not covered" >callback=TestRunner.safeWrap(callback);c</span>onst profilesPanel=<span class="cstat-no" title="statement not covered" >UI.panels.heap_profiler;<span class="cstat-no" title="statement not covered" ></span>if(profilesPanel.visibleView&amp;&amp;profilesPanel.visibleView.profile&amp;&amp;profilesPanel.visibleView._profileHeader.title===title)</span></span>
<span class="cstat-no" title="statement not covered" >callback(profilesPanel.visibleView);e</span>lse
<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._waitUntilProfileViewIsShownCallback={title:title,callback:callback};}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._profileViewRefresh=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(HeapProfilerTestRunner._waitUntilProfileViewIsShownCallback&amp;&amp;HeapProfilerTestRunner._waitUntilProfileViewIsShownCallback.title===this._profileHeader.title){const callback=<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner._waitUntilProfileViewIsShownCallback;<span class="cstat-no" title="statement not covered" ></span>delete HeapProfilerTestRunner._waitUntilProfileViewIsShownCallback;<span class="cstat-no" title="statement not covered" >c</span>allback.callback(this);}</span>}</span>;<span class="cstat-no" title="statement not covered" >H</span>eapProfilerTestRunner.startSamplingHeapProfiler=<span class="fstat-no" title="function not covered" >as</span>ync function(){<span class="cstat-no" title="statement not covered" >if(!UI.context.flavor(SDK.HeapProfilerModel))</span></span>
<span class="cstat-no" title="statement not covered" >await new Promise(<span class="fstat-no" title="function not covered" >re</span>solve=&gt;<span class="cstat-no" title="statement not covered" >UI.context.addFlavorChangeListener(SDK.HeapProfilerModel,resolve))</span>;<span class="cstat-no" title="statement not covered" >P</span>rofiler.SamplingHeapProfileType.instance._startRecordingProfile();}</span>;<span class="cstat-no" title="statement not covered" >HeapProfilerTestRunner.stopSamplingHeapProfiler=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Profiler.SamplingHeapProfileType.instance._stopRecordingProfile();}</span>;;</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:03:43 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
