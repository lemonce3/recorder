<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/linux-unpacked/resources/inspector/heap_snapshot_worker/heap_snapshot_worker_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/linux-unpacked/resources/inspector/heap_snapshot_worker</a> heap_snapshot_worker_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/1642</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/491</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/268</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/439</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.AllocationProfile=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,liveObjectStats){<span class="cstat-no" title="statement not covered" >this._strings=profile.strings;<span class="cstat-no" title="statement not covered" >t</span>his._liveObjectStats=liveObjectStats;<span class="cstat-no" title="statement not covered" >t</span>his._nextNodeId=1;<span class="cstat-no" title="statement not covered" >t</span>his._functionInfos=[];<span class="cstat-no" title="statement not covered" >t</span>his._idToNode={};<span class="cstat-no" title="statement not covered" >t</span>his._idToTopDownNode={};<span class="cstat-no" title="statement not covered" >t</span>his._collapsedTopNodeIdToFunctionInfo={};<span class="cstat-no" title="statement not covered" >t</span>his._traceTops=null;<span class="cstat-no" title="statement not covered" >t</span>his._buildFunctionAllocationInfos(profile);<span class="cstat-no" title="statement not covered" >t</span>his._traceTree=this._buildAllocationTree(profile,liveObjectStats);}</span></span>
<span class="fstat-no" title="function not covered" >_b</span>uildFunctionAllocationInfos(profile){const strings=<span class="cstat-no" title="statement not covered" >this._strings;</span>const functionInfoFields=<span class="cstat-no" title="statement not covered" >profile.snapshot.meta.trace_function_info_fields;</span>const functionNameOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('name');</span>const scriptNameOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('script_name');</span>const scriptIdOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('script_id');</span>const lineOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('line');</span>const columnOffset=<span class="cstat-no" title="statement not covered" >functionInfoFields.indexOf('column');</span>const functionInfoFieldCount=<span class="cstat-no" title="statement not covered" >functionInfoFields.length;</span>const rawInfos=<span class="cstat-no" title="statement not covered" >profile.trace_function_infos;</span>const infoLength=<span class="cstat-no" title="statement not covered" >rawInfos.length;</span>const functionInfos=<span class="cstat-no" title="statement not covered" >this._functionInfos=new Array(infoLength/functionInfoFieldCount);</span>let index=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;infoLength;i+=functionInfoFieldCount){<span class="cstat-no" title="statement not covered" >functionInfos[index++]=new HeapSnapshotWorker.FunctionAllocationInfo(strings[rawInfos[i+functionNameOffset]],strings[rawInfos[i+scriptNameOffset]],rawInfos[i+scriptIdOffset],rawInfos[i+lineOffset],rawInfos[i+columnOffset]);}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildAllocationTree(profile,liveObjectStats){const traceTreeRaw=<span class="cstat-no" title="statement not covered" >profile.trace_tree;</span>const functionInfos=<span class="cstat-no" title="statement not covered" >this._functionInfos;</span>const idToTopDownNode=<span class="cstat-no" title="statement not covered" >this._idToTopDownNode;</span>const traceNodeFields=<span class="cstat-no" title="statement not covered" >profile.snapshot.meta.trace_node_fields;</span>const nodeIdOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('id');</span>const functionInfoIndexOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('function_info_index');</span>const allocationCountOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('count');</span>const allocationSizeOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('size');</span>const childrenOffset=<span class="cstat-no" title="statement not covered" >traceNodeFields.indexOf('children');</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >traceNodeFields.length;</span>function <span class="fstat-no" title="function not covered" >traverseNode(</span>rawNodeArray,nodeOffset,parent){const functionInfo=<span class="cstat-no" title="statement not covered" >functionInfos[rawNodeArray[nodeOffset+functionInfoIndexOffset]];</span>const id=<span class="cstat-no" title="statement not covered" >rawNodeArray[nodeOffset+nodeIdOffset];</span>const stats=<span class="cstat-no" title="statement not covered" >liveObjectStats[id];</span>const liveCount=<span class="cstat-no" title="statement not covered" >stats?stats.count:0;</span>const liveSize=<span class="cstat-no" title="statement not covered" >stats?stats.size:0;</span>const result=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.TopDownAllocationNode(id,functionInfo,rawNodeArray[nodeOffset+allocationCountOffset],rawNodeArray[nodeOffset+allocationSizeOffset],liveCount,liveSize,parent);<span class="cstat-no" title="statement not covered" ></span>idToTopDownNode[id]=result;<span class="cstat-no" title="statement not covered" >f</span>unctionInfo.addTraceTopNode(result);c</span>onst rawChildren=<span class="cstat-no" title="statement not covered" >rawNodeArray[nodeOffset+childrenOffset];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;rawChildren.length;i+=nodeFieldCount)</span>
<span class="cstat-no" title="statement not covered" >result.children.push(traverseNode(rawChildren,i,result));<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="cstat-no" title="statement not covered" >return traverseNode(traceTreeRaw,0,null);}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeTraceTops(){<span class="cstat-no" title="statement not covered" >if(this._traceTops)</span>
<span class="cstat-no" title="statement not covered" >return this._traceTops;c</span>onst result=<span class="cstat-no" title="statement not covered" >this._traceTops=[];</span>const functionInfos=<span class="cstat-no" title="statement not covered" >this._functionInfos;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;functionInfos.length;i++){const info=<span class="cstat-no" title="statement not covered" >functionInfos[i];<span class="cstat-no" title="statement not covered" ></span>if(info.totalCount===0)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst nodeId=<span class="cstat-no" title="statement not covered" >this._nextNodeId++;</span>const isRoot=<span class="cstat-no" title="statement not covered" >i===0;<span class="cstat-no" title="statement not covered" ></span>result.push(this._serializeNode(nodeId,info,info.totalCount,info.totalSize,info.totalLiveCount,info.totalLiveSize,!isRoot));<span class="cstat-no" title="statement not covered" >t</span>his._collapsedTopNodeIdToFunctionInfo[nodeId]=info;}</span>
<span class="cstat-no" title="statement not covered" >result.sort(<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return b.size-a.size;}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeCallers(nodeId){let node=<span class="cstat-no" title="statement not covered" >this._ensureBottomUpNode(nodeId);</span>const nodesWithSingleCaller=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>while(node.callers().length===1){<span class="cstat-no" title="statement not covered" >node=node.callers()[0];<span class="cstat-no" title="statement not covered" >n</span>odesWithSingleCaller.push(this._serializeCaller(node));}</span></span>
const branchingCallers=<span class="cstat-no" title="statement not covered" >[];</span>const callers=<span class="cstat-no" title="statement not covered" >node.callers();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;callers.length;i++)</span>
<span class="cstat-no" title="statement not covered" >branchingCallers.push(this._serializeCaller(callers[i]));<span class="cstat-no" title="statement not covered" >r</span>eturn new HeapSnapshotModel.AllocationNodeCallers(nodesWithSingleCaller,branchingCallers);}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeAllocationStack(traceNodeId){let node=<span class="cstat-no" title="statement not covered" >this._idToTopDownNode[traceNodeId];</span>const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>while(node){const functionInfo=<span class="cstat-no" title="statement not covered" >node.functionInfo;<span class="cstat-no" title="statement not covered" ></span>result.push(new HeapSnapshotModel.AllocationStackFrame(functionInfo.functionName,functionInfo.scriptName,functionInfo.scriptId,functionInfo.line,functionInfo.column));<span class="cstat-no" title="statement not covered" >n</span>ode=node.parent;}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >tr</span>aceIds(allocationNodeId){<span class="cstat-no" title="statement not covered" >return this._ensureBottomUpNode(allocationNodeId).traceTopIds;}</span>
<span class="fstat-no" title="function not covered" >_e</span>nsureBottomUpNode(nodeId){let node=<span class="cstat-no" title="statement not covered" >this._idToNode[nodeId];<span class="cstat-no" title="statement not covered" ></span>if(!node){const functionInfo=<span class="cstat-no" title="statement not covered" >this._collapsedTopNodeIdToFunctionInfo[nodeId];<span class="cstat-no" title="statement not covered" ></span>node=functionInfo.bottomUpRoot();<span class="cstat-no" title="statement not covered" >d</span>elete this._collapsedTopNodeIdToFunctionInfo[nodeId];<span class="cstat-no" title="statement not covered" >t</span>his._idToNode[nodeId]=node;}</span></span>
<span class="cstat-no" title="statement not covered" >return node;}</span>
<span class="fstat-no" title="function not covered" >_s</span>erializeCaller(node){const callerId=<span class="cstat-no" title="statement not covered" >this._nextNodeId++;<span class="cstat-no" title="statement not covered" ></span>this._idToNode[callerId]=node;<span class="cstat-no" title="statement not covered" >r</span>eturn this._serializeNode(callerId,node.functionInfo,node.allocationCount,node.allocationSize,node.liveCount,node.liveSize,node.hasCallers());}</span>
<span class="fstat-no" title="function not covered" >_s</span>erializeNode(nodeId,functionInfo,count,size,liveCount,liveSize,hasChildren){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.SerializedAllocationNode(nodeId,functionInfo.functionName,functionInfo.scriptName,functionInfo.scriptId,functionInfo.line,functionInfo.column,count,size,liveCount,liveSize,hasChildren);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.TopDownAllocationNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(id,functionInfo,count,size,liveCount,liveSize,parent){<span class="cstat-no" title="statement not covered" >this.id=id;<span class="cstat-no" title="statement not covered" >t</span>his.functionInfo=functionInfo;<span class="cstat-no" title="statement not covered" >t</span>his.allocationCount=count;<span class="cstat-no" title="statement not covered" >t</span>his.allocationSize=size;<span class="cstat-no" title="statement not covered" >t</span>his.liveCount=liveCount;<span class="cstat-no" title="statement not covered" >t</span>his.liveSize=liveSize;<span class="cstat-no" title="statement not covered" >t</span>his.parent=parent;<span class="cstat-no" title="statement not covered" >t</span>his.children=[];}</span>};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.BottomUpAllocationNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(functionInfo){<span class="cstat-no" title="statement not covered" >this.functionInfo=functionInfo;<span class="cstat-no" title="statement not covered" >t</span>his.allocationCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.allocationSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.liveCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.liveSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.traceTopIds=[];<span class="cstat-no" title="statement not covered" >t</span>his._callers=[];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dCaller(traceNode){const functionInfo=<span class="cstat-no" title="statement not covered" >traceNode.functionInfo;</span>let result;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._callers.length;i++){const caller=<span class="cstat-no" title="statement not covered" >this._callers[i];<span class="cstat-no" title="statement not covered" ></span>if(caller.functionInfo===functionInfo){<span class="cstat-no" title="statement not covered" >result=caller;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(!result){<span class="cstat-no" title="statement not covered" >result=new HeapSnapshotWorker.BottomUpAllocationNode(functionInfo);<span class="cstat-no" title="statement not covered" >t</span>his._callers.push(result);}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >ca</span>llers(){<span class="cstat-no" title="statement not covered" >return this._callers;}</span>
<span class="fstat-no" title="function not covered" >ha</span>sCallers(){<span class="cstat-no" title="statement not covered" >return this._callers.length&gt;0;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.FunctionAllocationInfo=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(functionName,scriptName,scriptId,line,column){<span class="cstat-no" title="statement not covered" >this.functionName=functionName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptName=scriptName;<span class="cstat-no" title="statement not covered" >t</span>his.scriptId=scriptId;<span class="cstat-no" title="statement not covered" >t</span>his.line=line;<span class="cstat-no" title="statement not covered" >t</span>his.column=column;<span class="cstat-no" title="statement not covered" >t</span>his.totalCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.totalSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveSize=0;<span class="cstat-no" title="statement not covered" >t</span>his._traceTops=[];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dTraceTopNode(node){<span class="cstat-no" title="statement not covered" >if(node.allocationCount===0)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._traceTops.push(node);<span class="cstat-no" title="statement not covered" >t</span>his.totalCount+=node.allocationCount;<span class="cstat-no" title="statement not covered" >t</span>his.totalSize+=node.allocationSize;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveCount+=node.liveCount;<span class="cstat-no" title="statement not covered" >t</span>his.totalLiveSize+=node.liveSize;}</span>
<span class="fstat-no" title="function not covered" >bo</span>ttomUpRoot(){<span class="cstat-no" title="statement not covered" >if(!this._traceTops.length)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span>f(!this._bottomUpTree)</span>
<span class="cstat-no" title="statement not covered" >this._buildAllocationTraceTree();<span class="cstat-no" title="statement not covered" >r</span>eturn this._bottomUpTree;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildAllocationTraceTree(){<span class="cstat-no" title="statement not covered" >this._bottomUpTree=new HeapSnapshotWorker.BottomUpAllocationNode(this);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._traceTops.length;i++){let node=<span class="cstat-no" title="statement not covered" >this._traceTops[i];</span>let bottomUpNode=<span class="cstat-no" title="statement not covered" >this._bottomUpTree;</span>const count=<span class="cstat-no" title="statement not covered" >node.allocationCount;</span>const size=<span class="cstat-no" title="statement not covered" >node.allocationSize;</span>const liveCount=<span class="cstat-no" title="statement not covered" >node.liveCount;</span>const liveSize=<span class="cstat-no" title="statement not covered" >node.liveSize;</span>const traceId=<span class="cstat-no" title="statement not covered" >node.id;<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >bottomUpNode.allocationCount+=count;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.allocationSize+=size;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.liveCount+=liveCount;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.liveSize+=liveSize;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode.traceTopIds.push(traceId);<span class="cstat-no" title="statement not covered" >n</span>ode=node.parent;<span class="cstat-no" title="statement not covered" >i</span>f(node===null)</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >b</span>ottomUpNode=bottomUpNode.addCaller(node);}</span>}}};;<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotItem=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItem.prototype={itemIndex(){},serialize(){}};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotEdge=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,edgeIndex){<span class="cstat-no" title="statement not covered" >this._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his._edges=snapshot.containmentEdges;<span class="cstat-no" title="statement not covered" >t</span>his.edgeIndex=edgeIndex||0;}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotEdge(this._snapshot,this.edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sStringName(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >no</span>de(){<span class="cstat-no" title="statement not covered" >return this._snapshot.createNode(this.nodeIndex());}</span>
<span class="fstat-no" title="function not covered" >no</span>deIndex(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeToNodeOffset];}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return'HeapSnapshotEdge: '+this.name();}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._snapshot._edgeTypes[this.rawType()];}</span>
<span class="fstat-no" title="function not covered" >it</span>emIndex(){<span class="cstat-no" title="statement not covered" >return this.edgeIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this.edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ra</span>wType(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset];}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotItemIterator=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItemIterator.prototype={hasNext(){},item(){},next(){}};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItemIndexProvider=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotItemIndexProvider.prototype={itemForIndex(newIndex){},};<span class="cstat-no" title="statement not covered" >H</span>eapSnapshotWorker.HeapSnapshotNodeIndexProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot){<span class="cstat-no" title="statement not covered" >this._node=snapshot.createNode();}</span></span>
<span class="fstat-no" title="function not covered" >it</span>emForIndex(index){<span class="cstat-no" title="statement not covered" >this._node.nodeIndex=index;<span class="cstat-no" title="statement not covered" >r</span>eturn this._node;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotEdgeIndexProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot){<span class="cstat-no" title="statement not covered" >this._edge=snapshot.createEdge(0);}</span></span>
<span class="fstat-no" title="function not covered" >it</span>emForIndex(index){<span class="cstat-no" title="statement not covered" >this._edge.edgeIndex=index;<span class="cstat-no" title="statement not covered" >r</span>eturn this._edge;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotRetainerEdgeIndexProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot){<span class="cstat-no" title="statement not covered" >this._retainerEdge=snapshot.createRetainingEdge(0);}</span></span>
<span class="fstat-no" title="function not covered" >it</span>emForIndex(index){<span class="cstat-no" title="statement not covered" >this._retainerEdge.setRetainerIndex(index);<span class="cstat-no" title="statement not covered" >r</span>eturn this._retainerEdge;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotEdgeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(node){<span class="cstat-no" title="statement not covered" >this._sourceNode=node;<span class="cstat-no" title="statement not covered" >t</span>his.edge=node._snapshot.createEdge(node.edgeIndexesStart());}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this.edge.edgeIndex&lt;this._sourceNode.edgeIndexesEnd();}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this.edge;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this.edge.edgeIndex+=this.edge._snapshot._edgeFieldsCount;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotRetainerEdge=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,retainerIndex){<span class="cstat-no" title="statement not covered" >this._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his.setRetainerIndex(retainerIndex);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotRetainerEdge(this._snapshot,this.retainerIndex());}</span>
<span class="fstat-no" title="function not covered" >ha</span>sStringName(){<span class="cstat-no" title="statement not covered" >return this._edge().hasStringName();}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._edge().name();}</span>
<span class="fstat-no" title="function not covered" >no</span>de(){<span class="cstat-no" title="statement not covered" >return this._node();}</span>
<span class="fstat-no" title="function not covered" >no</span>deIndex(){<span class="cstat-no" title="statement not covered" >return this._retainingNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >re</span>tainerIndex(){<span class="cstat-no" title="statement not covered" >return this._retainerIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>tRetainerIndex(retainerIndex){<span class="cstat-no" title="statement not covered" >if(retainerIndex===this._retainerIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._retainerIndex=retainerIndex;<span class="cstat-no" title="statement not covered" >t</span>his._globalEdgeIndex=this._snapshot._retainingEdges[retainerIndex];<span class="cstat-no" title="statement not covered" >t</span>his._retainingNodeIndex=this._snapshot._retainingNodes[retainerIndex];<span class="cstat-no" title="statement not covered" >t</span>his._edgeInstance=null;<span class="cstat-no" title="statement not covered" >t</span>his._nodeInstance=null;}</span>
<span class="fstat-no" title="function not covered" >se</span>t edgeIndex(edgeIndex){<span class="cstat-no" title="statement not covered" >this.setRetainerIndex(edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >_n</span>ode(){<span class="cstat-no" title="statement not covered" >if(!this._nodeInstance)</span>
<span class="cstat-no" title="statement not covered" >this._nodeInstance=this._snapshot.createNode(this._retainingNodeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn this._nodeInstance;}</span>
<span class="fstat-no" title="function not covered" >_e</span>dge(){<span class="cstat-no" title="statement not covered" >if(!this._edgeInstance)</span>
<span class="cstat-no" title="statement not covered" >this._edgeInstance=this._snapshot.createEdge(this._globalEdgeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn this._edgeInstance;}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return this._edge().toString();}</span>
<span class="fstat-no" title="function not covered" >it</span>emIndex(){<span class="cstat-no" title="statement not covered" >return this._retainerIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.Edge(this.name(),this.node().serialize(),this.type(),this._globalEdgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._edge().type();}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotRetainerEdgeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(retainedNode){const snapshot=<span class="cstat-no" title="statement not covered" >retainedNode._snapshot;</span>const retainedNodeOrdinal=<span class="cstat-no" title="statement not covered" >retainedNode.ordinal();</span>const retainerIndex=<span class="cstat-no" title="statement not covered" >snapshot._firstRetainerIndex[retainedNodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>this._retainersEnd=snapshot._firstRetainerIndex[retainedNodeOrdinal+1];<span class="cstat-no" title="statement not covered" >t</span>his.retainer=snapshot.createRetainingEdge(retainerIndex);}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this.retainer.retainerIndex()&lt;this._retainersEnd;}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this.retainer;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this.retainer.setRetainerIndex(this.retainer.retainerIndex()+1);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotNode=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,nodeIndex){<span class="cstat-no" title="statement not covered" >this._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >t</span>his.nodeIndex=nodeIndex||0;}</span></span>
<span class="fstat-no" title="function not covered" >di</span>stance(){<span class="cstat-no" title="statement not covered" >return this._snapshot._nodeDistances[this.nodeIndex/this._snapshot._nodeFieldCount];}</span>
<span class="fstat-no" title="function not covered" >cl</span>assName(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >cl</span>assIndex(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >do</span>minatorIndex(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._snapshot._nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>return this._snapshot._dominatorsTree[this.nodeIndex/this._snapshot._nodeFieldCount]*nodeFieldCount;}</span>
<span class="fstat-no" title="function not covered" >ed</span>ges(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotEdgeIterator(this);}</span>
<span class="fstat-no" title="function not covered" >ed</span>gesCount(){<span class="cstat-no" title="statement not covered" >return(this.edgeIndexesEnd()-this.edgeIndexesStart())/this._snapshot._edgeFieldsCount;}</span>
<span class="fstat-no" title="function not covered" >id</span>(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >is</span>Root(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex===this._snapshot._rootNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._snapshot.strings[this._name()];}</span>
<span class="fstat-no" title="function not covered" >re</span>tainedSize(){<span class="cstat-no" title="statement not covered" >return this._snapshot._retainedSizes[this.ordinal()];}</span>
<span class="fstat-no" title="function not covered" >re</span>tainers(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotRetainerEdgeIterator(this);}</span>
<span class="fstat-no" title="function not covered" >re</span>tainersCount(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>const ordinal=<span class="cstat-no" title="statement not covered" >this.ordinal();<span class="cstat-no" title="statement not covered" ></span>return snapshot._firstRetainerIndex[ordinal+1]-snapshot._firstRetainerIndex[ordinal];}</span>
<span class="fstat-no" title="function not covered" >se</span>lfSize(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeSelfSizeOffset];}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._snapshot._nodeTypes[this.rawType()];}</span>
<span class="fstat-no" title="function not covered" >tr</span>aceNodeId(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeTraceNodeIdOffset];}</span>
<span class="fstat-no" title="function not covered" >it</span>emIndex(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex;}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.Node(this.id(),this.name(),this.distance(),this.nodeIndex,this.retainedSize(),this.selfSize(),this.type());}</span>
<span class="fstat-no" title="function not covered" >_n</span>ame(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeNameOffset];}</span>
<span class="fstat-no" title="function not covered" >ed</span>geIndexesStart(){<span class="cstat-no" title="statement not covered" >return this._snapshot._firstEdgeIndexes[this.ordinal()];}</span>
<span class="fstat-no" title="function not covered" >ed</span>geIndexesEnd(){<span class="cstat-no" title="statement not covered" >return this._snapshot._firstEdgeIndexes[this.ordinal()+1];}</span>
<span class="fstat-no" title="function not covered" >or</span>dinal(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex/this._snapshot._nodeFieldCount;}</span>
<span class="fstat-no" title="function not covered" >_n</span>extNodeIndex(){<span class="cstat-no" title="statement not covered" >return this.nodeIndex+this._snapshot._nodeFieldCount;}</span>
<span class="fstat-no" title="function not covered" >ra</span>wType(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeTypeOffset];}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotNodeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(node){<span class="cstat-no" title="statement not covered" >this.node=node;<span class="cstat-no" title="statement not covered" >t</span>his._nodesLength=node._snapshot.nodes.length;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this.node.nodeIndex&lt;this._nodesLength;}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this.node;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this.node.nodeIndex=this.node._nextNodeIndex();}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotIndexRangeIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(itemProvider,indexes){<span class="cstat-no" title="statement not covered" >this._itemProvider=itemProvider;<span class="cstat-no" title="statement not covered" >t</span>his._indexes=indexes;<span class="cstat-no" title="statement not covered" >t</span>his._position=0;}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this._position&lt;this._indexes.length;}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){const index=<span class="cstat-no" title="statement not covered" >this._indexes[this._position];<span class="cstat-no" title="statement not covered" ></span>return this._itemProvider.itemForIndex(index);}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >++this._position;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotFilteredIterator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(iterator,filter){<span class="cstat-no" title="statement not covered" >this._iterator=iterator;<span class="cstat-no" title="statement not covered" >t</span>his._filter=filter;<span class="cstat-no" title="statement not covered" >t</span>his._skipFilteredItems();}</span></span>
<span class="fstat-no" title="function not covered" >ha</span>sNext(){<span class="cstat-no" title="statement not covered" >return this._iterator.hasNext();}</span>
<span class="fstat-no" title="function not covered" >it</span>em(){<span class="cstat-no" title="statement not covered" >return this._iterator.item();}</span>
<span class="fstat-no" title="function not covered" >ne</span>xt(){<span class="cstat-no" title="statement not covered" >this._iterator.next();<span class="cstat-no" title="statement not covered" >t</span>his._skipFilteredItems();}</span>
<span class="fstat-no" title="function not covered" >_s</span>kipFilteredItems(){<span class="cstat-no" title="statement not covered" >while(this._iterator.hasNext()&amp;&amp;!this._filter(this._iterator.item()))</span>
<span class="cstat-no" title="statement not covered" >this._iterator.next();}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotProgress=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(dispatcher){<span class="cstat-no" title="statement not covered" >this._dispatcher=dispatcher;}</span></span>
<span class="fstat-no" title="function not covered" >up</span>dateStatus(status){<span class="cstat-no" title="statement not covered" >this._sendUpdateEvent(Common.UIString(status));}</span>
<span class="fstat-no" title="function not covered" >up</span>dateProgress(title,value,total){const percentValue=<span class="cstat-no" title="statement not covered" >((total?(value/total):0)*100).toFixed(0);<span class="cstat-no" title="statement not covered" ></span>this._sendUpdateEvent(Common.UIString(title,percentValue));}</span>
<span class="fstat-no" title="function not covered" >re</span>portProblem(error){<span class="cstat-no" title="statement not covered" >if(this._dispatcher)</span>
<span class="cstat-no" title="statement not covered" >this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot,error);}</span>
<span class="fstat-no" title="function not covered" >_s</span>endUpdateEvent(text){<span class="cstat-no" title="statement not covered" >if(this._dispatcher)</span>
<span class="cstat-no" title="statement not covered" >this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotProgressEvent.Update,text);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotProblemReport=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(title){<span class="cstat-no" title="statement not covered" >this._errors=[title];}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>dError(error){<span class="cstat-no" title="statement not covered" >if(this._errors.length&gt;100)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._errors.push(error);}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return this._errors.join('\n  ');}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshot=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,progress){<span class="cstat-no" title="statement not covered" >this.nodes=profile.nodes;<span class="cstat-no" title="statement not covered" >t</span>his.containmentEdges=profile.edges;<span class="cstat-no" title="statement not covered" >t</span>his._metaNode=profile.snapshot.meta;<span class="cstat-no" title="statement not covered" >t</span>his._rawSamples=profile.samples;<span class="cstat-no" title="statement not covered" >t</span>his._samples=null;<span class="cstat-no" title="statement not covered" >t</span>his.strings=profile.strings;<span class="cstat-no" title="statement not covered" >t</span>his._locations=profile.locations;<span class="cstat-no" title="statement not covered" >t</span>his._progress=progress;<span class="cstat-no" title="statement not covered" >t</span>his._noDistance=-5;<span class="cstat-no" title="statement not covered" >t</span>his._rootNodeIndex=0;<span class="cstat-no" title="statement not covered" >i</span>f(profile.snapshot.root_index)</span></span>
<span class="cstat-no" title="statement not covered" >this._rootNodeIndex=profile.snapshot.root_index;<span class="cstat-no" title="statement not covered" >t</span>his._snapshotDiffs={};<span class="cstat-no" title="statement not covered" >t</span>his._aggregatesForDiff=null;<span class="cstat-no" title="statement not covered" >t</span>his._aggregates={};<span class="cstat-no" title="statement not covered" >t</span>his._aggregatesSortedFlags={};<span class="cstat-no" title="statement not covered" >t</span>his._profile=profile;}</span>
<span class="fstat-no" title="function not covered" >in</span>itialize(){const meta=<span class="cstat-no" title="statement not covered" >this._metaNode;<span class="cstat-no" title="statement not covered" ></span>this._nodeTypeOffset=meta.node_fields.indexOf('type');<span class="cstat-no" title="statement not covered" >t</span>his._nodeNameOffset=meta.node_fields.indexOf('name');<span class="cstat-no" title="statement not covered" >t</span>his._nodeIdOffset=meta.node_fields.indexOf('id');<span class="cstat-no" title="statement not covered" >t</span>his._nodeSelfSizeOffset=meta.node_fields.indexOf('self_size');<span class="cstat-no" title="statement not covered" >t</span>his._nodeEdgeCountOffset=meta.node_fields.indexOf('edge_count');<span class="cstat-no" title="statement not covered" >t</span>his._nodeTraceNodeIdOffset=meta.node_fields.indexOf('trace_node_id');<span class="cstat-no" title="statement not covered" >t</span>his._nodeFieldCount=meta.node_fields.length;<span class="cstat-no" title="statement not covered" >t</span>his._nodeTypes=meta.node_types[this._nodeTypeOffset];<span class="cstat-no" title="statement not covered" >t</span>his._nodeArrayType=this._nodeTypes.indexOf('array');<span class="cstat-no" title="statement not covered" >t</span>his._nodeHiddenType=this._nodeTypes.indexOf('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._nodeObjectType=this._nodeTypes.indexOf('object');<span class="cstat-no" title="statement not covered" >t</span>his._nodeNativeType=this._nodeTypes.indexOf('native');<span class="cstat-no" title="statement not covered" >t</span>his._nodeConsStringType=this._nodeTypes.indexOf('concatenated string');<span class="cstat-no" title="statement not covered" >t</span>his._nodeSlicedStringType=this._nodeTypes.indexOf('sliced string');<span class="cstat-no" title="statement not covered" >t</span>his._nodeCodeType=this._nodeTypes.indexOf('code');<span class="cstat-no" title="statement not covered" >t</span>his._nodeSyntheticType=this._nodeTypes.indexOf('synthetic');<span class="cstat-no" title="statement not covered" >t</span>his._edgeFieldsCount=meta.edge_fields.length;<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypeOffset=meta.edge_fields.indexOf('type');<span class="cstat-no" title="statement not covered" >t</span>his._edgeNameOffset=meta.edge_fields.indexOf('name_or_index');<span class="cstat-no" title="statement not covered" >t</span>his._edgeToNodeOffset=meta.edge_fields.indexOf('to_node');<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypes=meta.edge_types[this._edgeTypeOffset];<span class="cstat-no" title="statement not covered" >t</span>his._edgeTypes.push('invisible');<span class="cstat-no" title="statement not covered" >t</span>his._edgeElementType=this._edgeTypes.indexOf('element');<span class="cstat-no" title="statement not covered" >t</span>his._edgeHiddenType=this._edgeTypes.indexOf('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._edgeInternalType=this._edgeTypes.indexOf('internal');<span class="cstat-no" title="statement not covered" >t</span>his._edgeShortcutType=this._edgeTypes.indexOf('shortcut');<span class="cstat-no" title="statement not covered" >t</span>his._edgeWeakType=this._edgeTypes.indexOf('weak');<span class="cstat-no" title="statement not covered" >t</span>his._edgeInvisibleType=this._edgeTypes.indexOf('invisible');c</span>onst location_fields=<span class="cstat-no" title="statement not covered" >meta.location_fields||[];<span class="cstat-no" title="statement not covered" ></span>this._locationIndexOffset=location_fields.indexOf('object_index');<span class="cstat-no" title="statement not covered" >t</span>his._locationScriptIdOffset=location_fields.indexOf('script_id');<span class="cstat-no" title="statement not covered" >t</span>his._locationLineOffset=location_fields.indexOf('line');<span class="cstat-no" title="statement not covered" >t</span>his._locationColumnOffset=location_fields.indexOf('column');<span class="cstat-no" title="statement not covered" >t</span>his._locationFieldCount=location_fields.length;<span class="cstat-no" title="statement not covered" >t</span>his.nodeCount=this.nodes.length/this._nodeFieldCount;<span class="cstat-no" title="statement not covered" >t</span>his._edgeCount=this.containmentEdges.length/this._edgeFieldsCount;<span class="cstat-no" title="statement not covered" >t</span>his._retainedSizes=new Float64Array(this.nodeCount);<span class="cstat-no" title="statement not covered" >t</span>his._firstEdgeIndexes=new Uint32Array(this.nodeCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._retainingNodes=new Uint32Array(this._edgeCount);<span class="cstat-no" title="statement not covered" >t</span>his._retainingEdges=new Uint32Array(this._edgeCount);<span class="cstat-no" title="statement not covered" >t</span>his._firstRetainerIndex=new Uint32Array(this.nodeCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._nodeDistances=new Int32Array(this.nodeCount);<span class="cstat-no" title="statement not covered" >t</span>his._firstDominatedNodeIndex=new Uint32Array(this.nodeCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._dominatedNodes=new Uint32Array(this.nodeCount-1);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building edge indexes\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildEdgeIndexes();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building retainers\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildRetainers();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating node flags\u2026');<span class="cstat-no" title="statement not covered" >t</span>his.calculateFlags();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating distances\u2026');<span class="cstat-no" title="statement not covered" >t</span>his.calculateDistances();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building postorder index\u2026');c</span>onst result=<span class="cstat-no" title="statement not covered" >this._buildPostOrderIndex();<span class="cstat-no" title="statement not covered" ></span>this._progress.updateStatus('Building dominator tree\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._dominatorsTree=this._buildDominatorTree(result.postOrderIndex2NodeOrdinal,result.nodeOrdinal2PostOrderIndex);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating retained sizes\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._calculateRetainedSizes(result.postOrderIndex2NodeOrdinal);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building dominated nodes\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildDominatedNodes();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating statistics\u2026');<span class="cstat-no" title="statement not covered" >t</span>his.calculateStatistics();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Calculating samples\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildSamples();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Building locations\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._buildLocationMap();<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Finished processing.');<span class="cstat-no" title="statement not covered" >i</span>f(this._profile.snapshot.trace_function_count){<span class="cstat-no" title="statement not covered" >this._progress.updateStatus('Building allocation statistics\u2026');c</span>onst nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();</span>const liveObjects=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;c</span>onst traceNodeId=<span class="cstat-no" title="statement not covered" >node.traceNodeId();</span>let stats=<span class="cstat-no" title="statement not covered" >liveObjects[traceNodeId];<span class="cstat-no" title="statement not covered" ></span>if(!stats)</span></span></span>
<span class="cstat-no" title="statement not covered" >liveObjects[traceNodeId]=stats={count:0,size:0,ids:[]};<span class="cstat-no" title="statement not covered" >s</span>tats.count++;<span class="cstat-no" title="statement not covered" >s</span>tats.size+=node.selfSize();<span class="cstat-no" title="statement not covered" >s</span>tats.ids.push(node.id());}</span>
<span class="cstat-no" title="statement not covered" >this._allocationProfile=new HeapSnapshotWorker.AllocationProfile(this._profile,liveObjects);<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus('Done');}</span>}
<span class="fstat-no" title="function not covered" >_b</span>uildEdgeIndexes(){const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const nodeEdgeCountOffset=<span class="cstat-no" title="statement not covered" >this._nodeEdgeCountOffset;<span class="cstat-no" title="statement not covered" ></span>firstEdgeIndexes[nodeCount]=this.containmentEdges.length;<span class="cstat-no" title="statement not covered" >f</span>or(let nodeOrdinal=0,edgeIndex=0;nodeOrdinal&lt;nodeCount;++nodeOrdinal){<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal]=edgeIndex;<span class="cstat-no" title="statement not covered" >e</span>dgeIndex+=nodes[nodeOrdinal*nodeFieldCount+nodeEdgeCountOffset]*edgeFieldsCount;}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildRetainers(){const retainingNodes=<span class="cstat-no" title="statement not covered" >this._retainingNodes;</span>const retainingEdges=<span class="cstat-no" title="statement not covered" >this._retainingEdges;</span>const firstRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;<span class="cstat-no" title="statement not covered" ></span>for(let toNodeFieldIndex=edgeToNodeOffset,l=containmentEdges.length;toNodeFieldIndex&lt;l;toNodeFieldIndex+=edgeFieldsCount){const toNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[toNodeFieldIndex];<span class="cstat-no" title="statement not covered" ></span>if(toNodeIndex%nodeFieldCount)</span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('Invalid toNodeIndex '+toNodeIndex);<span class="cstat-no" title="statement not covered" >+</span>+firstRetainerIndex[toNodeIndex/nodeFieldCount];}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0,firstUnusedRetainerSlot=0;i&lt;nodeCount;i++){const retainersCount=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[i];<span class="cstat-no" title="statement not covered" ></span>firstRetainerIndex[i]=firstUnusedRetainerSlot;<span class="cstat-no" title="statement not covered" >r</span>etainingNodes[firstUnusedRetainerSlot]=retainersCount;<span class="cstat-no" title="statement not covered" >f</span>irstUnusedRetainerSlot+=retainersCount;}</span></span>
<span class="cstat-no" title="statement not covered" >firstRetainerIndex[nodeCount]=retainingNodes.length;l</span>et nextNodeFirstEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[0];<span class="cstat-no" title="statement not covered" ></span>for(let srcNodeOrdinal=0;srcNodeOrdinal&lt;nodeCount;++srcNodeOrdinal){const firstEdgeIndex=<span class="cstat-no" title="statement not covered" >nextNodeFirstEdgeIndex;<span class="cstat-no" title="statement not covered" ></span>nextNodeFirstEdgeIndex=firstEdgeIndexes[srcNodeOrdinal+1];c</span>onst srcNodeIndex=<span class="cstat-no" title="statement not covered" >srcNodeOrdinal*nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=firstEdgeIndex;edgeIndex&lt;nextNodeFirstEdgeIndex;edgeIndex+=edgeFieldsCount){const toNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];<span class="cstat-no" title="statement not covered" ></span>if(toNodeIndex%nodeFieldCount)</span></span></span>
<span class="cstat-no" title="statement not covered" >throw new Error('Invalid toNodeIndex '+toNodeIndex);c</span>onst firstRetainerSlotIndex=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[toNodeIndex/nodeFieldCount];</span>const nextUnusedRetainerSlotIndex=<span class="cstat-no" title="statement not covered" >firstRetainerSlotIndex+(--retainingNodes[firstRetainerSlotIndex]);<span class="cstat-no" title="statement not covered" ></span>retainingNodes[nextUnusedRetainerSlotIndex]=srcNodeIndex;<span class="cstat-no" title="statement not covered" >r</span>etainingEdges[nextUnusedRetainerSlotIndex]=edgeIndex;}</span>}}
<span class="fstat-no" title="function not covered" >cr</span>eateNode(nodeIndex){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdge(edgeIndex){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdge(retainerIndex){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >_a</span>llNodes(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotNodeIterator(this.rootNode());}</span>
<span class="fstat-no" title="function not covered" >ro</span>otNode(){<span class="cstat-no" title="statement not covered" >return this.createNode(this._rootNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >ge</span>t rootNodeIndex(){<span class="cstat-no" title="statement not covered" >return this._rootNodeIndex;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t totalSize(){<span class="cstat-no" title="statement not covered" >return this.rootNode().retainedSize();}</span>
<span class="fstat-no" title="function not covered" >_g</span>etDominatedIndex(nodeIndex){<span class="cstat-no" title="statement not covered" >if(nodeIndex%this._nodeFieldCount)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Invalid nodeIndex: '+nodeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn this._firstDominatedNodeIndex[nodeIndex/this._nodeFieldCount];}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateFilter(nodeFilter){const minNodeId=<span class="cstat-no" title="statement not covered" >nodeFilter.minNodeId;</span>const maxNodeId=<span class="cstat-no" title="statement not covered" >nodeFilter.maxNodeId;</span>const allocationNodeId=<span class="cstat-no" title="statement not covered" >nodeFilter.allocationNodeId;</span>let filter;<span class="cstat-no" title="statement not covered" >if(typeof allocationNodeId==='number'){<span class="cstat-no" title="statement not covered" >filter=this._createAllocationStackFilter(allocationNodeId);<span class="cstat-no" title="statement not covered" >f</span>ilter.key='AllocationNodeId: '+allocationNodeId;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof minNodeId==='number'&amp;&amp;typeof maxNodeId==='number'){<span class="cstat-no" title="statement not covered" >filter=this._createNodeIdFilter(minNodeId,maxNodeId);<span class="cstat-no" title="statement not covered" >f</span>ilter.key='NodeIdRange: '+minNodeId+'..'+maxNodeId;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return filter;}</span>
<span class="fstat-no" title="function not covered" >se</span>arch(searchConfig,nodeFilter){const query=<span class="cstat-no" title="statement not covered" >searchConfig.query;</span>function <span class="fstat-no" title="function not covered" >filterString(</span>matchedStringIndexes,string,index){<span class="cstat-no" title="statement not covered" >if(string.indexOf(query)!==-1)</span>
<span class="cstat-no" title="statement not covered" >matchedStringIndexes.add(index);<span class="cstat-no" title="statement not covered" >r</span>eturn matchedStringIndexes;}</span>
const regexp=<span class="cstat-no" title="statement not covered" >searchConfig.isRegex?new RegExp(query):createPlainTextSearchRegex(query,'i');</span>function <span class="fstat-no" title="function not covered" >filterRegexp(</span>matchedStringIndexes,string,index){<span class="cstat-no" title="statement not covered" >if(regexp.test(string))</span>
<span class="cstat-no" title="statement not covered" >matchedStringIndexes.add(index);<span class="cstat-no" title="statement not covered" >r</span>eturn matchedStringIndexes;}</span>
const stringFilter=<span class="cstat-no" title="statement not covered" >(searchConfig.isRegex||!searchConfig.caseSensitive)?filterRegexp:filterString;</span>const stringIndexes=<span class="cstat-no" title="statement not covered" >this.strings.reduce(stringFilter,new Set());<span class="cstat-no" title="statement not covered" ></span>if(!stringIndexes.size)</span>
<span class="cstat-no" title="statement not covered" >return[];c</span>onst filter=<span class="cstat-no" title="statement not covered" >this._createFilter(nodeFilter);</span>const nodeIds=<span class="cstat-no" title="statement not covered" >[];</span>const nodesLength=<span class="cstat-no" title="statement not covered" >this.nodes.length;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodeNameOffset=<span class="cstat-no" title="statement not covered" >this._nodeNameOffset;</span>const nodeIdOffset=<span class="cstat-no" title="statement not covered" >this._nodeIdOffset;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(node))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(stringIndexes.has(nodes[nodeIndex+nodeNameOffset]))</span>
<span class="cstat-no" title="statement not covered" >nodeIds.push(nodes[nodeIndex+nodeIdOffset]);}</span>
<span class="cstat-no" title="statement not covered" >return nodeIds;}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregatesWithFilter(nodeFilter){const filter=<span class="cstat-no" title="statement not covered" >this._createFilter(nodeFilter);</span>const key=<span class="cstat-no" title="statement not covered" >filter?filter.key:'allObjects';<span class="cstat-no" title="statement not covered" ></span>return this.aggregates(false,key,filter);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateNodeIdFilter(minNodeId,maxNodeId){function <span class="fstat-no" title="function not covered" >nodeIdFilter(</span>node){const id=<span class="cstat-no" title="statement not covered" >node.id();<span class="cstat-no" title="statement not covered" ></span>return id&gt;minNodeId&amp;&amp;id&lt;=maxNodeId;}</span>
<span class="cstat-no" title="statement not covered" >return nodeIdFilter;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateAllocationStackFilter(bottomUpAllocationNodeId){const traceIds=<span class="cstat-no" title="statement not covered" >this._allocationProfile.traceIds(bottomUpAllocationNodeId);<span class="cstat-no" title="statement not covered" ></span>if(!traceIds.length)</span>
<span class="cstat-no" title="statement not covered" >return undefined;c</span>onst set=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;traceIds.length;i++)</span>
<span class="cstat-no" title="statement not covered" >set[traceIds[i]]=true;f</span>unction <span class="fstat-no" title="function not covered" >traceIdFilter(</span>node){<span class="cstat-no" title="statement not covered" >return!!set[node.traceNodeId()];}</span>
<span class="cstat-no" title="statement not covered" >return traceIdFilter;}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregates(sortedIndexes,key,filter){let aggregatesByClassName=<span class="cstat-no" title="statement not covered" >key&amp;&amp;this._aggregates[key];<span class="cstat-no" title="statement not covered" ></span>if(!aggregatesByClassName){const aggregates=<span class="cstat-no" title="statement not covered" >this._buildAggregates(filter);<span class="cstat-no" title="statement not covered" ></span>this._calculateClassesRetainedSize(aggregates.aggregatesByClassIndex,filter);<span class="cstat-no" title="statement not covered" >a</span>ggregatesByClassName=aggregates.aggregatesByClassName;<span class="cstat-no" title="statement not covered" >i</span>f(key)</span></span>
<span class="cstat-no" title="statement not covered" >this._aggregates[key]=aggregatesByClassName;}</span>
<span class="cstat-no" title="statement not covered" >if(sortedIndexes&amp;&amp;(!key||!this._aggregatesSortedFlags[key])){<span class="cstat-no" title="statement not covered" >this._sortAggregateIndexes(aggregatesByClassName);<span class="cstat-no" title="statement not covered" >i</span>f(key)</span></span>
<span class="cstat-no" title="statement not covered" >this._aggregatesSortedFlags[key]=sortedIndexes;}</span>
<span class="cstat-no" title="statement not covered" >return aggregatesByClassName;}</span>
<span class="fstat-no" title="function not covered" >al</span>locationTracesTops(){<span class="cstat-no" title="statement not covered" >return this._allocationProfile.serializeTraceTops();}</span>
<span class="fstat-no" title="function not covered" >al</span>locationNodeCallers(nodeId){<span class="cstat-no" title="statement not covered" >return this._allocationProfile.serializeCallers(nodeId);}</span>
<span class="fstat-no" title="function not covered" >al</span>locationStack(nodeIndex){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const allocationNodeId=<span class="cstat-no" title="statement not covered" >node.traceNodeId();<span class="cstat-no" title="statement not covered" ></span>if(!allocationNodeId)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this._allocationProfile.serializeAllocationStack(allocationNodeId);}</span>
<span class="fstat-no" title="function not covered" >ag</span>gregatesForDiff(){<span class="cstat-no" title="statement not covered" >if(this._aggregatesForDiff)</span>
<span class="cstat-no" title="statement not covered" >return this._aggregatesForDiff;c</span>onst aggregatesByClassName=<span class="cstat-no" title="statement not covered" >this.aggregates(true,'allObjects');<span class="cstat-no" title="statement not covered" ></span>this._aggregatesForDiff={};c</span>onst node=<span class="cstat-no" title="statement not covered" >this.createNode();<span class="cstat-no" title="statement not covered" ></span>for(const className in aggregatesByClassName){const aggregate=<span class="cstat-no" title="statement not covered" >aggregatesByClassName[className];</span>const indexes=<span class="cstat-no" title="statement not covered" >aggregate.idxs;</span>const ids=<span class="cstat-no" title="statement not covered" >new Array(indexes.length);</span>const selfSizes=<span class="cstat-no" title="statement not covered" >new Array(indexes.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;indexes.length;i++){<span class="cstat-no" title="statement not covered" >node.nodeIndex=indexes[i];<span class="cstat-no" title="statement not covered" >i</span>ds[i]=node.id();<span class="cstat-no" title="statement not covered" >s</span>elfSizes[i]=node.selfSize();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._aggregatesForDiff[className]={indexes:indexes,ids:ids,selfSizes:selfSizes};}</span>
<span class="cstat-no" title="statement not covered" >return this._aggregatesForDiff;}</span>
<span class="fstat-no" title="function not covered" >is</span>UserRoot(node){<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateDistances(filter){const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const distances=<span class="cstat-no" title="statement not covered" >this._nodeDistances;</span>const noDistance=<span class="cstat-no" title="statement not covered" >this._noDistance;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;nodeCount;++i)</span>
<span class="cstat-no" title="statement not covered" >distances[i]=noDistance;c</span>onst nodesToVisit=<span class="cstat-no" title="statement not covered" >new Uint32Array(this.nodeCount);</span>let nodesToVisitLength=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let iter=this.rootNode().edges();iter.hasNext();iter.next()){const node=<span class="cstat-no" title="statement not covered" >iter.edge.node();<span class="cstat-no" title="statement not covered" ></span>if(this.isUserRoot(node)){<span class="cstat-no" title="statement not covered" >distances[node.ordinal()]=1;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[nodesToVisitLength++]=node.nodeIndex;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._bfs(nodesToVisit,nodesToVisitLength,distances,filter);<span class="cstat-no" title="statement not covered" >d</span>istances[this.rootNode().ordinal()]=HeapSnapshotModel.baseSystemDistance;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[0]=this.rootNode().nodeIndex;<span class="cstat-no" title="statement not covered" >n</span>odesToVisitLength=1;<span class="cstat-no" title="statement not covered" >t</span>his._bfs(nodesToVisit,nodesToVisitLength,distances,filter);}</span>
<span class="fstat-no" title="function not covered" >_b</span>fs(nodesToVisit,nodesToVisitLength,distances,filter){const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const edgeWeakType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const noDistance=<span class="cstat-no" title="statement not covered" >this._noDistance;</span>let index=<span class="cstat-no" title="statement not covered" >0;</span>const edge=<span class="cstat-no" title="statement not covered" >this.createEdge(0);</span>const node=<span class="cstat-no" title="statement not covered" >this.createNode(0);<span class="cstat-no" title="statement not covered" ></span>while(index&lt;nodesToVisitLength){const nodeIndex=<span class="cstat-no" title="statement not covered" >nodesToVisit[index++];</span>const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const distance=<span class="cstat-no" title="statement not covered" >distances[nodeOrdinal]+1;</span>const firstEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const edgesEnd=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >f</span>or(let edgeIndex=firstEdgeIndex;edgeIndex&lt;edgesEnd;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType===edgeWeakType)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(distances[childNodeOrdinal]!==noDistance)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >e</span>dge.edgeIndex=edgeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(node,edge))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >d</span>istances[childNodeOrdinal]=distance;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[nodesToVisitLength++]=childNodeIndex;}</span>}
<span class="cstat-no" title="statement not covered" >if(nodesToVisitLength&gt;nodeCount){<span class="cstat-no" title="statement not covered" >throw new Error('BFS failed. Nodes to visit ('+nodesToVisitLength+') is more than nodes count ('+nodeCount+')');}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildAggregates(filter){const aggregates=<span class="cstat-no" title="statement not covered" >{};</span>const aggregatesByClassName=<span class="cstat-no" title="statement not covered" >{};</span>const classIndexes=<span class="cstat-no" title="statement not covered" >[];</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const selfSizeOffset=<span class="cstat-no" title="statement not covered" >this._nodeSelfSizeOffset;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();</span>const nodeDistances=<span class="cstat-no" title="statement not covered" >this._nodeDistances;<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(filter&amp;&amp;!filter(node))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst selfSize=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+selfSizeOffset];<span class="cstat-no" title="statement not covered" ></span>if(!selfSize&amp;&amp;nodes[nodeIndex+nodeTypeOffset]!==nodeNativeType)</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst classIndex=<span class="cstat-no" title="statement not covered" >node.classIndex();</span>const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const distance=<span class="cstat-no" title="statement not covered" >nodeDistances[nodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>if(!(classIndex in aggregates)){const nodeType=<span class="cstat-no" title="statement not covered" >node.type();</span>const nameMatters=<span class="cstat-no" title="statement not covered" >nodeType==='object'||nodeType==='native';</span>const value=<span class="cstat-no" title="statement not covered" >{count:1,distance:distance,self:selfSize,maxRet:0,type:nodeType,name:nameMatters?node.name():null,idxs:[nodeIndex]};<span class="cstat-no" title="statement not covered" ></span>aggregates[classIndex]=value;<span class="cstat-no" title="statement not covered" >c</span>lassIndexes.push(classIndex);<span class="cstat-no" title="statement not covered" >a</span>ggregatesByClassName[node.className()]=value;}</span>else{const clss=<span class="cstat-no" title="statement not covered" >aggregates[classIndex];<span class="cstat-no" title="statement not covered" ></span>clss.distance=Math.min(clss.distance,distance);<span class="cstat-no" title="statement not covered" >+</span>+clss.count;<span class="cstat-no" title="statement not covered" >c</span>lss.self+=selfSize;<span class="cstat-no" title="statement not covered" >c</span>lss.idxs.push(nodeIndex);}</span>}</span>
<span class="cstat-no" title="statement not covered" >for(let i=0,l=classIndexes.length;i&lt;l;++i){const classIndex=<span class="cstat-no" title="statement not covered" >classIndexes[i];<span class="cstat-no" title="statement not covered" ></span>aggregates[classIndex].idxs=aggregates[classIndex].idxs.slice();}</span></span>
<span class="cstat-no" title="statement not covered" >return{aggregatesByClassName:aggregatesByClassName,aggregatesByClassIndex:aggregates};}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateClassesRetainedSize(aggregates,filter){const rootNodeIndex=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex;</span>const node=<span class="cstat-no" title="statement not covered" >this.createNode(rootNodeIndex);</span>const list=<span class="cstat-no" title="statement not covered" >[rootNodeIndex];</span>const sizes=<span class="cstat-no" title="statement not covered" >[-1];</span>const classes=<span class="cstat-no" title="statement not covered" >[];</span>const seenClassNameIndexes=<span class="cstat-no" title="statement not covered" >{};</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const dominatedNodes=<span class="cstat-no" title="statement not covered" >this._dominatedNodes;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const firstDominatedNodeIndex=<span class="cstat-no" title="statement not covered" >this._firstDominatedNodeIndex;<span class="cstat-no" title="statement not covered" ></span>while(list.length){const nodeIndex=<span class="cstat-no" title="statement not covered" >list.pop();<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=nodeIndex;l</span>et classIndex=<span class="cstat-no" title="statement not covered" >node.classIndex();</span>const seen=<span class="cstat-no" title="statement not covered" >!!seenClassNameIndexes[classIndex];</span>const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const dominatedIndexFrom=<span class="cstat-no" title="statement not covered" >firstDominatedNodeIndex[nodeOrdinal];</span>const dominatedIndexTo=<span class="cstat-no" title="statement not covered" >firstDominatedNodeIndex[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>if(!seen&amp;&amp;(!filter||filter(node))&amp;&amp;(node.selfSize()||nodes[nodeIndex+nodeTypeOffset]===nodeNativeType)){<span class="cstat-no" title="statement not covered" >aggregates[classIndex].maxRet+=node.retainedSize();<span class="cstat-no" title="statement not covered" >i</span>f(dominatedIndexFrom!==dominatedIndexTo){<span class="cstat-no" title="statement not covered" >seenClassNameIndexes[classIndex]=true;<span class="cstat-no" title="statement not covered" >s</span>izes.push(list.length);<span class="cstat-no" title="statement not covered" >c</span>lasses.push(classIndex);}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(let i=dominatedIndexFrom;i&lt;dominatedIndexTo;i++)</span>
<span class="cstat-no" title="statement not covered" >list.push(dominatedNodes[i]);c</span>onst l=<span class="cstat-no" title="statement not covered" >list.length;<span class="cstat-no" title="statement not covered" ></span>while(sizes[sizes.length-1]===l){<span class="cstat-no" title="statement not covered" >sizes.pop();<span class="cstat-no" title="statement not covered" >c</span>lassIndex=classes.pop();<span class="cstat-no" title="statement not covered" >s</span>eenClassNameIndexes[classIndex]=false;}</span>}</span>}
<span class="fstat-no" title="function not covered" >_s</span>ortAggregateIndexes(aggregates){const nodeA=<span class="cstat-no" title="statement not covered" >this.createNode();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.createNode();<span class="cstat-no" title="statement not covered" ></span>for(const clss in aggregates){<span class="cstat-no" title="statement not covered" >aggregates[clss].idxs.sort(<span class="fstat-no" title="function not covered" >(i</span>dxA,idxB)=&gt;{<span class="cstat-no" title="statement not covered" >nodeA.nodeIndex=idxA;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=idxB;<span class="cstat-no" title="statement not covered" >r</span>eturn nodeA.id()&lt;nodeB.id()?-1:1;}</span>);}</span>}</span>
<span class="fstat-no" title="function not covered" >_i</span>sEssentialEdge(nodeIndex,edgeType){<span class="cstat-no" title="statement not covered" >return edgeType!==this._edgeWeakType&amp;&amp;(edgeType!==this._edgeShortcutType||nodeIndex===this._rootNodeIndex);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildPostOrderIndex(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const rootNodeOrdinal=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex/nodeFieldCount;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const mapAndFlag=<span class="cstat-no" title="statement not covered" >this.userObjectsMapAndFlag();</span>const flags=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.map:null;</span>const flag=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.flag:0;</span>const stackNodes=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const stackCurrentEdge=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const postOrderIndex2NodeOrdinal=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const nodeOrdinal2PostOrderIndex=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodeCount);</span>const visited=<span class="cstat-no" title="statement not covered" >new Uint8Array(nodeCount);</span>let postOrderIndex=<span class="cstat-no" title="statement not covered" >0;</span>let stackTop=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>stackNodes[0]=rootNodeOrdinal;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[0]=firstEdgeIndexes[rootNodeOrdinal];<span class="cstat-no" title="statement not covered" >v</span>isited[rootNodeOrdinal]=1;l</span>et iteration=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >++iteration;<span class="cstat-no" title="statement not covered" >w</span>hile(stackTop&gt;=0){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >stackNodes[stackTop];</span>const edgeIndex=<span class="cstat-no" title="statement not covered" >stackCurrentEdge[stackTop];</span>const edgesEnd=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>if(edgeIndex&lt;edgesEnd){<span class="cstat-no" title="statement not covered" >stackCurrentEdge[stackTop]+=edgeFieldsCount;c</span>onst edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(!this._isEssentialEdge(nodeOrdinal*nodeFieldCount,edgeType))</span></span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(visited[childNodeOrdinal])</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst nodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[nodeOrdinal]&amp;flag);</span>const childNodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[childNodeOrdinal]&amp;flag);<span class="cstat-no" title="statement not covered" ></span>if(nodeOrdinal!==rootNodeOrdinal&amp;&amp;childNodeFlag&amp;&amp;!nodeFlag)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >+</span>+stackTop;<span class="cstat-no" title="statement not covered" >s</span>tackNodes[stackTop]=childNodeOrdinal;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[stackTop]=firstEdgeIndexes[childNodeOrdinal];<span class="cstat-no" title="statement not covered" >v</span>isited[childNodeOrdinal]=1;}</span>else{<span class="cstat-no" title="statement not covered" >nodeOrdinal2PostOrderIndex[nodeOrdinal]=postOrderIndex;<span class="cstat-no" title="statement not covered" >p</span>ostOrderIndex2NodeOrdinal[postOrderIndex++]=nodeOrdinal;<span class="cstat-no" title="statement not covered" >-</span>-stackTop;}</span>}
<span class="cstat-no" title="statement not covered" >if(postOrderIndex===nodeCount||iteration&gt;1)</span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst errors=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotProblemReport(`Heap snapshot: ${</span>
                            nodeCount - postOrderIndex
                          } nodes are unreachable from the root. Following nodes have only weak retainers:`);const dumpNode=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>--postOrderIndex;<span class="cstat-no" title="statement not covered" >s</span>tackTop=0;<span class="cstat-no" title="statement not covered" >s</span>tackNodes[0]=rootNodeOrdinal;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[0]=firstEdgeIndexes[rootNodeOrdinal+1];<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;nodeCount;++i){<span class="cstat-no" title="statement not covered" >if(visited[i]||!this._hasOnlyWeakRetainers(i))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >s</span>tackNodes[++stackTop]=i;<span class="cstat-no" title="statement not covered" >s</span>tackCurrentEdge[stackTop]=firstEdgeIndexes[i];<span class="cstat-no" title="statement not covered" >v</span>isited[i]=1;<span class="cstat-no" title="statement not covered" >d</span>umpNode.nodeIndex=i*nodeFieldCount;c</span>onst retainers=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let it=dumpNode.retainers();it.hasNext();it.next())</span>
<span class="cstat-no" title="statement not covered" >retainers.push(`${it.item().node().name()}@${it.item().node().id()}.${it.item().name()}`);<span class="cstat-no" title="statement not covered" >e</span>rrors.addError(`${dumpNode.name()} @${dumpNode.id()}  weak retainers: ${retainers.join(', ')}`);}</span>
<span class="cstat-no" title="statement not covered" >console.warn(errors.toString());}</span>
<span class="cstat-no" title="statement not covered" >if(postOrderIndex!==nodeCount){const errors=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotProblemReport('Still found '+(nodeCount-postOrderIndex)+' unreachable nodes in heap snapshot:');</span>const dumpNode=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>--postOrderIndex;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;nodeCount;++i){<span class="cstat-no" title="statement not covered" >if(visited[i])</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >d</span>umpNode.nodeIndex=i*nodeFieldCount;<span class="cstat-no" title="statement not covered" >e</span>rrors.addError(dumpNode.name()+' @'+dumpNode.id());<span class="cstat-no" title="statement not covered" >n</span>odeOrdinal2PostOrderIndex[i]=postOrderIndex;<span class="cstat-no" title="statement not covered" >p</span>ostOrderIndex2NodeOrdinal[postOrderIndex++]=i;}</span>
<span class="cstat-no" title="statement not covered" >nodeOrdinal2PostOrderIndex[rootNodeOrdinal]=postOrderIndex;<span class="cstat-no" title="statement not covered" >p</span>ostOrderIndex2NodeOrdinal[postOrderIndex++]=rootNodeOrdinal;<span class="cstat-no" title="statement not covered" >c</span>onsole.warn(errors.toString());}</span>
<span class="cstat-no" title="statement not covered" >return{postOrderIndex2NodeOrdinal:postOrderIndex2NodeOrdinal,nodeOrdinal2PostOrderIndex:nodeOrdinal2PostOrderIndex};}</span>
<span class="fstat-no" title="function not covered" >_h</span>asOnlyWeakRetainers(nodeOrdinal){const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeWeakType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const edgeShortcutType=<span class="cstat-no" title="statement not covered" >this._edgeShortcutType;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const retainingEdges=<span class="cstat-no" title="statement not covered" >this._retainingEdges;</span>const beginRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex[nodeOrdinal];</span>const endRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let retainerIndex=beginRetainerIndex;retainerIndex&lt;endRetainerIndex;++retainerIndex){const retainerEdgeIndex=<span class="cstat-no" title="statement not covered" >retainingEdges[retainerIndex];</span>const retainerEdgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[retainerEdgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(retainerEdgeType!==edgeWeakType&amp;&amp;retainerEdgeType!==edgeShortcutType)</span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildDominatorTree(postOrderIndex2NodeOrdinal,nodeOrdinal2PostOrderIndex){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const firstRetainerIndex=<span class="cstat-no" title="statement not covered" >this._firstRetainerIndex;</span>const retainingNodes=<span class="cstat-no" title="statement not covered" >this._retainingNodes;</span>const retainingEdges=<span class="cstat-no" title="statement not covered" >this._retainingEdges;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const rootNodeIndex=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex;</span>const mapAndFlag=<span class="cstat-no" title="statement not covered" >this.userObjectsMapAndFlag();</span>const flags=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.map:null;</span>const flag=<span class="cstat-no" title="statement not covered" >mapAndFlag?mapAndFlag.flag:0;</span>const nodesCount=<span class="cstat-no" title="statement not covered" >postOrderIndex2NodeOrdinal.length;</span>const rootPostOrderedIndex=<span class="cstat-no" title="statement not covered" >nodesCount-1;</span>const noEntry=<span class="cstat-no" title="statement not covered" >nodesCount;</span>const dominators=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodesCount);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;rootPostOrderedIndex;++i)</span>
<span class="cstat-no" title="statement not covered" >dominators[i]=noEntry;<span class="cstat-no" title="statement not covered" >d</span>ominators[rootPostOrderedIndex]=rootPostOrderedIndex;c</span>onst affected=<span class="cstat-no" title="statement not covered" >new Uint8Array(nodesCount);</span>let nodeOrdinal;{<span class="cstat-no" title="statement not covered" >nodeOrdinal=this._rootNodeIndex/nodeFieldCount;c</span>onst endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=firstEdgeIndexes[nodeOrdinal];edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(!this._isEssentialEdge(this._rootNodeIndex,edgeType))</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst childNodeOrdinal=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset]/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]]=1;}</span>}
let changed=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>while(changed){<span class="cstat-no" title="statement not covered" >changed=false;<span class="cstat-no" title="statement not covered" >f</span>or(let postOrderIndex=rootPostOrderedIndex-1;postOrderIndex&gt;=0;--postOrderIndex){<span class="cstat-no" title="statement not covered" >if(affected[postOrderIndex]===0)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >a</span>ffected[postOrderIndex]=0;<span class="cstat-no" title="statement not covered" >i</span>f(dominators[postOrderIndex]===rootPostOrderedIndex)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >n</span>odeOrdinal=postOrderIndex2NodeOrdinal[postOrderIndex];c</span>onst nodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[nodeOrdinal]&amp;flag);</span>let newDominatorIndex=<span class="cstat-no" title="statement not covered" >noEntry;</span>const beginRetainerIndex=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[nodeOrdinal];</span>const endRetainerIndex=<span class="cstat-no" title="statement not covered" >firstRetainerIndex[nodeOrdinal+1];</span>let orphanNode=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>for(let retainerIndex=beginRetainerIndex;retainerIndex&lt;endRetainerIndex;++retainerIndex){const retainerEdgeIndex=<span class="cstat-no" title="statement not covered" >retainingEdges[retainerIndex];</span>const retainerEdgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[retainerEdgeIndex+edgeTypeOffset];</span>const retainerNodeIndex=<span class="cstat-no" title="statement not covered" >retainingNodes[retainerIndex];<span class="cstat-no" title="statement not covered" ></span>if(!this._isEssentialEdge(retainerNodeIndex,retainerEdgeType))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >o</span>rphanNode=false;c</span>onst retainerNodeOrdinal=<span class="cstat-no" title="statement not covered" >retainerNodeIndex/nodeFieldCount;</span>const retainerNodeFlag=<span class="cstat-no" title="statement not covered" >!flags||(flags[retainerNodeOrdinal]&amp;flag);<span class="cstat-no" title="statement not covered" ></span>if(retainerNodeIndex!==rootNodeIndex&amp;&amp;nodeFlag&amp;&amp;!retainerNodeFlag)</span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et retanerPostOrderIndex=<span class="cstat-no" title="statement not covered" >nodeOrdinal2PostOrderIndex[retainerNodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>if(dominators[retanerPostOrderIndex]!==noEntry){<span class="cstat-no" title="statement not covered" >if(newDominatorIndex===noEntry){<span class="cstat-no" title="statement not covered" >newDominatorIndex=retanerPostOrderIndex;}</span>else{<span class="cstat-no" title="statement not covered" >while(retanerPostOrderIndex!==newDominatorIndex){<span class="cstat-no" title="statement not covered" >while(retanerPostOrderIndex&lt;newDominatorIndex)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >retanerPostOrderIndex=dominators[retanerPostOrderIndex];<span class="cstat-no" title="statement not covered" >w</span>hile(newDominatorIndex&lt;retanerPostOrderIndex)</span>
<span class="cstat-no" title="statement not covered" >newDominatorIndex=dominators[newDominatorIndex];}</span>}
<span class="cstat-no" title="statement not covered" >if(newDominatorIndex===rootPostOrderedIndex)</span>
<span class="cstat-no" title="statement not covered" >break;}</span>}
<span class="cstat-no" title="statement not covered" >if(orphanNode)</span>
<span class="cstat-no" title="statement not covered" >newDominatorIndex=rootPostOrderedIndex;<span class="cstat-no" title="statement not covered" >i</span>f(newDominatorIndex!==noEntry&amp;&amp;dominators[postOrderIndex]!==newDominatorIndex){<span class="cstat-no" title="statement not covered" >dominators[postOrderIndex]=newDominatorIndex;<span class="cstat-no" title="statement not covered" >c</span>hanged=true;<span class="cstat-no" title="statement not covered" >n</span>odeOrdinal=postOrderIndex2NodeOrdinal[postOrderIndex];c</span>onst beginEdgeToNodeFieldIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal]+edgeToNodeOffset;</span>const endEdgeToNodeFieldIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let toNodeFieldIndex=beginEdgeToNodeFieldIndex;toNodeFieldIndex&lt;endEdgeToNodeFieldIndex;toNodeFieldIndex+=edgeFieldsCount){const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >containmentEdges[toNodeFieldIndex]/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]]=1;}</span>}</span>}</span>}
const dominatorsTree=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodesCount);<span class="cstat-no" title="statement not covered" ></span>for(let postOrderIndex=0,l=dominators.length;postOrderIndex&lt;l;++postOrderIndex){<span class="cstat-no" title="statement not covered" >nodeOrdinal=postOrderIndex2NodeOrdinal[postOrderIndex];<span class="cstat-no" title="statement not covered" >d</span>ominatorsTree[nodeOrdinal]=postOrderIndex2NodeOrdinal[dominators[postOrderIndex]];}</span></span>
<span class="cstat-no" title="statement not covered" >return dominatorsTree;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateRetainedSizes(postOrderIndex2NodeOrdinal){const nodeCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodeSelfSizeOffset=<span class="cstat-no" title="statement not covered" >this._nodeSelfSizeOffset;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const dominatorsTree=<span class="cstat-no" title="statement not covered" >this._dominatorsTree;</span>const retainedSizes=<span class="cstat-no" title="statement not covered" >this._retainedSizes;<span class="cstat-no" title="statement not covered" ></span>for(let nodeOrdinal=0;nodeOrdinal&lt;nodeCount;++nodeOrdinal)</span>
<span class="cstat-no" title="statement not covered" >retainedSizes[nodeOrdinal]=nodes[nodeOrdinal*nodeFieldCount+nodeSelfSizeOffset];<span class="cstat-no" title="statement not covered" >f</span>or(let postOrderIndex=0;postOrderIndex&lt;nodeCount-1;++postOrderIndex){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >postOrderIndex2NodeOrdinal[postOrderIndex];</span>const dominatorOrdinal=<span class="cstat-no" title="statement not covered" >dominatorsTree[nodeOrdinal];<span class="cstat-no" title="statement not covered" ></span>retainedSizes[dominatorOrdinal]+=retainedSizes[nodeOrdinal];}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildDominatedNodes(){const indexArray=<span class="cstat-no" title="statement not covered" >this._firstDominatedNodeIndex;</span>const dominatedNodes=<span class="cstat-no" title="statement not covered" >this._dominatedNodes;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const dominatorsTree=<span class="cstat-no" title="statement not covered" >this._dominatorsTree;</span>let fromNodeOrdinal=<span class="cstat-no" title="statement not covered" >0;</span>let toNodeOrdinal=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const rootNodeOrdinal=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(rootNodeOrdinal===fromNodeOrdinal)</span>
<span class="cstat-no" title="statement not covered" >fromNodeOrdinal=1;e</span>lse <span class="cstat-no" title="statement not covered" >if(rootNodeOrdinal===toNodeOrdinal-1)</span>
<span class="cstat-no" title="statement not covered" >toNodeOrdinal=toNodeOrdinal-1;e</span>lse
<span class="cstat-no" title="statement not covered" >throw new Error('Root node is expected to be either first or last');<span class="cstat-no" title="statement not covered" >f</span>or(let nodeOrdinal=fromNodeOrdinal;nodeOrdinal&lt;toNodeOrdinal;++nodeOrdinal)</span>
<span class="cstat-no" title="statement not covered" >++indexArray[dominatorsTree[nodeOrdinal]];l</span>et firstDominatedNodeIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0,l=this.nodeCount;i&lt;l;++i){const dominatedCount=<span class="cstat-no" title="statement not covered" >dominatedNodes[firstDominatedNodeIndex]=indexArray[i];<span class="cstat-no" title="statement not covered" ></span>indexArray[i]=firstDominatedNodeIndex;<span class="cstat-no" title="statement not covered" >f</span>irstDominatedNodeIndex+=dominatedCount;}</span></span>
<span class="cstat-no" title="statement not covered" >indexArray[this.nodeCount]=dominatedNodes.length;<span class="cstat-no" title="statement not covered" >f</span>or(let nodeOrdinal=fromNodeOrdinal;nodeOrdinal&lt;toNodeOrdinal;++nodeOrdinal){const dominatorOrdinal=<span class="cstat-no" title="statement not covered" >dominatorsTree[nodeOrdinal];</span>let dominatedRefIndex=<span class="cstat-no" title="statement not covered" >indexArray[dominatorOrdinal];<span class="cstat-no" title="statement not covered" ></span>dominatedRefIndex+=(--dominatedNodes[dominatedRefIndex]);<span class="cstat-no" title="statement not covered" >d</span>ominatedNodes[dominatedRefIndex]=nodeOrdinal*nodeFieldCount;}</span>}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildSamples(){const samples=<span class="cstat-no" title="statement not covered" >this._rawSamples;<span class="cstat-no" title="statement not covered" ></span>if(!samples||!samples.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst sampleCount=<span class="cstat-no" title="statement not covered" >samples.length/2;</span>const sizeForRange=<span class="cstat-no" title="statement not covered" >new Array(sampleCount);</span>const timestamps=<span class="cstat-no" title="statement not covered" >new Array(sampleCount);</span>const lastAssignedIds=<span class="cstat-no" title="statement not covered" >new Array(sampleCount);</span>const timestampOffset=<span class="cstat-no" title="statement not covered" >this._metaNode.sample_fields.indexOf('timestamp_us');</span>const lastAssignedIdOffset=<span class="cstat-no" title="statement not covered" >this._metaNode.sample_fields.indexOf('last_assigned_id');<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;sampleCount;i++){<span class="cstat-no" title="statement not covered" >sizeForRange[i]=0;<span class="cstat-no" title="statement not covered" >t</span>imestamps[i]=(samples[2*i+timestampOffset])/1000;<span class="cstat-no" title="statement not covered" >l</span>astAssignedIds[i]=samples[2*i+lastAssignedIdOffset];}</span></span>
const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;c</span>onst nodeId=<span class="cstat-no" title="statement not covered" >node.id();<span class="cstat-no" title="statement not covered" ></span>if(nodeId%2===0)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst rangeIndex=<span class="cstat-no" title="statement not covered" >lastAssignedIds.lowerBound(nodeId);<span class="cstat-no" title="statement not covered" ></span>if(rangeIndex===sampleCount){<span class="cstat-no" title="statement not covered" >continue;}</span></span>
<span class="cstat-no" title="statement not covered" >sizeForRange[rangeIndex]+=node.selfSize();}</span>
<span class="cstat-no" title="statement not covered" >this._samples=new HeapSnapshotModel.Samples(timestamps,lastAssignedIds,sizeForRange);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildLocationMap(){const map=<span class="cstat-no" title="statement not covered" >new Map();</span>const locations=<span class="cstat-no" title="statement not covered" >this._locations;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;locations.length;i+=this._locationFieldCount){const nodeIndex=<span class="cstat-no" title="statement not covered" >locations[i+this._locationIndexOffset];</span>const scriptId=<span class="cstat-no" title="statement not covered" >locations[i+this._locationScriptIdOffset];</span>const line=<span class="cstat-no" title="statement not covered" >locations[i+this._locationLineOffset];</span>const col=<span class="cstat-no" title="statement not covered" >locations[i+this._locationColumnOffset];<span class="cstat-no" title="statement not covered" ></span>map.set(nodeIndex,new HeapSnapshotModel.Location(scriptId,line,col));}</span></span>
<span class="cstat-no" title="statement not covered" >this._locationMap=map;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tLocation(nodeIndex){<span class="cstat-no" title="statement not covered" >return this._locationMap.get(nodeIndex)||null;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tSamples(){<span class="cstat-no" title="statement not covered" >return this._samples;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateFlags(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateStatistics(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >us</span>erObjectsMapAndFlag(){<span class="cstat-no" title="statement not covered" >throw new Error('Not implemented');}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateSnapshotDiff(baseSnapshotId,baseSnapshotAggregates){let snapshotDiff=<span class="cstat-no" title="statement not covered" >this._snapshotDiffs[baseSnapshotId];<span class="cstat-no" title="statement not covered" ></span>if(snapshotDiff)</span>
<span class="cstat-no" title="statement not covered" >return snapshotDiff;<span class="cstat-no" title="statement not covered" >s</span>napshotDiff={};c</span>onst aggregates=<span class="cstat-no" title="statement not covered" >this.aggregates(true,'allObjects');<span class="cstat-no" title="statement not covered" ></span>for(const className in baseSnapshotAggregates){const baseAggregate=<span class="cstat-no" title="statement not covered" >baseSnapshotAggregates[className];</span>const diff=<span class="cstat-no" title="statement not covered" >this._calculateDiffForClass(baseAggregate,aggregates[className]);<span class="cstat-no" title="statement not covered" ></span>if(diff)</span></span>
<span class="cstat-no" title="statement not covered" >snapshotDiff[className]=diff;}</span>
const emptyBaseAggregate=<span class="cstat-no" title="statement not covered" >new HeapSnapshotModel.AggregateForDiff();<span class="cstat-no" title="statement not covered" ></span>for(const className in aggregates){<span class="cstat-no" title="statement not covered" >if(className in baseSnapshotAggregates)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >s</span>napshotDiff[className]=this._calculateDiffForClass(emptyBaseAggregate,aggregates[className]);}</span>
<span class="cstat-no" title="statement not covered" >this._snapshotDiffs[baseSnapshotId]=snapshotDiff;<span class="cstat-no" title="statement not covered" >r</span>eturn snapshotDiff;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateDiffForClass(baseAggregate,aggregate){const baseIds=<span class="cstat-no" title="statement not covered" >baseAggregate.ids;</span>const baseIndexes=<span class="cstat-no" title="statement not covered" >baseAggregate.indexes;</span>const baseSelfSizes=<span class="cstat-no" title="statement not covered" >baseAggregate.selfSizes;</span>const indexes=<span class="cstat-no" title="statement not covered" >aggregate?aggregate.idxs:[];</span>let i=<span class="cstat-no" title="statement not covered" >0;</span>let j=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >baseIds.length;</span>const m=<span class="cstat-no" title="statement not covered" >indexes.length;</span>const diff=<span class="cstat-no" title="statement not covered" >new HeapSnapshotModel.Diff();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.createNode(indexes[j]);<span class="cstat-no" title="statement not covered" ></span>while(i&lt;l&amp;&amp;j&lt;m){const nodeAId=<span class="cstat-no" title="statement not covered" >baseIds[i];<span class="cstat-no" title="statement not covered" ></span>if(nodeAId&lt;nodeB.id()){<span class="cstat-no" title="statement not covered" >diff.deletedIndexes.push(baseIndexes[i]);<span class="cstat-no" title="statement not covered" >d</span>iff.removedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.removedSize+=baseSelfSizes[i];<span class="cstat-no" title="statement not covered" >+</span>+i;}</span>else <span class="cstat-no" title="statement not covered" >if(nodeAId&gt;nodeB.id()){<span class="cstat-no" title="statement not covered" >diff.addedIndexes.push(indexes[j]);<span class="cstat-no" title="statement not covered" >d</span>iff.addedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.addedSize+=nodeB.selfSize();<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexes[++j];}</span>else{<span class="cstat-no" title="statement not covered" >++i;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexes[++j];}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(i&lt;l){<span class="cstat-no" title="statement not covered" >diff.deletedIndexes.push(baseIndexes[i]);<span class="cstat-no" title="statement not covered" >d</span>iff.removedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.removedSize+=baseSelfSizes[i];<span class="cstat-no" title="statement not covered" >+</span>+i;}</span></span>
<span class="cstat-no" title="statement not covered" >while(j&lt;m){<span class="cstat-no" title="statement not covered" >diff.addedIndexes.push(indexes[j]);<span class="cstat-no" title="statement not covered" >d</span>iff.addedCount++;<span class="cstat-no" title="statement not covered" >d</span>iff.addedSize+=nodeB.selfSize();<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexes[++j];}</span></span>
<span class="cstat-no" title="statement not covered" >diff.countDelta=diff.addedCount-diff.removedCount;<span class="cstat-no" title="statement not covered" >d</span>iff.sizeDelta=diff.addedSize-diff.removedSize;<span class="cstat-no" title="statement not covered" >i</span>f(!diff.addedCount&amp;&amp;!diff.removedCount)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn diff;}</span>
<span class="fstat-no" title="function not covered" >_n</span>odeForSnapshotObjectId(snapshotObjectId){<span class="cstat-no" title="statement not covered" >for(let it=this._allNodes();it.hasNext();it.next()){<span class="cstat-no" title="statement not covered" >if(it.node.id()===snapshotObjectId)</span></span>
<span class="cstat-no" title="statement not covered" >return it.node;}</span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >no</span>deClassName(snapshotObjectId){const node=<span class="cstat-no" title="statement not covered" >this._nodeForSnapshotObjectId(snapshotObjectId);<span class="cstat-no" title="statement not covered" ></span>if(node)</span>
<span class="cstat-no" title="statement not covered" >return node.className();<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>
<span class="fstat-no" title="function not covered" >id</span>sOfObjectsWithName(name){const ids=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let it=this._allNodes();it.hasNext();it.next()){<span class="cstat-no" title="statement not covered" >if(it.item().name()===name)</span></span>
<span class="cstat-no" title="statement not covered" >ids.push(it.item().id());}</span>
<span class="cstat-no" title="statement not covered" >return ids;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdgesProvider(nodeIndex){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const filter=<span class="cstat-no" title="statement not covered" >this.containmentEdgesFilter();</span>const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotEdgeIndexProvider(this);<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotEdgesProvider(this,filter,node.edges(),indexProvider);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdgesProviderForTest(nodeIndex,filter){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotEdgeIndexProvider(this);<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotEdgesProvider(this,filter,node.edges(),indexProvider);}</span>
<span class="fstat-no" title="function not covered" >re</span>tainingEdgesFilter(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >co</span>ntainmentEdgesFilter(){<span class="cstat-no" title="statement not covered" >return null;}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdgesProvider(nodeIndex){const node=<span class="cstat-no" title="statement not covered" >this.createNode(nodeIndex);</span>const filter=<span class="cstat-no" title="statement not covered" >this.retainingEdgesFilter();</span>const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotRetainerEdgeIndexProvider(this);<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotEdgesProvider(this,filter,node.retainers(),indexProvider);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateAddedNodesProvider(baseSnapshotId,className){const snapshotDiff=<span class="cstat-no" title="statement not covered" >this._snapshotDiffs[baseSnapshotId];</span>const diffForClass=<span class="cstat-no" title="statement not covered" >snapshotDiff[className];<span class="cstat-no" title="statement not covered" ></span>return new HeapSnapshotWorker.HeapSnapshotNodesProvider(this,diffForClass.addedIndexes);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateDeletedNodesProvider(nodeIndexes){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotNodesProvider(this,nodeIndexes);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateNodesProviderForClass(className,nodeFilter){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.HeapSnapshotNodesProvider(this,this.aggregatesWithFilter(nodeFilter)[className].idxs);}</span>
<span class="fstat-no" title="function not covered" >_m</span>axJsNodeId(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>let id=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=this._nodeIdOffset;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){const nextId=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex];<span class="cstat-no" title="statement not covered" ></span>if(nextId%2===0)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(id&lt;nextId)</span>
<span class="cstat-no" title="statement not covered" >id=nextId;}</span>
<span class="cstat-no" title="statement not covered" >return id;}</span>
<span class="fstat-no" title="function not covered" >up</span>dateStaticData(){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.StaticData(this.nodeCount,this._rootNodeIndex,this.totalSize,this._maxJsNodeId());}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshot.AggregatedInfo;c</span>onst HeapSnapshotMetainfo=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.node_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.node_types=[];<span class="cstat-no" title="statement not covered" >t</span>his.edge_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.edge_types=[];<span class="cstat-no" title="statement not covered" >t</span>his.trace_function_info_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.trace_node_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.sample_fields=[];<span class="cstat-no" title="statement not covered" >t</span>his.type_strings={};}</span>};</span>const HeapSnapshotHeader=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.title='';<span class="cstat-no" title="statement not covered" >t</span>his.meta=new HeapSnapshotMetainfo();<span class="cstat-no" title="statement not covered" >t</span>his.node_count=0;<span class="cstat-no" title="statement not covered" >t</span>his.edge_count=0;<span class="cstat-no" title="statement not covered" >t</span>his.trace_function_count=0;}</span>};<span class="cstat-no" title="statement not covered" ></span>HeapSnapshotWorker.HeapSnapshotItemProvider=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(iterator,indexProvider){<span class="cstat-no" title="statement not covered" >this._iterator=iterator;<span class="cstat-no" title="statement not covered" >t</span>his._indexProvider=indexProvider;<span class="cstat-no" title="statement not covered" >t</span>his._isEmpty=!iterator.hasNext();<span class="cstat-no" title="statement not covered" >t</span>his._iterationOrder=null;<span class="cstat-no" title="statement not covered" >t</span>his._currentComparator=null;<span class="cstat-no" title="statement not covered" >t</span>his._sortedPrefixLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._sortedSuffixLength=0;}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>reateIterationOrder(){<span class="cstat-no" title="statement not covered" >if(this._iterationOrder)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._iterationOrder=[];<span class="cstat-no" title="statement not covered" >f</span>or(let iterator=this._iterator;iterator.hasNext();iterator.next())</span>
<span class="cstat-no" title="statement not covered" >this._iterationOrder.push(iterator.item().itemIndex());}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this._isEmpty;}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeItemsRange(begin,end){<span class="cstat-no" title="statement not covered" >this._createIterationOrder();<span class="cstat-no" title="statement not covered" >i</span>f(begin&gt;end)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Start position &gt; end position: '+begin+' &gt; '+end);<span class="cstat-no" title="statement not covered" >i</span>f(end&gt;this._iterationOrder.length)</span>
<span class="cstat-no" title="statement not covered" >end=this._iterationOrder.length;<span class="cstat-no" title="statement not covered" >i</span>f(this._sortedPrefixLength&lt;end&amp;&amp;begin&lt;this._iterationOrder.length-this._sortedSuffixLength){<span class="cstat-no" title="statement not covered" >this.sort(this._currentComparator,this._sortedPrefixLength,this._iterationOrder.length-1-this._sortedSuffixLength,begin,end-1);<span class="cstat-no" title="statement not covered" >i</span>f(begin&lt;=this._sortedPrefixLength)</span></span>
<span class="cstat-no" title="statement not covered" >this._sortedPrefixLength=end;<span class="cstat-no" title="statement not covered" >i</span>f(end&gt;=this._iterationOrder.length-this._sortedSuffixLength)</span>
<span class="cstat-no" title="statement not covered" >this._sortedSuffixLength=this._iterationOrder.length-begin;}</span>
let position=<span class="cstat-no" title="statement not covered" >begin;</span>const count=<span class="cstat-no" title="statement not covered" >end-begin;</span>const result=<span class="cstat-no" title="statement not covered" >new Array(count);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;count;++i){const itemIndex=<span class="cstat-no" title="statement not covered" >this._iterationOrder[position++];</span>const item=<span class="cstat-no" title="statement not covered" >this._indexProvider.itemForIndex(itemIndex);<span class="cstat-no" title="statement not covered" ></span>result[i]=item.serialize();}</span></span>
<span class="cstat-no" title="statement not covered" >return new HeapSnapshotModel.ItemsRange(begin,end,this._iterationOrder.length,result);}</span>
<span class="fstat-no" title="function not covered" >so</span>rtAndRewind(comparator){<span class="cstat-no" title="statement not covered" >this._currentComparator=comparator;<span class="cstat-no" title="statement not covered" >t</span>his._sortedPrefixLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._sortedSuffixLength=0;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotEdgesProvider=class extends HeapSnapshotWorker.HeapSnapshotItemProvider{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,filter,edgesIter,indexProvider){const iter=<span class="cstat-no" title="statement not covered" >filter?new HeapSnapshotWorker.HeapSnapshotFilteredIterator(edgesIter,(filter)):edgesIter;<span class="cstat-no" title="statement not covered" ></span>super(iter,indexProvider);<span class="cstat-no" title="statement not covered" >t</span>his.snapshot=snapshot;}</span></span>
<span class="fstat-no" title="function not covered" >so</span>rt(comparator,leftBound,rightBound,windowLeft,windowRight){const fieldName1=<span class="cstat-no" title="statement not covered" >comparator.fieldName1;</span>const fieldName2=<span class="cstat-no" title="statement not covered" >comparator.fieldName2;</span>const ascending1=<span class="cstat-no" title="statement not covered" >comparator.ascending1;</span>const ascending2=<span class="cstat-no" title="statement not covered" >comparator.ascending2;</span>const edgeA=<span class="cstat-no" title="statement not covered" >this._iterator.item().clone();</span>const edgeB=<span class="cstat-no" title="statement not covered" >edgeA.clone();</span>const nodeA=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>function <span class="fstat-no" title="function not covered" >compareEdgeFieldName(</span>ascending,indexA,indexB){<span class="cstat-no" title="statement not covered" >edgeA.edgeIndex=indexA;<span class="cstat-no" title="statement not covered" >e</span>dgeB.edgeIndex=indexB;<span class="cstat-no" title="statement not covered" >i</span>f(edgeB.name()==='__proto__')</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(edgeA.name()==='__proto__')</span>
<span class="cstat-no" title="statement not covered" >return 1;c</span>onst result=<span class="cstat-no" title="statement not covered" >edgeA.hasStringName()===edgeB.hasStringName()?(edgeA.name()&lt;edgeB.name()?-1:(edgeA.name()&gt;edgeB.name()?1:0)):(edgeA.hasStringName()?-1:1);<span class="cstat-no" title="statement not covered" ></span>return ascending?result:-result;}</span>
function <span class="fstat-no" title="function not covered" >compareNodeField(</span>fieldName,ascending,indexA,indexB){<span class="cstat-no" title="statement not covered" >edgeA.edgeIndex=indexA;<span class="cstat-no" title="statement not covered" >n</span>odeA.nodeIndex=edgeA.nodeIndex();c</span>onst valueA=<span class="cstat-no" title="statement not covered" >nodeA[fieldName]();<span class="cstat-no" title="statement not covered" ></span>edgeB.edgeIndex=indexB;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=edgeB.nodeIndex();c</span>onst valueB=<span class="cstat-no" title="statement not covered" >nodeB[fieldName]();</span>const result=<span class="cstat-no" title="statement not covered" >valueA&lt;valueB?-1:(valueA&gt;valueB?1:0);<span class="cstat-no" title="statement not covered" ></span>return ascending?result:-result;}</span>
function <span class="fstat-no" title="function not covered" >compareEdgeAndNode(</span>indexA,indexB){let result=<span class="cstat-no" title="statement not covered" >compareEdgeFieldName(ascending1,indexA,indexB);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=compareNodeField(fieldName2,ascending2,indexA,indexB);<span class="cstat-no" title="statement not covered" >i</span>f(result===0)</span>
<span class="cstat-no" title="statement not covered" >return indexA-indexB;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
function <span class="fstat-no" title="function not covered" >compareNodeAndEdge(</span>indexA,indexB){let result=<span class="cstat-no" title="statement not covered" >compareNodeField(fieldName1,ascending1,indexA,indexB);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=compareEdgeFieldName(ascending2,indexA,indexB);<span class="cstat-no" title="statement not covered" >i</span>f(result===0)</span>
<span class="cstat-no" title="statement not covered" >return indexA-indexB;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
function <span class="fstat-no" title="function not covered" >compareNodeAndNode(</span>indexA,indexB){let result=<span class="cstat-no" title="statement not covered" >compareNodeField(fieldName1,ascending1,indexA,indexB);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=compareNodeField(fieldName2,ascending2,indexA,indexB);<span class="cstat-no" title="statement not covered" >i</span>f(result===0)</span>
<span class="cstat-no" title="statement not covered" >return indexA-indexB;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="cstat-no" title="statement not covered" >if(fieldName1==='!edgeName')</span>
<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(compareEdgeAndNode,leftBound,rightBound,windowLeft,windowRight);e</span>lse <span class="cstat-no" title="statement not covered" >if(fieldName2==='!edgeName')</span>
<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(compareNodeAndEdge,leftBound,rightBound,windowLeft,windowRight);e</span>lse
<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(compareNodeAndNode,leftBound,rightBound,windowLeft,windowRight);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotNodesProvider=class extends HeapSnapshotWorker.HeapSnapshotItemProvider{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,nodeIndexes){const indexProvider=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotNodeIndexProvider(snapshot);</span>const it=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotIndexRangeIterator(indexProvider,nodeIndexes);<span class="cstat-no" title="statement not covered" ></span>super(it,indexProvider);<span class="cstat-no" title="statement not covered" >t</span>his.snapshot=snapshot;}</span></span>
<span class="fstat-no" title="function not covered" >no</span>dePosition(snapshotObjectId){<span class="cstat-no" title="statement not covered" >this._createIterationOrder();c</span>onst node=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>let i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;this._iterationOrder.length;i++){<span class="cstat-no" title="statement not covered" >node.nodeIndex=this._iterationOrder[i];<span class="cstat-no" title="statement not covered" >i</span>f(node.id()===snapshotObjectId)</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>
<span class="cstat-no" title="statement not covered" >if(i===this._iterationOrder.length)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst targetNodeIndex=<span class="cstat-no" title="statement not covered" >this._iterationOrder[i];</span>let smallerCount=<span class="cstat-no" title="statement not covered" >0;</span>const compare=<span class="cstat-no" title="statement not covered" >this._buildCompareFunction(this._currentComparator);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._iterationOrder.length;i++){<span class="cstat-no" title="statement not covered" >if(compare(this._iterationOrder[i],targetNodeIndex)&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >++smallerCount;}</span>
<span class="cstat-no" title="statement not covered" >return smallerCount;}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildCompareFunction(comparator){const nodeA=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>const nodeB=<span class="cstat-no" title="statement not covered" >this.snapshot.createNode();</span>const fieldAccessor1=<span class="cstat-no" title="statement not covered" >nodeA[comparator.fieldName1];</span>const fieldAccessor2=<span class="cstat-no" title="statement not covered" >nodeA[comparator.fieldName2];</span>const ascending1=<span class="cstat-no" title="statement not covered" >comparator.ascending1?1:-1;</span>const ascending2=<span class="cstat-no" title="statement not covered" >comparator.ascending2?1:-1;</span>function <span class="fstat-no" title="function not covered" >sortByNodeField(</span>fieldAccessor,ascending){const valueA=<span class="cstat-no" title="statement not covered" >fieldAccessor.call(nodeA);</span>const valueB=<span class="cstat-no" title="statement not covered" >fieldAccessor.call(nodeB);<span class="cstat-no" title="statement not covered" ></span>return valueA&lt;valueB?-ascending:(valueA&gt;valueB?ascending:0);}</span>
function <span class="fstat-no" title="function not covered" >sortByComparator(</span>indexA,indexB){<span class="cstat-no" title="statement not covered" >nodeA.nodeIndex=indexA;<span class="cstat-no" title="statement not covered" >n</span>odeB.nodeIndex=indexB;l</span>et result=<span class="cstat-no" title="statement not covered" >sortByNodeField(fieldAccessor1,ascending1);<span class="cstat-no" title="statement not covered" ></span>if(result===0)</span>
<span class="cstat-no" title="statement not covered" >result=sortByNodeField(fieldAccessor2,ascending2);<span class="cstat-no" title="statement not covered" >r</span>eturn result||indexA-indexB;}</span>
<span class="cstat-no" title="statement not covered" >return sortByComparator;}</span>
<span class="fstat-no" title="function not covered" >so</span>rt(comparator,leftBound,rightBound,windowLeft,windowRight){<span class="cstat-no" title="statement not covered" >this._iterationOrder.sortRange(this._buildCompareFunction(comparator),leftBound,rightBound,windowLeft,windowRight);}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshot=class extends HeapSnapshotWorker.HeapSnapshot{<span class="fstat-no" title="function not covered" >co</span>nstructor(profile,progress){<span class="cstat-no" title="statement not covered" >super(profile,progress);<span class="cstat-no" title="statement not covered" >t</span>his._nodeFlags={canBeQueried:1,detachedDOMTreeNode:2,pageObject:4};<span class="cstat-no" title="statement not covered" >t</span>his._lazyStringCache={};<span class="cstat-no" title="statement not covered" >t</span>his.initialize();}</span></span>
<span class="fstat-no" title="function not covered" >cr</span>eateNode(nodeIndex){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotNode(this,nodeIndex===undefined?-1:nodeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateEdge(edgeIndex){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotEdge(this,edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateRetainingEdge(retainerIndex){<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotRetainerEdge(this,retainerIndex);}</span>
<span class="fstat-no" title="function not covered" >co</span>ntainmentEdgesFilter(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >ed</span>ge=&gt;<span class="cstat-no" title="statement not covered" >!edge.isInvisible();</span>}</span>
<span class="fstat-no" title="function not covered" >re</span>tainingEdgesFilter(){const containmentEdgesFilter=<span class="cstat-no" title="statement not covered" >this.containmentEdgesFilter();</span>function <span class="fstat-no" title="function not covered" >filter(</span>edge){<span class="cstat-no" title="statement not covered" >return containmentEdgesFilter(edge)&amp;&amp;!edge.node().isRoot()&amp;&amp;!edge.isWeak();}</span>
<span class="cstat-no" title="statement not covered" >return filter;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateFlags(){<span class="cstat-no" title="statement not covered" >this._flags=new Uint32Array(this.nodeCount);<span class="cstat-no" title="statement not covered" >t</span>his._markDetachedDOMTreeNodes();<span class="cstat-no" title="statement not covered" >t</span>his._markQueriableHeapObjects();<span class="cstat-no" title="statement not covered" >t</span>his._markPageOwnedNodes();}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateDistances(){function <span class="fstat-no" title="function not covered" >filter(</span>node,edge){<span class="cstat-no" title="statement not covered" >if(node.isHidden())</span>
<span class="cstat-no" title="statement not covered" >return edge.name()!=='sloppy_function_map'||node.rawName()!=='system / NativeContext';<span class="cstat-no" title="statement not covered" >i</span>f(node.isArray()){<span class="cstat-no" title="statement not covered" >if(node.rawName()!=='(map descriptors)')</span></span>
<span class="cstat-no" title="statement not covered" >return true;c</span>onst index=<span class="cstat-no" title="statement not covered" >edge.name();<span class="cstat-no" title="statement not covered" ></span>return index&lt;2||(index%3)!==1;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="cstat-no" title="statement not covered" >super.calculateDistances(filter);}</span>
<span class="fstat-no" title="function not covered" >is</span>UserRoot(node){<span class="cstat-no" title="statement not covered" >return node.isUserRoot()||node.isDocumentDOMTreesRoot();}</span>
<span class="fstat-no" title="function not covered" >us</span>erObjectsMapAndFlag(){<span class="cstat-no" title="statement not covered" >return{map:this._flags,flag:this._nodeFlags.pageObject};}</span>
<span class="fstat-no" title="function not covered" >_f</span>lagsOfNode(node){<span class="cstat-no" title="statement not covered" >return this._flags[node.nodeIndex/this._nodeFieldCount];}</span>
<span class="fstat-no" title="function not covered" >_m</span>arkDetachedDOMTreeNodes(){const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const flag=<span class="cstat-no" title="statement not covered" >this._nodeFlags.detachedDOMTreeNode;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0,ordinal=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount,ordinal++){const nodeType=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+nodeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(nodeType!==nodeNativeType)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >n</span>ode.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(node.name().startsWith('Detached '))</span>
<span class="cstat-no" title="statement not covered" >this._flags[ordinal]|=flag;}</span>}
<span class="fstat-no" title="function not covered" >_m</span>arkQueriableHeapObjects(){const flag=<span class="cstat-no" title="statement not covered" >this._nodeFlags.canBeQueried;</span>const hiddenEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeHiddenType;</span>const internalEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeInternalType;</span>const invisibleEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeInvisibleType;</span>const weakEdgeType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const flags=<span class="cstat-no" title="statement not covered" >this._flags;</span>const list=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let iter=this.rootNode().edges();iter.hasNext();iter.next()){<span class="cstat-no" title="statement not covered" >if(iter.edge.node().isUserRoot())</span></span>
<span class="cstat-no" title="statement not covered" >list.push(iter.edge.node().nodeIndex/nodeFieldCount);}</span>
<span class="cstat-no" title="statement not covered" >while(list.length){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >list.pop();<span class="cstat-no" title="statement not covered" ></span>if(flags[nodeOrdinal]&amp;flag)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span>lags[nodeOrdinal]|=flag;c</span>onst beginEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(flags[childNodeOrdinal]&amp;flag)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst type=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(type===hiddenEdgeType||type===invisibleEdgeType||type===internalEdgeType||type===weakEdgeType)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >l</span>ist.push(childNodeOrdinal);}</span>}}
<span class="fstat-no" title="function not covered" >_m</span>arkPageOwnedNodes(){const edgeShortcutType=<span class="cstat-no" title="statement not covered" >this._edgeShortcutType;</span>const edgeElementType=<span class="cstat-no" title="statement not covered" >this._edgeElementType;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeWeakType=<span class="cstat-no" title="statement not covered" >this._edgeWeakType;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >this._firstEdgeIndexes;</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodesCount=<span class="cstat-no" title="statement not covered" >this.nodeCount;</span>const flags=<span class="cstat-no" title="statement not covered" >this._flags;</span>const pageObjectFlag=<span class="cstat-no" title="statement not covered" >this._nodeFlags.pageObject;</span>const nodesToVisit=<span class="cstat-no" title="statement not covered" >new Uint32Array(nodesCount);</span>let nodesToVisitLength=<span class="cstat-no" title="statement not covered" >0;</span>const rootNodeOrdinal=<span class="cstat-no" title="statement not covered" >this._rootNodeIndex/nodeFieldCount;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=firstEdgeIndexes[rootNodeOrdinal],endEdgeIndex=firstEdgeIndexes[rootNodeOrdinal+1];edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];</span>const nodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType===edgeElementType){<span class="cstat-no" title="statement not covered" >node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(!node.isDocumentDOMTreesRoot())</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;}</span>else <span class="cstat-no" title="statement not covered" >if(edgeType!==edgeShortcutType){<span class="cstat-no" title="statement not covered" >continue;}</span></span>
const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>nodesToVisit[nodesToVisitLength++]=nodeOrdinal;<span class="cstat-no" title="statement not covered" >f</span>lags[nodeOrdinal]|=pageObjectFlag;}</span>
<span class="cstat-no" title="statement not covered" >while(nodesToVisitLength){const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodesToVisit[--nodesToVisitLength];</span>const beginEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const childNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];</span>const childNodeOrdinal=<span class="cstat-no" title="statement not covered" >childNodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(flags[childNodeOrdinal]&amp;pageObjectFlag)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst type=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(type===edgeWeakType)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >n</span>odesToVisit[nodesToVisitLength++]=childNodeOrdinal;<span class="cstat-no" title="statement not covered" >f</span>lags[childNodeOrdinal]|=pageObjectFlag;}</span>}}
<span class="fstat-no" title="function not covered" >ca</span>lculateStatistics(){const nodeFieldCount=<span class="cstat-no" title="statement not covered" >this._nodeFieldCount;</span>const nodes=<span class="cstat-no" title="statement not covered" >this.nodes;</span>const nodesLength=<span class="cstat-no" title="statement not covered" >nodes.length;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >this._nodeTypeOffset;</span>const nodeSizeOffset=<span class="cstat-no" title="statement not covered" >this._nodeSelfSizeOffset;</span>const nodeNativeType=<span class="cstat-no" title="statement not covered" >this._nodeNativeType;</span>const nodeCodeType=<span class="cstat-no" title="statement not covered" >this._nodeCodeType;</span>const nodeConsStringType=<span class="cstat-no" title="statement not covered" >this._nodeConsStringType;</span>const nodeSlicedStringType=<span class="cstat-no" title="statement not covered" >this._nodeSlicedStringType;</span>const distances=<span class="cstat-no" title="statement not covered" >this._nodeDistances;</span>let sizeNative=<span class="cstat-no" title="statement not covered" >0;</span>let sizeCode=<span class="cstat-no" title="statement not covered" >0;</span>let sizeStrings=<span class="cstat-no" title="statement not covered" >0;</span>let sizeJSArrays=<span class="cstat-no" title="statement not covered" >0;</span>let sizeSystem=<span class="cstat-no" title="statement not covered" >0;</span>const node=<span class="cstat-no" title="statement not covered" >this.rootNode();<span class="cstat-no" title="statement not covered" ></span>for(let nodeIndex=0;nodeIndex&lt;nodesLength;nodeIndex+=nodeFieldCount){const nodeSize=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+nodeSizeOffset];</span>const ordinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;<span class="cstat-no" title="statement not covered" ></span>if(distances[ordinal]&gt;=HeapSnapshotModel.baseSystemDistance){<span class="cstat-no" title="statement not covered" >sizeSystem+=nodeSize;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
const nodeType=<span class="cstat-no" title="statement not covered" >nodes[nodeIndex+nodeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=nodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(nodeType===nodeNativeType)</span>
<span class="cstat-no" title="statement not covered" >sizeNative+=nodeSize;e</span>lse <span class="cstat-no" title="statement not covered" >if(nodeType===nodeCodeType)</span>
<span class="cstat-no" title="statement not covered" >sizeCode+=nodeSize;e</span>lse <span class="cstat-no" title="statement not covered" >if(nodeType===nodeConsStringType||nodeType===nodeSlicedStringType||node.type()==='string')</span>
<span class="cstat-no" title="statement not covered" >sizeStrings+=nodeSize;e</span>lse <span class="cstat-no" title="statement not covered" >if(node.name()==='Array')</span>
<span class="cstat-no" title="statement not covered" >sizeJSArrays+=this._calculateArraySize(node);}</span>
<span class="cstat-no" title="statement not covered" >this._statistics=new HeapSnapshotModel.Statistics();<span class="cstat-no" title="statement not covered" >t</span>his._statistics.total=this.totalSize;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.v8heap=this.totalSize-sizeNative;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.native=sizeNative;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.code=sizeCode;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.jsArrays=sizeJSArrays;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.strings=sizeStrings;<span class="cstat-no" title="statement not covered" >t</span>his._statistics.system=sizeSystem;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateArraySize(node){let size=<span class="cstat-no" title="statement not covered" >node.selfSize();</span>const beginEdgeIndex=<span class="cstat-no" title="statement not covered" >node.edgeIndexesStart();</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >node.edgeIndexesEnd();</span>const containmentEdges=<span class="cstat-no" title="statement not covered" >this.containmentEdges;</span>const strings=<span class="cstat-no" title="statement not covered" >this.strings;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >this._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >this._edgeTypeOffset;</span>const edgeNameOffset=<span class="cstat-no" title="statement not covered" >this._edgeNameOffset;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >this._edgeFieldsCount;</span>const edgeInternalType=<span class="cstat-no" title="statement not covered" >this._edgeInternalType;<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex;edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType!==edgeInternalType)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst edgeName=<span class="cstat-no" title="statement not covered" >strings[containmentEdges[edgeIndex+edgeNameOffset]];<span class="cstat-no" title="statement not covered" ></span>if(edgeName!=='elements')</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst elementsNodeIndex=<span class="cstat-no" title="statement not covered" >containmentEdges[edgeIndex+edgeToNodeOffset];<span class="cstat-no" title="statement not covered" ></span>node.nodeIndex=elementsNodeIndex;<span class="cstat-no" title="statement not covered" >i</span>f(node.retainersCount()===1)</span>
<span class="cstat-no" title="statement not covered" >size+=node.selfSize();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >return size;}</span>
<span class="fstat-no" title="function not covered" >ge</span>tStatistics(){<span class="cstat-no" title="statement not covered" >return this._statistics;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshotNode=class extends HeapSnapshotWorker.HeapSnapshotNode{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,nodeIndex){<span class="cstat-no" title="statement not covered" >super(snapshot,nodeIndex);}</span></span>
<span class="fstat-no" title="function not covered" >ca</span>nBeQueried(){const flags=<span class="cstat-no" title="statement not covered" >this._snapshot._flagsOfNode(this);<span class="cstat-no" title="statement not covered" ></span>return!!(flags&amp;this._snapshot._nodeFlags.canBeQueried);}</span>
<span class="fstat-no" title="function not covered" >ra</span>wName(){<span class="cstat-no" title="statement not covered" >return super.name();}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>if(this.rawType()===snapshot._nodeConsStringType){let string=<span class="cstat-no" title="statement not covered" >snapshot._lazyStringCache[this.nodeIndex];<span class="cstat-no" title="statement not covered" ></span>if(typeof string==='undefined'){<span class="cstat-no" title="statement not covered" >string=this._consStringName();<span class="cstat-no" title="statement not covered" >s</span>napshot._lazyStringCache[this.nodeIndex]=string;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return string;}</span>
<span class="cstat-no" title="statement not covered" >return this.rawName();}</span>
<span class="fstat-no" title="function not covered" >_c</span>onsStringName(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>const consStringType=<span class="cstat-no" title="statement not covered" >snapshot._nodeConsStringType;</span>const edgeInternalType=<span class="cstat-no" title="statement not covered" >snapshot._edgeInternalType;</span>const edgeFieldsCount=<span class="cstat-no" title="statement not covered" >snapshot._edgeFieldsCount;</span>const edgeToNodeOffset=<span class="cstat-no" title="statement not covered" >snapshot._edgeToNodeOffset;</span>const edgeTypeOffset=<span class="cstat-no" title="statement not covered" >snapshot._edgeTypeOffset;</span>const edgeNameOffset=<span class="cstat-no" title="statement not covered" >snapshot._edgeNameOffset;</span>const strings=<span class="cstat-no" title="statement not covered" >snapshot.strings;</span>const edges=<span class="cstat-no" title="statement not covered" >snapshot.containmentEdges;</span>const firstEdgeIndexes=<span class="cstat-no" title="statement not covered" >snapshot._firstEdgeIndexes;</span>const nodeFieldCount=<span class="cstat-no" title="statement not covered" >snapshot._nodeFieldCount;</span>const nodeTypeOffset=<span class="cstat-no" title="statement not covered" >snapshot._nodeTypeOffset;</span>const nodeNameOffset=<span class="cstat-no" title="statement not covered" >snapshot._nodeNameOffset;</span>const nodes=<span class="cstat-no" title="statement not covered" >snapshot.nodes;</span>const nodesStack=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>nodesStack.push(this.nodeIndex);l</span>et name=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>while(nodesStack.length&amp;&amp;name.length&lt;1024){const nodeIndex=<span class="cstat-no" title="statement not covered" >nodesStack.pop();<span class="cstat-no" title="statement not covered" ></span>if(nodes[nodeIndex+nodeTypeOffset]!==consStringType){<span class="cstat-no" title="statement not covered" >name+=strings[nodes[nodeIndex+nodeNameOffset]];<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
const nodeOrdinal=<span class="cstat-no" title="statement not covered" >nodeIndex/nodeFieldCount;</span>const beginEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal];</span>const endEdgeIndex=<span class="cstat-no" title="statement not covered" >firstEdgeIndexes[nodeOrdinal+1];</span>let firstNodeIndex=<span class="cstat-no" title="statement not covered" >0;</span>let secondNodeIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let edgeIndex=beginEdgeIndex;edgeIndex&lt;endEdgeIndex&amp;&amp;(!firstNodeIndex||!secondNodeIndex);edgeIndex+=edgeFieldsCount){const edgeType=<span class="cstat-no" title="statement not covered" >edges[edgeIndex+edgeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(edgeType===edgeInternalType){const edgeName=<span class="cstat-no" title="statement not covered" >strings[edges[edgeIndex+edgeNameOffset]];<span class="cstat-no" title="statement not covered" ></span>if(edgeName==='first')</span></span></span>
<span class="cstat-no" title="statement not covered" >firstNodeIndex=edges[edgeIndex+edgeToNodeOffset];e</span>lse <span class="cstat-no" title="statement not covered" >if(edgeName==='second')</span>
<span class="cstat-no" title="statement not covered" >secondNodeIndex=edges[edgeIndex+edgeToNodeOffset];}</span>}
<span class="cstat-no" title="statement not covered" >nodesStack.push(secondNodeIndex);<span class="cstat-no" title="statement not covered" >n</span>odesStack.push(firstNodeIndex);}</span>
<span class="cstat-no" title="statement not covered" >return name;}</span>
<span class="fstat-no" title="function not covered" >cl</span>assName(){const type=<span class="cstat-no" title="statement not covered" >this.type();<span class="cstat-no" title="statement not covered" ></span>switch(type){case'hidden':<span class="cstat-no" title="statement not covered" >return'(system)';c</span>ase'object':case'native':<span class="cstat-no" title="statement not covered" >return this.name();c</span>ase'code':<span class="cstat-no" title="statement not covered" >return'(compiled code)';d</span>efault:<span class="cstat-no" title="statement not covered" >return'('+type+')';}</span>}</span>
<span class="fstat-no" title="function not covered" >cl</span>assIndex(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>const nodes=<span class="cstat-no" title="statement not covered" >snapshot.nodes;</span>const type=<span class="cstat-no" title="statement not covered" >nodes[this.nodeIndex+snapshot._nodeTypeOffset];<span class="cstat-no" title="statement not covered" ></span>if(type===snapshot._nodeObjectType||type===snapshot._nodeNativeType)</span>
<span class="cstat-no" title="statement not covered" >return nodes[this.nodeIndex+snapshot._nodeNameOffset];<span class="cstat-no" title="statement not covered" >r</span>eturn-1-type;}</span>
<span class="fstat-no" title="function not covered" >id</span>(){const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return snapshot.nodes[this.nodeIndex+snapshot._nodeIdOffset];}</span>
<span class="fstat-no" title="function not covered" >is</span>Hidden(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._nodeHiddenType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Array(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._nodeArrayType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Synthetic(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._nodeSyntheticType;}</span>
<span class="fstat-no" title="function not covered" >is</span>UserRoot(){<span class="cstat-no" title="statement not covered" >return!this.isSynthetic();}</span>
<span class="fstat-no" title="function not covered" >is</span>DocumentDOMTreesRoot(){<span class="cstat-no" title="statement not covered" >return this.isSynthetic()&amp;&amp;this.name()==='(Document DOM trees)';}</span>
<span class="fstat-no" title="function not covered" >se</span>rialize(){const result=<span class="cstat-no" title="statement not covered" >super.serialize();</span>const flags=<span class="cstat-no" title="statement not covered" >this._snapshot._flagsOfNode(this);<span class="cstat-no" title="statement not covered" ></span>if(flags&amp;this._snapshot._nodeFlags.canBeQueried)</span>
<span class="cstat-no" title="statement not covered" >result.canBeQueried=true;<span class="cstat-no" title="statement not covered" >i</span>f(flags&amp;this._snapshot._nodeFlags.detachedDOMTreeNode)</span>
<span class="cstat-no" title="statement not covered" >result.detachedDOMTreeNode=true;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshotEdge=class extends HeapSnapshotWorker.HeapSnapshotEdge{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,edgeIndex){<span class="cstat-no" title="statement not covered" >super(snapshot,edgeIndex);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){const snapshot=(<span class="cstat-no" title="statement not covered" >this._snapshot)</span>;<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotEdge(snapshot,this.edgeIndex);}</span>
<span class="fstat-no" title="function not covered" >ha</span>sStringName(){<span class="cstat-no" title="statement not covered" >if(!this.isShortcut())</span>
<span class="cstat-no" title="statement not covered" >return this._hasStringName();<span class="cstat-no" title="statement not covered" >r</span>eturn isNaN(parseInt(this._name(),10));}</span>
<span class="fstat-no" title="function not covered" >is</span>Element(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeElementType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Hidden(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeHiddenType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Weak(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeWeakType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Internal(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeInternalType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Invisible(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeInvisibleType;}</span>
<span class="fstat-no" title="function not covered" >is</span>Shortcut(){<span class="cstat-no" title="statement not covered" >return this.rawType()===this._snapshot._edgeShortcutType;}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){const name=<span class="cstat-no" title="statement not covered" >this._name();<span class="cstat-no" title="statement not covered" ></span>if(!this.isShortcut())</span>
<span class="cstat-no" title="statement not covered" >return String(name);c</span>onst numName=<span class="cstat-no" title="statement not covered" >parseInt(name,10);<span class="cstat-no" title="statement not covered" ></span>return String(isNaN(numName)?name:numName);}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){const name=<span class="cstat-no" title="statement not covered" >this.name();<span class="cstat-no" title="statement not covered" ></span>switch(this.type()){case'context':<span class="cstat-no" title="statement not covered" >return'-&gt;'+name;c</span>ase'element':<span class="cstat-no" title="statement not covered" >return'['+name+']';c</span>ase'weak':<span class="cstat-no" title="statement not covered" >return'[['+name+']]';c</span>ase'property':<span class="cstat-no" title="statement not covered" >return name.indexOf(' ')===-1?'.'+name:'["'+name+'"]';c</span>ase'shortcut':<span class="cstat-no" title="statement not covered" >if(typeof name==='string')</span></span>
<span class="cstat-no" title="statement not covered" >return name.indexOf(' ')===-1?'.'+name:'["'+name+'"]';e</span>lse
<span class="cstat-no" title="statement not covered" >return'['+name+']';c</span>ase'internal':case'hidden':case'invisible':<span class="cstat-no" title="statement not covered" >return'{'+name+'}';}</span>
<span class="cstat-no" title="statement not covered" >return'?'+name+'?';}</span>
<span class="fstat-no" title="function not covered" >_h</span>asStringName(){const type=<span class="cstat-no" title="statement not covered" >this.rawType();</span>const snapshot=<span class="cstat-no" title="statement not covered" >this._snapshot;<span class="cstat-no" title="statement not covered" ></span>return type!==snapshot._edgeElementType&amp;&amp;type!==snapshot._edgeHiddenType;}</span>
<span class="fstat-no" title="function not covered" >_n</span>ame(){<span class="cstat-no" title="statement not covered" >return this._hasStringName()?this._snapshot.strings[this._nameOrIndex()]:this._nameOrIndex();}</span>
<span class="fstat-no" title="function not covered" >_n</span>ameOrIndex(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeNameOffset];}</span>
<span class="fstat-no" title="function not covered" >ra</span>wType(){<span class="cstat-no" title="statement not covered" >return this._edges[this.edgeIndex+this._snapshot._edgeTypeOffset];}</span>};<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.JSHeapSnapshotRetainerEdge=class extends HeapSnapshotWorker.HeapSnapshotRetainerEdge{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshot,retainerIndex){<span class="cstat-no" title="statement not covered" >super(snapshot,retainerIndex);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>one(){const snapshot=(<span class="cstat-no" title="statement not covered" >this._snapshot)</span>;<span class="cstat-no" title="statement not covered" >return new HeapSnapshotWorker.JSHeapSnapshotRetainerEdge(snapshot,this.retainerIndex());}</span>
<span class="fstat-no" title="function not covered" >is</span>Hidden(){<span class="cstat-no" title="statement not covered" >return this._edge().isHidden();}</span>
<span class="fstat-no" title="function not covered" >is</span>Internal(){<span class="cstat-no" title="statement not covered" >return this._edge().isInternal();}</span>
<span class="fstat-no" title="function not covered" >is</span>Invisible(){<span class="cstat-no" title="statement not covered" >return this._edge().isInvisible();}</span>
<span class="fstat-no" title="function not covered" >is</span>Shortcut(){<span class="cstat-no" title="statement not covered" >return this._edge().isShortcut();}</span>
<span class="fstat-no" title="function not covered" >is</span>Weak(){<span class="cstat-no" title="statement not covered" >return this._edge().isWeak();}</span>};<span class="cstat-no" title="statement not covered" >(function <span class="fstat-no" title="function not covered" >disableLoggingForTest(</span>){<span class="cstat-no" title="statement not covered" >if(self.Runtime&amp;&amp;Runtime.queryParam('test'))</span></span>
<span class="cstat-no" title="statement not covered" >console.warn=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >undefined;</span>}</span>)();;<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotLoader=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(dispatcher){<span class="cstat-no" title="statement not covered" >this._reset();<span class="cstat-no" title="statement not covered" >t</span>his._progress=new HeapSnapshotWorker.HeapSnapshotProgress(dispatcher);<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';<span class="cstat-no" title="statement not covered" >t</span>his._dataCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his._done=false;<span class="cstat-no" title="statement not covered" >t</span>his._parseInput();}</span></span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this._reset();}</span>
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >this._json='';<span class="cstat-no" title="statement not covered" >t</span>his._snapshot={};}</span>
<span class="fstat-no" title="function not covered" >cl</span>ose(){<span class="cstat-no" title="statement not covered" >this._done=true;<span class="cstat-no" title="statement not covered" >i</span>f(this._dataCallback)</span>
<span class="cstat-no" title="statement not covered" >this._dataCallback('');}</span>
<span class="fstat-no" title="function not covered" >bu</span>ildSnapshot(){<span class="cstat-no" title="statement not covered" >this._progress.updateStatus(ls`Processing snapshot\u2026`);c</span>onst result=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.JSHeapSnapshot(this._snapshot,this._progress);<span class="cstat-no" title="statement not covered" ></span>this._reset();<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >_p</span>arseUintArray(){let index=<span class="cstat-no" title="statement not covered" >0;</span>const char0=<span class="cstat-no" title="statement not covered" >'0'.charCodeAt(0);</span>const char9=<span class="cstat-no" title="statement not covered" >'9'.charCodeAt(0);</span>const closingBracket=<span class="cstat-no" title="statement not covered" >']'.charCodeAt(0);</span>const length=<span class="cstat-no" title="statement not covered" >this._json.length;<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >while(index&lt;length){const code=<span class="cstat-no" title="statement not covered" >this._json.charCodeAt(index);<span class="cstat-no" title="statement not covered" ></span>if(char0&lt;=code&amp;&amp;code&lt;=char9){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(code===closingBracket){<span class="cstat-no" title="statement not covered" >this._json=this._json.slice(index+1);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >++index;}</span>
<span class="cstat-no" title="statement not covered" >if(index===length){<span class="cstat-no" title="statement not covered" >this._json='';<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
let nextNumber=<span class="cstat-no" title="statement not covered" >0;</span>const startIndex=<span class="cstat-no" title="statement not covered" >index;<span class="cstat-no" title="statement not covered" ></span>while(index&lt;length){const code=<span class="cstat-no" title="statement not covered" >this._json.charCodeAt(index);<span class="cstat-no" title="statement not covered" ></span>if(char0&gt;code||code&gt;char9)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span>extNumber*=10;<span class="cstat-no" title="statement not covered" >n</span>extNumber+=(code-char0);<span class="cstat-no" title="statement not covered" >+</span>+index;}</span>
<span class="cstat-no" title="statement not covered" >if(index===length){<span class="cstat-no" title="statement not covered" >this._json=this._json.slice(startIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >this._array[this._arrayIndex++]=nextNumber;}</span>}
<span class="fstat-no" title="function not covered" >_p</span>arseStringsArray(){<span class="cstat-no" title="statement not covered" >this._progress.updateStatus('Parsing strings\u2026');c</span>onst closingBracketIndex=<span class="cstat-no" title="statement not covered" >this._json.lastIndexOf(']');<span class="cstat-no" title="statement not covered" ></span>if(closingBracketIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Incomplete JSON');<span class="cstat-no" title="statement not covered" >t</span>his._json=this._json.slice(0,closingBracketIndex+1);<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.strings=JSON.parse(this._json);}</span>
<span class="fstat-no" title="function not covered" >wr</span>ite(chunk){<span class="cstat-no" title="statement not covered" >this._buffer+=chunk;<span class="cstat-no" title="statement not covered" >i</span>f(!this._dataCallback)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._dataCallback(this._buffer);<span class="cstat-no" title="statement not covered" >t</span>his._dataCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';}</span>
<span class="fstat-no" title="function not covered" >_f</span>etchChunk(){<span class="cstat-no" title="statement not covered" >return this._done?Promise.resolve(this._buffer):new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this._dataCallback=r)</span>;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _findToken(token,startIndex){<span class="cstat-no" title="statement not covered" >while(true){const pos=<span class="cstat-no" title="statement not covered" >this._json.indexOf(token,startIndex||0);<span class="cstat-no" title="statement not covered" ></span>if(pos!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >return pos;<span class="cstat-no" title="statement not covered" >s</span>tartIndex=this._json.length-token.length+1;<span class="cstat-no" title="statement not covered" >t</span>his._json+=await this._fetchChunk();}</span>}
<span class="fstat-no" title="function not covered" >as</span>ync _parseArray(name,title,length){const nameIndex=<span class="cstat-no" title="statement not covered" >await this._findToken(name);</span>const bracketIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('[',nameIndex);<span class="cstat-no" title="statement not covered" ></span>this._json=this._json.slice(bracketIndex+1);<span class="cstat-no" title="statement not covered" >t</span>his._array=length?new Uint32Array(length):[];<span class="cstat-no" title="statement not covered" >t</span>his._arrayIndex=0;<span class="cstat-no" title="statement not covered" >w</span>hile(this._parseUintArray()){<span class="cstat-no" title="statement not covered" >this._progress.updateProgress(title,this._arrayIndex,this._array.length);<span class="cstat-no" title="statement not covered" >t</span>his._json+=await this._fetchChunk();}</span></span>
const result=<span class="cstat-no" title="statement not covered" >this._array;<span class="cstat-no" title="statement not covered" ></span>this._array=null;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _parseInput(){const snapshotToken=<span class="cstat-no" title="statement not covered" >'"snapshot"';</span>const snapshotTokenIndex=<span class="cstat-no" title="statement not covered" >await this._findToken(snapshotToken);<span class="cstat-no" title="statement not covered" ></span>if(snapshotTokenIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Snapshot token not found');<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus(ls`Loading snapshot info\u2026`);c</span>onst json=<span class="cstat-no" title="statement not covered" >this._json.slice(snapshotTokenIndex+snapshotToken.length+1);<span class="cstat-no" title="statement not covered" ></span>this._jsonTokenizer=new TextUtils.TextUtils.BalancedJSONTokenizer(<span class="fstat-no" title="function not covered" >me</span>taJSON=&gt;{<span class="cstat-no" title="statement not covered" >this._json=this._jsonTokenizer.remainder();<span class="cstat-no" title="statement not covered" >t</span>his._jsonTokenizer=null;<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.snapshot=(JSON.parse(metaJSON));}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._jsonTokenizer.write(json);<span class="cstat-no" title="statement not covered" >w</span>hile(this._jsonTokenizer)</span>
<span class="cstat-no" title="statement not covered" >this._jsonTokenizer.write(await this._fetchChunk());<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.nodes=await this._parseArray('"nodes"',ls`Loading nodes\u2026 %d%%`,this._snapshot.snapshot.meta.node_fields.length*this._snapshot.snapshot.node_count);<span class="cstat-no" title="statement not covered" >t</span>his._snapshot.edges=await this._parseArray('"edges"',ls`Loading edges\u2026 %d%%`,this._snapshot.snapshot.meta.edge_fields.length*this._snapshot.snapshot.edge_count);<span class="cstat-no" title="statement not covered" >i</span>f(this._snapshot.snapshot.trace_function_count){<span class="cstat-no" title="statement not covered" >this._snapshot.trace_function_infos=await this._parseArray('"trace_function_infos"',ls`Loading allocation traces\u2026 %d%%`,this._snapshot.snapshot.meta.trace_function_info_fields.length*this._snapshot.snapshot.trace_function_count);c</span>onst thisTokenEndIndex=<span class="cstat-no" title="statement not covered" >await this._findToken(':');</span>const nextTokenIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('"',thisTokenEndIndex);</span>const openBracketIndex=<span class="cstat-no" title="statement not covered" >this._json.indexOf('[');</span>const closeBracketIndex=<span class="cstat-no" title="statement not covered" >this._json.lastIndexOf(']',nextTokenIndex);<span class="cstat-no" title="statement not covered" ></span>this._snapshot.trace_tree=JSON.parse(this._json.substring(openBracketIndex,closeBracketIndex+1));<span class="cstat-no" title="statement not covered" >t</span>his._json=this._json.slice(closeBracketIndex+1);}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._snapshot.snapshot.meta.sample_fields)</span>
<span class="cstat-no" title="statement not covered" >this._snapshot.samples=await this._parseArray('"samples"',ls`Loading samples\u2026`);<span class="cstat-no" title="statement not covered" >i</span>f(this._snapshot.snapshot.meta['location_fields'])</span>
<span class="cstat-no" title="statement not covered" >this._snapshot.locations=await this._parseArray('"locations"',ls`Loading locations\u2026`);e</span>lse
<span class="cstat-no" title="statement not covered" >this._snapshot.locations=[];<span class="cstat-no" title="statement not covered" >t</span>his._progress.updateStatus(ls`Loading strings\u2026`);c</span>onst stringsTokenIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('"strings"');</span>const bracketIndex=<span class="cstat-no" title="statement not covered" >await this._findToken('[',stringsTokenIndex);<span class="cstat-no" title="statement not covered" ></span>this._json=this._json.slice(bracketIndex);<span class="cstat-no" title="statement not covered" >w</span>hile(!this._done)</span>
<span class="cstat-no" title="statement not covered" >this._json+=await this._fetchChunk();<span class="cstat-no" title="statement not covered" >t</span>his._parseStringsArray();}</span>};;<span class="cstat-no" title="statement not covered" >HeapSnapshotWorker.HeapSnapshotWorkerDispatcher=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(globalObject,postMessage){<span class="cstat-no" title="statement not covered" >this._objects=[];<span class="cstat-no" title="statement not covered" >t</span>his._global=globalObject;<span class="cstat-no" title="statement not covered" >t</span>his._postMessage=postMessage;}</span></span>
<span class="fstat-no" title="function not covered" >_f</span>indFunction(name){const path=<span class="cstat-no" title="statement not covered" >name.split('.');</span>let result=<span class="cstat-no" title="statement not covered" >this._global;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;path.length;++i)</span>
<span class="cstat-no" title="statement not covered" >result=result[path[i]];<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >se</span>ndEvent(name,data){<span class="cstat-no" title="statement not covered" >this._postMessage({eventName:name,data:data});}</span>
<span class="fstat-no" title="function not covered" >di</span>spatchMessage(event){const data=(<span class="cstat-no" title="statement not covered" >event.data)</span>;const response=<span class="cstat-no" title="statement not covered" >{callId:data.callId};<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >switch(data.disposition){case'create':const constructorFunction=<span class="cstat-no" title="statement not covered" >this._findFunction(data.methodName);<span class="cstat-no" title="statement not covered" ></span>this._objects[data.objectId]=new constructorFunction(this);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'dispose':<span class="cstat-no" title="statement not covered" >delete this._objects[data.objectId];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'getter':{const object=<span class="cstat-no" title="statement not covered" >this._objects[data.objectId];</span>const result=<span class="cstat-no" title="statement not covered" >object[data.methodName];<span class="cstat-no" title="statement not covered" ></span>response.result=result;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span>
case'factory':{const object=<span class="cstat-no" title="statement not covered" >this._objects[data.objectId];</span>const result=<span class="cstat-no" title="statement not covered" >object[data.methodName].apply(object,data.methodArguments);<span class="cstat-no" title="statement not covered" ></span>if(result)</span>
<span class="cstat-no" title="statement not covered" >this._objects[data.newObjectId]=result;<span class="cstat-no" title="statement not covered" >r</span>esponse.result=!!result;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case'method':{const object=<span class="cstat-no" title="statement not covered" >this._objects[data.objectId];<span class="cstat-no" title="statement not covered" ></span>response.result=object[data.methodName].apply(object,data.methodArguments);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case'evaluateForTest':<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >response.result=self.eval(data.source);}</span>catch(e){<span class="cstat-no" title="statement not covered" >response.result=e.toString();}</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>}catch(e){<span class="cstat-no" title="statement not covered" >response.error=e.toString();<span class="cstat-no" title="statement not covered" >r</span>esponse.errorCallStack=e.stack;<span class="cstat-no" title="statement not covered" >i</span>f(data.methodName)</span>
<span class="cstat-no" title="statement not covered" >response.errorMethodName=data.methodName;}</span>
<span class="cstat-no" title="statement not covered" >this._postMessage(response);}</span>};;function <span class="fstat-no" title="function not covered" >postMessageWrapper(</span>message){<span class="cstat-no" title="statement not covered" >postMessage(message);}</span>
const dispatcher=<span class="cstat-no" title="statement not covered" >new HeapSnapshotWorker.HeapSnapshotWorkerDispatcher(this,postMessageWrapper);</span>function <span class="fstat-no" title="function not covered" >installMessageEventListener(</span>listener){<span class="cstat-no" title="statement not covered" >self.addEventListener('message',listener,false);}</span>
<span class="cstat-no" title="statement not covered" >installMessageEventListener(dispatcher.dispatchMessage.bind(dispatcher));;</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:03:43 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
