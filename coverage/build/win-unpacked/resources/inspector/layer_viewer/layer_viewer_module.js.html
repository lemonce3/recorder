<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/win-unpacked/resources/inspector/layer_viewer/layer_viewer_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/win-unpacked/resources/inspector/layer_viewer</a> layer_viewer_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/1185</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/436</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/194</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/308</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >LayerViewer.LayerDetailsView=class extends UI.Widget{<span class="fstat-no" title="function not covered" >co</span>nstructor(layerViewHost){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('layer_viewer/layerDetailsView.css');<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost=layerViewHost;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.registerView(this);<span class="cstat-no" title="statement not covered" >t</span>his._emptyWidget=new UI.EmptyWidget(Common.UIString('Select a layer to see its details'));<span class="cstat-no" title="statement not covered" >t</span>his._buildContent();}</span></span>
<span class="fstat-no" title="function not covered" >ho</span>verObject(selection){}
<span class="fstat-no" title="function not covered" >se</span>lectObject(selection){<span class="cstat-no" title="statement not covered" >this._selection=selection;<span class="cstat-no" title="statement not covered" >i</span>f(this.isShowing())</span>
<span class="cstat-no" title="statement not covered" >this.update();}</span>
<span class="fstat-no" title="function not covered" >se</span>tLayerTree(layerTree){}
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >super.wasShown();<span class="cstat-no" title="statement not covered" >t</span>his.update();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nScrollRectClicked(index,event){<span class="cstat-no" title="statement not covered" >if(event.which!==1)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.selectObject(new LayerViewer.LayerView.ScrollRectSelection(this._selection.layer(),index));}</span>
<span class="fstat-no" title="function not covered" >_o</span>nPaintProfilerButtonClicked(){<span class="cstat-no" title="statement not covered" >if(this._selection.type()===LayerViewer.LayerView.Selection.Type.Snapshot||this._selection.layer())</span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(LayerViewer.LayerDetailsView.Events.PaintProfilerRequested,this._selection);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateScrollRectElement(scrollRect,index){<span class="cstat-no" title="statement not covered" >if(index)</span>
<span class="cstat-no" title="statement not covered" >this._scrollRectsCell.createTextChild(', ');c</span>onst element=<span class="cstat-no" title="statement not covered" >this._scrollRectsCell.createChild('span','scroll-rect');<span class="cstat-no" title="statement not covered" ></span>if(this._selection.scrollRectIndex===index)</span>
<span class="cstat-no" title="statement not covered" >element.classList.add('active');<span class="cstat-no" title="statement not covered" >e</span>lement.textContent=Common.UIString('%s %d × %d (at %d, %d)',LayerViewer.LayerDetailsView._slowScrollRectNames.get(scrollRect.type),scrollRect.rect.x,scrollRect.rect.y,scrollRect.rect.width,scrollRect.rect.height);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('click',this._onScrollRectClicked.bind(this,index),false);}</span>
<span class="fstat-no" title="function not covered" >_f</span>ormatStickyAncestorLayer(title,layer){<span class="cstat-no" title="statement not covered" >if(!layer)</span>
<span class="cstat-no" title="statement not covered" >return'';c</span>onst node=<span class="cstat-no" title="statement not covered" >layer.nodeForSelfOrAncestor();</span>const name=<span class="cstat-no" title="statement not covered" >node?node.simpleSelector():Common.UIString('&lt;unnamed&gt;');<span class="cstat-no" title="statement not covered" ></span>return Common.UIString('%s: %s (%s)',title,name,layer.id());}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateStickyAncestorChild(title,layer){<span class="cstat-no" title="statement not covered" >if(!layer)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._stickyPositionConstraintCell.createTextChild(', ');c</span>onst child=<span class="cstat-no" title="statement not covered" >this._stickyPositionConstraintCell.createChild('span');<span class="cstat-no" title="statement not covered" ></span>child.textContent=this._formatStickyAncestorLayer(title,layer);}</span>
<span class="fstat-no" title="function not covered" >_p</span>opulateStickyPositionConstraintCell(constraint){<span class="cstat-no" title="statement not covered" >this._stickyPositionConstraintCell.removeChildren();<span class="cstat-no" title="statement not covered" >i</span>f(!constraint)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst stickyBoxRect=<span class="cstat-no" title="statement not covered" >constraint.stickyBoxRect();</span>const stickyBoxRectElement=<span class="cstat-no" title="statement not covered" >this._stickyPositionConstraintCell.createChild('span');<span class="cstat-no" title="statement not covered" ></span>stickyBoxRectElement.textContent=Common.UIString('Sticky Box %d × %d (at %d, %d)',stickyBoxRect.width,stickyBoxRect.height,stickyBoxRect.x,stickyBoxRect.y);<span class="cstat-no" title="statement not covered" >t</span>his._stickyPositionConstraintCell.createTextChild(', ');c</span>onst containingBlockRect=<span class="cstat-no" title="statement not covered" >constraint.containingBlockRect();</span>const containingBlockRectElement=<span class="cstat-no" title="statement not covered" >this._stickyPositionConstraintCell.createChild('span');<span class="cstat-no" title="statement not covered" ></span>containingBlockRectElement.textContent=Common.UIString('Containing Block %d × %d (at %d, %d)',containingBlockRect.width,containingBlockRect.height,containingBlockRect.x,containingBlockRect.y);<span class="cstat-no" title="statement not covered" >t</span>his._createStickyAncestorChild(Common.UIString('Nearest Layer Shifting Sticky Box'),constraint.nearestLayerShiftingStickyBox());<span class="cstat-no" title="statement not covered" >t</span>his._createStickyAncestorChild(Common.UIString('Nearest Layer Shifting Containing Block'),constraint.nearestLayerShiftingContainingBlock());}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){const layer=<span class="cstat-no" title="statement not covered" >this._selection&amp;&amp;this._selection.layer();<span class="cstat-no" title="statement not covered" ></span>if(!layer){<span class="cstat-no" title="statement not covered" >this._tableElement.remove();<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerButton.remove();<span class="cstat-no" title="statement not covered" >t</span>his._emptyWidget.show(this.contentElement);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._emptyWidget.detach();<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.appendChild(this._tableElement);<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.appendChild(this._paintProfilerButton);<span class="cstat-no" title="statement not covered" >t</span>his._sizeCell.textContent=Common.UIString('%d × %d (at %d,%d)',layer.width(),layer.height(),layer.offsetX(),layer.offsetY());<span class="cstat-no" title="statement not covered" >t</span>his._paintCountCell.parentElement.classList.toggle('hidden',!layer.paintCount());<span class="cstat-no" title="statement not covered" >t</span>his._paintCountCell.textContent=layer.paintCount();<span class="cstat-no" title="statement not covered" >t</span>his._memoryEstimateCell.textContent=Number.bytesToString(layer.gpuMemoryUsage());<span class="cstat-no" title="statement not covered" >l</span>ayer.requestCompositingReasons().then(this._updateCompositingReasons.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._scrollRectsCell.removeChildren();<span class="cstat-no" title="statement not covered" >l</span>ayer.scrollRects().forEach(this._createScrollRectElement.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._populateStickyPositionConstraintCell(layer.stickyPositionConstraint());c</span>onst snapshot=<span class="cstat-no" title="statement not covered" >this._selection.type()===LayerViewer.LayerView.Selection.Type.Snapshot?(this._selection).snapshot():null;<span class="cstat-no" title="statement not covered" ></span>this._paintProfilerButton.classList.toggle('hidden',!snapshot);}</span>
<span class="fstat-no" title="function not covered" >_b</span>uildContent(){<span class="cstat-no" title="statement not covered" >this._tableElement=this.contentElement.createChild('table');<span class="cstat-no" title="statement not covered" >t</span>his._tbodyElement=this._tableElement.createChild('tbody');<span class="cstat-no" title="statement not covered" >t</span>his._sizeCell=this._createRow(Common.UIString('Size'));<span class="cstat-no" title="statement not covered" >t</span>his._compositingReasonsCell=this._createRow(Common.UIString('Compositing Reasons'));<span class="cstat-no" title="statement not covered" >t</span>his._memoryEstimateCell=this._createRow(Common.UIString('Memory estimate'));<span class="cstat-no" title="statement not covered" >t</span>his._paintCountCell=this._createRow(Common.UIString('Paint count'));<span class="cstat-no" title="statement not covered" >t</span>his._scrollRectsCell=this._createRow(Common.UIString('Slow scroll regions'));<span class="cstat-no" title="statement not covered" >t</span>his._stickyPositionConstraintCell=this._createRow(Common.UIString('Sticky position constraint'));<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerButton=this.contentElement.createChild('a','hidden link');<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerButton.textContent=Common.UIString('Paint Profiler');<span class="cstat-no" title="statement not covered" >t</span>his._paintProfilerButton.addEventListener('click',this._onPaintProfilerButtonClicked.bind(this));}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateRow(title){const tr=<span class="cstat-no" title="statement not covered" >this._tbodyElement.createChild('tr');</span>const titleCell=<span class="cstat-no" title="statement not covered" >tr.createChild('td');<span class="cstat-no" title="statement not covered" ></span>titleCell.textContent=title;<span class="cstat-no" title="statement not covered" >r</span>eturn tr.createChild('td');}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateCompositingReasons(compositingReasons){<span class="cstat-no" title="statement not covered" >if(!compositingReasons||!compositingReasons.length){<span class="cstat-no" title="statement not covered" >this._compositingReasonsCell.textContent='n/a';<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._compositingReasonsCell.removeChildren();c</span>onst list=<span class="cstat-no" title="statement not covered" >this._compositingReasonsCell.createChild('ul');<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;compositingReasons.length;++i){let text=<span class="cstat-no" title="statement not covered" >LayerViewer.LayerDetailsView.CompositingReasonDetail[compositingReasons[i]]||compositingReasons[i];<span class="cstat-no" title="statement not covered" ></span>if(/\s.*[^.]$/.test(text))</span></span>
<span class="cstat-no" title="statement not covered" >text+='.';<span class="cstat-no" title="statement not covered" >l</span>ist.createChild('li').textContent=text;}</span>}};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerDetailsView.Events={PaintProfilerRequested:Symbol('PaintProfilerRequested')};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.LayerDetailsView.CompositingReasonDetail={'transform3D':Common.UIString('Composition due to association with an element with a CSS 3D transform.'),'video':Common.UIString('Composition due to association with a &lt;video&gt; element.'),'canvas':Common.UIString('Composition due to the element being a &lt;canvas&gt; element.'),'plugin':Common.UIString('Composition due to association with a plugin.'),'iFrame':Common.UIString('Composition due to association with an &lt;iframe&gt; element.'),'backfaceVisibilityHidden':Common.UIString('Composition due to association with an element with a "backface-visibility: hidden" style.'),'animation':Common.UIString('Composition due to association with an animated element.'),'filters':Common.UIString('Composition due to association with an element with CSS filters applied.'),'scrollDependentPosition':Common.UIString('Composition due to association with an element with a "position: fixed" or "position: sticky" style.'),'overflowScrollingTouch':Common.UIString('Composition due to association with an element with a "overflow-scrolling: touch" style.'),'blending':Common.UIString('Composition due to association with an element that has blend mode other than "normal".'),'assumedOverlap':Common.UIString('Composition due to association with an element that may overlap other composited elements.'),'overlap':Common.UIString('Composition due to association with an element overlapping other composited elements.'),'negativeZIndexChildren':Common.UIString('Composition due to association with an element with descendants that have a negative z-index.'),'transformWithCompositedDescendants':Common.UIString('Composition due to association with an element with composited descendants.'),'opacityWithCompositedDescendants':Common.UIString('Composition due to association with an element with opacity applied and composited descendants.'),'maskWithCompositedDescendants':Common.UIString('Composition due to association with a masked element and composited descendants.'),'reflectionWithCompositedDescendants':Common.UIString('Composition due to association with an element with a reflection and composited descendants.'),'filterWithCompositedDescendants':Common.UIString('Composition due to association with an element with CSS filters applied and composited descendants.'),'blendingWithCompositedDescendants':Common.UIString('Composition due to association with an element with CSS blending applied and composited descendants.'),'clipsCompositingDescendants':Common.UIString('Composition due to association with an element clipping compositing descendants.'),'perspective':Common.UIString('Composition due to association with an element with perspective applied.'),'preserve3D':Common.UIString('Composition due to association with an element with a "transform-style: preserve-3d" style.'),'root':Common.UIString('Root layer.'),'layerForClip':Common.UIString('Layer for clip.'),'layerForScrollbar':Common.UIString('Layer for scrollbar.'),'layerForScrollingContainer':Common.UIString('Layer for scrolling container.'),'layerForForeground':Common.UIString('Layer for foreground.'),'layerForBackground':Common.UIString('Layer for background.'),'layerForMask':Common.UIString('Layer for mask.'),'layerForVideoOverlay':Common.UIString('Layer for video overlay.'),};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.LayerDetailsView._slowScrollRectNames=new Map([[SDK.Layer.ScrollRectType.NonFastScrollable,Common.UIString('Non fast scrollable')],[SDK.Layer.ScrollRectType.TouchEventHandler,Common.UIString('Touch event handler')],[SDK.Layer.ScrollRectType.WheelEventHandler,Common.UIString('Wheel event handler')],[SDK.Layer.ScrollRectType.RepaintsOnScroll,Common.UIString('Repaints on scroll')]]);;<span class="cstat-no" title="statement not covered" ></span>LayerViewer.LayerTreeOutline=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(layerViewHost){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost=layerViewHost;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.registerView(this);<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline=new UI.TreeOutlineInShadow();<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline.element.classList.add('layer-tree','overflow-auto');<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline.element.addEventListener('mousemove',this._onMouseMove.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline.element.addEventListener('mouseout',this._onMouseMove.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline.element.addEventListener('contextmenu',this._onContextMenu.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._lastHoveredNode=null;<span class="cstat-no" title="statement not covered" >t</span>his.element=this._treeOutline.element;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.showInternalLayersSetting().addChangeListener(this._update,this);}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>cus(){<span class="cstat-no" title="statement not covered" >this._treeOutline.focus();}</span>
<span class="fstat-no" title="function not covered" >se</span>lectObject(selection){<span class="cstat-no" title="statement not covered" >this.hoverObject(null);c</span>onst layer=<span class="cstat-no" title="statement not covered" >selection&amp;&amp;selection.layer();</span>const node=<span class="cstat-no" title="statement not covered" >layer&amp;&amp;layer[LayerViewer.LayerTreeElement._symbol];<span class="cstat-no" title="statement not covered" ></span>if(node)</span>
<span class="cstat-no" title="statement not covered" >node.revealAndSelect(true);e</span>lse <span class="cstat-no" title="statement not covered" >if(this._treeOutline.selectedTreeElement)</span>
<span class="cstat-no" title="statement not covered" >this._treeOutline.selectedTreeElement.deselect();}</span>
<span class="fstat-no" title="function not covered" >ho</span>verObject(selection){const layer=<span class="cstat-no" title="statement not covered" >selection&amp;&amp;selection.layer();</span>const node=<span class="cstat-no" title="statement not covered" >layer&amp;&amp;layer[LayerViewer.LayerTreeElement._symbol];<span class="cstat-no" title="statement not covered" ></span>if(node===this._lastHoveredNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._lastHoveredNode)</span>
<span class="cstat-no" title="statement not covered" >this._lastHoveredNode.setHovered(false);<span class="cstat-no" title="statement not covered" >i</span>f(node)</span>
<span class="cstat-no" title="statement not covered" >node.setHovered(true);<span class="cstat-no" title="statement not covered" >t</span>his._lastHoveredNode=node;}</span>
<span class="fstat-no" title="function not covered" >se</span>tLayerTree(layerTree){<span class="cstat-no" title="statement not covered" >this._layerTree=layerTree;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){const showInternalLayers=<span class="cstat-no" title="statement not covered" >this._layerViewHost.showInternalLayersSetting().get();</span>const seenLayers=<span class="cstat-no" title="statement not covered" >new Map();</span>let root=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this._layerTree){<span class="cstat-no" title="statement not covered" >if(!showInternalLayers)</span></span>
<span class="cstat-no" title="statement not covered" >root=this._layerTree.contentRoot();<span class="cstat-no" title="statement not covered" >i</span>f(!root)</span>
<span class="cstat-no" title="statement not covered" >root=this._layerTree.root();}</span>
function <span class="fstat-no" title="function not covered" >updateLayer(</span>layer){<span class="cstat-no" title="statement not covered" >if(!layer.drawsContent()&amp;&amp;!showInternalLayers)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(seenLayers.get(layer))</span>
<span class="cstat-no" title="statement not covered" >console.assert(false,'Duplicate layer: '+layer.id());<span class="cstat-no" title="statement not covered" >s</span>eenLayers.set(layer,true);l</span>et node=<span class="cstat-no" title="statement not covered" >layer[LayerViewer.LayerTreeElement._symbol];</span>let parentLayer=<span class="cstat-no" title="statement not covered" >layer.parent();<span class="cstat-no" title="statement not covered" ></span>while(parentLayer&amp;&amp;parentLayer!==root&amp;&amp;!parentLayer.drawsContent()&amp;&amp;!showInternalLayers)</span>
<span class="cstat-no" title="statement not covered" >parentLayer=parentLayer.parent();c</span>onst parent=<span class="cstat-no" title="statement not covered" >layer===root?this._treeOutline.rootElement():parentLayer[LayerViewer.LayerTreeElement._symbol];<span class="cstat-no" title="statement not covered" ></span>if(!parent){<span class="cstat-no" title="statement not covered" >console.assert(false,'Parent is not in the tree');<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!node){<span class="cstat-no" title="statement not covered" >node=new LayerViewer.LayerTreeElement(this,layer);<span class="cstat-no" title="statement not covered" >p</span>arent.appendChild(node);<span class="cstat-no" title="statement not covered" >i</span>f(!layer.drawsContent())</span></span>
<span class="cstat-no" title="statement not covered" >node.expand();}</span>else{<span class="cstat-no" title="statement not covered" >if(node.parent!==parent){const oldSelection=<span class="cstat-no" title="statement not covered" >this._treeOutline.selectedTreeElement;<span class="cstat-no" title="statement not covered" ></span>if(node.parent)</span></span>
<span class="cstat-no" title="statement not covered" >node.parent.removeChild(node);<span class="cstat-no" title="statement not covered" >p</span>arent.appendChild(node);<span class="cstat-no" title="statement not covered" >i</span>f(oldSelection!==this._treeOutline.selectedTreeElement)</span>
<span class="cstat-no" title="statement not covered" >oldSelection.select();}</span>
<span class="cstat-no" title="statement not covered" >node._update();}</span>}
<span class="cstat-no" title="statement not covered" >if(root)</span>
<span class="cstat-no" title="statement not covered" >this._layerTree.forEachLayer(updateLayer.bind(this),root);c</span>onst rootElement=<span class="cstat-no" title="statement not covered" >this._treeOutline.rootElement();<span class="cstat-no" title="statement not covered" ></span>for(let node=rootElement.firstChild();node&amp;&amp;!node.root;){<span class="cstat-no" title="statement not covered" >if(seenLayers.get(node._layer)){<span class="cstat-no" title="statement not covered" >node=node.traverseNextTreeElement(false);}</span>else{const nextNode=<span class="cstat-no" title="statement not covered" >node.nextSibling||node.parent;<span class="cstat-no" title="statement not covered" ></span>node.parent.removeChild(node);<span class="cstat-no" title="statement not covered" >i</span>f(node===this._lastHoveredNode)</span></span></span>
<span class="cstat-no" title="statement not covered" >this._lastHoveredNode=null;<span class="cstat-no" title="statement not covered" >n</span>ode=nextNode;}</span>}
<span class="cstat-no" title="statement not covered" >if(!this._treeOutline.selectedTreeElement){const elementToSelect=<span class="cstat-no" title="statement not covered" >this._layerTree.contentRoot()||this._layerTree.root();<span class="cstat-no" title="statement not covered" ></span>if(elementToSelect)</span></span>
<span class="cstat-no" title="statement not covered" >elementToSelect[LayerViewer.LayerTreeElement._symbol].revealAndSelect(true);}</span>}
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){const node=<span class="cstat-no" title="statement not covered" >this._treeOutline.treeElementFromEvent(event);<span class="cstat-no" title="statement not covered" ></span>if(node===this._lastHoveredNode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.hoverObject(this._selectionForNode(node));}</span>
<span class="fstat-no" title="function not covered" >_s</span>electedNodeChanged(node){<span class="cstat-no" title="statement not covered" >this._layerViewHost.selectObject(this._selectionForNode(node));}</span>
<span class="fstat-no" title="function not covered" >_o</span>nContextMenu(event){const selection=<span class="cstat-no" title="statement not covered" >this._selectionForNode(this._treeOutline.treeElementFromEvent(event));</span>const contextMenu=<span class="cstat-no" title="statement not covered" >new UI.ContextMenu(event);<span class="cstat-no" title="statement not covered" ></span>this._layerViewHost.showContextMenu(contextMenu,selection);}</span>
<span class="fstat-no" title="function not covered" >_s</span>electionForNode(node){<span class="cstat-no" title="statement not covered" >return node&amp;&amp;node._layer?new LayerViewer.LayerView.LayerSelection(node._layer):null;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerTreeElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(tree,layer){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline=tree;<span class="cstat-no" title="statement not covered" >t</span>his._layer=layer;<span class="cstat-no" title="statement not covered" >t</span>his._layer[LayerViewer.LayerTreeElement._symbol]=this;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span></span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){const node=<span class="cstat-no" title="statement not covered" >this._layer.nodeForSelfOrAncestor();</span>const title=<span class="cstat-no" title="statement not covered" >createDocumentFragment();<span class="cstat-no" title="statement not covered" ></span>title.createTextChild(node?node.simpleSelector():'#'+this._layer.id());c</span>onst details=<span class="cstat-no" title="statement not covered" >title.createChild('span','dimmed');<span class="cstat-no" title="statement not covered" ></span>details.textContent=Common.UIString(' (%d × %d)',this._layer.width(),this._layer.height());<span class="cstat-no" title="statement not covered" >t</span>his.title=title;}</span>
<span class="fstat-no" title="function not covered" >on</span>select(){<span class="cstat-no" title="statement not covered" >this._treeOutline._selectedNodeChanged(this);<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
<span class="fstat-no" title="function not covered" >se</span>tHovered(hovered){<span class="cstat-no" title="statement not covered" >this.listItemElement.classList.toggle('hovered',hovered);}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerTreeElement._symbol=Symbol('layer');;<span class="cstat-no" title="statement not covered" ></span>LayerViewer.LayerView=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.LayerView.prototype={hoverObject(selection){},selectObject(selection){},setLayerTree(layerTree){}};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.LayerView.Selection=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(type,layer){<span class="cstat-no" title="statement not covered" >this._type=type;<span class="cstat-no" title="statement not covered" >t</span>his._layer=layer;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic isEqual(a,b){<span class="cstat-no" title="statement not covered" >return a&amp;&amp;b?a._isEqual(b):a===b;}</span>
<span class="fstat-no" title="function not covered" >ty</span>pe(){<span class="cstat-no" title="statement not covered" >return this._type;}</span>
<span class="fstat-no" title="function not covered" >la</span>yer(){<span class="cstat-no" title="statement not covered" >return this._layer;}</span>
<span class="fstat-no" title="function not covered" >_i</span>sEqual(other){<span class="cstat-no" title="statement not covered" >return false;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerView.Selection.Type={Layer:Symbol('Layer'),ScrollRect:Symbol('ScrollRect'),Snapshot:Symbol('Snapshot')};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.LayerView.LayerSelection=class extends LayerViewer.LayerView.Selection{<span class="fstat-no" title="function not covered" >co</span>nstructor(layer){<span class="cstat-no" title="statement not covered" >console.assert(layer,'LayerSelection with empty layer');<span class="cstat-no" title="statement not covered" >s</span>uper(LayerViewer.LayerView.Selection.Type.Layer,layer);}</span></span>
<span class="fstat-no" title="function not covered" >_i</span>sEqual(other){<span class="cstat-no" title="statement not covered" >return other._type===LayerViewer.LayerView.Selection.Type.Layer&amp;&amp;other.layer().id()===this.layer().id();}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerView.ScrollRectSelection=class extends LayerViewer.LayerView.Selection{<span class="fstat-no" title="function not covered" >co</span>nstructor(layer,scrollRectIndex){<span class="cstat-no" title="statement not covered" >super(LayerViewer.LayerView.Selection.Type.ScrollRect,layer);<span class="cstat-no" title="statement not covered" >t</span>his.scrollRectIndex=scrollRectIndex;}</span></span>
<span class="fstat-no" title="function not covered" >_i</span>sEqual(other){<span class="cstat-no" title="statement not covered" >return other._type===LayerViewer.LayerView.Selection.Type.ScrollRect&amp;&amp;this.layer().id()===other.layer().id()&amp;&amp;this.scrollRectIndex===other.scrollRectIndex;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerView.SnapshotSelection=class extends LayerViewer.LayerView.Selection{<span class="fstat-no" title="function not covered" >co</span>nstructor(layer,snapshot){<span class="cstat-no" title="statement not covered" >super(LayerViewer.LayerView.Selection.Type.Snapshot,layer);<span class="cstat-no" title="statement not covered" >t</span>his._snapshot=snapshot;}</span></span>
<span class="fstat-no" title="function not covered" >_i</span>sEqual(other){<span class="cstat-no" title="statement not covered" >return other._type===LayerViewer.LayerView.Selection.Type.Snapshot&amp;&amp;this.layer().id()===other.layer().id()&amp;&amp;this._snapshot===other._snapshot;}</span>
<span class="fstat-no" title="function not covered" >sn</span>apshot(){<span class="cstat-no" title="statement not covered" >return this._snapshot;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerViewHost=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._views=[];<span class="cstat-no" title="statement not covered" >t</span>his._selectedObject=null;<span class="cstat-no" title="statement not covered" >t</span>his._hoveredObject=null;<span class="cstat-no" title="statement not covered" >t</span>his._showInternalLayersSetting=Common.settings.createSetting('layersShowInternalLayers',false);}</span></span>
<span class="fstat-no" title="function not covered" >re</span>gisterView(layerView){<span class="cstat-no" title="statement not covered" >this._views.push(layerView);}</span>
<span class="fstat-no" title="function not covered" >se</span>tLayerTree(layerTree){<span class="cstat-no" title="statement not covered" >this._target=layerTree.target();c</span>onst selectedLayer=<span class="cstat-no" title="statement not covered" >this._selectedObject&amp;&amp;this._selectedObject.layer();<span class="cstat-no" title="statement not covered" ></span>if(selectedLayer&amp;&amp;(!layerTree||!layerTree.layerById(selectedLayer.id())))</span>
<span class="cstat-no" title="statement not covered" >this.selectObject(null);c</span>onst hoveredLayer=<span class="cstat-no" title="statement not covered" >this._hoveredObject&amp;&amp;this._hoveredObject.layer();<span class="cstat-no" title="statement not covered" ></span>if(hoveredLayer&amp;&amp;(!layerTree||!layerTree.layerById(hoveredLayer.id())))</span>
<span class="cstat-no" title="statement not covered" >this.hoverObject(null);<span class="cstat-no" title="statement not covered" >f</span>or(const view of this._views)</span>
<span class="cstat-no" title="statement not covered" >view.setLayerTree(layerTree);}</span>
<span class="fstat-no" title="function not covered" >ho</span>verObject(selection){<span class="cstat-no" title="statement not covered" >if(LayerViewer.LayerView.Selection.isEqual(this._hoveredObject,selection))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._hoveredObject=selection;c</span>onst layer=<span class="cstat-no" title="statement not covered" >selection&amp;&amp;selection.layer();<span class="cstat-no" title="statement not covered" ></span>this._toggleNodeHighlight(layer?layer.nodeForSelfOrAncestor():null);<span class="cstat-no" title="statement not covered" >f</span>or(const view of this._views)</span>
<span class="cstat-no" title="statement not covered" >view.hoverObject(selection);}</span>
<span class="fstat-no" title="function not covered" >se</span>lectObject(selection){<span class="cstat-no" title="statement not covered" >if(LayerViewer.LayerView.Selection.isEqual(this._selectedObject,selection))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._selectedObject=selection;<span class="cstat-no" title="statement not covered" >f</span>or(const view of this._views)</span>
<span class="cstat-no" title="statement not covered" >view.selectObject(selection);}</span>
<span class="fstat-no" title="function not covered" >se</span>lection(){<span class="cstat-no" title="statement not covered" >return this._selectedObject;}</span>
<span class="fstat-no" title="function not covered" >sh</span>owContextMenu(contextMenu,selection){<span class="cstat-no" title="statement not covered" >contextMenu.defaultSection().appendCheckboxItem(Common.UIString('Show internal layers'),this._toggleShowInternalLayers.bind(this),this._showInternalLayersSetting.get());c</span>onst node=<span class="cstat-no" title="statement not covered" >selection&amp;&amp;selection.layer()&amp;&amp;selection.layer().nodeForSelfOrAncestor();<span class="cstat-no" title="statement not covered" ></span>if(node)</span>
<span class="cstat-no" title="statement not covered" >contextMenu.appendApplicableItems(node);<span class="cstat-no" title="statement not covered" >c</span>ontextMenu.show();}</span>
<span class="fstat-no" title="function not covered" >sh</span>owInternalLayersSetting(){<span class="cstat-no" title="statement not covered" >return this._showInternalLayersSetting;}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleShowInternalLayers(){<span class="cstat-no" title="statement not covered" >this._showInternalLayersSetting.set(!this._showInternalLayersSetting.get());}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleNodeHighlight(node){<span class="cstat-no" title="statement not covered" >if(node){<span class="cstat-no" title="statement not covered" >node.highlightForTwoSeconds();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >SDK.OverlayModel.hideDOMNodeHighlight();}</span>};;<span class="cstat-no" title="statement not covered" >LayerViewer.Layers3DView=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(layerViewHost){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('layer_viewer/layers3DView.css');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.add('layers-3d-view');<span class="cstat-no" title="statement not covered" >t</span>his._failBanner=new UI.VBox();<span class="cstat-no" title="statement not covered" >t</span>his._failBanner.element.classList.add('full-widget-dimmed-banner');<span class="cstat-no" title="statement not covered" >t</span>his._failBanner.element.createTextChild(Common.UIString('Layer information is not yet available.'));<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost=layerViewHost;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.registerView(this);<span class="cstat-no" title="statement not covered" >t</span>his._transformController=new LayerViewer.TransformController(this.contentElement);<span class="cstat-no" title="statement not covered" >t</span>his._transformController.addEventListener(LayerViewer.TransformController.Events.TransformChanged,this._update,this);<span class="cstat-no" title="statement not covered" >t</span>his._initToolbar();<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement=this.contentElement.createChild('canvas');<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.tabIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.addEventListener('dblclick',this._onDoubleClick.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.addEventListener('mousedown',this._onMouseDown.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.addEventListener('mouseup',this._onMouseUp.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.addEventListener('mouseleave',this._onMouseMove.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.addEventListener('mousemove',this._onMouseMove.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.addEventListener('contextmenu',this._onContextMenu.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._lastSelection={};<span class="cstat-no" title="statement not covered" >t</span>his._layerTree=null;<span class="cstat-no" title="statement not covered" >t</span>his._textureManager=new LayerViewer.LayerTextureManager(this._update.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._chromeTextures=[];<span class="cstat-no" title="statement not covered" >t</span>his._rects=[];<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.showInternalLayersSetting().addChangeListener(this._update,this);}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tLayerTree(layerTree){<span class="cstat-no" title="statement not covered" >this._layerTree=layerTree;<span class="cstat-no" title="statement not covered" >t</span>his._layerTexture=null;<span class="cstat-no" title="statement not covered" >d</span>elete this._oldTextureScale;<span class="cstat-no" title="statement not covered" >i</span>f(this._showPaints())</span>
<span class="cstat-no" title="statement not covered" >this._textureManager.setLayerTree(layerTree);<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >sh</span>owImageForLayer(layer,imageURL){<span class="cstat-no" title="statement not covered" >if(!imageURL){<span class="cstat-no" title="statement not covered" >this._layerTexture=null;<span class="cstat-no" title="statement not covered" >t</span>his._update();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >UI.loadImage(imageURL).then(<span class="fstat-no" title="function not covered" >im</span>age=&gt;{const texture=<span class="cstat-no" title="statement not covered" >image&amp;&amp;LayerViewer.LayerTextureManager._createTextureForImage(this._gl,image);<span class="cstat-no" title="statement not covered" ></span>this._layerTexture=texture?{layer:layer,texture:texture}:null;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>);}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >this._resizeCanvas();<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >this._textureManager.suspend();}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >this._textureManager.resume();<span class="cstat-no" title="statement not covered" >i</span>f(!this._needsUpdate)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._resizeCanvas();<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >up</span>dateLayerSnapshot(layer){<span class="cstat-no" title="statement not covered" >this._textureManager.layerNeedsUpdate(layer);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etOutline(type,selection){<span class="cstat-no" title="statement not covered" >this._lastSelection[type]=selection;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >ho</span>verObject(selection){<span class="cstat-no" title="statement not covered" >this._setOutline(LayerViewer.Layers3DView.OutlineType.Hovered,selection);}</span>
<span class="fstat-no" title="function not covered" >se</span>lectObject(selection){<span class="cstat-no" title="statement not covered" >this._setOutline(LayerViewer.Layers3DView.OutlineType.Hovered,null);<span class="cstat-no" title="statement not covered" >t</span>his._setOutline(LayerViewer.Layers3DView.OutlineType.Selected,selection);}</span>
<span class="fstat-no" title="function not covered" >sn</span>apshotForSelection(selection){<span class="cstat-no" title="statement not covered" >if(selection.type()===LayerViewer.LayerView.Selection.Type.Snapshot){const snapshotWithRect=<span class="cstat-no" title="statement not covered" >(selection).snapshot();<span class="cstat-no" title="statement not covered" ></span>snapshotWithRect.snapshot.addReference();<span class="cstat-no" title="statement not covered" >r</span>eturn(Promise.resolve(snapshotWithRect));}</span></span>
<span class="cstat-no" title="statement not covered" >if(selection.layer()){const promise=<span class="cstat-no" title="statement not covered" >selection.layer().snapshots()[0];<span class="cstat-no" title="statement not covered" ></span>if(promise)</span></span>
<span class="cstat-no" title="statement not covered" >return promise;}</span>
<span class="cstat-no" title="statement not covered" >return(Promise.resolve(null));}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitGL(canvas){const gl=<span class="cstat-no" title="statement not covered" >canvas.getContext('webgl');<span class="cstat-no" title="statement not covered" ></span>if(!gl)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >g</span>l.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);<span class="cstat-no" title="statement not covered" >g</span>l.enable(gl.BLEND);<span class="cstat-no" title="statement not covered" >g</span>l.clearColor(0.0,0.0,0.0,0.0);<span class="cstat-no" title="statement not covered" >g</span>l.enable(gl.DEPTH_TEST);<span class="cstat-no" title="statement not covered" >r</span>eturn gl;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateShader(type,script){const shader=<span class="cstat-no" title="statement not covered" >this._gl.createShader(type);<span class="cstat-no" title="statement not covered" ></span>this._gl.shaderSource(shader,script);<span class="cstat-no" title="statement not covered" >t</span>his._gl.compileShader(shader);<span class="cstat-no" title="statement not covered" >t</span>his._gl.attachShader(this._shaderProgram,shader);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitShaders(){<span class="cstat-no" title="statement not covered" >this._shaderProgram=this._gl.createProgram();<span class="cstat-no" title="statement not covered" >t</span>his._createShader(this._gl.FRAGMENT_SHADER,LayerViewer.Layers3DView.FragmentShader);<span class="cstat-no" title="statement not covered" >t</span>his._createShader(this._gl.VERTEX_SHADER,LayerViewer.Layers3DView.VertexShader);<span class="cstat-no" title="statement not covered" >t</span>his._gl.linkProgram(this._shaderProgram);<span class="cstat-no" title="statement not covered" >t</span>his._gl.useProgram(this._shaderProgram);<span class="cstat-no" title="statement not covered" >t</span>his._shaderProgram.vertexPositionAttribute=this._gl.getAttribLocation(this._shaderProgram,'aVertexPosition');<span class="cstat-no" title="statement not covered" >t</span>his._gl.enableVertexAttribArray(this._shaderProgram.vertexPositionAttribute);<span class="cstat-no" title="statement not covered" >t</span>his._shaderProgram.vertexColorAttribute=this._gl.getAttribLocation(this._shaderProgram,'aVertexColor');<span class="cstat-no" title="statement not covered" >t</span>his._gl.enableVertexAttribArray(this._shaderProgram.vertexColorAttribute);<span class="cstat-no" title="statement not covered" >t</span>his._shaderProgram.textureCoordAttribute=this._gl.getAttribLocation(this._shaderProgram,'aTextureCoord');<span class="cstat-no" title="statement not covered" >t</span>his._gl.enableVertexAttribArray(this._shaderProgram.textureCoordAttribute);<span class="cstat-no" title="statement not covered" >t</span>his._shaderProgram.pMatrixUniform=this._gl.getUniformLocation(this._shaderProgram,'uPMatrix');<span class="cstat-no" title="statement not covered" >t</span>his._shaderProgram.samplerUniform=this._gl.getUniformLocation(this._shaderProgram,'uSampler');}</span>
<span class="fstat-no" title="function not covered" >_r</span>esizeCanvas(){<span class="cstat-no" title="statement not covered" >this._canvasElement.width=this._canvasElement.offsetWidth*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._canvasElement.height=this._canvasElement.offsetHeight*window.devicePixelRatio;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateTransformAndConstraints(){const paddingFraction=<span class="cstat-no" title="statement not covered" >0.1;</span>const viewport=<span class="cstat-no" title="statement not covered" >this._layerTree.viewportSize();</span>const baseWidth=<span class="cstat-no" title="statement not covered" >viewport?viewport.width:this._dimensionsForAutoscale.width;</span>const baseHeight=<span class="cstat-no" title="statement not covered" >viewport?viewport.height:this._dimensionsForAutoscale.height;</span>const canvasWidth=<span class="cstat-no" title="statement not covered" >this._canvasElement.width;</span>const canvasHeight=<span class="cstat-no" title="statement not covered" >this._canvasElement.height;</span>const paddingX=<span class="cstat-no" title="statement not covered" >canvasWidth*paddingFraction;</span>const paddingY=<span class="cstat-no" title="statement not covered" >canvasHeight*paddingFraction;</span>const scaleX=<span class="cstat-no" title="statement not covered" >(canvasWidth-2*paddingX)/baseWidth;</span>const scaleY=<span class="cstat-no" title="statement not covered" >(canvasHeight-2*paddingY)/baseHeight;</span>const viewScale=<span class="cstat-no" title="statement not covered" >Math.min(scaleX,scaleY);</span>const minScaleConstraint=<span class="cstat-no" title="statement not covered" >Math.min(baseWidth/this._dimensionsForAutoscale.width,baseHeight/this._dimensionsForAutoscale.width)/2;<span class="cstat-no" title="statement not covered" ></span>this._transformController.setScaleConstraints(minScaleConstraint,10/viewScale);c</span>onst scale=<span class="cstat-no" title="statement not covered" >this._transformController.scale();</span>const rotateX=<span class="cstat-no" title="statement not covered" >this._transformController.rotateX();</span>const rotateY=<span class="cstat-no" title="statement not covered" >this._transformController.rotateY();<span class="cstat-no" title="statement not covered" ></span>this._scale=scale*viewScale;c</span>onst textureScale=<span class="cstat-no" title="statement not covered" >Number.constrain(this._scale,0.1,1);<span class="cstat-no" title="statement not covered" ></span>if(textureScale!==this._oldTextureScale){<span class="cstat-no" title="statement not covered" >this._oldTextureScale=textureScale;<span class="cstat-no" title="statement not covered" >t</span>his._textureManager.setScale(textureScale);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(LayerViewer.Layers3DView.Events.ScaleChanged,textureScale);}</span></span>
const scaleAndRotationMatrix=<span class="cstat-no" title="statement not covered" >new WebKitCSSMatrix().scale(scale,scale,scale).translate(canvasWidth/2,canvasHeight/2,0).rotate(rotateX,rotateY,0).scale(viewScale,viewScale,viewScale).translate(-baseWidth/2,-baseHeight/2,0);</span>let bounds;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._rects.length;++i)</span>
<span class="cstat-no" title="statement not covered" >bounds=UI.Geometry.boundsForTransformedPoints(scaleAndRotationMatrix,this._rects[i].vertices,bounds);<span class="cstat-no" title="statement not covered" >t</span>his._transformController.clampOffsets((paddingX-bounds.maxX)/window.devicePixelRatio,(canvasWidth-paddingX-bounds.minX)/window.devicePixelRatio,(paddingY-bounds.maxY)/window.devicePixelRatio,(canvasHeight-paddingY-bounds.minY)/window.devicePixelRatio);c</span>onst offsetX=<span class="cstat-no" title="statement not covered" >this._transformController.offsetX()*window.devicePixelRatio;</span>const offsetY=<span class="cstat-no" title="statement not covered" >this._transformController.offsetY()*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>this._projectionMatrix=new WebKitCSSMatrix().translate(offsetX,offsetY,0).multiply(scaleAndRotationMatrix);c</span>onst glProjectionMatrix=<span class="cstat-no" title="statement not covered" >new WebKitCSSMatrix().scale(1,-1,-1).translate(-1,-1,0).scale(2/this._canvasElement.width,2/this._canvasElement.height,1/1000000).multiply(this._projectionMatrix);<span class="cstat-no" title="statement not covered" ></span>this._gl.uniformMatrix4fv(this._shaderProgram.pMatrixUniform,false,this._arrayFromMatrix(glProjectionMatrix));}</span>
<span class="fstat-no" title="function not covered" >_a</span>rrayFromMatrix(m){<span class="cstat-no" title="statement not covered" >return new Float32Array([m.m11,m.m12,m.m13,m.m14,m.m21,m.m22,m.m23,m.m24,m.m31,m.m32,m.m33,m.m34,m.m41,m.m42,m.m43,m.m44]);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitWhiteTexture(){<span class="cstat-no" title="statement not covered" >this._whiteTexture=this._gl.createTexture();<span class="cstat-no" title="statement not covered" >t</span>his._gl.bindTexture(this._gl.TEXTURE_2D,this._whiteTexture);c</span>onst whitePixel=<span class="cstat-no" title="statement not covered" >new Uint8Array([255,255,255,255]);<span class="cstat-no" title="statement not covered" ></span>this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,1,1,0,this._gl.RGBA,this._gl.UNSIGNED_BYTE,whitePixel);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitChromeTextures(){function <span class="fstat-no" title="function not covered" >loadChromeTexture(</span>index,url){<span class="cstat-no" title="statement not covered" >UI.loadImage(url).then(<span class="fstat-no" title="function not covered" >im</span>age=&gt;{<span class="cstat-no" title="statement not covered" >this._chromeTextures[index]=image&amp;&amp;LayerViewer.LayerTextureManager._createTextureForImage(this._gl,image)||undefined;}</span>);}</span>
<span class="cstat-no" title="statement not covered" >loadChromeTexture.call(this,LayerViewer.Layers3DView.ChromeTexture.Left,'Images/chromeLeft.png');<span class="cstat-no" title="statement not covered" >l</span>oadChromeTexture.call(this,LayerViewer.Layers3DView.ChromeTexture.Middle,'Images/chromeMiddle.png');<span class="cstat-no" title="statement not covered" >l</span>oadChromeTexture.call(this,LayerViewer.Layers3DView.ChromeTexture.Right,'Images/chromeRight.png');}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitGLIfNecessary(){<span class="cstat-no" title="statement not covered" >if(this._gl)</span>
<span class="cstat-no" title="statement not covered" >return this._gl;<span class="cstat-no" title="statement not covered" >t</span>his._gl=this._initGL(this._canvasElement);<span class="cstat-no" title="statement not covered" >i</span>f(!this._gl)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span>his._initShaders();<span class="cstat-no" title="statement not covered" >t</span>his._initWhiteTexture();<span class="cstat-no" title="statement not covered" >t</span>his._initChromeTextures();<span class="cstat-no" title="statement not covered" >t</span>his._textureManager.setContext(this._gl);<span class="cstat-no" title="statement not covered" >r</span>eturn this._gl;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateDepthsAndVisibility(){<span class="cstat-no" title="statement not covered" >this._depthByLayerId={};l</span>et depth=<span class="cstat-no" title="statement not covered" >0;</span>const showInternalLayers=<span class="cstat-no" title="statement not covered" >this._layerViewHost.showInternalLayersSetting().get();</span>const root=<span class="cstat-no" title="statement not covered" >showInternalLayers?this._layerTree.root():(this._layerTree.contentRoot()||this._layerTree.root());</span>const queue=<span class="cstat-no" title="statement not covered" >[root];<span class="cstat-no" title="statement not covered" ></span>this._depthByLayerId[root.id()]=0;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLayers=new Set();<span class="cstat-no" title="statement not covered" >w</span>hile(queue.length&gt;0){const layer=<span class="cstat-no" title="statement not covered" >queue.shift();<span class="cstat-no" title="statement not covered" ></span>if(showInternalLayers||layer.drawsContent())</span></span>
<span class="cstat-no" title="statement not covered" >this._visibleLayers.add(layer);c</span>onst children=<span class="cstat-no" title="statement not covered" >layer.children();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;children.length;++i){<span class="cstat-no" title="statement not covered" >this._depthByLayerId[children[i].id()]=++depth;<span class="cstat-no" title="statement not covered" >q</span>ueue.push(children[i]);}</span>}</span>
<span class="cstat-no" title="statement not covered" >this._maxDepth=depth;}</span>
<span class="fstat-no" title="function not covered" >_d</span>epthForLayer(layer){<span class="cstat-no" title="statement not covered" >return this._depthByLayerId[layer.id()]*LayerViewer.Layers3DView.LayerSpacing;}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateScrollRectDepth(layer,index){<span class="cstat-no" title="statement not covered" >return this._depthForLayer(layer)+index*LayerViewer.Layers3DView.ScrollRectSpacing+1;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateDimensionsForAutoscale(layer){<span class="cstat-no" title="statement not covered" >this._dimensionsForAutoscale.width=Math.max(layer.width(),this._dimensionsForAutoscale.width);<span class="cstat-no" title="statement not covered" >t</span>his._dimensionsForAutoscale.height=Math.max(layer.height(),this._dimensionsForAutoscale.height);}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateLayerRect(layer){<span class="cstat-no" title="statement not covered" >if(!this._visibleLayers.has(layer))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst selection=<span class="cstat-no" title="statement not covered" >new LayerViewer.LayerView.LayerSelection(layer);</span>const rect=<span class="cstat-no" title="statement not covered" >new LayerViewer.Layers3DView.Rectangle(selection);<span class="cstat-no" title="statement not covered" ></span>rect.setVertices(layer.quad(),this._depthForLayer(layer));<span class="cstat-no" title="statement not covered" >t</span>his._appendRect(rect);<span class="cstat-no" title="statement not covered" >t</span>his._updateDimensionsForAutoscale(layer);}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendRect(rect){const selection=<span class="cstat-no" title="statement not covered" >rect.relatedObject;</span>const isSelected=<span class="cstat-no" title="statement not covered" >LayerViewer.LayerView.Selection.isEqual(this._lastSelection[LayerViewer.Layers3DView.OutlineType.Selected],selection);</span>const isHovered=<span class="cstat-no" title="statement not covered" >LayerViewer.LayerView.Selection.isEqual(this._lastSelection[LayerViewer.Layers3DView.OutlineType.Hovered],selection);<span class="cstat-no" title="statement not covered" ></span>if(isSelected){<span class="cstat-no" title="statement not covered" >rect.borderColor=LayerViewer.Layers3DView.SelectedBorderColor;}</span>else <span class="cstat-no" title="statement not covered" >if(isHovered){<span class="cstat-no" title="statement not covered" >rect.borderColor=LayerViewer.Layers3DView.HoveredBorderColor;c</span>onst fillColor=<span class="cstat-no" title="statement not covered" >rect.fillColor||[255,255,255,1];</span>const maskColor=<span class="cstat-no" title="statement not covered" >LayerViewer.Layers3DView.HoveredImageMaskColor;<span class="cstat-no" title="statement not covered" ></span>rect.fillColor=[fillColor[0]*maskColor[0]/255,fillColor[1]*maskColor[1]/255,fillColor[2]*maskColor[2]/255,fillColor[3]*maskColor[3]];}</span>else{<span class="cstat-no" title="statement not covered" >rect.borderColor=LayerViewer.Layers3DView.BorderColor;}</span></span></span>
<span class="cstat-no" title="statement not covered" >rect.lineWidth=isSelected?LayerViewer.Layers3DView.SelectedBorderWidth:LayerViewer.Layers3DView.BorderWidth;<span class="cstat-no" title="statement not covered" >t</span>his._rects.push(rect);}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateLayerScrollRects(layer){const scrollRects=<span class="cstat-no" title="statement not covered" >layer.scrollRects();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;scrollRects.length;++i){const selection=<span class="cstat-no" title="statement not covered" >new LayerViewer.LayerView.ScrollRectSelection(layer,i);</span>const rect=<span class="cstat-no" title="statement not covered" >new LayerViewer.Layers3DView.Rectangle(selection);<span class="cstat-no" title="statement not covered" ></span>rect.calculateVerticesFromRect(layer,scrollRects[i].rect,this._calculateScrollRectDepth(layer,i));<span class="cstat-no" title="statement not covered" >r</span>ect.fillColor=LayerViewer.Layers3DView.ScrollRectBackgroundColor;<span class="cstat-no" title="statement not covered" >t</span>his._appendRect(rect);}</span>}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculateLayerTileRects(layer){const tiles=<span class="cstat-no" title="statement not covered" >this._textureManager.tilesForLayer(layer);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;tiles.length;++i){const tile=<span class="cstat-no" title="statement not covered" >tiles[i];<span class="cstat-no" title="statement not covered" ></span>if(!tile.texture)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst selection=<span class="cstat-no" title="statement not covered" >new LayerViewer.LayerView.SnapshotSelection(layer,{rect:tile.rect,snapshot:tile.snapshot});</span>const rect=<span class="cstat-no" title="statement not covered" >new LayerViewer.Layers3DView.Rectangle(selection);<span class="cstat-no" title="statement not covered" ></span>rect.calculateVerticesFromRect(layer,tile.rect,this._depthForLayer(layer)+1);<span class="cstat-no" title="statement not covered" >r</span>ect.texture=tile.texture;<span class="cstat-no" title="statement not covered" >t</span>his._appendRect(rect);}</span>}
<span class="fstat-no" title="function not covered" >_c</span>alculateRects(){<span class="cstat-no" title="statement not covered" >this._rects=[];<span class="cstat-no" title="statement not covered" >t</span>his._dimensionsForAutoscale={width:0,height:0};<span class="cstat-no" title="statement not covered" >t</span>his._layerTree.forEachLayer(this._calculateLayerRect.bind(this));<span class="cstat-no" title="statement not covered" >i</span>f(this._showSlowScrollRectsSetting.get())</span>
<span class="cstat-no" title="statement not covered" >this._layerTree.forEachLayer(this._calculateLayerScrollRects.bind(this));<span class="cstat-no" title="statement not covered" >i</span>f(this._layerTexture&amp;&amp;this._visibleLayers.has(this._layerTexture.layer)){const layer=<span class="cstat-no" title="statement not covered" >this._layerTexture.layer;</span>const selection=<span class="cstat-no" title="statement not covered" >new LayerViewer.LayerView.LayerSelection(layer);</span>const rect=<span class="cstat-no" title="statement not covered" >new LayerViewer.Layers3DView.Rectangle(selection);<span class="cstat-no" title="statement not covered" ></span>rect.setVertices(layer.quad(),this._depthForLayer(layer));<span class="cstat-no" title="statement not covered" >r</span>ect.texture=this._layerTexture.texture;<span class="cstat-no" title="statement not covered" >t</span>his._appendRect(rect);}</span>else <span class="cstat-no" title="statement not covered" >if(this._showPaints()){<span class="cstat-no" title="statement not covered" >this._layerTree.forEachLayer(this._calculateLayerTileRects.bind(this));}</span>}</span></span>
<span class="fstat-no" title="function not covered" >_m</span>akeColorsArray(color){let colors=<span class="cstat-no" title="statement not covered" >[];</span>const normalizedColor=<span class="cstat-no" title="statement not covered" >[color[0]/255,color[1]/255,color[2]/255,color[3]];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;4;i++)</span>
<span class="cstat-no" title="statement not covered" >colors=colors.concat(normalizedColor);<span class="cstat-no" title="statement not covered" >r</span>eturn colors;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etVertexAttribute(attribute,array,length){const gl=<span class="cstat-no" title="statement not covered" >this._gl;</span>const buffer=<span class="cstat-no" title="statement not covered" >gl.createBuffer();<span class="cstat-no" title="statement not covered" ></span>gl.bindBuffer(gl.ARRAY_BUFFER,buffer);<span class="cstat-no" title="statement not covered" >g</span>l.bufferData(gl.ARRAY_BUFFER,new Float32Array(array),gl.STATIC_DRAW);<span class="cstat-no" title="statement not covered" >g</span>l.vertexAttribPointer(attribute,length,gl.FLOAT,false,0,0);}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawRectangle(vertices,mode,color,texture){const gl=<span class="cstat-no" title="statement not covered" >this._gl;</span>const white=<span class="cstat-no" title="statement not covered" >[255,255,255,1];<span class="cstat-no" title="statement not covered" ></span>color=color||white;<span class="cstat-no" title="statement not covered" >t</span>his._setVertexAttribute(this._shaderProgram.vertexPositionAttribute,vertices,3);<span class="cstat-no" title="statement not covered" >t</span>his._setVertexAttribute(this._shaderProgram.textureCoordAttribute,[0,1,1,1,1,0,0,0],2);<span class="cstat-no" title="statement not covered" >t</span>his._setVertexAttribute(this._shaderProgram.vertexColorAttribute,this._makeColorsArray(color),color.length);<span class="cstat-no" title="statement not covered" >i</span>f(texture){<span class="cstat-no" title="statement not covered" >gl.activeTexture(gl.TEXTURE0);<span class="cstat-no" title="statement not covered" >g</span>l.bindTexture(gl.TEXTURE_2D,texture);<span class="cstat-no" title="statement not covered" >g</span>l.uniform1i(this._shaderProgram.samplerUniform,0);}</span>else{<span class="cstat-no" title="statement not covered" >gl.bindTexture(gl.TEXTURE_2D,this._whiteTexture);}</span></span>
const numberOfVertices=<span class="cstat-no" title="statement not covered" >vertices.length/3;<span class="cstat-no" title="statement not covered" ></span>gl.drawArrays(mode,0,numberOfVertices);}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawTexture(vertices,texture,color){<span class="cstat-no" title="statement not covered" >this._drawRectangle(vertices,this._gl.TRIANGLE_FAN,color,texture);}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawViewportAndChrome(){const viewport=<span class="cstat-no" title="statement not covered" >this._layerTree.viewportSize();<span class="cstat-no" title="statement not covered" ></span>if(!viewport)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst drawChrome=<span class="cstat-no" title="statement not covered" >!Common.moduleSetting('frameViewerHideChromeWindow').get()&amp;&amp;this._chromeTextures.length&gt;=3&amp;&amp;this._chromeTextures.indexOf(undefined)&lt;0;</span>const z=<span class="cstat-no" title="statement not covered" >(this._maxDepth+1)*LayerViewer.Layers3DView.LayerSpacing;</span>const borderWidth=<span class="cstat-no" title="statement not covered" >Math.ceil(LayerViewer.Layers3DView.ViewportBorderWidth*this._scale);</span>let vertices=<span class="cstat-no" title="statement not covered" >[viewport.width,0,z,viewport.width,viewport.height,z,0,viewport.height,z,0,0,z];<span class="cstat-no" title="statement not covered" ></span>this._gl.lineWidth(borderWidth);<span class="cstat-no" title="statement not covered" >t</span>his._drawRectangle(vertices,drawChrome?this._gl.LINE_STRIP:this._gl.LINE_LOOP,LayerViewer.Layers3DView.ViewportBorderColor);<span class="cstat-no" title="statement not covered" >i</span>f(!drawChrome)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst borderAdjustment=<span class="cstat-no" title="statement not covered" >LayerViewer.Layers3DView.ViewportBorderWidth/2;</span>const viewportWidth=<span class="cstat-no" title="statement not covered" >this._layerTree.viewportSize().width+2*borderAdjustment;</span>const chromeHeight=<span class="cstat-no" title="statement not covered" >this._chromeTextures[0].image.naturalHeight;</span>const middleFragmentWidth=<span class="cstat-no" title="statement not covered" >viewportWidth-this._chromeTextures[0].image.naturalWidth-this._chromeTextures[2].image.naturalWidth;</span>let x=<span class="cstat-no" title="statement not covered" >-borderAdjustment;</span>const y=<span class="cstat-no" title="statement not covered" >-chromeHeight;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._chromeTextures.length;++i){const width=<span class="cstat-no" title="statement not covered" >i===LayerViewer.Layers3DView.ChromeTexture.Middle?middleFragmentWidth:this._chromeTextures[i].image.naturalWidth;<span class="cstat-no" title="statement not covered" ></span>if(width&lt;0||x+width&gt;viewportWidth)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >v</span>ertices=[x,y,z,x+width,y,z,x+width,y+chromeHeight,z,x,y+chromeHeight,z];<span class="cstat-no" title="statement not covered" >t</span>his._drawTexture(vertices,(this._chromeTextures[i]));<span class="cstat-no" title="statement not covered" >x</span>+=width;}</span>}
<span class="fstat-no" title="function not covered" >_d</span>rawViewRect(rect){const vertices=<span class="cstat-no" title="statement not covered" >rect.vertices;<span class="cstat-no" title="statement not covered" ></span>if(rect.texture)</span>
<span class="cstat-no" title="statement not covered" >this._drawTexture(vertices,rect.texture,rect.fillColor||undefined);e</span>lse <span class="cstat-no" title="statement not covered" >if(rect.fillColor)</span>
<span class="cstat-no" title="statement not covered" >this._drawRectangle(vertices,this._gl.TRIANGLE_FAN,rect.fillColor);<span class="cstat-no" title="statement not covered" >t</span>his._gl.lineWidth(rect.lineWidth);<span class="cstat-no" title="statement not covered" >i</span>f(rect.borderColor)</span>
<span class="cstat-no" title="statement not covered" >this._drawRectangle(vertices,this._gl.LINE_LOOP,rect.borderColor);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >if(!this.isShowing()){<span class="cstat-no" title="statement not covered" >this._needsUpdate=true;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!this._layerTree||!this._layerTree.root()){<span class="cstat-no" title="statement not covered" >this._failBanner.show(this.contentElement);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const gl=<span class="cstat-no" title="statement not covered" >this._initGLIfNecessary();<span class="cstat-no" title="statement not covered" ></span>if(!gl){<span class="cstat-no" title="statement not covered" >this._failBanner.element.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._failBanner.element.appendChild(this._webglDisabledBanner());<span class="cstat-no" title="statement not covered" >t</span>his._failBanner.show(this.contentElement);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._failBanner.detach();<span class="cstat-no" title="statement not covered" >t</span>his._gl.viewportWidth=this._canvasElement.width;<span class="cstat-no" title="statement not covered" >t</span>his._gl.viewportHeight=this._canvasElement.height;<span class="cstat-no" title="statement not covered" >t</span>his._calculateDepthsAndVisibility();<span class="cstat-no" title="statement not covered" >t</span>his._calculateRects();<span class="cstat-no" title="statement not covered" >t</span>his._updateTransformAndConstraints();<span class="cstat-no" title="statement not covered" >g</span>l.viewport(0,0,gl.viewportWidth,gl.viewportHeight);<span class="cstat-no" title="statement not covered" >g</span>l.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);<span class="cstat-no" title="statement not covered" >t</span>his._rects.forEach(this._drawViewRect.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._drawViewportAndChrome();}</span>
<span class="fstat-no" title="function not covered" >_w</span>ebglDisabledBanner(){const fragment=<span class="cstat-no" title="statement not covered" >this.contentElement.ownerDocument.createDocumentFragment();<span class="cstat-no" title="statement not covered" ></span>fragment.createChild('div').textContent=Common.UIString('Can\'t display layers,');<span class="cstat-no" title="statement not covered" >f</span>ragment.createChild('div').textContent=Common.UIString('WebGL support is disabled in your browser.');<span class="cstat-no" title="statement not covered" >f</span>ragment.appendChild(UI.formatLocalized('Check %s for possible reasons.',[UI.XLink.create('about:gpu')]));<span class="cstat-no" title="statement not covered" >r</span>eturn fragment;}</span>
<span class="fstat-no" title="function not covered" >_s</span>electionFromEventPoint(event){<span class="cstat-no" title="statement not covered" >if(!this._layerTree)</span>
<span class="cstat-no" title="statement not covered" >return null;l</span>et closestIntersectionPoint=<span class="cstat-no" title="statement not covered" >Infinity;</span>let closestObject=<span class="cstat-no" title="statement not covered" >null;</span>const projectionMatrix=<span class="cstat-no" title="statement not covered" >new WebKitCSSMatrix().scale(1,-1,-1).translate(-1,-1,0).multiply(this._projectionMatrix);</span>const x0=<span class="cstat-no" title="statement not covered" >(event.clientX-this._canvasElement.totalOffsetLeft())*window.devicePixelRatio;</span>const y0=<span class="cstat-no" title="statement not covered" >-(event.clientY-this._canvasElement.totalOffsetTop())*window.devicePixelRatio;</span>function <span class="fstat-no" title="function not covered" >checkIntersection(</span>rect){<span class="cstat-no" title="statement not covered" >if(!rect.relatedObject)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst t=<span class="cstat-no" title="statement not covered" >rect.intersectWithLine(projectionMatrix,x0,y0);<span class="cstat-no" title="statement not covered" ></span>if(t&lt;closestIntersectionPoint){<span class="cstat-no" title="statement not covered" >closestIntersectionPoint=t;<span class="cstat-no" title="statement not covered" >c</span>losestObject=rect.relatedObject;}</span>}</span>
<span class="cstat-no" title="statement not covered" >this._rects.forEach(checkIntersection);<span class="cstat-no" title="statement not covered" >r</span>eturn closestObject;}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateVisibilitySetting(caption,name,value,toolbar){const setting=<span class="cstat-no" title="statement not covered" >Common.settings.createSetting(name,value);<span class="cstat-no" title="statement not covered" ></span>setting.setTitle(Common.UIString(caption));<span class="cstat-no" title="statement not covered" >s</span>etting.addChangeListener(this._update,this);<span class="cstat-no" title="statement not covered" >t</span>oolbar.appendToolbarItem(new UI.ToolbarSettingCheckbox(setting));<span class="cstat-no" title="statement not covered" >r</span>eturn setting;}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitToolbar(){<span class="cstat-no" title="statement not covered" >this._panelToolbar=this._transformController.toolbar();<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.appendChild(this._panelToolbar.element);<span class="cstat-no" title="statement not covered" >t</span>his._showSlowScrollRectsSetting=this._createVisibilitySetting('Slow scroll rects','frameViewerShowSlowScrollRects',true,this._panelToolbar);<span class="cstat-no" title="statement not covered" >t</span>his._showPaintsSetting=this._createVisibilitySetting('Paints','frameViewerShowPaints',true,this._panelToolbar);<span class="cstat-no" title="statement not covered" >t</span>his._showPaintsSetting.addChangeListener(this._updatePaints,this);<span class="cstat-no" title="statement not covered" >C</span>ommon.moduleSetting('frameViewerHideChromeWindow').addChangeListener(this._update,this);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nContextMenu(event){const contextMenu=<span class="cstat-no" title="statement not covered" >new UI.ContextMenu(event);<span class="cstat-no" title="statement not covered" ></span>contextMenu.defaultSection().appendItem(Common.UIString('Reset View'),this._transformController.resetAndNotify.bind(this._transformController),false);c</span>onst selection=<span class="cstat-no" title="statement not covered" >this._selectionFromEventPoint(event);<span class="cstat-no" title="statement not covered" ></span>if(selection&amp;&amp;selection.type()===LayerViewer.LayerView.Selection.Type.Snapshot){<span class="cstat-no" title="statement not covered" >contextMenu.defaultSection().appendItem(Common.UIString('Show Paint Profiler'),this.dispatchEventToListeners.bind(this,LayerViewer.Layers3DView.Events.PaintProfilerRequested,selection),false);}</span></span>
<span class="cstat-no" title="statement not covered" >this._layerViewHost.showContextMenu(contextMenu,selection);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){<span class="cstat-no" title="statement not covered" >if(event.which)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._layerViewHost.hoverObject(this._selectionFromEventPoint(event));}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseDown(event){<span class="cstat-no" title="statement not covered" >this._mouseDownX=event.clientX;<span class="cstat-no" title="statement not covered" >t</span>his._mouseDownY=event.clientY;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseUp(event){const maxDistanceInPixels=<span class="cstat-no" title="statement not covered" >6;<span class="cstat-no" title="statement not covered" ></span>if(this._mouseDownX&amp;&amp;Math.abs(event.clientX-this._mouseDownX)&lt;maxDistanceInPixels&amp;&amp;Math.abs(event.clientY-this._mouseDownY)&lt;maxDistanceInPixels)</span>
<span class="cstat-no" title="statement not covered" >this._layerViewHost.selectObject(this._selectionFromEventPoint(event));<span class="cstat-no" title="statement not covered" >d</span>elete this._mouseDownX;<span class="cstat-no" title="statement not covered" >d</span>elete this._mouseDownY;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nDoubleClick(event){const selection=<span class="cstat-no" title="statement not covered" >this._selectionFromEventPoint(event);<span class="cstat-no" title="statement not covered" ></span>if(selection&amp;&amp;(selection.type()===LayerViewer.LayerView.Selection.Type.Snapshot||selection.layer()))</span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(LayerViewer.Layers3DView.Events.PaintProfilerRequested,selection);<span class="cstat-no" title="statement not covered" >e</span>vent.stopPropagation();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdatePaints(){<span class="cstat-no" title="statement not covered" >if(this._showPaints()){<span class="cstat-no" title="statement not covered" >this._textureManager.setLayerTree(this._layerTree);<span class="cstat-no" title="statement not covered" >t</span>his._textureManager.forceUpdate();}</span>else{<span class="cstat-no" title="statement not covered" >this._textureManager.reset();}</span></span>
<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >_s</span>howPaints(){<span class="cstat-no" title="statement not covered" >return this._showPaintsSetting.get();}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.Layers3DView.LayerStyle;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.OutlineType={Hovered:'hovered',Selected:'selected'};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.Events={PaintProfilerRequested:Symbol('PaintProfilerRequested'),ScaleChanged:Symbol('ScaleChanged')};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.ChromeTexture={Left:0,Middle:1,Right:2};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.ScrollRectTitles={RepaintsOnScroll:Common.UIString('repaints on scroll'),TouchEventHandler:Common.UIString('touch event listener'),WheelEventHandler:Common.UIString('mousewheel event listener')};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.FragmentShader=''+'precision mediump float;\n'+'varying vec4 vColor;\n'+'varying vec2 vTextureCoord;\n'+'uniform sampler2D uSampler;\n'+'void main(void)\n'+'{\n'+'    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * vColor;\n'+'}';<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.VertexShader=''+'attribute vec3 aVertexPosition;\n'+'attribute vec2 aTextureCoord;\n'+'attribute vec4 aVertexColor;\n'+'uniform mat4 uPMatrix;\n'+'varying vec2 vTextureCoord;\n'+'varying vec4 vColor;\n'+'void main(void)\n'+'{\n'+'gl_Position = uPMatrix * vec4(aVertexPosition, 1.0);\n'+'vColor = aVertexColor;\n'+'vTextureCoord = aTextureCoord;\n'+'}';<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.HoveredBorderColor=[0,0,255,1];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.SelectedBorderColor=[0,255,0,1];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.BorderColor=[0,0,0,1];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.ViewportBorderColor=[160,160,160,1];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.ScrollRectBackgroundColor=[178,100,100,0.6];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.HoveredImageMaskColor=[200,200,255,1];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.BorderWidth=1;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.SelectedBorderWidth=2;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.ViewportBorderWidth=3;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.LayerSpacing=20;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.Layers3DView.ScrollRectSpacing=4;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.LayerTextureManager=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(textureUpdatedCallback){<span class="cstat-no" title="statement not covered" >this._textureUpdatedCallback=textureUpdatedCallback;<span class="cstat-no" title="statement not covered" >t</span>his._throttler=new Common.Throttler(0);<span class="cstat-no" title="statement not covered" >t</span>his._scale=0;<span class="cstat-no" title="statement not covered" >t</span>his._active=false;<span class="cstat-no" title="statement not covered" >t</span>his.reset();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _createTextureForImage(gl,image){const texture=<span class="cstat-no" title="statement not covered" >gl.createTexture();<span class="cstat-no" title="statement not covered" ></span>texture.image=image;<span class="cstat-no" title="statement not covered" >g</span>l.bindTexture(gl.TEXTURE_2D,texture);<span class="cstat-no" title="statement not covered" >g</span>l.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,1);<span class="cstat-no" title="statement not covered" >g</span>l.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,texture.image);<span class="cstat-no" title="statement not covered" >g</span>l.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);<span class="cstat-no" title="statement not covered" >g</span>l.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);<span class="cstat-no" title="statement not covered" >g</span>l.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);<span class="cstat-no" title="statement not covered" >g</span>l.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);<span class="cstat-no" title="statement not covered" >g</span>l.bindTexture(gl.TEXTURE_2D,null);<span class="cstat-no" title="statement not covered" >r</span>eturn texture;}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >if(this._tilesByLayer)</span>
<span class="cstat-no" title="statement not covered" >this.setLayerTree(null);<span class="cstat-no" title="statement not covered" >t</span>his._tilesByLayer=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._queue=[];}</span>
<span class="fstat-no" title="function not covered" >se</span>tContext(glContext){<span class="cstat-no" title="statement not covered" >this._gl=glContext;<span class="cstat-no" title="statement not covered" >i</span>f(this._scale)</span>
<span class="cstat-no" title="statement not covered" >this._updateTextures();}</span>
<span class="fstat-no" title="function not covered" >su</span>spend(){<span class="cstat-no" title="statement not covered" >this._active=false;}</span>
<span class="fstat-no" title="function not covered" >re</span>sume(){<span class="cstat-no" title="statement not covered" >this._active=true;<span class="cstat-no" title="statement not covered" >i</span>f(this._queue.length)</span>
<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >se</span>tLayerTree(layerTree){const newLayers=<span class="cstat-no" title="statement not covered" >new Set();</span>const oldLayers=<span class="cstat-no" title="statement not covered" >Array.from(this._tilesByLayer.keys());<span class="cstat-no" title="statement not covered" ></span>if(layerTree){<span class="cstat-no" title="statement not covered" >layerTree.forEachLayer(<span class="fstat-no" title="function not covered" >la</span>yer=&gt;{<span class="cstat-no" title="statement not covered" >if(!layer.drawsContent())</span></span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span>ewLayers.add(layer);<span class="cstat-no" title="statement not covered" >i</span>f(!this._tilesByLayer.has(layer)){<span class="cstat-no" title="statement not covered" >this._tilesByLayer.set(layer,[]);<span class="cstat-no" title="statement not covered" >t</span>his.layerNeedsUpdate(layer);}</span>}</span>);}
<span class="cstat-no" title="statement not covered" >if(!oldLayers.length)</span>
<span class="cstat-no" title="statement not covered" >this.forceUpdate();<span class="cstat-no" title="statement not covered" >f</span>or(const layer of oldLayers){<span class="cstat-no" title="statement not covered" >if(newLayers.has(layer))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span>his._tilesByLayer.get(layer).forEach(<span class="fstat-no" title="function not covered" >ti</span>le=&gt;<span class="cstat-no" title="statement not covered" >tile.dispose())</span>;<span class="cstat-no" title="statement not covered" >t</span>his._tilesByLayer.delete(layer);}</span>}
<span class="fstat-no" title="function not covered" >_s</span>etSnapshotsForLayer(layer,snapshots){const oldSnapshotsToTiles=<span class="cstat-no" title="statement not covered" >new Map((this._tilesByLayer.get(layer)||[]).map(<span class="fstat-no" title="function not covered" >ti</span>le=&gt;<span class="cstat-no" title="statement not covered" >[tile.snapshot,tile])</span>);</span>const newTiles=<span class="cstat-no" title="statement not covered" >[];</span>const reusedTiles=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const snapshot of snapshots){const oldTile=<span class="cstat-no" title="statement not covered" >oldSnapshotsToTiles.get(snapshot);<span class="cstat-no" title="statement not covered" ></span>if(oldTile){<span class="cstat-no" title="statement not covered" >reusedTiles.push(oldTile);<span class="cstat-no" title="statement not covered" >o</span>ldSnapshotsToTiles.delete(oldTile);}</span>else{<span class="cstat-no" title="statement not covered" >newTiles.push(new LayerViewer.LayerTextureManager.Tile(snapshot));}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._tilesByLayer.set(layer,reusedTiles.concat(newTiles));<span class="cstat-no" title="statement not covered" >f</span>or(const tile of oldSnapshotsToTiles.values())</span>
<span class="cstat-no" title="statement not covered" >tile.dispose();<span class="cstat-no" title="statement not covered" >i</span>f(!this._gl||!this._scale)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.all(newTiles.map(<span class="fstat-no" title="function not covered" >ti</span>le=&gt;<span class="cstat-no" title="statement not covered" >tile.update(this._gl,this._scale))</span>).then(this._textureUpdatedCallback);}</span>
<span class="fstat-no" title="function not covered" >se</span>tScale(scale){<span class="cstat-no" title="statement not covered" >if(this._scale&amp;&amp;this._scale&gt;=scale)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._scale=scale;<span class="cstat-no" title="statement not covered" >t</span>his._updateTextures();}</span>
<span class="fstat-no" title="function not covered" >ti</span>lesForLayer(layer){<span class="cstat-no" title="statement not covered" >return this._tilesByLayer.get(layer)||[];}</span>
<span class="fstat-no" title="function not covered" >la</span>yerNeedsUpdate(layer){<span class="cstat-no" title="statement not covered" >if(this._queue.indexOf(layer)&lt;0)</span>
<span class="cstat-no" title="statement not covered" >this._queue.push(layer);<span class="cstat-no" title="statement not covered" >i</span>f(this._active)</span>
<span class="cstat-no" title="statement not covered" >this._throttler.schedule(this._update.bind(this));}</span>
<span class="fstat-no" title="function not covered" >fo</span>rceUpdate(){<span class="cstat-no" title="statement not covered" >this._queue.forEach(<span class="fstat-no" title="function not covered" >la</span>yer=&gt;<span class="cstat-no" title="statement not covered" >this._updateLayer(layer))</span>;<span class="cstat-no" title="statement not covered" >t</span>his._queue=[];<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){const layer=<span class="cstat-no" title="statement not covered" >this._queue.shift();<span class="cstat-no" title="statement not covered" ></span>if(!layer)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >i</span>f(this._queue.length)</span>
<span class="cstat-no" title="statement not covered" >this._throttler.schedule(this._update.bind(this));<span class="cstat-no" title="statement not covered" >r</span>eturn this._updateLayer(layer);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateLayer(layer){<span class="cstat-no" title="statement not covered" >return Promise.all(layer.snapshots()).then(<span class="fstat-no" title="function not covered" >sn</span>apshots=&gt;<span class="cstat-no" title="statement not covered" >this._setSnapshotsForLayer(layer,snapshots.filter(<span class="fstat-no" title="function not covered" >sn</span>apshot=&gt;<span class="cstat-no" title="statement not covered" >!!snapshot)</span>))</span>;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateTextures(){<span class="cstat-no" title="statement not covered" >if(!this._gl)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this._scale)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span>or(const tiles of this._tilesByLayer.values()){<span class="cstat-no" title="statement not covered" >for(const tile of tiles){const promise=<span class="cstat-no" title="statement not covered" >tile.updateScale(this._gl,this._scale);<span class="cstat-no" title="statement not covered" ></span>if(promise)</span></span></span>
<span class="cstat-no" title="statement not covered" >promise.then(this._textureUpdatedCallback);}</span>}}};<span class="cstat-no" title="statement not covered" >LayerViewer.Layers3DView.Rectangle=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(relatedObject){<span class="cstat-no" title="statement not covered" >this.relatedObject=relatedObject;<span class="cstat-no" title="statement not covered" >t</span>his.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>his.borderColor=null;<span class="cstat-no" title="statement not covered" >t</span>his.fillColor=null;<span class="cstat-no" title="statement not covered" >t</span>his.texture=null;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tVertices(quad,z){<span class="cstat-no" title="statement not covered" >this.vertices=[quad[0],quad[1],z,quad[2],quad[3],z,quad[4],quad[5],z,quad[6],quad[7],z];}</span>
<span class="fstat-no" title="function not covered" >_c</span>alculatePointOnQuad(quad,ratioX,ratioY){const x0=<span class="cstat-no" title="statement not covered" >quad[0];</span>const y0=<span class="cstat-no" title="statement not covered" >quad[1];</span>const x1=<span class="cstat-no" title="statement not covered" >quad[2];</span>const y1=<span class="cstat-no" title="statement not covered" >quad[3];</span>const x2=<span class="cstat-no" title="statement not covered" >quad[4];</span>const y2=<span class="cstat-no" title="statement not covered" >quad[5];</span>const x3=<span class="cstat-no" title="statement not covered" >quad[6];</span>const y3=<span class="cstat-no" title="statement not covered" >quad[7];</span>const firstSidePointX=<span class="cstat-no" title="statement not covered" >x0+ratioX*(x1-x0);</span>const firstSidePointY=<span class="cstat-no" title="statement not covered" >y0+ratioX*(y1-y0);</span>const thirdSidePointX=<span class="cstat-no" title="statement not covered" >x3+ratioX*(x2-x3);</span>const thirdSidePointY=<span class="cstat-no" title="statement not covered" >y3+ratioX*(y2-y3);</span>const x=<span class="cstat-no" title="statement not covered" >firstSidePointX+ratioY*(thirdSidePointX-firstSidePointX);</span>const y=<span class="cstat-no" title="statement not covered" >firstSidePointY+ratioY*(thirdSidePointY-firstSidePointY);<span class="cstat-no" title="statement not covered" ></span>return[x,y];}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculateVerticesFromRect(layer,rect,z){const quad=<span class="cstat-no" title="statement not covered" >layer.quad();</span>const rx1=<span class="cstat-no" title="statement not covered" >rect.x/layer.width();</span>const rx2=<span class="cstat-no" title="statement not covered" >(rect.x+rect.width)/layer.width();</span>const ry1=<span class="cstat-no" title="statement not covered" >rect.y/layer.height();</span>const ry2=<span class="cstat-no" title="statement not covered" >(rect.y+rect.height)/layer.height();</span>const rectQuad=<span class="cstat-no" title="statement not covered" >this._calculatePointOnQuad(quad,rx1,ry1).concat(this._calculatePointOnQuad(quad,rx2,ry1)).concat(this._calculatePointOnQuad(quad,rx2,ry2)).concat(this._calculatePointOnQuad(quad,rx1,ry2));<span class="cstat-no" title="statement not covered" ></span>this.setVertices(rectQuad,z);}</span>
<span class="fstat-no" title="function not covered" >in</span>tersectWithLine(matrix,x0,y0){let i;const points=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;4;++i){<span class="cstat-no" title="statement not covered" >points[i]=UI.Geometry.multiplyVectorByMatrixAndNormalize(new UI.Geometry.Vector(this.vertices[i*3],this.vertices[i*3+1],this.vertices[i*3+2]),matrix);}</span></span>
const normal=<span class="cstat-no" title="statement not covered" >UI.Geometry.crossProduct(UI.Geometry.subtract(points[1],points[0]),UI.Geometry.subtract(points[2],points[1]));</span>const A=<span class="cstat-no" title="statement not covered" >normal.x;</span>const B=<span class="cstat-no" title="statement not covered" >normal.y;</span>const C=<span class="cstat-no" title="statement not covered" >normal.z;</span>const D=<span class="cstat-no" title="statement not covered" >-(A*points[0].x+B*points[0].y+C*points[0].z);</span>const t=<span class="cstat-no" title="statement not covered" >-(D+A*x0+B*y0)/C;</span>const pt=<span class="cstat-no" title="statement not covered" >new UI.Geometry.Vector(x0,y0,t);</span>const tVects=<span class="cstat-no" title="statement not covered" >points.map(UI.Geometry.subtract.bind(null,pt));<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;tVects.length;++i){const product=<span class="cstat-no" title="statement not covered" >UI.Geometry.scalarProduct(normal,UI.Geometry.crossProduct(tVects[i],tVects[(i+1)%tVects.length]));<span class="cstat-no" title="statement not covered" ></span>if(product&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >return undefined;}</span>
<span class="cstat-no" title="statement not covered" >return t;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LayerTextureManager.Tile=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(snapshotWithRect){<span class="cstat-no" title="statement not covered" >this.snapshot=snapshotWithRect.snapshot;<span class="cstat-no" title="statement not covered" >t</span>his.rect=snapshotWithRect.rect;<span class="cstat-no" title="statement not covered" >t</span>his.scale=0;<span class="cstat-no" title="statement not covered" >t</span>his.texture=null;}</span></span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this.snapshot.release();<span class="cstat-no" title="statement not covered" >i</span>f(this.texture){<span class="cstat-no" title="statement not covered" >this._gl.deleteTexture(this.texture);<span class="cstat-no" title="statement not covered" >t</span>his.texture=null;}</span>}</span>
<span class="fstat-no" title="function not covered" >up</span>dateScale(glContext,scale){<span class="cstat-no" title="statement not covered" >if(this.texture&amp;&amp;this.scale&gt;=scale)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.update(glContext,scale);}</span>
<span class="fstat-no" title="function not covered" >as</span>ync update(glContext,scale){<span class="cstat-no" title="statement not covered" >this._gl=glContext;<span class="cstat-no" title="statement not covered" >t</span>his.scale=scale;c</span>onst imageURL=<span class="cstat-no" title="statement not covered" >await this.snapshot.replay(scale);</span>const image=<span class="cstat-no" title="statement not covered" >imageURL&amp;&amp;await UI.loadImage(imageURL);<span class="cstat-no" title="statement not covered" ></span>this.texture=image&amp;&amp;LayerViewer.LayerTextureManager._createTextureForImage(glContext,image);}</span>};;<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerView=class extends UI.HBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(showImageCallback){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('layer_viewer/paintProfiler.css');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.add('paint-profiler-overview');<span class="cstat-no" title="statement not covered" >t</span>his._canvasContainer=this.contentElement.createChild('div','paint-profiler-canvas-container');<span class="cstat-no" title="statement not covered" >t</span>his._progressBanner=this.contentElement.createChild('div','full-widget-dimmed-banner hidden');<span class="cstat-no" title="statement not covered" >t</span>his._progressBanner.textContent=Common.UIString('Profiling\u2026');<span class="cstat-no" title="statement not covered" >t</span>his._pieChart=new PerfUI.PieChart(55,this._formatPieChartTime.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._pieChart.element.classList.add('paint-profiler-pie-chart');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.appendChild(this._pieChart.element);<span class="cstat-no" title="statement not covered" >t</span>his._showImageCallback=showImageCallback;<span class="cstat-no" title="statement not covered" >t</span>his._canvas=this._canvasContainer.createChild('canvas','fill');<span class="cstat-no" title="statement not covered" >t</span>his._context=this._canvas.getContext('2d');<span class="cstat-no" title="statement not covered" >t</span>his._selectionWindow=new PerfUI.OverviewGrid.Window(this._canvasContainer);<span class="cstat-no" title="statement not covered" >t</span>his._selectionWindow.addEventListener(PerfUI.OverviewGrid.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._innerBarWidth=4*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._minBarHeight=window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._barPaddingWidth=2*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._outerBarWidth=this._innerBarWidth+this._barPaddingWidth;<span class="cstat-no" title="statement not covered" >t</span>his._pendingScale=1;<span class="cstat-no" title="statement not covered" >t</span>his._scale=this._pendingScale;<span class="cstat-no" title="statement not covered" >t</span>his._reset();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic categories(){<span class="cstat-no" title="statement not covered" >if(LayerViewer.PaintProfilerView._categories)</span>
<span class="cstat-no" title="statement not covered" >return LayerViewer.PaintProfilerView._categories;<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.PaintProfilerView._categories={shapes:new LayerViewer.PaintProfilerCategory('shapes',Common.UIString('Shapes'),'rgb(255, 161, 129)'),bitmap:new LayerViewer.PaintProfilerCategory('bitmap',Common.UIString('Bitmap'),'rgb(136, 196, 255)'),text:new LayerViewer.PaintProfilerCategory('text',Common.UIString('Text'),'rgb(180, 255, 137)'),misc:new LayerViewer.PaintProfilerCategory('misc',Common.UIString('Misc'),'rgb(206, 160, 255)')};<span class="cstat-no" title="statement not covered" >r</span>eturn LayerViewer.PaintProfilerView._categories;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _initLogItemCategories(){<span class="cstat-no" title="statement not covered" >if(LayerViewer.PaintProfilerView._logItemCategoriesMap)</span>
<span class="cstat-no" title="statement not covered" >return LayerViewer.PaintProfilerView._logItemCategoriesMap;c</span>onst categories=<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerView.categories();</span>const logItemCategories=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>logItemCategories['Clear']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawPaint']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawData']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['SetMatrix']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['PushCull']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['PopCull']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['Translate']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['Scale']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['Concat']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['Restore']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['SaveLayer']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['Save']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['BeginCommentGroup']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['AddComment']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['EndCommentGroup']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['ClipRect']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['ClipRRect']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['ClipPath']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['ClipRegion']=categories['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawPoints']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawRect']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawOval']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawRRect']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawPath']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawVertices']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawDRRect']=categories['shapes'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawBitmap']=categories['bitmap'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawBitmapRectToRect']=categories['bitmap'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawBitmapMatrix']=categories['bitmap'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawBitmapNine']=categories['bitmap'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawSprite']=categories['bitmap'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawPicture']=categories['bitmap'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawText']=categories['text'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawPosText']=categories['text'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawPosTextH']=categories['text'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories['DrawTextOnPath']=categories['text'];<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.PaintProfilerView._logItemCategoriesMap=logItemCategories;<span class="cstat-no" title="statement not covered" >r</span>eturn logItemCategories;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _categoryForLogItem(logItem){const method=<span class="cstat-no" title="statement not covered" >logItem.method.toTitleCase();</span>const logItemCategories=<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerView._initLogItemCategories();</span>let result=<span class="cstat-no" title="statement not covered" >logItemCategories[method];<span class="cstat-no" title="statement not covered" ></span>if(!result){<span class="cstat-no" title="statement not covered" >result=LayerViewer.PaintProfilerView.categories()['misc'];<span class="cstat-no" title="statement not covered" >l</span>ogItemCategories[method]=result;}</span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >as</span>ync setSnapshotAndLog(snapshot,log,clipRect){<span class="cstat-no" title="statement not covered" >this._reset();<span class="cstat-no" title="statement not covered" >t</span>his._snapshot=snapshot;<span class="cstat-no" title="statement not covered" >i</span>f(this._snapshot)</span>
<span class="cstat-no" title="statement not covered" >this._snapshot.addReference();<span class="cstat-no" title="statement not covered" >t</span>his._log=log;<span class="cstat-no" title="statement not covered" >t</span>his._logCategories=this._log.map(LayerViewer.PaintProfilerView._categoryForLogItem);<span class="cstat-no" title="statement not covered" >i</span>f(!this._snapshot){<span class="cstat-no" title="statement not covered" >this._update();<span class="cstat-no" title="statement not covered" >t</span>his._pieChart.setTotal(0);<span class="cstat-no" title="statement not covered" >t</span>his._selectionWindow.setEnabled(false);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._selectionWindow.setEnabled(true);<span class="cstat-no" title="statement not covered" >t</span>his._progressBanner.classList.remove('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._updateImage();c</span>onst profiles=<span class="cstat-no" title="statement not covered" >await snapshot.profile(clipRect);<span class="cstat-no" title="statement not covered" ></span>this._progressBanner.classList.add('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._profiles=profiles;<span class="cstat-no" title="statement not covered" >t</span>his._update();<span class="cstat-no" title="statement not covered" >t</span>his._updatePieChart();}</span>
<span class="fstat-no" title="function not covered" >se</span>tScale(scale){const needsUpdate=<span class="cstat-no" title="statement not covered" >scale&gt;this._scale;</span>const predictiveGrowthFactor=<span class="cstat-no" title="statement not covered" >2;<span class="cstat-no" title="statement not covered" ></span>this._pendingScale=Math.min(1,scale*predictiveGrowthFactor);<span class="cstat-no" title="statement not covered" >i</span>f(needsUpdate&amp;&amp;this._snapshot)</span>
<span class="cstat-no" title="statement not covered" >this._updateImage();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >this._canvas.width=this._canvasContainer.clientWidth*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._canvas.height=this._canvasContainer.clientHeight*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._samplesPerBar=0;<span class="cstat-no" title="statement not covered" >i</span>f(!this._profiles||!this._profiles.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst maxBars=<span class="cstat-no" title="statement not covered" >Math.floor((this._canvas.width-2*this._barPaddingWidth)/this._outerBarWidth);</span>const sampleCount=<span class="cstat-no" title="statement not covered" >this._log.length;<span class="cstat-no" title="statement not covered" ></span>this._samplesPerBar=Math.ceil(sampleCount/maxBars);l</span>et maxBarTime=<span class="cstat-no" title="statement not covered" >0;</span>const barTimes=<span class="cstat-no" title="statement not covered" >[];</span>const barHeightByCategory=<span class="cstat-no" title="statement not covered" >[];</span>let heightByCategory=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0,lastBarIndex=0,lastBarTime=0;i&lt;sampleCount;){let categoryName=<span class="cstat-no" title="statement not covered" >(this._logCategories[i]&amp;&amp;this._logCategories[i].name)||'misc';</span>const sampleIndex=<span class="cstat-no" title="statement not covered" >this._log[i].commandIndex;<span class="cstat-no" title="statement not covered" ></span>for(let row=0;row&lt;this._profiles.length;row++){const sample=<span class="cstat-no" title="statement not covered" >this._profiles[row][sampleIndex];<span class="cstat-no" title="statement not covered" ></span>lastBarTime+=sample;<span class="cstat-no" title="statement not covered" >h</span>eightByCategory[categoryName]=(heightByCategory[categoryName]||0)+sample;}</span></span></span>
<span class="cstat-no" title="statement not covered" >++i;<span class="cstat-no" title="statement not covered" >i</span>f(i-lastBarIndex===this._samplesPerBar||i===sampleCount){const factor=<span class="cstat-no" title="statement not covered" >this._profiles.length*(i-lastBarIndex);<span class="cstat-no" title="statement not covered" ></span>lastBarTime/=factor;<span class="cstat-no" title="statement not covered" >f</span>or(categoryName in heightByCategory)</span></span>
<span class="cstat-no" title="statement not covered" >heightByCategory[categoryName]/=factor;<span class="cstat-no" title="statement not covered" >b</span>arTimes.push(lastBarTime);<span class="cstat-no" title="statement not covered" >b</span>arHeightByCategory.push(heightByCategory);<span class="cstat-no" title="statement not covered" >i</span>f(lastBarTime&gt;maxBarTime)</span>
<span class="cstat-no" title="statement not covered" >maxBarTime=lastBarTime;<span class="cstat-no" title="statement not covered" >l</span>astBarTime=0;<span class="cstat-no" title="statement not covered" >h</span>eightByCategory={};<span class="cstat-no" title="statement not covered" >l</span>astBarIndex=i;}</span>}
const paddingHeight=<span class="cstat-no" title="statement not covered" >4*window.devicePixelRatio;</span>const scale=<span class="cstat-no" title="statement not covered" >(this._canvas.height-paddingHeight-this._minBarHeight)/maxBarTime;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;barTimes.length;++i){<span class="cstat-no" title="statement not covered" >for(const categoryName in barHeightByCategory[i])</span></span>
<span class="cstat-no" title="statement not covered" >barHeightByCategory[i][categoryName]*=(barTimes[i]*scale+this._minBarHeight)/barTimes[i];<span class="cstat-no" title="statement not covered" >t</span>his._renderBar(i,barHeightByCategory[i]);}</span>}
<span class="fstat-no" title="function not covered" >_r</span>enderBar(index,heightByCategory){const categories=<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerView.categories();</span>let currentHeight=<span class="cstat-no" title="statement not covered" >0;</span>const x=<span class="cstat-no" title="statement not covered" >this._barPaddingWidth+index*this._outerBarWidth;<span class="cstat-no" title="statement not covered" ></span>for(const categoryName in categories){<span class="cstat-no" title="statement not covered" >if(!heightByCategory[categoryName])</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >c</span>urrentHeight+=heightByCategory[categoryName];c</span>onst y=<span class="cstat-no" title="statement not covered" >this._canvas.height-currentHeight;<span class="cstat-no" title="statement not covered" ></span>this._context.fillStyle=categories[categoryName].color;<span class="cstat-no" title="statement not covered" >t</span>his._context.fillRect(x,y,this._innerBarWidth,heightByCategory[categoryName]);}</span>}
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(LayerViewer.PaintProfilerView.Events.WindowChanged);<span class="cstat-no" title="statement not covered" >t</span>his._updatePieChart();<span class="cstat-no" title="statement not covered" >i</span>f(this._updateImageTimer)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updateImageTimer=setTimeout(this._updateImage.bind(this),100);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdatePieChart(){const window=<span class="cstat-no" title="statement not covered" >this.selectionWindow();<span class="cstat-no" title="statement not covered" ></span>if(!this._profiles||!this._profiles.length||!window)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et totalTime=<span class="cstat-no" title="statement not covered" >0;</span>const timeByCategory=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=window.left;i&lt;window.right;++i){const logEntry=<span class="cstat-no" title="statement not covered" >this._log[i];</span>const category=<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerView._categoryForLogItem(logEntry);<span class="cstat-no" title="statement not covered" ></span>timeByCategory[category.color]=timeByCategory[category.color]||0;<span class="cstat-no" title="statement not covered" >f</span>or(let j=0;j&lt;this._profiles.length;++j){const time=<span class="cstat-no" title="statement not covered" >this._profiles[j][logEntry.commandIndex];<span class="cstat-no" title="statement not covered" ></span>totalTime+=time;<span class="cstat-no" title="statement not covered" >t</span>imeByCategory[category.color]+=time;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this._pieChart.setTotal(totalTime/this._profiles.length);<span class="cstat-no" title="statement not covered" >f</span>or(const color in timeByCategory)</span>
<span class="cstat-no" title="statement not covered" >this._pieChart.addSlice(timeByCategory[color]/this._profiles.length,color);}</span>
<span class="fstat-no" title="function not covered" >_f</span>ormatPieChartTime(value){<span class="cstat-no" title="statement not covered" >return Number.millisToString(value*1000,true);}</span>
<span class="fstat-no" title="function not covered" >se</span>lectionWindow(){<span class="cstat-no" title="statement not covered" >if(!this._log)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst screenLeft=<span class="cstat-no" title="statement not covered" >this._selectionWindow.windowLeft*this._canvas.width;</span>const screenRight=<span class="cstat-no" title="statement not covered" >this._selectionWindow.windowRight*this._canvas.width;</span>const barLeft=<span class="cstat-no" title="statement not covered" >Math.floor(screenLeft/this._outerBarWidth);</span>const barRight=<span class="cstat-no" title="statement not covered" >Math.floor((screenRight+this._innerBarWidth-this._barPaddingWidth/2)/this._outerBarWidth);</span>const stepLeft=<span class="cstat-no" title="statement not covered" >Number.constrain(barLeft*this._samplesPerBar,0,this._log.length-1);</span>const stepRight=<span class="cstat-no" title="statement not covered" >Number.constrain(barRight*this._samplesPerBar,0,this._log.length);<span class="cstat-no" title="statement not covered" ></span>return{left:stepLeft,right:stepRight};}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateImage(){<span class="cstat-no" title="statement not covered" >delete this._updateImageTimer;l</span>et left;let right;const window=<span class="cstat-no" title="statement not covered" >this.selectionWindow();<span class="cstat-no" title="statement not covered" ></span>if(this._profiles&amp;&amp;this._profiles.length&amp;&amp;window){<span class="cstat-no" title="statement not covered" >left=this._log[window.left].commandIndex;<span class="cstat-no" title="statement not covered" >r</span>ight=this._log[window.right-1].commandIndex;}</span></span>
const scale=<span class="cstat-no" title="statement not covered" >this._pendingScale;<span class="cstat-no" title="statement not covered" ></span>this._snapshot.replay(scale,left,right).then(<span class="fstat-no" title="function not covered" >im</span>age=&gt;{<span class="cstat-no" title="statement not covered" >if(!image)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._scale=scale;<span class="cstat-no" title="statement not covered" >t</span>his._showImageCallback(image);}</span>);}
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >if(this._snapshot)</span>
<span class="cstat-no" title="statement not covered" >this._snapshot.release();<span class="cstat-no" title="statement not covered" >t</span>his._snapshot=null;<span class="cstat-no" title="statement not covered" >t</span>his._profiles=null;<span class="cstat-no" title="statement not covered" >t</span>his._selectionWindow.reset();<span class="cstat-no" title="statement not covered" >t</span>his._selectionWindow.setEnabled(false);}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerView.Events={WindowChanged:Symbol('WindowChanged')};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.PaintProfilerCommandLogView=class extends UI.ThrottledWidget{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.setMinimumSize(100,25);<span class="cstat-no" title="statement not covered" >t</span>his.element.classList.add('overflow-auto');<span class="cstat-no" title="statement not covered" >t</span>his._treeOutline=new UI.TreeOutlineInShadow();<span class="cstat-no" title="statement not covered" >t</span>his.element.appendChild(this._treeOutline.element);<span class="cstat-no" title="statement not covered" >t</span>his._log=[];}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tCommandLog(log){<span class="cstat-no" title="statement not covered" >this._log=log;<span class="cstat-no" title="statement not covered" >t</span>his._treeItemCache=new Map();<span class="cstat-no" title="statement not covered" >t</span>his.updateWindow({left:0,right:this._log.length});}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendLogItem(logItem){let treeElement=<span class="cstat-no" title="statement not covered" >this._treeItemCache.get(logItem);<span class="cstat-no" title="statement not covered" ></span>if(!treeElement){<span class="cstat-no" title="statement not covered" >treeElement=new LayerViewer.LogTreeElement(this,logItem);<span class="cstat-no" title="statement not covered" >t</span>his._treeItemCache.set(logItem,treeElement);}</span>else <span class="cstat-no" title="statement not covered" >if(treeElement.parent){<span class="cstat-no" title="statement not covered" >return;}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._treeOutline.appendChild(treeElement);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateWindow(selectionWindow){<span class="cstat-no" title="statement not covered" >this._selectionWindow=selectionWindow;<span class="cstat-no" title="statement not covered" >t</span>his.update();}</span>
<span class="fstat-no" title="function not covered" >do</span>Update(){<span class="cstat-no" title="statement not covered" >if(!this._selectionWindow||!this._log.length){<span class="cstat-no" title="statement not covered" >this._treeOutline.removeChildren();<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span></span>
const root=<span class="cstat-no" title="statement not covered" >this._treeOutline.rootElement();<span class="cstat-no" title="statement not covered" ></span>for(;;){const child=<span class="cstat-no" title="statement not covered" >root.firstChild();<span class="cstat-no" title="statement not covered" ></span>if(!child||child._logItem.commandIndex&gt;=this._selectionWindow.left)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span>oot.removeChildAtIndex(0);}</span>
<span class="cstat-no" title="statement not covered" >for(;;){const child=<span class="cstat-no" title="statement not covered" >root.lastChild();<span class="cstat-no" title="statement not covered" ></span>if(!child||child._logItem.commandIndex&lt;this._selectionWindow.right)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span>oot.removeChildAtIndex(root.children().length-1);}</span>
<span class="cstat-no" title="statement not covered" >for(let i=this._selectionWindow.left,right=this._selectionWindow.right;i&lt;right;++i)</span>
<span class="cstat-no" title="statement not covered" >this._appendLogItem(this._log[i]);<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LogTreeElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(ownerView,logItem){<span class="cstat-no" title="statement not covered" >super('',!!logItem.params);<span class="cstat-no" title="statement not covered" >t</span>his._logItem=logItem;<span class="cstat-no" title="statement not covered" >t</span>his._ownerView=ownerView;<span class="cstat-no" title="statement not covered" >t</span>his._filled=false;}</span></span>
<span class="fstat-no" title="function not covered" >on</span>attach(){<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >on</span>populate(){<span class="cstat-no" title="statement not covered" >for(const param in this._logItem.params)</span>
<span class="cstat-no" title="statement not covered" >LayerViewer.LogPropertyTreeElement._appendLogPropertyItem(this,param,this._logItem.params[param]);}</span>
<span class="fstat-no" title="function not covered" >_p</span>aramToString(param,name){<span class="cstat-no" title="statement not covered" >if(typeof param!=='object')</span>
<span class="cstat-no" title="statement not covered" >return typeof param==='string'&amp;&amp;param.length&gt;100?name:JSON.stringify(param);l</span>et str=<span class="cstat-no" title="statement not covered" >'';</span>let keyCount=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const key in param){<span class="cstat-no" title="statement not covered" >if(++keyCount&gt;4||typeof param[key]==='object'||(typeof param[key]==='string'&amp;&amp;param[key].length&gt;100))</span></span>
<span class="cstat-no" title="statement not covered" >return name;<span class="cstat-no" title="statement not covered" >i</span>f(str)</span>
<span class="cstat-no" title="statement not covered" >str+=', ';<span class="cstat-no" title="statement not covered" >s</span>tr+=param[key];}</span>
<span class="cstat-no" title="statement not covered" >return str;}</span>
<span class="fstat-no" title="function not covered" >_p</span>aramsToString(params){let str=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(const key in params){<span class="cstat-no" title="statement not covered" >if(str)</span></span>
<span class="cstat-no" title="statement not covered" >str+=', ';<span class="cstat-no" title="statement not covered" >s</span>tr+=this._paramToString(params[key],key);}</span>
<span class="cstat-no" title="statement not covered" >return str;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){const title=<span class="cstat-no" title="statement not covered" >createDocumentFragment();<span class="cstat-no" title="statement not covered" ></span>title.createTextChild(this._logItem.method+'('+this._paramsToString(this._logItem.params)+')');<span class="cstat-no" title="statement not covered" >t</span>his.title=title;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.LogPropertyTreeElement=class extends UI.TreeElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(property){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._property=property;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _appendLogPropertyItem(element,name,value){const treeElement=<span class="cstat-no" title="statement not covered" >new LayerViewer.LogPropertyTreeElement({name:name,value:value});<span class="cstat-no" title="statement not covered" ></span>element.appendChild(treeElement);<span class="cstat-no" title="statement not covered" >i</span>f(value&amp;&amp;typeof value==='object'){<span class="cstat-no" title="statement not covered" >for(const property in value)</span></span>
<span class="cstat-no" title="statement not covered" >LayerViewer.LogPropertyTreeElement._appendLogPropertyItem(treeElement,property,value[property]);}</span>}
<span class="fstat-no" title="function not covered" >on</span>attach(){const title=<span class="cstat-no" title="statement not covered" >createDocumentFragment();</span>const nameElement=<span class="cstat-no" title="statement not covered" >title.createChild('span','name');<span class="cstat-no" title="statement not covered" ></span>nameElement.textContent=this._property.name;c</span>onst separatorElement=<span class="cstat-no" title="statement not covered" >title.createChild('span','separator');<span class="cstat-no" title="statement not covered" ></span>separatorElement.textContent=': ';<span class="cstat-no" title="statement not covered" >i</span>f(this._property.value===null||typeof this._property.value!=='object'){const valueElement=<span class="cstat-no" title="statement not covered" >title.createChild('span','value');<span class="cstat-no" title="statement not covered" ></span>valueElement.textContent=JSON.stringify(this._property.value);<span class="cstat-no" title="statement not covered" >v</span>alueElement.classList.add('cm-js-'+(this._property.value===null?'null':typeof this._property.value));}</span></span>
<span class="cstat-no" title="statement not covered" >this.title=title;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.PaintProfilerCategory=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(name,title,color){<span class="cstat-no" title="statement not covered" >this.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.color=color;}</span>};;<span class="cstat-no" title="statement not covered" ></span>LayerViewer.TransformController=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(element,disableRotate){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._shortcuts={};<span class="cstat-no" title="statement not covered" >t</span>his.element=element;<span class="cstat-no" title="statement not covered" >i</span>f(this.element.tabIndex&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >this.element.tabIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._registerShortcuts();<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(element,this._onDragStart.bind(this),this._onDrag.bind(this),this._onDragEnd.bind(this),'move',null);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('keydown',this._onKeyDown.bind(this),false);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('keyup',this._onKeyUp.bind(this),false);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('mousewheel',this._onMouseWheel.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._minScale=0;<span class="cstat-no" title="statement not covered" >t</span>his._maxScale=Infinity;<span class="cstat-no" title="statement not covered" >t</span>his._controlPanelToolbar=new UI.Toolbar('transform-control-panel');<span class="cstat-no" title="statement not covered" >t</span>his._modeButtons={};<span class="cstat-no" title="statement not covered" >i</span>f(!disableRotate){const panModeButton=<span class="cstat-no" title="statement not covered" >new UI.ToolbarToggle(Common.UIString('Pan mode (X)'),'largeicon-pan');<span class="cstat-no" title="statement not covered" ></span>panModeButton.addEventListener(UI.ToolbarButton.Events.Click,this._setMode.bind(this,LayerViewer.TransformController.Modes.Pan));<span class="cstat-no" title="statement not covered" >t</span>his._modeButtons[LayerViewer.TransformController.Modes.Pan]=panModeButton;<span class="cstat-no" title="statement not covered" >t</span>his._controlPanelToolbar.appendToolbarItem(panModeButton);c</span>onst rotateModeButton=<span class="cstat-no" title="statement not covered" >new UI.ToolbarToggle(Common.UIString('Rotate mode (V)'),'largeicon-rotate');<span class="cstat-no" title="statement not covered" ></span>rotateModeButton.addEventListener(UI.ToolbarButton.Events.Click,this._setMode.bind(this,LayerViewer.TransformController.Modes.Rotate));<span class="cstat-no" title="statement not covered" >t</span>his._modeButtons[LayerViewer.TransformController.Modes.Rotate]=rotateModeButton;<span class="cstat-no" title="statement not covered" >t</span>his._controlPanelToolbar.appendToolbarItem(rotateModeButton);}</span></span>
<span class="cstat-no" title="statement not covered" >this._setMode(LayerViewer.TransformController.Modes.Pan);c</span>onst resetButton=<span class="cstat-no" title="statement not covered" >new UI.ToolbarButton(Common.UIString('Reset transform (0)'),'largeicon-center');<span class="cstat-no" title="statement not covered" ></span>resetButton.addEventListener(UI.ToolbarButton.Events.Click,this.resetAndNotify.bind(this,undefined));<span class="cstat-no" title="statement not covered" >t</span>his._controlPanelToolbar.appendToolbarItem(resetButton);<span class="cstat-no" title="statement not covered" >t</span>his._reset();}</span>
<span class="fstat-no" title="function not covered" >to</span>olbar(){<span class="cstat-no" title="statement not covered" >return this._controlPanelToolbar;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyDown(event){<span class="cstat-no" title="statement not covered" >if(event.keyCode===UI.KeyboardShortcut.Keys.Shift.code){<span class="cstat-no" title="statement not covered" >this._toggleMode();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const shortcutKey=<span class="cstat-no" title="statement not covered" >UI.KeyboardShortcut.makeKeyFromEventIgnoringModifiers(event);</span>const handler=<span class="cstat-no" title="statement not covered" >this._shortcuts[shortcutKey];<span class="cstat-no" title="statement not covered" ></span>if(handler&amp;&amp;handler(event))</span>
<span class="cstat-no" title="statement not covered" >event.consume();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyUp(event){<span class="cstat-no" title="statement not covered" >if(event.keyCode===UI.KeyboardShortcut.Keys.Shift.code)</span>
<span class="cstat-no" title="statement not covered" >this._toggleMode();}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddShortcuts(keys,handler){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;keys.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._shortcuts[keys[i].key]=handler;}</span>
<span class="fstat-no" title="function not covered" >_r</span>egisterShortcuts(){<span class="cstat-no" title="statement not covered" >this._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.ResetView,this.resetAndNotify.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.PanMode,this._setMode.bind(this,LayerViewer.TransformController.Modes.Pan));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.RotateMode,this._setMode.bind(this,LayerViewer.TransformController.Modes.Rotate));c</span>onst zoomFactor=<span class="cstat-no" title="statement not covered" >1.1;<span class="cstat-no" title="statement not covered" ></span>this._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.ZoomIn,this._onKeyboardZoom.bind(this,zoomFactor));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.ZoomOut,this._onKeyboardZoom.bind(this,1/zoomFactor));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.Up,this._onKeyboardPanOrRotate.bind(this,0,-1));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.Down,this._onKeyboardPanOrRotate.bind(this,0,1));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.Left,this._onKeyboardPanOrRotate.bind(this,-1,0));<span class="cstat-no" title="statement not covered" >t</span>his._addShortcuts(UI.ShortcutsScreen.LayersPanelShortcuts.Right,this._onKeyboardPanOrRotate.bind(this,1,0));}</span>
<span class="fstat-no" title="function not covered" >_p</span>ostChangeEvent(){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(LayerViewer.TransformController.Events.TransformChanged);}</span>
<span class="fstat-no" title="function not covered" >_r</span>eset(){<span class="cstat-no" title="statement not covered" >this._scale=1;<span class="cstat-no" title="statement not covered" >t</span>his._offsetX=0;<span class="cstat-no" title="statement not covered" >t</span>his._offsetY=0;<span class="cstat-no" title="statement not covered" >t</span>his._rotateX=0;<span class="cstat-no" title="statement not covered" >t</span>his._rotateY=0;}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleMode(){<span class="cstat-no" title="statement not covered" >this._setMode(this._mode===LayerViewer.TransformController.Modes.Pan?LayerViewer.TransformController.Modes.Rotate:LayerViewer.TransformController.Modes.Pan);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etMode(mode){<span class="cstat-no" title="statement not covered" >if(this._mode===mode)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._mode=mode;<span class="cstat-no" title="statement not covered" >t</span>his._updateModeButtons();<span class="cstat-no" title="statement not covered" >t</span>his.element.focus();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateModeButtons(){<span class="cstat-no" title="statement not covered" >for(const mode in this._modeButtons)</span>
<span class="cstat-no" title="statement not covered" >this._modeButtons[mode].setToggled(mode===this._mode);}</span>
<span class="fstat-no" title="function not covered" >re</span>setAndNotify(event){<span class="cstat-no" title="statement not covered" >this._reset();<span class="cstat-no" title="statement not covered" >t</span>his._postChangeEvent();<span class="cstat-no" title="statement not covered" >i</span>f(event)</span>
<span class="cstat-no" title="statement not covered" >event.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.element.focus();}</span>
<span class="fstat-no" title="function not covered" >se</span>tScaleConstraints(minScale,maxScale){<span class="cstat-no" title="statement not covered" >this._minScale=minScale;<span class="cstat-no" title="statement not covered" >t</span>his._maxScale=maxScale;<span class="cstat-no" title="statement not covered" >t</span>his._scale=Number.constrain(this._scale,minScale,maxScale);}</span>
<span class="fstat-no" title="function not covered" >cl</span>ampOffsets(minX,maxX,minY,maxY){<span class="cstat-no" title="statement not covered" >this._offsetX=Number.constrain(this._offsetX,minX,maxX);<span class="cstat-no" title="statement not covered" >t</span>his._offsetY=Number.constrain(this._offsetY,minY,maxY);}</span>
<span class="fstat-no" title="function not covered" >sc</span>ale(){<span class="cstat-no" title="statement not covered" >return this._scale;}</span>
<span class="fstat-no" title="function not covered" >of</span>fsetX(){<span class="cstat-no" title="statement not covered" >return this._offsetX;}</span>
<span class="fstat-no" title="function not covered" >of</span>fsetY(){<span class="cstat-no" title="statement not covered" >return this._offsetY;}</span>
<span class="fstat-no" title="function not covered" >ro</span>tateX(){<span class="cstat-no" title="statement not covered" >return this._rotateX;}</span>
<span class="fstat-no" title="function not covered" >ro</span>tateY(){<span class="cstat-no" title="statement not covered" >return this._rotateY;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nScale(scaleFactor,x,y){<span class="cstat-no" title="statement not covered" >scaleFactor=Number.constrain(this._scale*scaleFactor,this._minScale,this._maxScale)/this._scale;<span class="cstat-no" title="statement not covered" >t</span>his._scale*=scaleFactor;<span class="cstat-no" title="statement not covered" >t</span>his._offsetX-=(x-this._offsetX)*(scaleFactor-1);<span class="cstat-no" title="statement not covered" >t</span>his._offsetY-=(y-this._offsetY)*(scaleFactor-1);<span class="cstat-no" title="statement not covered" >t</span>his._postChangeEvent();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nPan(offsetX,offsetY){<span class="cstat-no" title="statement not covered" >this._offsetX+=offsetX;<span class="cstat-no" title="statement not covered" >t</span>his._offsetY+=offsetY;<span class="cstat-no" title="statement not covered" >t</span>his._postChangeEvent();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nRotate(rotateX,rotateY){<span class="cstat-no" title="statement not covered" >this._rotateX=rotateX;<span class="cstat-no" title="statement not covered" >t</span>his._rotateY=rotateY;<span class="cstat-no" title="statement not covered" >t</span>his._postChangeEvent();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyboardZoom(zoomFactor){<span class="cstat-no" title="statement not covered" >this._onScale(zoomFactor,this.element.clientWidth/2,this.element.clientHeight/2);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyboardPanOrRotate(xMultiplier,yMultiplier){const panStepInPixels=<span class="cstat-no" title="statement not covered" >6;</span>const rotateStepInDegrees=<span class="cstat-no" title="statement not covered" >5;<span class="cstat-no" title="statement not covered" ></span>if(this._mode===LayerViewer.TransformController.Modes.Rotate){<span class="cstat-no" title="statement not covered" >this._onRotate(this._rotateX+yMultiplier*rotateStepInDegrees,this._rotateY+xMultiplier*rotateStepInDegrees);}</span>else{<span class="cstat-no" title="statement not covered" >this._onPan(xMultiplier*panStepInPixels,yMultiplier*panStepInPixels);}</span>}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseWheel(event){const zoomFactor=<span class="cstat-no" title="statement not covered" >1.1;</span>const mouseWheelZoomSpeed=<span class="cstat-no" title="statement not covered" >1/120;</span>const scaleFactor=<span class="cstat-no" title="statement not covered" >Math.pow(zoomFactor,event.wheelDeltaY*mouseWheelZoomSpeed);<span class="cstat-no" title="statement not covered" ></span>this._onScale(scaleFactor,event.clientX-this.element.totalOffsetLeft(),event.clientY-this.element.totalOffsetTop());}</span>
<span class="fstat-no" title="function not covered" >_o</span>nDrag(event){<span class="cstat-no" title="statement not covered" >if(this._mode===LayerViewer.TransformController.Modes.Rotate){<span class="cstat-no" title="statement not covered" >this._onRotate(this._oldRotateX+(this._originY-event.clientY)/this.element.clientHeight*180,this._oldRotateY-(this._originX-event.clientX)/this.element.clientWidth*180);}</span>else{<span class="cstat-no" title="statement not covered" >this._onPan(event.clientX-this._originX,event.clientY-this._originY);<span class="cstat-no" title="statement not covered" >t</span>his._originX=event.clientX;<span class="cstat-no" title="statement not covered" >t</span>his._originY=event.clientY;}</span>}</span>
<span class="fstat-no" title="function not covered" >_o</span>nDragStart(event){<span class="cstat-no" title="statement not covered" >this.element.focus();<span class="cstat-no" title="statement not covered" >t</span>his._originX=event.clientX;<span class="cstat-no" title="statement not covered" >t</span>his._originY=event.clientY;<span class="cstat-no" title="statement not covered" >t</span>his._oldRotateX=this._rotateX;<span class="cstat-no" title="statement not covered" >t</span>his._oldRotateY=this._rotateY;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nDragEnd(){<span class="cstat-no" title="statement not covered" >delete this._originX;<span class="cstat-no" title="statement not covered" >d</span>elete this._originY;<span class="cstat-no" title="statement not covered" >d</span>elete this._oldRotateX;<span class="cstat-no" title="statement not covered" >d</span>elete this._oldRotateY;}</span>};<span class="cstat-no" title="statement not covered" >LayerViewer.TransformController.Events={TransformChanged:Symbol('TransformChanged')};<span class="cstat-no" title="statement not covered" >L</span>ayerViewer.TransformController.Modes={Pan:'Pan',Rotate:'Rotate',};;<span class="cstat-no" title="statement not covered" ></span>Runtime.cachedResources["layer_viewer/layers3DView.css"]="/*\n * Copyright 2016 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.layers-3d-view {\n    overflow: hidden;\n    -webkit-user-select: none;\n}\n\n.toolbar {\n    background-color: var(--toolbar-bg-color);\n    border-bottom: var(--divider-border);\n}\n\ncanvas {\n    flex: 1 1;\n}\n\n/*# sourceURL=layer_viewer/layers3DView.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["layer_viewer/paintProfiler.css"]="/*\n * Copyright 2016 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.paint-profiler-overview {\n    background-color: #eee;\n}\n\n.paint-profiler-canvas-container {\n    flex: auto;\n    position: relative;\n}\n\n.paint-profiler-pie-chart {\n    width: 60px !important;\n    height: 60px !important;\n    padding: 2px;\n    overflow: hidden;\n    font-size: 10px;\n}\n\n.paint-profiler-canvas-container canvas {\n    z-index: 200;\n    background-color: white;\n    opacity: 0.95;\n    height: 100%;\n    width: 100%;\n}\n\n.paint-profiler-canvas-container .overview-grid-dividers-background,\n.paint-profiler-canvas-container .overview-grid-window {\n    bottom: 0;\n    height: auto;\n}\n\n.paint-profiler-canvas-container .overview-grid-window-resizer {\n    z-index: 2000;\n}\n\n/*# sourceURL=layer_viewer/paintProfiler.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["layer_viewer/layerDetailsView.css"]="/*\n * Copyright 2016 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\ntable td {\n    padding-left: 8px;\n}\n\ntable td:first-child {\n    font-weight: bold;\n}\n\n.scroll-rect.active {\n    background-color: rgba(100, 100, 100, 0.2);\n}\n\nul {\n    list-style: none;\n    padding-inline-start: 0;\n    margin-block-start: 0;\n    margin-block-end: 0;\n}\n\na {\n    padding: 8px;\n    display: block;\n}\n\n/*# sourceURL=layer_viewer/layerDetailsView.css */";</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:03:43 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
