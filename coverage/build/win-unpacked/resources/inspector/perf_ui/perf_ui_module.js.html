<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/win-unpacked/resources/inspector/perf_ui/perf_ui_module.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../../index.html">All files</a> / <a href="index.html">build/win-unpacked/resources/inspector/perf_ui</a> perf_ui_module.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/2006</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/707</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/289</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/486</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >PerfUI.ChartViewportDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>erfUI.ChartViewportDelegate.prototype={windowChanged(startTime,endTime,animate){},updateRangeSelection(startTime,endTime){},setSize(width,height){},update(){}};<span class="cstat-no" title="statement not covered" >P</span>erfUI.ChartViewport=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(delegate){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('perf_ui/chartViewport.css');<span class="cstat-no" title="statement not covered" >t</span>his._delegate=delegate;<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement=this.contentElement.createChild('div','fill');<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement.addEventListener('mousemove',this._updateCursorPosition.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement.addEventListener('mouseout',this._onMouseOut.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement.addEventListener('mousewheel',this._onMouseWheel.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement.addEventListener('keydown',this._onChartKeyDown.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement.addEventListener('keyup',this._onChartKeyUp.bind(this),false);<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(this.viewportElement,this._startDragging.bind(this),this._dragging.bind(this),this._endDragging.bind(this),'-webkit-grabbing',null);<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(this.viewportElement,this._startRangeSelection.bind(this),this._rangeSelectionDragging.bind(this),this._endRangeSelection.bind(this),'text',null);<span class="cstat-no" title="statement not covered" >t</span>his._alwaysShowVerticalScroll=false;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionEnabled=true;<span class="cstat-no" title="statement not covered" >t</span>his._vScrollElement=this.contentElement.createChild('div','chart-viewport-v-scroll');<span class="cstat-no" title="statement not covered" >t</span>his._vScrollContent=this._vScrollElement.createChild('div');<span class="cstat-no" title="statement not covered" >t</span>his._vScrollElement.addEventListener('scroll',this._onScroll.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._selectionOverlay=this.contentElement.createChild('div','chart-viewport-selection-overlay hidden');<span class="cstat-no" title="statement not covered" >t</span>his._selectedTimeSpanLabel=this._selectionOverlay.createChild('div','time-span');<span class="cstat-no" title="statement not covered" >t</span>his._cursorElement=this.contentElement.createChild('div','chart-cursor-element hidden');<span class="cstat-no" title="statement not covered" >t</span>his.reset();}</span></span>
<span class="fstat-no" title="function not covered" >al</span>waysShowVerticalScroll(){<span class="cstat-no" title="statement not covered" >this._alwaysShowVerticalScroll=true;<span class="cstat-no" title="statement not covered" >t</span>his._vScrollElement.classList.add('always-show-scrollbar');}</span>
<span class="fstat-no" title="function not covered" >di</span>sableRangeSelection(){<span class="cstat-no" title="statement not covered" >this._rangeSelectionEnabled=false;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionStart=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionEnd=null;<span class="cstat-no" title="statement not covered" >t</span>his._updateRangeSelectionOverlay();}</span>
<span class="fstat-no" title="function not covered" >is</span>Dragging(){<span class="cstat-no" title="statement not covered" >return this._isDragging;}</span>
<span class="fstat-no" title="function not covered" >el</span>ementsToRestoreScrollPositionsFor(){<span class="cstat-no" title="statement not covered" >return[this._vScrollElement];}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateScrollBar(){const showScroll=<span class="cstat-no" title="statement not covered" >this._alwaysShowVerticalScroll||this._totalHeight&gt;this._offsetHeight;<span class="cstat-no" title="statement not covered" ></span>if(this._vScrollElement.classList.contains('hidden')!==showScroll)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._vScrollElement.classList.toggle('hidden',!showScroll);<span class="cstat-no" title="statement not covered" >t</span>his._updateContentElementSize();}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >this._updateScrollBar();<span class="cstat-no" title="statement not covered" >t</span>his._updateContentElementSize();<span class="cstat-no" title="statement not covered" >t</span>his.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._vScrollElement.scrollTop=0;<span class="cstat-no" title="statement not covered" >t</span>his._scrollTop=0;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionStart=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionEnd=null;<span class="cstat-no" title="statement not covered" >t</span>his._isDragging=false;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartPointX=0;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartPointY=0;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartScrollTop=0;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLeftTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._visibleRightTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._offsetWidth=0;<span class="cstat-no" title="statement not covered" >t</span>his._offsetHeight=0;<span class="cstat-no" title="statement not covered" >t</span>his._totalHeight=0;<span class="cstat-no" title="statement not covered" >t</span>his._targetLeftTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._targetRightTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._updateContentElementSize();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateContentElementSize(){let offsetWidth=<span class="cstat-no" title="statement not covered" >this._vScrollElement.offsetLeft;<span class="cstat-no" title="statement not covered" ></span>if(!offsetWidth)</span>
<span class="cstat-no" title="statement not covered" >offsetWidth=this.contentElement.offsetWidth;<span class="cstat-no" title="statement not covered" >t</span>his._offsetWidth=offsetWidth;<span class="cstat-no" title="statement not covered" >t</span>his._offsetHeight=this.contentElement.offsetHeight;<span class="cstat-no" title="statement not covered" >t</span>his._delegate.setSize(this._offsetWidth,this._offsetHeight);}</span>
<span class="fstat-no" title="function not covered" >se</span>tContentHeight(totalHeight){<span class="cstat-no" title="statement not covered" >this._totalHeight=totalHeight;<span class="cstat-no" title="statement not covered" >t</span>his._vScrollContent.style.height=totalHeight+'px';<span class="cstat-no" title="statement not covered" >t</span>his._updateScrollBar();<span class="cstat-no" title="statement not covered" >i</span>f(this._scrollTop+this._offsetHeight&lt;=totalHeight)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._scrollTop=Math.max(0,totalHeight-this._offsetHeight);<span class="cstat-no" title="statement not covered" >t</span>his._vScrollElement.scrollTop=this._scrollTop;}</span>
<span class="fstat-no" title="function not covered" >se</span>tScrollOffset(offset,height){<span class="cstat-no" title="statement not covered" >height=height||0;<span class="cstat-no" title="statement not covered" >i</span>f(this._vScrollElement.scrollTop&gt;offset)</span>
<span class="cstat-no" title="statement not covered" >this._vScrollElement.scrollTop=offset;e</span>lse <span class="cstat-no" title="statement not covered" >if(this._vScrollElement.scrollTop&lt;offset-this._offsetHeight+height)</span>
<span class="cstat-no" title="statement not covered" >this._vScrollElement.scrollTop=offset-this._offsetHeight+height;}</span>
<span class="fstat-no" title="function not covered" >sc</span>rollOffset(){<span class="cstat-no" title="statement not covered" >return this._vScrollElement.scrollTop;}</span>
<span class="fstat-no" title="function not covered" >se</span>tBoundaries(zeroTime,totalTime){<span class="cstat-no" title="statement not covered" >this._minimumBoundary=zeroTime;<span class="cstat-no" title="statement not covered" >t</span>his._totalTime=totalTime;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseWheel(e){const doZoomInstead=<span class="cstat-no" title="statement not covered" >e.shiftKey^(Common.moduleSetting('flamechartMouseWheelAction').get()==='zoom');</span>const panVertically=<span class="cstat-no" title="statement not covered" >!doZoomInstead&amp;&amp;(e.wheelDeltaY||Math.abs(e.wheelDeltaX)===120);</span>const panHorizontally=<span class="cstat-no" title="statement not covered" >doZoomInstead&amp;&amp;Math.abs(e.wheelDeltaX)&gt;Math.abs(e.wheelDeltaY);<span class="cstat-no" title="statement not covered" ></span>if(panVertically){<span class="cstat-no" title="statement not covered" >this._vScrollElement.scrollTop-=(e.wheelDeltaY||e.wheelDeltaX)/120*this._offsetHeight/8;}</span>else <span class="cstat-no" title="statement not covered" >if(panHorizontally){<span class="cstat-no" title="statement not covered" >this._handlePanGesture(-e.wheelDeltaX,true);}</span>else{const mouseWheelZoomSpeed=<span class="cstat-no" title="statement not covered" >1/120;<span class="cstat-no" title="statement not covered" ></span>this._handleZoomGesture(Math.pow(1.2,-(e.wheelDeltaY||e.wheelDeltaX)*mouseWheelZoomSpeed)-1);}</span></span></span>
<span class="cstat-no" title="statement not covered" >e.consume(true);}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartDragging(event){<span class="cstat-no" title="statement not covered" >if(event.shiftKey)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his._isDragging=true;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartPointX=event.pageX;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartPointY=event.pageY;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartScrollTop=this._vScrollElement.scrollTop;<span class="cstat-no" title="statement not covered" >t</span>his.viewportElement.style.cursor='';<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_d</span>ragging(event){const pixelShift=<span class="cstat-no" title="statement not covered" >this._dragStartPointX-event.pageX;<span class="cstat-no" title="statement not covered" ></span>this._dragStartPointX=event.pageX;<span class="cstat-no" title="statement not covered" >t</span>his._handlePanGesture(pixelShift);c</span>onst pixelScroll=<span class="cstat-no" title="statement not covered" >this._dragStartPointY-event.pageY;<span class="cstat-no" title="statement not covered" ></span>this._vScrollElement.scrollTop=this._dragStartScrollTop+pixelScroll;}</span>
<span class="fstat-no" title="function not covered" >_e</span>ndDragging(){<span class="cstat-no" title="statement not covered" >this._isDragging=false;}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartRangeSelection(event){<span class="cstat-no" title="statement not covered" >if(!event.shiftKey||!this._rangeSelectionEnabled)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his._isDragging=true;<span class="cstat-no" title="statement not covered" >t</span>his._selectionOffsetShiftX=event.offsetX-event.pageX;<span class="cstat-no" title="statement not covered" >t</span>his._selectionOffsetShiftY=event.offsetY-event.pageY;<span class="cstat-no" title="statement not covered" >t</span>his._selectionStartX=event.offsetX;c</span>onst style=<span class="cstat-no" title="statement not covered" >this._selectionOverlay.style;<span class="cstat-no" title="statement not covered" ></span>style.left=this._selectionStartX+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.width='1px';<span class="cstat-no" title="statement not covered" >t</span>his._selectedTimeSpanLabel.textContent='';<span class="cstat-no" title="statement not covered" >t</span>his._selectionOverlay.classList.remove('hidden');<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_e</span>ndRangeSelection(){<span class="cstat-no" title="statement not covered" >this._isDragging=false;<span class="cstat-no" title="statement not covered" >t</span>his._selectionStartX=null;}</span>
<span class="fstat-no" title="function not covered" >hi</span>deRangeSelection(){<span class="cstat-no" title="statement not covered" >this._selectionOverlay.classList.add('hidden');<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionStart=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionEnd=null;}</span>
<span class="fstat-no" title="function not covered" >se</span>tRangeSelection(startTime,endTime){<span class="cstat-no" title="statement not covered" >if(!this._rangeSelectionEnabled)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionStart=Math.min(startTime,endTime);<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionEnd=Math.max(startTime,endTime);<span class="cstat-no" title="statement not covered" >t</span>his._updateRangeSelectionOverlay();<span class="cstat-no" title="statement not covered" >t</span>his._delegate.updateRangeSelection(this._rangeSelectionStart,this._rangeSelectionEnd);}</span>
<span class="fstat-no" title="function not covered" >on</span>Click(event){const time=<span class="cstat-no" title="statement not covered" >this.pixelToTime(event.offsetX);<span class="cstat-no" title="statement not covered" ></span>if(this._rangeSelectionStart!==null&amp;&amp;time&gt;=this._rangeSelectionStart&amp;&amp;time&lt;=this._rangeSelectionEnd)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.hideRangeSelection();}</span>
<span class="fstat-no" title="function not covered" >_r</span>angeSelectionDragging(event){const x=<span class="cstat-no" title="statement not covered" >Number.constrain(event.pageX+this._selectionOffsetShiftX,0,this._offsetWidth);</span>const start=<span class="cstat-no" title="statement not covered" >this.pixelToTime(this._selectionStartX);</span>const end=<span class="cstat-no" title="statement not covered" >this.pixelToTime(x);<span class="cstat-no" title="statement not covered" ></span>this.setRangeSelection(start,end);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateRangeSelectionOverlay(){const margin=<span class="cstat-no" title="statement not covered" >100;</span>const left=<span class="cstat-no" title="statement not covered" >Number.constrain(this.timeToPosition(this._rangeSelectionStart),-margin,this._offsetWidth+margin);</span>const right=<span class="cstat-no" title="statement not covered" >Number.constrain(this.timeToPosition(this._rangeSelectionEnd),-margin,this._offsetWidth+margin);</span>const style=<span class="cstat-no" title="statement not covered" >this._selectionOverlay.style;<span class="cstat-no" title="statement not covered" ></span>style.left=left+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.width=(right-left)+'px';c</span>onst timeSpan=<span class="cstat-no" title="statement not covered" >this._rangeSelectionEnd-this._rangeSelectionStart;<span class="cstat-no" title="statement not covered" ></span>this._selectedTimeSpanLabel.textContent=Number.preciseMillisToString(timeSpan,2);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nScroll(){<span class="cstat-no" title="statement not covered" >this._scrollTop=this._vScrollElement.scrollTop;<span class="cstat-no" title="statement not covered" >t</span>his.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseOut(){<span class="cstat-no" title="statement not covered" >this._lastMouseOffsetX=-1;<span class="cstat-no" title="statement not covered" >t</span>his._showCursor(false);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateCursorPosition(e){<span class="cstat-no" title="statement not covered" >this._showCursor(e.shiftKey);<span class="cstat-no" title="statement not covered" >t</span>his._cursorElement.style.left=e.offsetX+'px';<span class="cstat-no" title="statement not covered" >t</span>his._lastMouseOffsetX=e.offsetX;}</span>
<span class="fstat-no" title="function not covered" >pi</span>xelToTime(x){<span class="cstat-no" title="statement not covered" >return this.pixelToTimeOffset(x)+this._visibleLeftTime;}</span>
<span class="fstat-no" title="function not covered" >pi</span>xelToTimeOffset(x){<span class="cstat-no" title="statement not covered" >return x*(this._visibleRightTime-this._visibleLeftTime)/this._offsetWidth;}</span>
<span class="fstat-no" title="function not covered" >ti</span>meToPosition(time){<span class="cstat-no" title="statement not covered" >return Math.floor((time-this._visibleLeftTime)/(this._visibleRightTime-this._visibleLeftTime)*this._offsetWidth);}</span>
<span class="fstat-no" title="function not covered" >ti</span>meToPixel(){<span class="cstat-no" title="statement not covered" >return this._offsetWidth/(this._visibleRightTime-this._visibleLeftTime);}</span>
<span class="fstat-no" title="function not covered" >_s</span>howCursor(visible){<span class="cstat-no" title="statement not covered" >this._cursorElement.classList.toggle('hidden',!visible||this._isDragging);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nChartKeyDown(e){<span class="cstat-no" title="statement not covered" >this._showCursor(e.shiftKey);<span class="cstat-no" title="statement not covered" >t</span>his._handleZoomPanKeys(e);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nChartKeyUp(e){<span class="cstat-no" title="statement not covered" >this._showCursor(e.shiftKey);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleZoomPanKeys(e){<span class="cstat-no" title="statement not covered" >if(!UI.KeyboardShortcut.hasNoModifiers(e))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst zoomFactor=<span class="cstat-no" title="statement not covered" >e.shiftKey?0.8:0.3;</span>const panOffset=<span class="cstat-no" title="statement not covered" >e.shiftKey?320:160;<span class="cstat-no" title="statement not covered" ></span>switch(e.code){case'KeyA':<span class="cstat-no" title="statement not covered" >this._handlePanGesture(-panOffset,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'KeyD':<span class="cstat-no" title="statement not covered" >this._handlePanGesture(panOffset,true);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'KeyW':<span class="cstat-no" title="statement not covered" >this._handleZoomGesture(-zoomFactor);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'KeyS':<span class="cstat-no" title="statement not covered" >this._handleZoomGesture(zoomFactor);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >return;}</span></span>
<span class="cstat-no" title="statement not covered" >e.consume(true);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleZoomGesture(zoom){const bounds=<span class="cstat-no" title="statement not covered" >{left:this._targetLeftTime,right:this._targetRightTime};</span>const cursorTime=<span class="cstat-no" title="statement not covered" >this.pixelToTime(this._lastMouseOffsetX);<span class="cstat-no" title="statement not covered" ></span>bounds.left+=(bounds.left-cursorTime)*zoom;<span class="cstat-no" title="statement not covered" >b</span>ounds.right+=(bounds.right-cursorTime)*zoom;<span class="cstat-no" title="statement not covered" >t</span>his._requestWindowTimes(bounds,true);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andlePanGesture(offset,animate){const bounds=<span class="cstat-no" title="statement not covered" >{left:this._targetLeftTime,right:this._targetRightTime};</span>const timeOffset=<span class="cstat-no" title="statement not covered" >Number.constrain(this.pixelToTimeOffset(offset),this._minimumBoundary-bounds.left,this._totalTime+this._minimumBoundary-bounds.right);<span class="cstat-no" title="statement not covered" ></span>bounds.left+=timeOffset;<span class="cstat-no" title="statement not covered" >b</span>ounds.right+=timeOffset;<span class="cstat-no" title="statement not covered" >t</span>his._requestWindowTimes(bounds,!!animate);}</span>
<span class="fstat-no" title="function not covered" >_r</span>equestWindowTimes(bounds,animate){const maxBound=<span class="cstat-no" title="statement not covered" >this._minimumBoundary+this._totalTime;<span class="cstat-no" title="statement not covered" ></span>if(bounds.left&lt;this._minimumBoundary){<span class="cstat-no" title="statement not covered" >bounds.right=Math.min(bounds.right+this._minimumBoundary-bounds.left,maxBound);<span class="cstat-no" title="statement not covered" >b</span>ounds.left=this._minimumBoundary;}</span>else <span class="cstat-no" title="statement not covered" >if(bounds.right&gt;maxBound){<span class="cstat-no" title="statement not covered" >bounds.left=Math.max(bounds.left-bounds.right+maxBound,this._minimumBoundary);<span class="cstat-no" title="statement not covered" >b</span>ounds.right=maxBound;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(bounds.right-bounds.left&lt;PerfUI.FlameChart.MinimalTimeWindowMs)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._delegate.windowChanged(bounds.left,bounds.right,animate);}</span>
<span class="fstat-no" title="function not covered" >sc</span>heduleUpdate(){<span class="cstat-no" title="statement not covered" >if(this._updateTimerId||this._cancelWindowTimesAnimation)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimerId=this.element.window().requestAnimationFrame(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._updateTimerId=0;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >this._updateRangeSelectionOverlay();<span class="cstat-no" title="statement not covered" >t</span>his._delegate.update();}</span>
<span class="fstat-no" title="function not covered" >se</span>tWindowTimes(startTime,endTime,animate){<span class="cstat-no" title="statement not covered" >if(startTime===this._targetLeftTime&amp;&amp;endTime===this._targetRightTime)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!animate||this._visibleLeftTime===0||this._visibleRightTime===Infinity||(startTime===0&amp;&amp;endTime===Infinity)||(startTime===Infinity&amp;&amp;endTime===Infinity)){<span class="cstat-no" title="statement not covered" >this._targetLeftTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._targetRightTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLeftTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._visibleRightTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his.scheduleUpdate();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._cancelWindowTimesAnimation){<span class="cstat-no" title="statement not covered" >this._cancelWindowTimesAnimation();<span class="cstat-no" title="statement not covered" >t</span>his._visibleLeftTime=this._targetLeftTime;<span class="cstat-no" title="statement not covered" >t</span>his._visibleRightTime=this._targetRightTime;}</span></span>
<span class="cstat-no" title="statement not covered" >this._targetLeftTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._targetRightTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._cancelWindowTimesAnimation=UI.animateFunction(this.element.window(),animateWindowTimes.bind(this),[{from:this._visibleLeftTime,to:startTime},{from:this._visibleRightTime,to:endTime}],100,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._cancelWindowTimesAnimation=null)</span>;f</span>unction <span class="fstat-no" title="function not covered" >animateWindowTimes(</span>startTime,endTime){<span class="cstat-no" title="statement not covered" >this._visibleLeftTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._visibleRightTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>}
<span class="fstat-no" title="function not covered" >wi</span>ndowLeftTime(){<span class="cstat-no" title="statement not covered" >return this._visibleLeftTime;}</span>
<span class="fstat-no" title="function not covered" >wi</span>ndowRightTime(){<span class="cstat-no" title="statement not covered" >return this._visibleRightTime;}</span>};;<span class="cstat-no" title="statement not covered" >PerfUI.FilmStripView=class extends UI.HBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('perf_ui/filmStripView.css');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.add('film-strip-view');<span class="cstat-no" title="statement not covered" >t</span>his._statusLabel=this.contentElement.createChild('div','label');<span class="cstat-no" title="statement not covered" >t</span>his.reset();<span class="cstat-no" title="statement not covered" >t</span>his.setMode(PerfUI.FilmStripView.Modes.TimeBased);}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic _setImageData(imageElement,data){<span class="cstat-no" title="statement not covered" >if(data)</span>
<span class="cstat-no" title="statement not covered" >imageElement.src='data:image/jpg;base64,'+data;}</span>
<span class="fstat-no" title="function not covered" >se</span>tMode(mode){<span class="cstat-no" title="statement not covered" >this._mode=mode;<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.toggle('time-based',mode===PerfUI.FilmStripView.Modes.TimeBased);<span class="cstat-no" title="statement not covered" >t</span>his.update();}</span>
<span class="fstat-no" title="function not covered" >se</span>tModel(filmStripModel,zeroTime,spanTime){<span class="cstat-no" title="statement not covered" >this._model=filmStripModel;<span class="cstat-no" title="statement not covered" >t</span>his._zeroTime=zeroTime;<span class="cstat-no" title="statement not covered" >t</span>his._spanTime=spanTime;c</span>onst frames=<span class="cstat-no" title="statement not covered" >filmStripModel.frames();<span class="cstat-no" title="statement not covered" ></span>if(!frames.length){<span class="cstat-no" title="statement not covered" >this.reset();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this.update();}</span>
<span class="fstat-no" title="function not covered" >cr</span>eateFrameElement(frame){const time=<span class="cstat-no" title="statement not covered" >frame.timestamp;</span>const element=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','frame');<span class="cstat-no" title="statement not covered" ></span>element.title=Common.UIString('Doubleclick to zoom image. Click to view preceding requests.');<span class="cstat-no" title="statement not covered" >e</span>lement.createChild('div','time').textContent=Number.millisToString(time-this._zeroTime);c</span>onst imageElement=<span class="cstat-no" title="statement not covered" >element.createChild('div','thumbnail').createChild('img');<span class="cstat-no" title="statement not covered" ></span>element.addEventListener('mousedown',this._onMouseEvent.bind(this,PerfUI.FilmStripView.Events.FrameSelected,time),false);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('mouseenter',this._onMouseEvent.bind(this,PerfUI.FilmStripView.Events.FrameEnter,time),false);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('mouseout',this._onMouseEvent.bind(this,PerfUI.FilmStripView.Events.FrameExit,time),false);<span class="cstat-no" title="statement not covered" >e</span>lement.addEventListener('dblclick',this._onDoubleClick.bind(this,frame),false);<span class="cstat-no" title="statement not covered" >r</span>eturn frame.imageDataPromise().then(PerfUI.FilmStripView._setImageData.bind(null,imageElement)).then(returnElement);f</span>unction <span class="fstat-no" title="function not covered" >returnElement(</span>){<span class="cstat-no" title="statement not covered" >return element;}</span>}
<span class="fstat-no" title="function not covered" >fr</span>ameByTime(time){function <span class="fstat-no" title="function not covered" >comparator(</span>time,frame){<span class="cstat-no" title="statement not covered" >return time-frame.timestamp;}</span>
const frames=<span class="cstat-no" title="statement not covered" >this._model.frames();</span>const index=<span class="cstat-no" title="statement not covered" >Math.max(frames.upperBound(time,comparator)-1,0);<span class="cstat-no" title="statement not covered" ></span>return frames[index];}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >if(!this._model)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst frames=<span class="cstat-no" title="statement not covered" >this._model.frames();<span class="cstat-no" title="statement not covered" ></span>if(!frames.length)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._mode===PerfUI.FilmStripView.Modes.FrameBased){<span class="cstat-no" title="statement not covered" >Promise.all(frames.map(this.createFrameElement.bind(this))).then(appendElements.bind(this));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const width=<span class="cstat-no" title="statement not covered" >this.contentElement.clientWidth;</span>const scale=<span class="cstat-no" title="statement not covered" >this._spanTime/width;<span class="cstat-no" title="statement not covered" ></span>this.createFrameElement(frames[0]).then(continueWhenFrameImageLoaded.bind(this));f</span>unction <span class="fstat-no" title="function not covered" >continueWhenFrameImageLoaded(</span>element0){const frameWidth=<span class="cstat-no" title="statement not covered" >Math.ceil(UI.measurePreferredSize(element0,this.contentElement).width);<span class="cstat-no" title="statement not covered" ></span>if(!frameWidth)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let pos=frameWidth;pos&lt;width;pos+=frameWidth){const time=<span class="cstat-no" title="statement not covered" >pos*scale+this._zeroTime;<span class="cstat-no" title="statement not covered" ></span>promises.push(this.createFrameElement(this.frameByTime(time)).then(fixWidth));}</span></span>
<span class="cstat-no" title="statement not covered" >Promise.all(promises).then(appendElements.bind(this));f</span>unction <span class="fstat-no" title="function not covered" >fixWidth(</span>element){<span class="cstat-no" title="statement not covered" >element.style.width=frameWidth+'px';<span class="cstat-no" title="statement not covered" >r</span>eturn element;}</span>}
function <span class="fstat-no" title="function not covered" >appendElements(</span>elements){<span class="cstat-no" title="statement not covered" >this.contentElement.removeChildren();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;elements.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this.contentElement.appendChild(elements[i]);}</span>}
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >if(this._mode===PerfUI.FilmStripView.Modes.FrameBased)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his.update();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseEvent(eventName,timestamp){<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(eventName,timestamp);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nDoubleClick(filmStripFrame){<span class="cstat-no" title="statement not covered" >new PerfUI.FilmStripView.Dialog(filmStripFrame,this._zeroTime);}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._zeroTime=0;<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.appendChild(this._statusLabel);}</span>
<span class="fstat-no" title="function not covered" >se</span>tStatusText(text){<span class="cstat-no" title="statement not covered" >this._statusLabel.textContent=text;}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.FilmStripView.Events={FrameSelected:Symbol('FrameSelected'),FrameEnter:Symbol('FrameEnter'),FrameExit:Symbol('FrameExit'),};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FilmStripView.Modes={TimeBased:'TimeBased',FrameBased:'FrameBased'};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FilmStripView.Dialog=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(filmStripFrame,zeroTime){const prevButton=<span class="cstat-no" title="statement not covered" >UI.createTextButton('\u25C0',this._onPrevFrame.bind(this));<span class="cstat-no" title="statement not covered" ></span>prevButton.title=Common.UIString('Previous frame');c</span>onst nextButton=<span class="cstat-no" title="statement not covered" >UI.createTextButton('\u25B6',this._onNextFrame.bind(this));<span class="cstat-no" title="statement not covered" ></span>nextButton.title=Common.UIString('Next frame');<span class="cstat-no" title="statement not covered" >t</span>his._fragment=UI.Fragment.build`</span></span>
      &lt;x-widget flex=none margin=12px&gt;
        &lt;x-hbox overflow=auto border='1px solid #ddd' max-height=80vh max-width=80vw&gt;
          &lt;img $=image&gt;&lt;/img&gt;
        &lt;/x-hbox&gt;
        &lt;x-hbox x-center justify-content=center margin-top=10px&gt;
          ${prevButton}
          &lt;x-hbox $=time margin=8px&gt;&lt;/x-hbox&gt;
          ${nextButton}
        &lt;/x-hbox&gt;
      &lt;/x-widget&gt;
    `;<span class="cstat-no" title="statement not covered" >this._widget=(this._fragment.element());<span class="cstat-no" title="statement not covered" >t</span>his._widget.tabIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._widget.addEventListener('keydown',this._keyDown.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._frames=filmStripFrame.model().frames();<span class="cstat-no" title="statement not covered" >t</span>his._index=filmStripFrame.index;<span class="cstat-no" title="statement not covered" >t</span>his._zeroTime=zeroTime||filmStripFrame.model().zeroTime();<span class="cstat-no" title="statement not covered" >t</span>his._dialog=null;<span class="cstat-no" title="statement not covered" >t</span>his._render();}</span>
<span class="fstat-no" title="function not covered" >_r</span>esize(){<span class="cstat-no" title="statement not covered" >if(!this._dialog){<span class="cstat-no" title="statement not covered" >this._dialog=new UI.Dialog();<span class="cstat-no" title="statement not covered" >t</span>his._dialog.contentElement.appendChild(this._widget);<span class="cstat-no" title="statement not covered" >t</span>his._dialog.setDefaultFocusedElement(this._widget);<span class="cstat-no" title="statement not covered" >t</span>his._dialog.show();}</span></span>
<span class="cstat-no" title="statement not covered" >this._dialog.setSizeBehavior(UI.GlassPane.SizeBehavior.MeasureContent);}</span>
<span class="fstat-no" title="function not covered" >_k</span>eyDown(event){<span class="cstat-no" title="statement not covered" >switch(event.key){case'ArrowLeft':<span class="cstat-no" title="statement not covered" >if(Host.isMac()&amp;&amp;event.metaKey)</span></span>
<span class="cstat-no" title="statement not covered" >this._onFirstFrame();e</span>lse
<span class="cstat-no" title="statement not covered" >this._onPrevFrame();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'ArrowRight':<span class="cstat-no" title="statement not covered" >if(Host.isMac()&amp;&amp;event.metaKey)</span>
<span class="cstat-no" title="statement not covered" >this._onLastFrame();e</span>lse
<span class="cstat-no" title="statement not covered" >this._onNextFrame();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'Home':<span class="cstat-no" title="statement not covered" >this._onFirstFrame();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'End':<span class="cstat-no" title="statement not covered" >this._onLastFrame();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}
<span class="fstat-no" title="function not covered" >_o</span>nPrevFrame(){<span class="cstat-no" title="statement not covered" >if(this._index&gt;0)</span>
<span class="cstat-no" title="statement not covered" >--this._index;<span class="cstat-no" title="statement not covered" >t</span>his._render();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nNextFrame(){<span class="cstat-no" title="statement not covered" >if(this._index&lt;this._frames.length-1)</span>
<span class="cstat-no" title="statement not covered" >++this._index;<span class="cstat-no" title="statement not covered" >t</span>his._render();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nFirstFrame(){<span class="cstat-no" title="statement not covered" >this._index=0;<span class="cstat-no" title="statement not covered" >t</span>his._render();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nLastFrame(){<span class="cstat-no" title="statement not covered" >this._index=this._frames.length-1;<span class="cstat-no" title="statement not covered" >t</span>his._render();}</span>
<span class="fstat-no" title="function not covered" >_r</span>ender(){const frame=<span class="cstat-no" title="statement not covered" >this._frames[this._index];<span class="cstat-no" title="statement not covered" ></span>this._fragment.$('time').textContent=Number.millisToString(frame.timestamp-this._zeroTime);<span class="cstat-no" title="statement not covered" >r</span>eturn frame.imageDataPromise().then(PerfUI.FilmStripView._setImageData.bind(null,this._fragment.$('image'))).then(this._resize.bind(this));}</span>};;<span class="cstat-no" title="statement not covered" >PerfUI.FlameChartDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChartDelegate.prototype={windowChanged(startTime,endTime,animate){},updateRangeSelection(startTime,endTime){},updateSelectedGroup(flameChart,group){},};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(dataProvider,flameChartDelegate,groupExpansionSetting){<span class="cstat-no" title="statement not covered" >super(true);<span class="cstat-no" title="statement not covered" >t</span>his.registerRequiredCSS('perf_ui/flameChart.css');<span class="cstat-no" title="statement not covered" >t</span>his.contentElement.classList.add('flame-chart-main-pane');<span class="cstat-no" title="statement not covered" >t</span>his._groupExpansionSetting=groupExpansionSetting;<span class="cstat-no" title="statement not covered" >t</span>his._groupExpansionState=groupExpansionSetting&amp;&amp;groupExpansionSetting.get()||{};<span class="cstat-no" title="statement not covered" >t</span>his._flameChartDelegate=flameChartDelegate;<span class="cstat-no" title="statement not covered" >t</span>his._useWebGL=Runtime.experiments.isEnabled('timelineWebGL');<span class="cstat-no" title="statement not covered" >t</span>his._chartViewport=new PerfUI.ChartViewport(this);<span class="cstat-no" title="statement not covered" >t</span>his._chartViewport.show(this.contentElement);<span class="cstat-no" title="statement not covered" >t</span>his._dataProvider=dataProvider;<span class="cstat-no" title="statement not covered" >t</span>his._viewportElement=this._chartViewport.viewportElement;<span class="cstat-no" title="statement not covered" >i</span>f(this._useWebGL){<span class="cstat-no" title="statement not covered" >this._canvasGL=(this._viewportElement.createChild('canvas','fill'));<span class="cstat-no" title="statement not covered" >t</span>his._initWebGL();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._canvas=(this._viewportElement.createChild('canvas','fill'));<span class="cstat-no" title="statement not covered" >t</span>his._canvas.tabIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his.setDefaultFocusedElement(this._canvas);<span class="cstat-no" title="statement not covered" >t</span>his._canvas.addEventListener('mousemove',this._onMouseMove.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvas.addEventListener('mouseout',this._onMouseOut.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvas.addEventListener('click',this._onClick.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._canvas.addEventListener('keydown',this._onKeyDown.bind(this),false);<span class="cstat-no" title="statement not covered" >t</span>his._entryInfo=this._viewportElement.createChild('div','flame-chart-entry-info');<span class="cstat-no" title="statement not covered" >t</span>his._markerHighlighElement=this._viewportElement.createChild('div','flame-chart-marker-highlight-element');<span class="cstat-no" title="statement not covered" >t</span>his._highlightElement=this._viewportElement.createChild('div','flame-chart-highlight-element');<span class="cstat-no" title="statement not covered" >t</span>his._selectedElement=this._viewportElement.createChild('div','flame-chart-selected-element');<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(this._viewportElement,this._startDragging.bind(this),this._dragging.bind(this),this._endDragging.bind(this),null);<span class="cstat-no" title="statement not covered" >t</span>his._rulerEnabled=true;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionStart=0;<span class="cstat-no" title="statement not covered" >t</span>his._rangeSelectionEnd=0;<span class="cstat-no" title="statement not covered" >t</span>his._barHeight=17;<span class="cstat-no" title="statement not covered" >t</span>his._textBaseline=5;<span class="cstat-no" title="statement not covered" >t</span>his._textPadding=5;<span class="cstat-no" title="statement not covered" >t</span>his._markerRadius=6;<span class="cstat-no" title="statement not covered" >t</span>his._chartViewport.setWindowTimes(dataProvider.minimumBoundary(),dataProvider.minimumBoundary()+dataProvider.totalTime());<span class="cstat-no" title="statement not covered" >t</span>his._headerLeftPadding=6;<span class="cstat-no" title="statement not covered" >t</span>his._arrowSide=8;<span class="cstat-no" title="statement not covered" >t</span>his._expansionArrowIndent=this._headerLeftPadding+this._arrowSide/2;<span class="cstat-no" title="statement not covered" >t</span>his._headerLabelXPadding=3;<span class="cstat-no" title="statement not covered" >t</span>his._headerLabelYPadding=2;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedMarkerIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedEntryIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._selectedEntryIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._rawTimelineDataLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._textWidth=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._markerPositions=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._lastMouseOffsetX=0;<span class="cstat-no" title="statement not covered" >t</span>his._selectedGroup=-1;<span class="cstat-no" title="statement not covered" >t</span>his._selectedGroupBackroundColor=UI.themeSupport.patchColorText(PerfUI.FlameChart.Colors.SelectedGroupBackground,UI.ThemeSupport.ColorUsage.Background);<span class="cstat-no" title="statement not covered" >t</span>his._selectedGroupBorderColor=UI.themeSupport.patchColorText(PerfUI.FlameChart.Colors.SelectedGroupBorder,UI.ThemeSupport.ColorUsage.Background);}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >this.hideHighlight();}</span>
<span class="fstat-no" title="function not covered" >se</span>tBarHeight(value){<span class="cstat-no" title="statement not covered" >this._barHeight=value;}</span>
<span class="fstat-no" title="function not covered" >se</span>tTextBaseline(value){<span class="cstat-no" title="statement not covered" >this._textBaseline=value;}</span>
<span class="fstat-no" title="function not covered" >se</span>tTextPadding(value){<span class="cstat-no" title="statement not covered" >this._textPadding=value;}</span>
<span class="fstat-no" title="function not covered" >en</span>ableRuler(enable){<span class="cstat-no" title="statement not covered" >this._rulerEnabled=enable;}</span>
<span class="fstat-no" title="function not covered" >al</span>waysShowVerticalScroll(){<span class="cstat-no" title="statement not covered" >this._chartViewport.alwaysShowVerticalScroll();}</span>
<span class="fstat-no" title="function not covered" >di</span>sableRangeSelection(){<span class="cstat-no" title="statement not covered" >this._chartViewport.disableRangeSelection();}</span>
<span class="fstat-no" title="function not covered" >hi</span>ghlightEntry(entryIndex){<span class="cstat-no" title="statement not covered" >if(this._highlightedEntryIndex===entryIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this._dataProvider.entryColor(entryIndex))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedEntryIndex=entryIndex;<span class="cstat-no" title="statement not covered" >t</span>his._updateElementPosition(this._highlightElement,this._highlightedEntryIndex);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(PerfUI.FlameChart.Events.EntryHighlighted,entryIndex);}</span>
<span class="fstat-no" title="function not covered" >hi</span>deHighlight(){<span class="cstat-no" title="statement not covered" >this._entryInfo.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._highlightedEntryIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._updateElementPosition(this._highlightElement,this._highlightedEntryIndex);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(PerfUI.FlameChart.Events.EntryHighlighted,-1);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esetCanvas(){const ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;</span>const width=<span class="cstat-no" title="statement not covered" >Math.round(this._offsetWidth*ratio);</span>const height=<span class="cstat-no" title="statement not covered" >Math.round(this._offsetHeight*ratio);<span class="cstat-no" title="statement not covered" ></span>this._canvas.width=width;<span class="cstat-no" title="statement not covered" >t</span>his._canvas.height=height;<span class="cstat-no" title="statement not covered" >t</span>his._canvas.style.width=`${width / ratio}px`;<span class="cstat-no" title="statement not covered" >t</span>his._canvas.style.height=`${height / ratio}px`;<span class="cstat-no" title="statement not covered" >i</span>f(this._useWebGL){<span class="cstat-no" title="statement not covered" >this._canvasGL.width=width;<span class="cstat-no" title="statement not covered" >t</span>his._canvasGL.height=height;<span class="cstat-no" title="statement not covered" >t</span>his._canvasGL.style.width=`${width / ratio}px`;<span class="cstat-no" title="statement not covered" >t</span>his._canvasGL.style.height=`${height / ratio}px`;}</span>}</span>
<span class="fstat-no" title="function not covered" >wi</span>ndowChanged(startTime,endTime,animate){<span class="cstat-no" title="statement not covered" >this._flameChartDelegate.windowChanged(startTime,endTime,animate);}</span>
<span class="fstat-no" title="function not covered" >up</span>dateRangeSelection(startTime,endTime){<span class="cstat-no" title="statement not covered" >this._flameChartDelegate.updateRangeSelection(startTime,endTime);}</span>
<span class="fstat-no" title="function not covered" >se</span>tSize(width,height){<span class="cstat-no" title="statement not covered" >this._offsetWidth=width;<span class="cstat-no" title="statement not covered" >t</span>his._offsetHeight=height;}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartDragging(event){<span class="cstat-no" title="statement not covered" >this.hideHighlight();<span class="cstat-no" title="statement not covered" >t</span>his._maxDragOffset=0;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartX=event.pageX;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartY=event.pageY;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_d</span>ragging(event){const dx=<span class="cstat-no" title="statement not covered" >event.pageX-this._dragStartX;</span>const dy=<span class="cstat-no" title="statement not covered" >event.pageY-this._dragStartY;<span class="cstat-no" title="statement not covered" ></span>this._maxDragOffset=Math.max(this._maxDragOffset,Math.sqrt(dx*dx+dy*dy));}</span>
<span class="fstat-no" title="function not covered" >_e</span>ndDragging(event){<span class="cstat-no" title="statement not covered" >this._updateHighlight();}</span>
<span class="fstat-no" title="function not covered" >_t</span>imelineData(){<span class="cstat-no" title="statement not covered" >if(!this._dataProvider)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._dataProvider.timelineData();<span class="cstat-no" title="statement not covered" ></span>if(timelineData!==this._rawTimelineData||timelineData.entryStartTimes.length!==this._rawTimelineDataLength)</span>
<span class="cstat-no" title="statement not covered" >this._processTimelineData(timelineData);<span class="cstat-no" title="statement not covered" >r</span>eturn this._rawTimelineData;}</span>
<span class="fstat-no" title="function not covered" >_r</span>evealEntry(entryIndex){const timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timeLeft=<span class="cstat-no" title="statement not covered" >this._chartViewport.windowLeftTime();</span>const timeRight=<span class="cstat-no" title="statement not covered" >this._chartViewport.windowRightTime();</span>const entryStartTime=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes[entryIndex];</span>const entryTotalTime=<span class="cstat-no" title="statement not covered" >timelineData.entryTotalTimes[entryIndex];</span>const entryEndTime=<span class="cstat-no" title="statement not covered" >entryStartTime+entryTotalTime;</span>let minEntryTimeWindow=<span class="cstat-no" title="statement not covered" >Math.min(entryTotalTime,timeRight-timeLeft);</span>const level=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels[entryIndex];<span class="cstat-no" title="statement not covered" ></span>this._chartViewport.setScrollOffset(this._levelToOffset(level),this._levelHeight(level));c</span>onst minVisibleWidthPx=<span class="cstat-no" title="statement not covered" >30;</span>const futurePixelToTime=<span class="cstat-no" title="statement not covered" >(timeRight-timeLeft)/this._offsetWidth;<span class="cstat-no" title="statement not covered" ></span>minEntryTimeWindow=Math.max(minEntryTimeWindow,futurePixelToTime*minVisibleWidthPx);<span class="cstat-no" title="statement not covered" >i</span>f(timeLeft&gt;entryEndTime){const delta=<span class="cstat-no" title="statement not covered" >timeLeft-entryEndTime+minEntryTimeWindow;<span class="cstat-no" title="statement not covered" ></span>this.windowChanged(timeLeft-delta,timeRight-delta,true);}</span>else <span class="cstat-no" title="statement not covered" >if(timeRight&lt;entryStartTime){const delta=<span class="cstat-no" title="statement not covered" >entryStartTime-timeRight+minEntryTimeWindow;<span class="cstat-no" title="statement not covered" ></span>this.windowChanged(timeLeft+delta,timeRight+delta,true);}</span>}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tWindowTimes(startTime,endTime,animate){<span class="cstat-no" title="statement not covered" >this._chartViewport.setWindowTimes(startTime,endTime,animate);<span class="cstat-no" title="statement not covered" >t</span>his._updateHighlight();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){<span class="cstat-no" title="statement not covered" >this._lastMouseOffsetX=event.offsetX;<span class="cstat-no" title="statement not covered" >t</span>his._lastMouseOffsetY=event.offsetY;<span class="cstat-no" title="statement not covered" >i</span>f(!this._enabled())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._chartViewport.isDragging())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._coordinatesToGroupIndex(event.offsetX,event.offsetY,true)&gt;=0){<span class="cstat-no" title="statement not covered" >this.hideHighlight();<span class="cstat-no" title="statement not covered" >t</span>his._viewportElement.style.cursor='pointer';<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._updateHighlight();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateHighlight(){const entryIndex=<span class="cstat-no" title="statement not covered" >this._coordinatesToEntryIndex(this._lastMouseOffsetX,this._lastMouseOffsetY);<span class="cstat-no" title="statement not covered" ></span>if(entryIndex===-1){<span class="cstat-no" title="statement not covered" >this.hideHighlight();c</span>onst group=<span class="cstat-no" title="statement not covered" >this._coordinatesToGroupIndex(this._lastMouseOffsetX,this._lastMouseOffsetY,false);<span class="cstat-no" title="statement not covered" ></span>if(group&gt;=0&amp;&amp;this._rawTimelineData.groups[group].selectable)</span></span>
<span class="cstat-no" title="statement not covered" >this._viewportElement.style.cursor='pointer';e</span>lse
<span class="cstat-no" title="statement not covered" >this._viewportElement.style.cursor='default';<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(this._chartViewport.isDragging())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updatePopover(entryIndex);<span class="cstat-no" title="statement not covered" >t</span>his._viewportElement.style.cursor=this._dataProvider.canJumpToEntry(entryIndex)?'pointer':'default';<span class="cstat-no" title="statement not covered" >t</span>his.highlightEntry(entryIndex);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseOut(){<span class="cstat-no" title="statement not covered" >this._lastMouseOffsetX=-1;<span class="cstat-no" title="statement not covered" >t</span>his._lastMouseOffsetY=-1;<span class="cstat-no" title="statement not covered" >t</span>his.hideHighlight();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdatePopover(entryIndex){<span class="cstat-no" title="statement not covered" >if(entryIndex===this._highlightedEntryIndex){<span class="cstat-no" title="statement not covered" >this._updatePopoverOffset();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._entryInfo.removeChildren();c</span>onst popoverElement=<span class="cstat-no" title="statement not covered" >this._dataProvider.prepareHighlightedEntryInfo(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(popoverElement){<span class="cstat-no" title="statement not covered" >this._entryInfo.appendChild(popoverElement);<span class="cstat-no" title="statement not covered" >t</span>his._updatePopoverOffset();}</span>}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdatePopoverOffset(){const mouseX=<span class="cstat-no" title="statement not covered" >this._lastMouseOffsetX;</span>const mouseY=<span class="cstat-no" title="statement not covered" >this._lastMouseOffsetY;</span>const parentWidth=<span class="cstat-no" title="statement not covered" >this._entryInfo.parentElement.clientWidth;</span>const parentHeight=<span class="cstat-no" title="statement not covered" >this._entryInfo.parentElement.clientHeight;</span>const infoWidth=<span class="cstat-no" title="statement not covered" >this._entryInfo.clientWidth;</span>const infoHeight=<span class="cstat-no" title="statement not covered" >this._entryInfo.clientHeight;</span>const offsetX=<span class="cstat-no" title="statement not covered" >10;</span>const offsetY=<span class="cstat-no" title="statement not covered" >6;</span>let x;let y;<span class="cstat-no" title="statement not covered" >for(let quadrant=0;quadrant&lt;4;++quadrant){const dx=<span class="cstat-no" title="statement not covered" >quadrant&amp;2?-offsetX-infoWidth:offsetX;</span>const dy=<span class="cstat-no" title="statement not covered" >quadrant&amp;1?-offsetY-infoHeight:offsetY;<span class="cstat-no" title="statement not covered" ></span>x=Number.constrain(mouseX+dx,0,parentWidth-infoWidth);<span class="cstat-no" title="statement not covered" >y</span>=Number.constrain(mouseY+dy,0,parentHeight-infoHeight);<span class="cstat-no" title="statement not covered" >i</span>f(x&gt;=mouseX||mouseX&gt;=x+infoWidth||y&gt;=mouseY||mouseY&gt;=y+infoHeight)</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>
<span class="cstat-no" title="statement not covered" >this._entryInfo.style.left=x+'px';<span class="cstat-no" title="statement not covered" >t</span>his._entryInfo.style.top=y+'px';}</span>
<span class="fstat-no" title="function not covered" >_o</span>nClick(event){<span class="cstat-no" title="statement not covered" >this.focus();c</span>onst clickThreshold=<span class="cstat-no" title="statement not covered" >5;<span class="cstat-no" title="statement not covered" ></span>if(this._maxDragOffset&gt;clickThreshold)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._selectGroup(this._coordinatesToGroupIndex(event.offsetX,event.offsetY,false));<span class="cstat-no" title="statement not covered" >t</span>his._toggleGroupVisibility(this._coordinatesToGroupIndex(event.offsetX,event.offsetY,true));c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(event.shiftKey&amp;&amp;this._highlightedEntryIndex!==-1&amp;&amp;timelineData){const start=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes[this._highlightedEntryIndex];</span>const end=<span class="cstat-no" title="statement not covered" >start+timelineData.entryTotalTimes[this._highlightedEntryIndex];<span class="cstat-no" title="statement not covered" ></span>this._chartViewport.setRangeSelection(start,end);}</span>else{<span class="cstat-no" title="statement not covered" >this._chartViewport.onClick(event);<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(PerfUI.FlameChart.Events.EntrySelected,this._highlightedEntryIndex);}</span>}</span>
<span class="fstat-no" title="function not covered" >_s</span>electGroup(groupIndex){const groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups;<span class="cstat-no" title="statement not covered" ></span>if(groupIndex&lt;0||!groups[groupIndex].selectable||this._selectedGroup===groupIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._selectedGroup=groupIndex;<span class="cstat-no" title="statement not covered" >t</span>his._flameChartDelegate.updateSelectedGroup(this,groups[groupIndex]);<span class="cstat-no" title="statement not covered" >t</span>his._resetCanvas();<span class="cstat-no" title="statement not covered" >t</span>his._draw();}</span>
<span class="fstat-no" title="function not covered" >_t</span>oggleGroupVisibility(groupIndex){<span class="cstat-no" title="statement not covered" >if(groupIndex&lt;0||!this._isGroupCollapsible(groupIndex))</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups;</span>const group=<span class="cstat-no" title="statement not covered" >groups[groupIndex];<span class="cstat-no" title="statement not covered" ></span>group.expanded=!group.expanded;<span class="cstat-no" title="statement not covered" >t</span>his._groupExpansionState[group.name]=group.expanded;<span class="cstat-no" title="statement not covered" >i</span>f(this._groupExpansionSetting)</span>
<span class="cstat-no" title="statement not covered" >this._groupExpansionSetting.set(this._groupExpansionState);<span class="cstat-no" title="statement not covered" >t</span>his._updateLevelPositions();<span class="cstat-no" title="statement not covered" >t</span>his._updateHighlight();<span class="cstat-no" title="statement not covered" >i</span>f(!group.expanded){const timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();</span>const level=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels[this._selectedEntryIndex];<span class="cstat-no" title="statement not covered" ></span>if(this._selectedEntryIndex&gt;=0&amp;&amp;level&gt;=group.startLevel&amp;&amp;(groupIndex&gt;=groups.length-1||groups[groupIndex+1].startLevel&gt;level))</span></span>
<span class="cstat-no" title="statement not covered" >this._selectedEntryIndex=-1;}</span>
<span class="cstat-no" title="statement not covered" >this._updateHeight();<span class="cstat-no" title="statement not covered" >t</span>his._resetCanvas();<span class="cstat-no" title="statement not covered" >t</span>his._draw();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nKeyDown(e){<span class="cstat-no" title="statement not covered" >this._handleSelectionNavigation(e);}</span>
<span class="fstat-no" title="function not covered" >_h</span>andleSelectionNavigation(e){<span class="cstat-no" title="statement not covered" >if(!UI.KeyboardShortcut.hasNoModifiers(e))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(this._selectedEntryIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;f</span>unction <span class="fstat-no" title="function not covered" >timeComparator(</span>time,entryIndex){<span class="cstat-no" title="statement not covered" >return time-timelineData.entryStartTimes[entryIndex];}</span>
function <span class="fstat-no" title="function not covered" >entriesIntersect(</span>entry1,entry2){const start1=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes[entry1];</span>const start2=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes[entry2];</span>const end1=<span class="cstat-no" title="statement not covered" >start1+timelineData.entryTotalTimes[entry1];</span>const end2=<span class="cstat-no" title="statement not covered" >start2+timelineData.entryTotalTimes[entry2];<span class="cstat-no" title="statement not covered" ></span>return start1&lt;end2&amp;&amp;start2&lt;end1;}</span>
const keys=<span class="cstat-no" title="statement not covered" >UI.KeyboardShortcut.Keys;<span class="cstat-no" title="statement not covered" ></span>if(e.keyCode===keys.Left.code||e.keyCode===keys.Right.code){const level=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels[this._selectedEntryIndex];</span>const levelIndexes=<span class="cstat-no" title="statement not covered" >this._timelineLevels[level];</span>let indexOnLevel=<span class="cstat-no" title="statement not covered" >levelIndexes.lowerBound(this._selectedEntryIndex);<span class="cstat-no" title="statement not covered" ></span>indexOnLevel+=e.keyCode===keys.Left.code?-1:1;<span class="cstat-no" title="statement not covered" >e</span>.consume(true);<span class="cstat-no" title="statement not covered" >i</span>f(indexOnLevel&gt;=0&amp;&amp;indexOnLevel&lt;levelIndexes.length)</span></span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(PerfUI.FlameChart.Events.EntrySelected,levelIndexes[indexOnLevel]);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(e.keyCode===keys.Up.code||e.keyCode===keys.Down.code){<span class="cstat-no" title="statement not covered" >e.consume(true);l</span>et level=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels[this._selectedEntryIndex];<span class="cstat-no" title="statement not covered" ></span>level+=e.keyCode===keys.Up.code?-1:1;<span class="cstat-no" title="statement not covered" >i</span>f(level&lt;0||level&gt;=this._timelineLevels.length)</span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst entryTime=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes[this._selectedEntryIndex]+</span>
timelineData.entryTotalTimes[this._selectedEntryIndex]/2;const levelIndexes=<span class="cstat-no" title="statement not covered" >this._timelineLevels[level];</span>let indexOnLevel=<span class="cstat-no" title="statement not covered" >levelIndexes.upperBound(entryTime,timeComparator)-1;<span class="cstat-no" title="statement not covered" ></span>if(!entriesIntersect(this._selectedEntryIndex,levelIndexes[indexOnLevel])){<span class="cstat-no" title="statement not covered" >++indexOnLevel;<span class="cstat-no" title="statement not covered" >i</span>f(indexOnLevel&gt;=levelIndexes.length||!entriesIntersect(this._selectedEntryIndex,levelIndexes[indexOnLevel]))</span></span>
<span class="cstat-no" title="statement not covered" >return;}</span>
<span class="cstat-no" title="statement not covered" >this.dispatchEventToListeners(PerfUI.FlameChart.Events.EntrySelected,levelIndexes[indexOnLevel]);}</span>}
<span class="fstat-no" title="function not covered" >_c</span>oordinatesToEntryIndex(x,y){<span class="cstat-no" title="statement not covered" >if(x&lt;0||y&lt;0)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >y</span>+=this._chartViewport.scrollOffset();c</span>onst cursorLevel=<span class="cstat-no" title="statement not covered" >this._visibleLevelOffsets.upperBound(y)-1;<span class="cstat-no" title="statement not covered" ></span>if(cursorLevel&lt;0||!this._visibleLevels[cursorLevel])</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst offsetFromLevel=<span class="cstat-no" title="statement not covered" >y-this._visibleLevelOffsets[cursorLevel];<span class="cstat-no" title="statement not covered" ></span>if(offsetFromLevel&gt;this._levelHeight(cursorLevel))</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >f</span>or(const[index,pos]of this._markerPositions){<span class="cstat-no" title="statement not covered" >if(timelineData.entryLevels[index]!==cursorLevel)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(pos.x&lt;=x&amp;&amp;x&lt;pos.x+pos.width)</span>
<span class="cstat-no" title="statement not covered" >return(index);}</span>
const entryStartTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes;</span>const entriesOnLevel=<span class="cstat-no" title="statement not covered" >this._timelineLevels[cursorLevel];<span class="cstat-no" title="statement not covered" ></span>if(!entriesOnLevel||!entriesOnLevel.length)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst cursorTime=<span class="cstat-no" title="statement not covered" >this._chartViewport.pixelToTime(x);</span>const indexOnLevel=<span class="cstat-no" title="statement not covered" >Math.max(entriesOnLevel.upperBound(cursorTime,<span class="fstat-no" title="function not covered" >(t</span>ime,entryIndex)=&gt;<span class="cstat-no" title="statement not covered" >time-entryStartTimes[entryIndex])</span>-1,0);</span>function <span class="fstat-no" title="function not covered" >checkEntryHit(</span>entryIndex){<span class="cstat-no" title="statement not covered" >if(entryIndex===undefined)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst startTime=<span class="cstat-no" title="statement not covered" >entryStartTimes[entryIndex];</span>const duration=<span class="cstat-no" title="statement not covered" >timelineData.entryTotalTimes[entryIndex];</span>const startX=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPosition(startTime);</span>const endX=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPosition(startTime+duration);</span>const barThresholdPx=<span class="cstat-no" title="statement not covered" >3;<span class="cstat-no" title="statement not covered" ></span>return startX-barThresholdPx&lt;x&amp;&amp;x&lt;endX+barThresholdPx;}</span>
let entryIndex=<span class="cstat-no" title="statement not covered" >entriesOnLevel[indexOnLevel];<span class="cstat-no" title="statement not covered" ></span>if(checkEntryHit.call(this,entryIndex))</span>
<span class="cstat-no" title="statement not covered" >return entryIndex;<span class="cstat-no" title="statement not covered" >e</span>ntryIndex=entriesOnLevel[indexOnLevel+1];<span class="cstat-no" title="statement not covered" >i</span>f(checkEntryHit.call(this,entryIndex))</span>
<span class="cstat-no" title="statement not covered" >return entryIndex;<span class="cstat-no" title="statement not covered" >r</span>eturn-1;}</span>
<span class="fstat-no" title="function not covered" >_c</span>oordinatesToGroupIndex(x,y,headerOnly){<span class="cstat-no" title="statement not covered" >if(x&lt;0||y&lt;0)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >y</span>+=this._chartViewport.scrollOffset();c</span>onst groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];</span>const group=<span class="cstat-no" title="statement not covered" >this._groupOffsets.upperBound(y)-1;<span class="cstat-no" title="statement not covered" ></span>if(group&lt;0||group&gt;=groups.length)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst height=<span class="cstat-no" title="statement not covered" >headerOnly?groups[group].style.height:this._groupOffsets[group+1]-this._groupOffsets[group];<span class="cstat-no" title="statement not covered" ></span>if(y-this._groupOffsets[group]&gt;=height)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(!headerOnly)</span>
<span class="cstat-no" title="statement not covered" >return group;c</span>onst context=(<span class="cstat-no" title="statement not covered" >this._canvas.getContext('2d'))</span>;<span class="cstat-no" title="statement not covered" >context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.font=groups[group].style.font;c</span>onst right=<span class="cstat-no" title="statement not covered" >this._headerLeftPadding+this._labelWidthForGroup(context,groups[group]);<span class="cstat-no" title="statement not covered" ></span>context.restore();<span class="cstat-no" title="statement not covered" >i</span>f(x&gt;right)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >r</span>eturn group;}</span>
<span class="fstat-no" title="function not covered" >_m</span>arkerIndexAtPosition(x){const markers=<span class="cstat-no" title="statement not covered" >this._timelineData().markers;<span class="cstat-no" title="statement not covered" ></span>if(!markers)</span>
<span class="cstat-no" title="statement not covered" >return-1;c</span>onst accurracyOffsetPx=<span class="cstat-no" title="statement not covered" >4;</span>const time=<span class="cstat-no" title="statement not covered" >this._chartViewport.pixelToTime(x);</span>const leftTime=<span class="cstat-no" title="statement not covered" >this._chartViewport.pixelToTime(x-accurracyOffsetPx);</span>const rightTime=<span class="cstat-no" title="statement not covered" >this._chartViewport.pixelToTime(x+accurracyOffsetPx);</span>const left=<span class="cstat-no" title="statement not covered" >this._markerIndexBeforeTime(leftTime);</span>let markerIndex=<span class="cstat-no" title="statement not covered" >-1;</span>let distance=<span class="cstat-no" title="statement not covered" >Infinity;<span class="cstat-no" title="statement not covered" ></span>for(let i=left;i&lt;markers.length&amp;&amp;markers[i].startTime()&lt;rightTime;i++){const nextDistance=<span class="cstat-no" title="statement not covered" >Math.abs(markers[i].startTime()-time);<span class="cstat-no" title="statement not covered" ></span>if(nextDistance&lt;distance){<span class="cstat-no" title="statement not covered" >markerIndex=i;<span class="cstat-no" title="statement not covered" >d</span>istance=nextDistance;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return markerIndex;}</span>
<span class="fstat-no" title="function not covered" >_m</span>arkerIndexBeforeTime(time){<span class="cstat-no" title="statement not covered" >return this._timelineData().markers.lowerBound(time,<span class="fstat-no" title="function not covered" >(m</span>arkerTimestamp,marker)=&gt;<span class="cstat-no" title="statement not covered" >markerTimestamp-marker.startTime())</span>;}</span>
<span class="fstat-no" title="function not covered" >_d</span>raw(){const timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst width=<span class="cstat-no" title="statement not covered" >this._offsetWidth;</span>const height=<span class="cstat-no" title="statement not covered" >this._offsetHeight;</span>const context=(<span class="cstat-no" title="statement not covered" >this._canvas.getContext('2d'))</span>;<span class="cstat-no" title="statement not covered" >context.save();c</span>onst ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;</span>const top=<span class="cstat-no" title="statement not covered" >this._chartViewport.scrollOffset();<span class="cstat-no" title="statement not covered" ></span>context.scale(ratio,ratio);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='rgba(0, 0, 0, 0)';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,0,width,height);<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(0,-top);c</span>onst defaultFont=<span class="cstat-no" title="statement not covered" >'11px '+Host.fontFamily();<span class="cstat-no" title="statement not covered" ></span>context.font=defaultFont;c</span>onst entryTotalTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryTotalTimes;</span>const entryStartTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes;</span>const entryLevels=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels;</span>const timeToPixel=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPixel();</span>const titleIndices=<span class="cstat-no" title="statement not covered" >[];</span>const markerIndices=<span class="cstat-no" title="statement not covered" >[];</span>const textPadding=<span class="cstat-no" title="statement not covered" >this._textPadding;</span>const minTextWidth=<span class="cstat-no" title="statement not covered" >2*textPadding+UI.measureTextWidth(context,'\u2026');</span>const minTextWidthDuration=<span class="cstat-no" title="statement not covered" >this._chartViewport.pixelToTimeOffset(minTextWidth);</span>const minVisibleBarLevel=<span class="cstat-no" title="statement not covered" >Math.max(this._visibleLevelOffsets.upperBound(top)-1,0);<span class="cstat-no" title="statement not covered" ></span>this._markerPositions.clear();c</span>onst colorBuckets=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(let level=minVisibleBarLevel;level&lt;this._dataProvider.maxStackDepth();++level){<span class="cstat-no" title="statement not covered" >if(this._levelToOffset(level)&gt;top+height)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(!this._visibleLevels[level])</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst levelIndexes=<span class="cstat-no" title="statement not covered" >this._timelineLevels[level];</span>const rightIndexOnLevel=<span class="cstat-no" title="statement not covered" >levelIndexes.lowerBound(this._chartViewport.windowRightTime(),<span class="fstat-no" title="function not covered" >(t</span>ime,entryIndex)=&gt;<span class="cstat-no" title="statement not covered" >time-entryStartTimes[entryIndex])</span>-</span>
1;let lastDrawOffset=<span class="cstat-no" title="statement not covered" >Infinity;<span class="cstat-no" title="statement not covered" ></span>for(let entryIndexOnLevel=rightIndexOnLevel;entryIndexOnLevel&gt;=0;--entryIndexOnLevel){const entryIndex=<span class="cstat-no" title="statement not covered" >levelIndexes[entryIndexOnLevel];</span>const duration=<span class="cstat-no" title="statement not covered" >entryTotalTimes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(isNaN(duration)){<span class="cstat-no" title="statement not covered" >markerIndices.push(entryIndex);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(duration&gt;=minTextWidthDuration||this._forceDecorationCache[entryIndex])</span>
<span class="cstat-no" title="statement not covered" >titleIndices.push(entryIndex);c</span>onst entryStartTime=<span class="cstat-no" title="statement not covered" >entryStartTimes[entryIndex];</span>const entryOffsetRight=<span class="cstat-no" title="statement not covered" >entryStartTime+duration;<span class="cstat-no" title="statement not covered" ></span>if(entryOffsetRight&lt;=this._chartViewport.windowLeftTime())</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>f(this._useWebGL)</span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst barX=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(entryStartTime);<span class="cstat-no" title="statement not covered" ></span>if(barX&gt;=lastDrawOffset)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >l</span>astDrawOffset=barX;c</span>onst color=<span class="cstat-no" title="statement not covered" >this._entryColorsCache[entryIndex];</span>let bucket=<span class="cstat-no" title="statement not covered" >colorBuckets.get(color);<span class="cstat-no" title="statement not covered" ></span>if(!bucket){<span class="cstat-no" title="statement not covered" >bucket=[];<span class="cstat-no" title="statement not covered" >c</span>olorBuckets.set(color,bucket);}</span></span>
<span class="cstat-no" title="statement not covered" >bucket.push(entryIndex);}</span>}
<span class="cstat-no" title="statement not covered" >if(this._useWebGL){<span class="cstat-no" title="statement not covered" >this._drawGL();}</span>else{<span class="cstat-no" title="statement not covered" >context.save();<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group,isFirst,groupHeight)=&gt;{<span class="cstat-no" title="statement not covered" >if(index===this._selectedGroup){<span class="cstat-no" title="statement not covered" >context.fillStyle=this._selectedGroupBackroundColor;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,offset,width,groupHeight-group.style.padding);}</span>}</span>);<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();<span class="cstat-no" title="statement not covered" >f</span>or(const[color,indexes]of colorBuckets){<span class="cstat-no" title="statement not covered" >context.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;indexes.length;++i){const entryIndex=<span class="cstat-no" title="statement not covered" >indexes[i];</span>const duration=<span class="cstat-no" title="statement not covered" >entryTotalTimes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(isNaN(duration))</span></span></span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst entryStartTime=<span class="cstat-no" title="statement not covered" >entryStartTimes[entryIndex];</span>const barX=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(entryStartTime);</span>const barLevel=<span class="cstat-no" title="statement not covered" >entryLevels[entryIndex];</span>const barHeight=<span class="cstat-no" title="statement not covered" >this._levelHeight(barLevel);</span>const barY=<span class="cstat-no" title="statement not covered" >this._levelToOffset(barLevel);</span>const barRight=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(entryStartTime+duration);</span>const barWidth=<span class="cstat-no" title="statement not covered" >Math.max(barRight-barX,1);<span class="cstat-no" title="statement not covered" ></span>context.rect(barX,barY,barWidth-0.4,barHeight-1);}</span>
<span class="cstat-no" title="statement not covered" >context.fillStyle=color;<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();}</span>}
<span class="cstat-no" title="statement not covered" >context.textBaseline='alphabetic';<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();l</span>et lastMarkerLevel=<span class="cstat-no" title="statement not covered" >-1;</span>let lastMarkerX=<span class="cstat-no" title="statement not covered" >-Infinity;<span class="cstat-no" title="statement not covered" ></span>for(let m=markerIndices.length-1;m&gt;=0;--m){const entryIndex=<span class="cstat-no" title="statement not covered" >markerIndices[m];</span>const title=<span class="cstat-no" title="statement not covered" >this._dataProvider.entryTitle(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(!title)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst entryStartTime=<span class="cstat-no" title="statement not covered" >entryStartTimes[entryIndex];</span>const level=<span class="cstat-no" title="statement not covered" >entryLevels[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(lastMarkerLevel!==level)</span>
<span class="cstat-no" title="statement not covered" >lastMarkerX=-Infinity;c</span>onst x=<span class="cstat-no" title="statement not covered" >Math.max(this._chartViewport.timeToPosition(entryStartTime),lastMarkerX);</span>const y=<span class="cstat-no" title="statement not covered" >this._levelToOffset(level);</span>const h=<span class="cstat-no" title="statement not covered" >this._levelHeight(level);</span>const padding=<span class="cstat-no" title="statement not covered" >4;</span>const width=<span class="cstat-no" title="statement not covered" >Math.ceil(UI.measureTextWidth(context,title))+2*padding;<span class="cstat-no" title="statement not covered" ></span>lastMarkerX=x+width+1;<span class="cstat-no" title="statement not covered" >l</span>astMarkerLevel=level;<span class="cstat-no" title="statement not covered" >t</span>his._markerPositions.set(entryIndex,{x,width});<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=this._dataProvider.entryColor(entryIndex);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(x,y,width,h-1);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='white';<span class="cstat-no" title="statement not covered" >c</span>ontext.fillText(title,x+padding,y+h-this._textBaseline);}</span>
<span class="cstat-no" title="statement not covered" >context.strokeStyle='rgba(0, 0, 0, 0.2)';<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;titleIndices.length;++i){const entryIndex=<span class="cstat-no" title="statement not covered" >titleIndices[i];</span>const entryStartTime=<span class="cstat-no" title="statement not covered" >entryStartTimes[entryIndex];</span>const barX=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(entryStartTime);</span>const barRight=<span class="cstat-no" title="statement not covered" >Math.min(this._timeToPositionClipped(entryStartTime+entryTotalTimes[entryIndex]),width)+1;</span>const barWidth=<span class="cstat-no" title="statement not covered" >barRight-barX;</span>const barLevel=<span class="cstat-no" title="statement not covered" >entryLevels[entryIndex];</span>const barY=<span class="cstat-no" title="statement not covered" >this._levelToOffset(barLevel);</span>let text=<span class="cstat-no" title="statement not covered" >this._dataProvider.entryTitle(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(text&amp;&amp;text.length){<span class="cstat-no" title="statement not covered" >context.font=this._dataProvider.entryFont(entryIndex)||defaultFont;<span class="cstat-no" title="statement not covered" >t</span>ext=UI.trimTextMiddle(context,text,barWidth-2*textPadding);}</span></span></span>
const unclippedBarX=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPosition(entryStartTime);</span>const barHeight=<span class="cstat-no" title="statement not covered" >this._levelHeight(barLevel);<span class="cstat-no" title="statement not covered" ></span>if(this._dataProvider.decorateEntry(entryIndex,context,text,barX,barY,barWidth,barHeight,unclippedBarX,timeToPixel))</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(!text||!text.length)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=this._dataProvider.textColor(entryIndex);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillText(text,barX+textPadding,barY+barHeight-this._textBaseline);}</span>
<span class="cstat-no" title="statement not covered" >context.restore();<span class="cstat-no" title="statement not covered" >t</span>his._drawGroupHeaders(width,height);<span class="cstat-no" title="statement not covered" >t</span>his._drawFlowEvents(context,width,height);<span class="cstat-no" title="statement not covered" >t</span>his._drawMarkers();c</span>onst dividersData=<span class="cstat-no" title="statement not covered" >PerfUI.TimelineGrid.calculateGridOffsets(this);<span class="cstat-no" title="statement not covered" ></span>PerfUI.TimelineGrid.drawCanvasGrid(context,dividersData);<span class="cstat-no" title="statement not covered" >i</span>f(this._rulerEnabled){<span class="cstat-no" title="statement not covered" >PerfUI.TimelineGrid.drawCanvasHeaders(context,dividersData,<span class="fstat-no" title="function not covered" >ti</span>me=&gt;<span class="cstat-no" title="statement not covered" >this.formatValue(time,dividersData.precision),</span>3,PerfUI.FlameChart.HeaderHeight);}</span></span>
<span class="cstat-no" title="statement not covered" >this._updateElementPosition(this._highlightElement,this._highlightedEntryIndex);<span class="cstat-no" title="statement not covered" >t</span>his._updateElementPosition(this._selectedElement,this._selectedEntryIndex);<span class="cstat-no" title="statement not covered" >t</span>his._updateMarkerHighlight();}</span>
<span class="fstat-no" title="function not covered" >_i</span>nitWebGL(){const gl=(<span class="cstat-no" title="statement not covered" >this._canvasGL.getContext('webgl'))</span>;<span class="cstat-no" title="statement not covered" >if(!gl){<span class="cstat-no" title="statement not covered" >console.error('Failed to obtain WebGL context.');<span class="cstat-no" title="statement not covered" >t</span>his._useWebGL=false;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const vertexShaderSource=<span class="cstat-no" title="statement not covered" >`</span>
      attribute vec2 aVertexPosition;
      attribute float aVertexColor;
&nbsp;
      uniform vec2 uScalingFactor;
      uniform vec2 uShiftVector;
&nbsp;
      varying mediump vec2 vPalettePosition;
&nbsp;
      void main() {
        vec2 shiftedPosition = aVertexPosition - uShiftVector;
        gl_Position = vec4(shiftedPosition * uScalingFactor + vec2(-1.0, 1.0), 0.0, 1.0);
        vPalettePosition = vec2(aVertexColor, 0.5);
      }`;const fragmentShaderSource=<span class="cstat-no" title="statement not covered" >`</span>
      varying mediump vec2 vPalettePosition;
      uniform sampler2D uSampler;
&nbsp;
      void main() {
        gl_FragColor = texture2D(uSampler, vPalettePosition);
      }`;function <span class="fstat-no" title="function not covered" >loadShader(</span>gl,type,source){const shader=<span class="cstat-no" title="statement not covered" >gl.createShader(type);<span class="cstat-no" title="statement not covered" ></span>gl.shaderSource(shader,source);<span class="cstat-no" title="statement not covered" >g</span>l.compileShader(shader);<span class="cstat-no" title="statement not covered" >i</span>f(gl.getShaderParameter(shader,gl.COMPILE_STATUS))</span>
<span class="cstat-no" title="statement not covered" >return shader;<span class="cstat-no" title="statement not covered" >c</span>onsole.error('Shader compile error: '+gl.getShaderInfoLog(shader));<span class="cstat-no" title="statement not covered" >g</span>l.deleteShader(shader);<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>
const vertexShader=<span class="cstat-no" title="statement not covered" >loadShader(gl,gl.VERTEX_SHADER,vertexShaderSource);</span>const fragmentShader=<span class="cstat-no" title="statement not covered" >loadShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource);</span>const shaderProgram=<span class="cstat-no" title="statement not covered" >gl.createProgram();<span class="cstat-no" title="statement not covered" ></span>gl.attachShader(shaderProgram,vertexShader);<span class="cstat-no" title="statement not covered" >g</span>l.attachShader(shaderProgram,fragmentShader);<span class="cstat-no" title="statement not covered" >g</span>l.linkProgram(shaderProgram);<span class="cstat-no" title="statement not covered" >i</span>f(gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){<span class="cstat-no" title="statement not covered" >this._shaderProgram=shaderProgram;<span class="cstat-no" title="statement not covered" >g</span>l.useProgram(shaderProgram);}</span>else{<span class="cstat-no" title="statement not covered" >console.error('Unable to initialize the shader program: '+gl.getProgramInfoLog(shaderProgram));<span class="cstat-no" title="statement not covered" >t</span>his._shaderProgram=null;}</span></span>
<span class="cstat-no" title="statement not covered" >this._vertexBuffer=gl.createBuffer();<span class="cstat-no" title="statement not covered" >t</span>his._colorBuffer=gl.createBuffer();<span class="cstat-no" title="statement not covered" >t</span>his._uScalingFactor=gl.getUniformLocation(shaderProgram,'uScalingFactor');<span class="cstat-no" title="statement not covered" >t</span>his._uShiftVector=gl.getUniformLocation(shaderProgram,'uShiftVector');c</span>onst uSampler=<span class="cstat-no" title="statement not covered" >gl.getUniformLocation(shaderProgram,'uSampler');<span class="cstat-no" title="statement not covered" ></span>gl.uniform1i(uSampler,0);<span class="cstat-no" title="statement not covered" >t</span>his._aVertexPosition=gl.getAttribLocation(this._shaderProgram,'aVertexPosition');<span class="cstat-no" title="statement not covered" >t</span>his._aVertexColor=gl.getAttribLocation(this._shaderProgram,'aVertexColor');<span class="cstat-no" title="statement not covered" >g</span>l.enableVertexAttribArray(this._aVertexPosition);<span class="cstat-no" title="statement not covered" >g</span>l.enableVertexAttribArray(this._aVertexColor);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etupGLGeometry(){const gl=(<span class="cstat-no" title="statement not covered" >this._canvasGL.getContext('webgl'))</span>;<span class="cstat-no" title="statement not covered" >if(!gl)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst entryTotalTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryTotalTimes;</span>const entryStartTimes=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes;</span>const entryLevels=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels;</span>const verticesPerBar=<span class="cstat-no" title="statement not covered" >6;</span>const vertexArray=<span class="cstat-no" title="statement not covered" >new Float32Array(entryTotalTimes.length*verticesPerBar*2);</span>let colorArray=<span class="cstat-no" title="statement not covered" >new Uint8Array(entryTotalTimes.length*verticesPerBar);</span>let vertex=<span class="cstat-no" title="statement not covered" >0;</span>const parsedColorCache=<span class="cstat-no" title="statement not covered" >new Map();</span>const colors=<span class="cstat-no" title="statement not covered" >[];</span>const collapsedOverviewLevels=<span class="cstat-no" title="statement not covered" >new Array(this._visibleLevels.length);</span>const groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];<span class="cstat-no" title="statement not covered" ></span>this._forEachGroup(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group)=&gt;{<span class="cstat-no" title="statement not covered" >if(group.style.useFirstLineForOverview||!this._isGroupCollapsible(index)||group.expanded)</span></span>
<span class="cstat-no" title="statement not covered" >return;l</span>et nextGroup=<span class="cstat-no" title="statement not covered" >index+1;<span class="cstat-no" title="statement not covered" ></span>while(nextGroup&lt;groups.length&amp;&amp;groups[nextGroup].style.nestingLevel&gt;group.style.nestingLevel)</span>
<span class="cstat-no" title="statement not covered" >++nextGroup;c</span>onst endLevel=<span class="cstat-no" title="statement not covered" >nextGroup&lt;groups.length?groups[nextGroup].startLevel:this._dataProvider.maxStackDepth();<span class="cstat-no" title="statement not covered" ></span>for(let i=group.startLevel;i&lt;endLevel;++i)</span>
<span class="cstat-no" title="statement not covered" >collapsedOverviewLevels[i]=offset;}</span>);<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;entryTotalTimes.length;++i){const level=<span class="cstat-no" title="statement not covered" >entryLevels[i];</span>const collapsedGroupOffset=<span class="cstat-no" title="statement not covered" >collapsedOverviewLevels[level];<span class="cstat-no" title="statement not covered" ></span>if(!this._visibleLevels[level]&amp;&amp;!collapsedGroupOffset)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst color=<span class="cstat-no" title="statement not covered" >this._entryColorsCache[i];<span class="cstat-no" title="statement not covered" ></span>if(!color)</span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et colorIndex=<span class="cstat-no" title="statement not covered" >parsedColorCache.get(color);<span class="cstat-no" title="statement not covered" ></span>if(colorIndex===undefined){const rgba=<span class="cstat-no" title="statement not covered" >Common.Color.parse(color).canonicalRGBA();<span class="cstat-no" title="statement not covered" ></span>rgba[3]=Math.round(rgba[3]*255);<span class="cstat-no" title="statement not covered" >c</span>olorIndex=colors.length/4;<span class="cstat-no" title="statement not covered" >c</span>olors.push(...rgba);<span class="cstat-no" title="statement not covered" >i</span>f(colorIndex===256)</span></span>
<span class="cstat-no" title="statement not covered" >colorArray=new Uint16Array(colorArray);<span class="cstat-no" title="statement not covered" >p</span>arsedColorCache.set(color,colorIndex);}</span>
<span class="cstat-no" title="statement not covered" >for(let j=0;j&lt;verticesPerBar;++j)</span>
<span class="cstat-no" title="statement not covered" >colorArray[vertex+j]=colorIndex;c</span>onst vpos=<span class="cstat-no" title="statement not covered" >vertex*2;</span>const x0=<span class="cstat-no" title="statement not covered" >entryStartTimes[i]-this._minimumBoundary;</span>const x1=<span class="cstat-no" title="statement not covered" >x0+entryTotalTimes[i];</span>const y0=<span class="cstat-no" title="statement not covered" >collapsedGroupOffset||this._levelToOffset(level);</span>const y1=<span class="cstat-no" title="statement not covered" >y0+this._levelHeight(level)-1;<span class="cstat-no" title="statement not covered" ></span>vertexArray[vpos+0]=x0;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+1]=y0;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+2]=x1;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+3]=y0;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+4]=x0;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+5]=y1;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+6]=x0;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+7]=y1;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+8]=x1;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+9]=y0;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+10]=x1;<span class="cstat-no" title="statement not covered" >v</span>ertexArray[vpos+11]=y1;<span class="cstat-no" title="statement not covered" >v</span>ertex+=verticesPerBar;}</span>
<span class="cstat-no" title="statement not covered" >this._vertexCount=vertex;c</span>onst paletteTexture=<span class="cstat-no" title="statement not covered" >gl.createTexture();<span class="cstat-no" title="statement not covered" ></span>gl.bindTexture(gl.TEXTURE_2D,paletteTexture);<span class="cstat-no" title="statement not covered" >g</span>l.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);<span class="cstat-no" title="statement not covered" >g</span>l.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);<span class="cstat-no" title="statement not covered" >g</span>l.activeTexture(gl.TEXTURE0);c</span>onst numColors=<span class="cstat-no" title="statement not covered" >colors.length/4;</span>const useShortForColors=<span class="cstat-no" title="statement not covered" >numColors&gt;=256;</span>const width=<span class="cstat-no" title="statement not covered" >!useShortForColors?256:Math.min(1&lt;&lt;16,gl.getParameter(gl.MAX_TEXTURE_SIZE));<span class="cstat-no" title="statement not covered" ></span>console.assert(numColors&lt;=width,'Too many colors');c</span>onst height=<span class="cstat-no" title="statement not covered" >1;</span>const colorIndexType=<span class="cstat-no" title="statement not covered" >useShortForColors?gl.UNSIGNED_SHORT:gl.UNSIGNED_BYTE;<span class="cstat-no" title="statement not covered" ></span>if(useShortForColors){const factor=<span class="cstat-no" title="statement not covered" >(1&lt;&lt;16)/width;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;vertex;++i)</span></span>
<span class="cstat-no" title="statement not covered" >colorArray[i]*=factor;}</span>
const pixels=<span class="cstat-no" title="statement not covered" >new Uint8Array(width*4);<span class="cstat-no" title="statement not covered" ></span>pixels.set(colors);<span class="cstat-no" title="statement not covered" >g</span>l.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,pixels);<span class="cstat-no" title="statement not covered" >g</span>l.bindBuffer(gl.ARRAY_BUFFER,this._vertexBuffer);<span class="cstat-no" title="statement not covered" >g</span>l.bufferData(gl.ARRAY_BUFFER,vertexArray,gl.STATIC_DRAW);<span class="cstat-no" title="statement not covered" >g</span>l.vertexAttribPointer(this._aVertexPosition,2,gl.FLOAT,false,0,0);<span class="cstat-no" title="statement not covered" >g</span>l.bindBuffer(gl.ARRAY_BUFFER,this._colorBuffer);<span class="cstat-no" title="statement not covered" >g</span>l.bufferData(gl.ARRAY_BUFFER,colorArray,gl.STATIC_DRAW);<span class="cstat-no" title="statement not covered" >g</span>l.vertexAttribPointer(this._aVertexColor,1,colorIndexType,true,0,0);}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawGL(){const gl=(<span class="cstat-no" title="statement not covered" >this._canvasGL.getContext('webgl'))</span>;<span class="cstat-no" title="statement not covered" >if(!gl)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();<span class="cstat-no" title="statement not covered" ></span>if(!timelineData)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this._prevTimelineData||timelineData.entryTotalTimes!==this._prevTimelineData.entryTotalTimes){<span class="cstat-no" title="statement not covered" >this._prevTimelineData=timelineData;<span class="cstat-no" title="statement not covered" >t</span>his._setupGLGeometry();}</span></span>
<span class="cstat-no" title="statement not covered" >gl.viewport(0,0,this._canvasGL.width,this._canvasGL.height);<span class="cstat-no" title="statement not covered" >i</span>f(!this._vertexCount)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst viewportScale=<span class="cstat-no" title="statement not covered" >[2.0/this.boundarySpan(),-2.0*window.devicePixelRatio/this._canvasGL.height];</span>const viewportShift=<span class="cstat-no" title="statement not covered" >[this.minimumBoundary()-this.zeroTime(),this._chartViewport.scrollOffset()];<span class="cstat-no" title="statement not covered" ></span>gl.uniform2fv(this._uScalingFactor,viewportScale);<span class="cstat-no" title="statement not covered" >g</span>l.uniform2fv(this._uShiftVector,viewportShift);<span class="cstat-no" title="statement not covered" >g</span>l.drawArrays(gl.TRIANGLES,0,this._vertexCount);}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawGroupHeaders(width,height){const context=(<span class="cstat-no" title="statement not covered" >this._canvas.getContext('2d'))</span>;const top=<span class="cstat-no" title="statement not covered" >this._chartViewport.scrollOffset();</span>const ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;</span>const groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];<span class="cstat-no" title="statement not covered" ></span>if(!groups.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst groupOffsets=<span class="cstat-no" title="statement not covered" >this._groupOffsets;</span>const lastGroupOffset=<span class="cstat-no" title="statement not covered" >Array.prototype.peekLast.call(groupOffsets);</span>const colorUsage=<span class="cstat-no" title="statement not covered" >UI.ThemeSupport.ColorUsage;<span class="cstat-no" title="statement not covered" ></span>context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.scale(ratio,ratio);<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(0,-top);c</span>onst defaultFont=<span class="cstat-no" title="statement not covered" >'11px '+Host.fontFamily();<span class="cstat-no" title="statement not covered" ></span>context.font=defaultFont;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=UI.themeSupport.patchColorText('#fff',colorUsage.Background);<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group)=&gt;{const paddingHeight=<span class="cstat-no" title="statement not covered" >group.style.padding;<span class="cstat-no" title="statement not covered" ></span>if(paddingHeight&lt;5)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,offset-paddingHeight+2,width,paddingHeight-4);}</span>);<span class="cstat-no" title="statement not covered" >if(groups.length&amp;&amp;lastGroupOffset&lt;top+height)</span>
<span class="cstat-no" title="statement not covered" >context.fillRect(0,lastGroupOffset+2,width,top+height-lastGroupOffset);<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle=UI.themeSupport.patchColorText('#eee',colorUsage.Background);<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group,isFirst)=&gt;{<span class="cstat-no" title="statement not covered" >if(isFirst||group.style.padding&lt;4)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >h</span>Line(offset-2.5);}</span>);<span class="cstat-no" title="statement not covered" >hLine(lastGroupOffset+1.5);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group)=&gt;{<span class="cstat-no" title="statement not covered" >if(group.style.useFirstLineForOverview)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this._isGroupCollapsible(index)||group.expanded){<span class="cstat-no" title="statement not covered" >if(!group.style.shareHeaderLine&amp;&amp;index!==this._selectedGroup){<span class="cstat-no" title="statement not covered" >context.fillStyle=group.style.backgroundColor;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,offset,width,group.style.height);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return;}</span>
<span class="cstat-no" title="statement not covered" >if(this._useWebGL)</span>
<span class="cstat-no" title="statement not covered" >return;l</span>et nextGroup=<span class="cstat-no" title="statement not covered" >index+1;<span class="cstat-no" title="statement not covered" ></span>while(nextGroup&lt;groups.length&amp;&amp;groups[nextGroup].style.nestingLevel&gt;group.style.nestingLevel)</span>
<span class="cstat-no" title="statement not covered" >nextGroup++;c</span>onst endLevel=<span class="cstat-no" title="statement not covered" >nextGroup&lt;groups.length?groups[nextGroup].startLevel:this._dataProvider.maxStackDepth();<span class="cstat-no" title="statement not covered" ></span>this._drawCollapsedOverviewForGroup(group,offset,endLevel);}</span>);<span class="cstat-no" title="statement not covered" >context.save();<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group)=&gt;{<span class="cstat-no" title="statement not covered" >context.font=group.style.font;<span class="cstat-no" title="statement not covered" >i</span>f(this._isGroupCollapsible(index)&amp;&amp;!group.expanded||group.style.shareHeaderLine){const width=<span class="cstat-no" title="statement not covered" >this._labelWidthForGroup(context,group)+2;<span class="cstat-no" title="statement not covered" ></span>if(index===this._selectedGroup)</span></span></span>
<span class="cstat-no" title="statement not covered" >context.fillStyle=this._selectedGroupBackroundColor;e</span>lse
<span class="cstat-no" title="statement not covered" >context.fillStyle=Common.Color.parse(group.style.backgroundColor).setAlpha(0.8).asString(null);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(this._headerLeftPadding-this._headerLabelXPadding,offset+this._headerLabelYPadding,width,group.style.height-2*this._headerLabelYPadding);}</span>
<span class="cstat-no" title="statement not covered" >context.fillStyle=group.style.color;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillText(group.name,Math.floor(this._expansionArrowIndent*(group.style.nestingLevel+1)+this._arrowSide),offset+group.style.height-this._textBaseline);}</span>);<span class="cstat-no" title="statement not covered" >context.restore();<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=UI.themeSupport.patchColorText('#6e6e6e',colorUsage.Foreground);<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group)=&gt;{<span class="cstat-no" title="statement not covered" >if(this._isGroupCollapsible(index)){<span class="cstat-no" title="statement not covered" >drawExpansionArrow.call(this,this._expansionArrowIndent*(group.style.nestingLevel+1),offset+group.style.height-this._textBaseline-this._arrowSide/2,!!group.expanded);}</span>}</span>);<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle=UI.themeSupport.patchColorText('#ddd',colorUsage.Background);<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >t</span>his._forEachGroupInViewport(<span class="fstat-no" title="function not covered" >(o</span>ffset,index,group,isFirst,groupHeight)=&gt;{<span class="cstat-no" title="statement not covered" >if(index===this._selectedGroup){const lineWidth=<span class="cstat-no" title="statement not covered" >2;</span>const bracketLength=<span class="cstat-no" title="statement not covered" >10;<span class="cstat-no" title="statement not covered" ></span>context.fillStyle=this._selectedGroupBorderColor;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,offset-lineWidth,lineWidth,groupHeight-group.style.padding+2*lineWidth);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,offset-lineWidth,bracketLength,lineWidth);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,offset+groupHeight-group.style.padding,bracketLength,lineWidth);}</span>}</span>);<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();f</span>unction <span class="fstat-no" title="function not covered" >hLine(</span>y){<span class="cstat-no" title="statement not covered" >context.moveTo(0,y);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(width,y);}</span>
function <span class="fstat-no" title="function not covered" >drawExpansionArrow(</span>x,y,expanded){const arrowHeight=<span class="cstat-no" title="statement not covered" >this._arrowSide*Math.sqrt(3)/2;</span>const arrowCenterOffset=<span class="cstat-no" title="statement not covered" >Math.round(arrowHeight/2);<span class="cstat-no" title="statement not covered" ></span>context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(x,y);<span class="cstat-no" title="statement not covered" >c</span>ontext.rotate(expanded?Math.PI/2:0);<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(-arrowCenterOffset,-this._arrowSide/2);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(-arrowCenterOffset,this._arrowSide/2);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(arrowHeight-arrowCenterOffset,0);<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();}</span>}
<span class="fstat-no" title="function not covered" >_f</span>orEachGroup(callback){const groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];<span class="cstat-no" title="statement not covered" ></span>if(!groups.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst groupOffsets=<span class="cstat-no" title="statement not covered" >this._groupOffsets;</span>const groupStack=<span class="cstat-no" title="statement not covered" >[{nestingLevel:-1,visible:true}];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;groups.length;++i){const groupTop=<span class="cstat-no" title="statement not covered" >groupOffsets[i];</span>const group=<span class="cstat-no" title="statement not covered" >groups[i];</span>let firstGroup=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>while(groupStack.peekLast().nestingLevel&gt;=group.style.nestingLevel){<span class="cstat-no" title="statement not covered" >groupStack.pop();<span class="cstat-no" title="statement not covered" >f</span>irstGroup=false;}</span></span></span>
const parentGroupVisible=<span class="cstat-no" title="statement not covered" >groupStack.peekLast().visible;</span>const thisGroupVisible=<span class="cstat-no" title="statement not covered" >parentGroupVisible&amp;&amp;(!this._isGroupCollapsible(i)||group.expanded);<span class="cstat-no" title="statement not covered" ></span>groupStack.push({nestingLevel:group.style.nestingLevel,visible:thisGroupVisible});c</span>onst nextOffset=<span class="cstat-no" title="statement not covered" >i===groups.length-1?groupOffsets[i+1]+group.style.padding:groupOffsets[i+1];<span class="cstat-no" title="statement not covered" ></span>if(!parentGroupVisible)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >c</span>allback(groupTop,i,group,firstGroup,nextOffset-groupTop);}</span>}
<span class="fstat-no" title="function not covered" >_f</span>orEachGroupInViewport(callback){const top=<span class="cstat-no" title="statement not covered" >this._chartViewport.scrollOffset();<span class="cstat-no" title="statement not covered" ></span>this._forEachGroup(<span class="fstat-no" title="function not covered" >(g</span>roupTop,index,group,firstGroup,height)=&gt;{<span class="cstat-no" title="statement not covered" >if(groupTop-group.style.padding&gt;top+this._offsetHeight)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(groupTop+height&lt;top)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >c</span>allback(groupTop,index,group,firstGroup,height);}</span>);}
<span class="fstat-no" title="function not covered" >_l</span>abelWidthForGroup(context,group){<span class="cstat-no" title="statement not covered" >return UI.measureTextWidth(context,group.name)+this._expansionArrowIndent*(group.style.nestingLevel+1)+</span>
2*this._headerLabelXPadding;}
<span class="fstat-no" title="function not covered" >_d</span>rawCollapsedOverviewForGroup(group,y,endLevel){const range=<span class="cstat-no" title="statement not covered" >new Common.SegmentedRange(mergeCallback);</span>const timeWindowLeft=<span class="cstat-no" title="statement not covered" >this._chartViewport.windowLeftTime();</span>const timeWindowRight=<span class="cstat-no" title="statement not covered" >this._chartViewport.windowRightTime();</span>const context=(<span class="cstat-no" title="statement not covered" >this._canvas.getContext('2d'))</span>;const barHeight=<span class="cstat-no" title="statement not covered" >group.style.height;</span>const entryStartTimes=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.entryStartTimes;</span>const entryTotalTimes=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.entryTotalTimes;</span>const timeToPixel=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPixel();<span class="cstat-no" title="statement not covered" ></span>for(let level=group.startLevel;level&lt;endLevel;++level){const levelIndexes=<span class="cstat-no" title="statement not covered" >this._timelineLevels[level];</span>const rightIndexOnLevel=<span class="cstat-no" title="statement not covered" >levelIndexes.lowerBound(timeWindowRight,<span class="fstat-no" title="function not covered" >(t</span>ime,entryIndex)=&gt;<span class="cstat-no" title="statement not covered" >time-entryStartTimes[entryIndex])</span>-1;</span>let lastDrawOffset=<span class="cstat-no" title="statement not covered" >Infinity;<span class="cstat-no" title="statement not covered" ></span>for(let entryIndexOnLevel=rightIndexOnLevel;entryIndexOnLevel&gt;=0;--entryIndexOnLevel){const entryIndex=<span class="cstat-no" title="statement not covered" >levelIndexes[entryIndexOnLevel];</span>const entryStartTime=<span class="cstat-no" title="statement not covered" >entryStartTimes[entryIndex];</span>const barX=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(entryStartTime);</span>const entryEndTime=<span class="cstat-no" title="statement not covered" >entryStartTime+entryTotalTimes[entryIndex];<span class="cstat-no" title="statement not covered" ></span>if(isNaN(entryEndTime)||barX&gt;=lastDrawOffset)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span>f(entryEndTime&lt;=timeWindowLeft)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >l</span>astDrawOffset=barX;c</span>onst color=<span class="cstat-no" title="statement not covered" >this._entryColorsCache[entryIndex];</span>const endBarX=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(entryEndTime);<span class="cstat-no" title="statement not covered" ></span>if(group.style.useDecoratorsForOverview&amp;&amp;this._dataProvider.forceDecoration(entryIndex)){const unclippedBarX=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPosition(entryStartTime);</span>const barWidth=<span class="cstat-no" title="statement not covered" >endBarX-barX;<span class="cstat-no" title="statement not covered" ></span>context.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=color;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(barX,y,barWidth,barHeight-1);<span class="cstat-no" title="statement not covered" >t</span>his._dataProvider.decorateEntry(entryIndex,context,'',barX,y,barWidth,barHeight,unclippedBarX,timeToPixel);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >range.append(new Common.Segment(barX,endBarX,color));}</span>}
const segments=<span class="cstat-no" title="statement not covered" >range.segments().slice().sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a.data.localeCompare(b.data))</span>;</span>let lastColor;<span class="cstat-no" title="statement not covered" >context.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;segments.length;++i){const segment=<span class="cstat-no" title="statement not covered" >segments[i];<span class="cstat-no" title="statement not covered" ></span>if(lastColor!==segments[i].data){<span class="cstat-no" title="statement not covered" >context.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >l</span>astColor=segments[i].data;<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=lastColor;}</span></span></span>
<span class="cstat-no" title="statement not covered" >context.rect(segment.begin,y,segment.end-segment.begin,barHeight);}</span>
<span class="cstat-no" title="statement not covered" >context.fill();f</span>unction <span class="fstat-no" title="function not covered" >mergeCallback(</span>a,b){<span class="cstat-no" title="statement not covered" >return a.data===b.data&amp;&amp;a.end+0.4&gt;b.end?a:null;}</span>}
<span class="fstat-no" title="function not covered" >_d</span>rawFlowEvents(context,width,height){<span class="cstat-no" title="statement not covered" >context.save();c</span>onst ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;</span>const top=<span class="cstat-no" title="statement not covered" >this._chartViewport.scrollOffset();</span>const arrowWidth=<span class="cstat-no" title="statement not covered" >6;<span class="cstat-no" title="statement not covered" ></span>context.scale(ratio,ratio);<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(0,-top);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle='#7f5050';<span class="cstat-no" title="statement not covered" >c</span>ontext.strokeStyle='#7f5050';c</span>onst td=<span class="cstat-no" title="statement not covered" >this._timelineData();</span>const endIndex=<span class="cstat-no" title="statement not covered" >td.flowStartTimes.lowerBound(this._chartViewport.windowRightTime());<span class="cstat-no" title="statement not covered" ></span>context.lineWidth=0.5;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;endIndex;++i){<span class="cstat-no" title="statement not covered" >if(!td.flowEndTimes[i]||td.flowEndTimes[i]&lt;this._chartViewport.windowLeftTime())</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst startX=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPosition(td.flowStartTimes[i]);</span>const endX=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPosition(td.flowEndTimes[i]);</span>const startLevel=<span class="cstat-no" title="statement not covered" >td.flowStartLevels[i];</span>const endLevel=<span class="cstat-no" title="statement not covered" >td.flowEndLevels[i];</span>const startY=<span class="cstat-no" title="statement not covered" >this._levelToOffset(startLevel)+this._levelHeight(startLevel)/2;</span>const endY=<span class="cstat-no" title="statement not covered" >this._levelToOffset(endLevel)+this._levelHeight(endLevel)/2;</span>const segment=<span class="cstat-no" title="statement not covered" >Math.min((endX-startX)/4,40);</span>const distanceTime=<span class="cstat-no" title="statement not covered" >td.flowEndTimes[i]-td.flowStartTimes[i];</span>const distanceY=<span class="cstat-no" title="statement not covered" >(endY-startY)/10;</span>const spread=<span class="cstat-no" title="statement not covered" >30;</span>const lineY=<span class="cstat-no" title="statement not covered" >distanceTime&lt;1?startY:spread+Math.max(0,startY+distanceY*(i%spread));</span>const p=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>p.push({x:startX,y:startY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:startX+arrowWidth,y:startY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:startX+segment+2*arrowWidth,y:startY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:startX+segment,y:lineY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:startX+segment*2,y:lineY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:endX-segment*2,y:lineY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:endX-segment,y:lineY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:endX-segment-2*arrowWidth,y:endY});<span class="cstat-no" title="statement not covered" >p</span>.push({x:endX-arrowWidth,y:endY});<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(p[0].x,p[0].y);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(p[1].x,p[1].y);<span class="cstat-no" title="statement not covered" >c</span>ontext.bezierCurveTo(p[2].x,p[2].y,p[3].x,p[3].y,p[4].x,p[4].y);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(p[5].x,p[5].y);<span class="cstat-no" title="statement not covered" >c</span>ontext.bezierCurveTo(p[6].x,p[6].y,p[7].x,p[7].y,p[8].x,p[8].y);<span class="cstat-no" title="statement not covered" >c</span>ontext.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.arc(startX,startY,2,-Math.PI/2,Math.PI/2,false);<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.moveTo(endX,endY);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(endX-arrowWidth,endY-3);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(endX-arrowWidth,endY+3);<span class="cstat-no" title="statement not covered" >c</span>ontext.fill();}</span>
<span class="cstat-no" title="statement not covered" >context.restore();}</span>
<span class="fstat-no" title="function not covered" >_d</span>rawMarkers(){const markers=<span class="cstat-no" title="statement not covered" >this._timelineData().markers;</span>const left=<span class="cstat-no" title="statement not covered" >this._markerIndexBeforeTime(this.minimumBoundary());</span>const rightBoundary=<span class="cstat-no" title="statement not covered" >this.maximumBoundary();</span>const timeToPixel=<span class="cstat-no" title="statement not covered" >this._chartViewport.timeToPixel();</span>const context=(<span class="cstat-no" title="statement not covered" >this._canvas.getContext('2d'))</span>;<span class="cstat-no" title="statement not covered" >context.save();c</span>onst ratio=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>context.scale(ratio,ratio);<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(0,3);c</span>onst height=<span class="cstat-no" title="statement not covered" >PerfUI.FlameChart.HeaderHeight-1;<span class="cstat-no" title="statement not covered" ></span>for(let i=left;i&lt;markers.length;i++){const timestamp=<span class="cstat-no" title="statement not covered" >markers[i].startTime();<span class="cstat-no" title="statement not covered" ></span>if(timestamp&gt;rightBoundary)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >m</span>arkers[i].draw(context,this._chartViewport.timeToPosition(timestamp),height,timeToPixel);}</span>
<span class="cstat-no" title="statement not covered" >context.restore();}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateMarkerHighlight(){const element=<span class="cstat-no" title="statement not covered" >this._markerHighlighElement;<span class="cstat-no" title="statement not covered" ></span>if(element.parentElement)</span>
<span class="cstat-no" title="statement not covered" >element.remove();c</span>onst markerIndex=<span class="cstat-no" title="statement not covered" >this._highlightedMarkerIndex;<span class="cstat-no" title="statement not covered" ></span>if(markerIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst marker=<span class="cstat-no" title="statement not covered" >this._timelineData().markers[markerIndex];</span>const barX=<span class="cstat-no" title="statement not covered" >this._timeToPositionClipped(marker.startTime());<span class="cstat-no" title="statement not covered" ></span>element.title=marker.title();c</span>onst style=<span class="cstat-no" title="statement not covered" >element.style;<span class="cstat-no" title="statement not covered" ></span>style.left=barX+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.backgroundColor=marker.color();<span class="cstat-no" title="statement not covered" >t</span>his._viewportElement.appendChild(element);}</span>
<span class="fstat-no" title="function not covered" >_p</span>rocessTimelineData(timelineData){<span class="cstat-no" title="statement not covered" >if(!timelineData){<span class="cstat-no" title="statement not covered" >this._timelineLevels=null;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevelOffsets=null;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevels=null;<span class="cstat-no" title="statement not covered" >t</span>his._groupOffsets=null;<span class="cstat-no" title="statement not covered" >t</span>his._rawTimelineData=null;<span class="cstat-no" title="statement not covered" >t</span>his._forceDecorationCache=null;<span class="cstat-no" title="statement not covered" >t</span>his._entryColorsCache=null;<span class="cstat-no" title="statement not covered" >t</span>his._rawTimelineDataLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._selectedGroup=-1;<span class="cstat-no" title="statement not covered" >t</span>his._flameChartDelegate.updateSelectedGroup(this,null);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >this._rawTimelineData=timelineData;<span class="cstat-no" title="statement not covered" >t</span>his._rawTimelineDataLength=timelineData.entryStartTimes.length;<span class="cstat-no" title="statement not covered" >t</span>his._forceDecorationCache=new Int8Array(this._rawTimelineDataLength);<span class="cstat-no" title="statement not covered" >t</span>his._entryColorsCache=new Array(this._rawTimelineDataLength);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._rawTimelineDataLength;++i){<span class="cstat-no" title="statement not covered" >this._forceDecorationCache[i]=this._dataProvider.forceDecoration(i)?1:0;<span class="cstat-no" title="statement not covered" >t</span>his._entryColorsCache[i]=this._dataProvider.entryColor(i);}</span></span>
const entryCounters=<span class="cstat-no" title="statement not covered" >new Uint32Array(this._dataProvider.maxStackDepth()+1);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;timelineData.entryLevels.length;++i)</span>
<span class="cstat-no" title="statement not covered" >++entryCounters[timelineData.entryLevels[i]];c</span>onst levelIndexes=<span class="cstat-no" title="statement not covered" >new Array(entryCounters.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;levelIndexes.length;++i){<span class="cstat-no" title="statement not covered" >levelIndexes[i]=new Uint32Array(entryCounters[i]);<span class="cstat-no" title="statement not covered" >e</span>ntryCounters[i]=0;}</span></span>
<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;timelineData.entryLevels.length;++i){const level=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels[i];<span class="cstat-no" title="statement not covered" ></span>levelIndexes[level][entryCounters[level]++]=i;}</span></span>
<span class="cstat-no" title="statement not covered" >this._timelineLevels=levelIndexes;c</span>onst groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;groups.length;++i){const expanded=<span class="cstat-no" title="statement not covered" >this._groupExpansionState[groups[i].name];<span class="cstat-no" title="statement not covered" ></span>if(expanded!==undefined)</span></span>
<span class="cstat-no" title="statement not covered" >groups[i].expanded=expanded;}</span>
<span class="cstat-no" title="statement not covered" >this._updateLevelPositions();<span class="cstat-no" title="statement not covered" >t</span>his._updateHeight();<span class="cstat-no" title="statement not covered" >t</span>his._selectedGroup=timelineData.selectedGroup?groups.indexOf(timelineData.selectedGroup):-1;<span class="cstat-no" title="statement not covered" >t</span>his._flameChartDelegate.updateSelectedGroup(this,timelineData.selectedGroup);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateLevelPositions(){const levelCount=<span class="cstat-no" title="statement not covered" >this._dataProvider.maxStackDepth();</span>const groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];<span class="cstat-no" title="statement not covered" ></span>this._visibleLevelOffsets=new Uint32Array(levelCount+1);<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevelHeights=new Uint32Array(levelCount);<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevels=new Uint16Array(levelCount);<span class="cstat-no" title="statement not covered" >t</span>his._groupOffsets=new Uint32Array(groups.length+1);l</span>et groupIndex=<span class="cstat-no" title="statement not covered" >-1;</span>let currentOffset=<span class="cstat-no" title="statement not covered" >this._rulerEnabled?PerfUI.FlameChart.HeaderHeight+2:2;</span>let visible=<span class="cstat-no" title="statement not covered" >true;</span>const groupStack=<span class="cstat-no" title="statement not covered" >[{nestingLevel:-1,visible:true}];</span>const lastGroupLevel=<span class="cstat-no" title="statement not covered" >Math.max(levelCount,groups.length?groups.peekLast().startLevel+1:0);</span>let level;<span class="cstat-no" title="statement not covered" >for(level=0;level&lt;lastGroupLevel;++level){let parentGroupIsVisible=<span class="cstat-no" title="statement not covered" >true;</span>let style;<span class="cstat-no" title="statement not covered" >while(groupIndex&lt;groups.length-1&amp;&amp;level===groups[groupIndex+1].startLevel){<span class="cstat-no" title="statement not covered" >++groupIndex;<span class="cstat-no" title="statement not covered" >s</span>tyle=groups[groupIndex].style;l</span>et nextLevel=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>while(groupStack.peekLast().nestingLevel&gt;=style.nestingLevel){<span class="cstat-no" title="statement not covered" >groupStack.pop();<span class="cstat-no" title="statement not covered" >n</span>extLevel=false;}</span></span></span></span>
const thisGroupIsVisible=<span class="cstat-no" title="statement not covered" >groupIndex&gt;=0&amp;&amp;this._isGroupCollapsible(groupIndex)?groups[groupIndex].expanded:true;<span class="cstat-no" title="statement not covered" ></span>parentGroupIsVisible=groupStack.peekLast().visible;<span class="cstat-no" title="statement not covered" >v</span>isible=thisGroupIsVisible&amp;&amp;parentGroupIsVisible;<span class="cstat-no" title="statement not covered" >g</span>roupStack.push({nestingLevel:style.nestingLevel,visible:visible});<span class="cstat-no" title="statement not covered" >i</span>f(parentGroupIsVisible)</span>
<span class="cstat-no" title="statement not covered" >currentOffset+=nextLevel?0:style.padding;<span class="cstat-no" title="statement not covered" >t</span>his._groupOffsets[groupIndex]=currentOffset;<span class="cstat-no" title="statement not covered" >i</span>f(parentGroupIsVisible&amp;&amp;!style.shareHeaderLine)</span>
<span class="cstat-no" title="statement not covered" >currentOffset+=style.height;}</span>
const isFirstOnLevel=<span class="cstat-no" title="statement not covered" >groupIndex&gt;=0&amp;&amp;level===groups[groupIndex].startLevel;</span>const thisLevelIsVisible=<span class="cstat-no" title="statement not covered" >parentGroupIsVisible&amp;&amp;(visible||isFirstOnLevel&amp;&amp;groups[groupIndex].style.useFirstLineForOverview);<span class="cstat-no" title="statement not covered" ></span>if(level&lt;levelCount){let height;<span class="cstat-no" title="statement not covered" >if(groupIndex&gt;=0){const group=<span class="cstat-no" title="statement not covered" >groups[groupIndex];</span>const styleB=<span class="cstat-no" title="statement not covered" >group.style;<span class="cstat-no" title="statement not covered" ></span>height=isFirstOnLevel&amp;&amp;!styleB.shareHeaderLine||(styleB.collapsible&amp;&amp;!group.expanded)?styleB.height:(styleB.itemsHeight||this._barHeight);}</span>else{<span class="cstat-no" title="statement not covered" >height=this._barHeight;}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._visibleLevels[level]=thisLevelIsVisible;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevelOffsets[level]=currentOffset;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevelHeights[level]=height;}</span>
<span class="cstat-no" title="statement not covered" >if(thisLevelIsVisible||(parentGroupIsVisible&amp;&amp;style&amp;&amp;style.shareHeaderLine&amp;&amp;isFirstOnLevel))</span>
<span class="cstat-no" title="statement not covered" >currentOffset+=this._visibleLevelHeights[level];}</span>
<span class="cstat-no" title="statement not covered" >if(groupIndex&gt;=0)</span>
<span class="cstat-no" title="statement not covered" >this._groupOffsets[groupIndex+1]=currentOffset;<span class="cstat-no" title="statement not covered" >t</span>his._visibleLevelOffsets[level]=currentOffset;<span class="cstat-no" title="statement not covered" >i</span>f(this._useWebGL)</span>
<span class="cstat-no" title="statement not covered" >this._setupGLGeometry();}</span>
<span class="fstat-no" title="function not covered" >_i</span>sGroupCollapsible(index){const groups=<span class="cstat-no" title="statement not covered" >this._rawTimelineData.groups||[];</span>const style=<span class="cstat-no" title="statement not covered" >groups[index].style;<span class="cstat-no" title="statement not covered" ></span>if(!style.shareHeaderLine||!style.collapsible)</span>
<span class="cstat-no" title="statement not covered" >return!!style.collapsible;c</span>onst isLastGroup=<span class="cstat-no" title="statement not covered" >index+1&gt;=groups.length;<span class="cstat-no" title="statement not covered" ></span>if(!isLastGroup&amp;&amp;groups[index+1].style.nestingLevel&gt;style.nestingLevel)</span>
<span class="cstat-no" title="statement not covered" >return true;c</span>onst nextGroupLevel=<span class="cstat-no" title="statement not covered" >isLastGroup?this._dataProvider.maxStackDepth():groups[index+1].startLevel;<span class="cstat-no" title="statement not covered" ></span>if(nextGroupLevel!==groups[index].startLevel+1)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span>eturn style.height!==style.itemsHeight;}</span>
<span class="fstat-no" title="function not covered" >se</span>tSelectedEntry(entryIndex){<span class="cstat-no" title="statement not covered" >if(this._selectedEntryIndex===entryIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(entryIndex!==-1)</span>
<span class="cstat-no" title="statement not covered" >this._chartViewport.hideRangeSelection();<span class="cstat-no" title="statement not covered" >t</span>his._selectedEntryIndex=entryIndex;<span class="cstat-no" title="statement not covered" >t</span>his._revealEntry(entryIndex);<span class="cstat-no" title="statement not covered" >t</span>his._updateElementPosition(this._selectedElement,this._selectedEntryIndex);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateElementPosition(element,entryIndex){const elementMinWidthPx=<span class="cstat-no" title="statement not covered" >2;<span class="cstat-no" title="statement not covered" ></span>element.classList.add('hidden');<span class="cstat-no" title="statement not covered" >i</span>f(entryIndex===-1)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst timelineData=<span class="cstat-no" title="statement not covered" >this._timelineData();</span>const startTime=<span class="cstat-no" title="statement not covered" >timelineData.entryStartTimes[entryIndex];</span>const duration=<span class="cstat-no" title="statement not covered" >timelineData.entryTotalTimes[entryIndex];</span>let barX=<span class="cstat-no" title="statement not covered" >0;</span>let barWidth=<span class="cstat-no" title="statement not covered" >0;</span>let visible=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>if(Number.isNaN(duration)){const position=<span class="cstat-no" title="statement not covered" >this._markerPositions.get(entryIndex);<span class="cstat-no" title="statement not covered" ></span>if(position){<span class="cstat-no" title="statement not covered" >barX=position.x;<span class="cstat-no" title="statement not covered" >b</span>arWidth=position.width;}</span>else{<span class="cstat-no" title="statement not covered" >visible=false;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >barX=this._chartViewport.timeToPosition(startTime);<span class="cstat-no" title="statement not covered" >b</span>arWidth=duration*this._chartViewport.timeToPixel();}</span></span>
<span class="cstat-no" title="statement not covered" >if(barX+barWidth&lt;=0||barX&gt;=this._offsetWidth)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst barCenter=<span class="cstat-no" title="statement not covered" >barX+barWidth/2;<span class="cstat-no" title="statement not covered" ></span>barWidth=Math.max(barWidth,elementMinWidthPx);<span class="cstat-no" title="statement not covered" >b</span>arX=barCenter-barWidth/2;c</span>onst entryLevel=<span class="cstat-no" title="statement not covered" >timelineData.entryLevels[entryIndex];</span>const barY=<span class="cstat-no" title="statement not covered" >this._levelToOffset(entryLevel)-this._chartViewport.scrollOffset();</span>const barHeight=<span class="cstat-no" title="statement not covered" >this._levelHeight(entryLevel);</span>const style=<span class="cstat-no" title="statement not covered" >element.style;<span class="cstat-no" title="statement not covered" ></span>style.left=barX+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.top=barY+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.width=barWidth+'px';<span class="cstat-no" title="statement not covered" >s</span>tyle.height=barHeight-1+'px';<span class="cstat-no" title="statement not covered" >e</span>lement.classList.toggle('hidden',!visible);<span class="cstat-no" title="statement not covered" >t</span>his._viewportElement.appendChild(element);}</span>
<span class="fstat-no" title="function not covered" >_t</span>imeToPositionClipped(time){<span class="cstat-no" title="statement not covered" >return Number.constrain(this._chartViewport.timeToPosition(time),0,this._offsetWidth);}</span>
<span class="fstat-no" title="function not covered" >_l</span>evelToOffset(level){<span class="cstat-no" title="statement not covered" >return this._visibleLevelOffsets[level];}</span>
<span class="fstat-no" title="function not covered" >_l</span>evelHeight(level){<span class="cstat-no" title="statement not covered" >return this._visibleLevelHeights[level];}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateBoundaries(){<span class="cstat-no" title="statement not covered" >this._totalTime=this._dataProvider.totalTime();<span class="cstat-no" title="statement not covered" >t</span>his._minimumBoundary=this._dataProvider.minimumBoundary();<span class="cstat-no" title="statement not covered" >t</span>his._chartViewport.setBoundaries(this._minimumBoundary,this._totalTime);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateHeight(){const height=<span class="cstat-no" title="statement not covered" >this._levelToOffset(this._dataProvider.maxStackDepth())+2;<span class="cstat-no" title="statement not covered" ></span>this._chartViewport.setContentHeight(height);}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){<span class="cstat-no" title="statement not covered" >this.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >if(!this._timelineData())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._resetCanvas();<span class="cstat-no" title="statement not covered" >t</span>his._updateHeight();<span class="cstat-no" title="statement not covered" >t</span>his._updateBoundaries();<span class="cstat-no" title="statement not covered" >t</span>his._draw();<span class="cstat-no" title="statement not covered" >i</span>f(!this._chartViewport.isDragging())</span>
<span class="cstat-no" title="statement not covered" >this._updateHighlight();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._chartViewport.reset();<span class="cstat-no" title="statement not covered" >t</span>his._rawTimelineData=null;<span class="cstat-no" title="statement not covered" >t</span>his._rawTimelineDataLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedMarkerIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._highlightedEntryIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._selectedEntryIndex=-1;<span class="cstat-no" title="statement not covered" >t</span>his._textWidth=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._chartViewport.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >sc</span>heduleUpdate(){<span class="cstat-no" title="statement not covered" >this._chartViewport.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_e</span>nabled(){<span class="cstat-no" title="statement not covered" >return this._rawTimelineDataLength!==0;}</span>
<span class="fstat-no" title="function not covered" >co</span>mputePosition(time){<span class="cstat-no" title="statement not covered" >return this._chartViewport.timeToPosition(time);}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return this._dataProvider.formatValue(value-this.zeroTime(),precision);}</span>
<span class="fstat-no" title="function not covered" >ma</span>ximumBoundary(){<span class="cstat-no" title="statement not covered" >return this._chartViewport.windowRightTime();}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._chartViewport.windowLeftTime();}</span>
<span class="fstat-no" title="function not covered" >ze</span>roTime(){<span class="cstat-no" title="statement not covered" >return this._dataProvider.minimumBoundary();}</span>
<span class="fstat-no" title="function not covered" >bo</span>undarySpan(){<span class="cstat-no" title="statement not covered" >return this.maximumBoundary()-this.minimumBoundary();}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.FlameChart.HeaderHeight=15;<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart.MinimalTimeWindowMs=0.5;<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChartDataProvider=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart.Group;<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart.GroupStyle;<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart.TimelineData=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(entryLevels,entryTotalTimes,entryStartTimes,groups){<span class="cstat-no" title="statement not covered" >this.entryLevels=entryLevels;<span class="cstat-no" title="statement not covered" >t</span>his.entryTotalTimes=entryTotalTimes;<span class="cstat-no" title="statement not covered" >t</span>his.entryStartTimes=entryStartTimes;<span class="cstat-no" title="statement not covered" >t</span>his.groups=groups;<span class="cstat-no" title="statement not covered" >t</span>his.markers=[];<span class="cstat-no" title="statement not covered" >t</span>his.flowStartTimes=[];<span class="cstat-no" title="statement not covered" >t</span>his.flowStartLevels=[];<span class="cstat-no" title="statement not covered" >t</span>his.flowEndTimes=[];<span class="cstat-no" title="statement not covered" >t</span>his.flowEndLevels=[];<span class="cstat-no" title="statement not covered" >t</span>his.selectedGroup=null;}</span>};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChartDataProvider.prototype={minimumBoundary(){},totalTime(){},formatValue(value,precision){},maxStackDepth(){},timelineData(){},prepareHighlightedEntryInfo(entryIndex){},canJumpToEntry(entryIndex){},entryTitle(entryIndex){},entryFont(entryIndex){},entryColor(entryIndex){},decorateEntry(entryIndex,context,text,barX,barY,barWidth,barHeight,unclippedBarX,timeToPixelRatio){},forceDecoration(entryIndex){},textColor(entryIndex){},};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChartMarker=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChartMarker.prototype={startTime(){},color(){},title(){},draw(context,x,height,pixelsPerMillisecond){},};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart.Events={EntrySelected:Symbol('EntrySelected'),EntryHighlighted:Symbol('EntryHighlighted')};<span class="cstat-no" title="statement not covered" >P</span>erfUI.FlameChart.Colors={SelectedGroupBackground:'hsl(215, 85%, 98%)',SelectedGroupBorder:'hsl(216, 68%, 54%)',};;<span class="cstat-no" title="statement not covered" ></span>PerfUI.GCActionDelegate=class{<span class="fstat-no" title="function not covered" >ha</span>ndleAction(context,actionId){<span class="cstat-no" title="statement not covered" >for(const heapProfilerModel of SDK.targetManager.models(SDK.HeapProfilerModel))</span></span>
<span class="cstat-no" title="statement not covered" >heapProfilerModel.collectGarbage();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>};;<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._locationPool=new Bindings.LiveLocationPool();<span class="cstat-no" title="statement not covered" >t</span>his.reset();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic instance(){<span class="cstat-no" title="statement not covered" >if(!PerfUI.LineLevelProfile._instance)</span>
<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile._instance=new PerfUI.LineLevelProfile();<span class="cstat-no" title="statement not covered" >r</span>eturn PerfUI.LineLevelProfile._instance;}</span>
<span class="fstat-no" title="function not covered" >ap</span>pendCPUProfile(profile){const nodesToGo=<span class="cstat-no" title="statement not covered" >[profile.profileHead];</span>const sampleDuration=<span class="cstat-no" title="statement not covered" >(profile.profileEndTime-profile.profileStartTime)/profile.totalHitCount;<span class="cstat-no" title="statement not covered" ></span>while(nodesToGo.length){const nodes=<span class="cstat-no" title="statement not covered" >nodesToGo.pop().children;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;nodes.length;++i){const node=<span class="cstat-no" title="statement not covered" >nodes[i];<span class="cstat-no" title="statement not covered" ></span>nodesToGo.push(node);<span class="cstat-no" title="statement not covered" >i</span>f(!node.url||!node.positionTicks)</span></span></span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et fileInfo=<span class="cstat-no" title="statement not covered" >this._files.get(node.url);<span class="cstat-no" title="statement not covered" ></span>if(!fileInfo){<span class="cstat-no" title="statement not covered" >fileInfo=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._files.set(node.url,fileInfo);}</span></span>
<span class="cstat-no" title="statement not covered" >for(let j=0;j&lt;node.positionTicks.length;++j){const lineInfo=<span class="cstat-no" title="statement not covered" >node.positionTicks[j];</span>const line=<span class="cstat-no" title="statement not covered" >lineInfo.line;</span>const time=<span class="cstat-no" title="statement not covered" >lineInfo.ticks*sampleDuration;<span class="cstat-no" title="statement not covered" ></span>fileInfo.set(line,(fileInfo.get(line)||0)+time);}</span>}</span>}
<span class="cstat-no" title="statement not covered" >this._scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._files=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_s</span>cheduleUpdate(){<span class="cstat-no" title="statement not covered" >if(this._updateTimer)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._updateTimer=setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._updateTimer=null;<span class="cstat-no" title="statement not covered" >t</span>his._doUpdate();}</span>,0);}</span>
<span class="fstat-no" title="function not covered" >_d</span>oUpdate(){<span class="cstat-no" title="statement not covered" >this._locationPool.disposeAll();<span class="cstat-no" title="statement not covered" >W</span>orkspace.workspace.uiSourceCodes().forEach(<span class="fstat-no" title="function not covered" >ui</span>SourceCode=&gt;<span class="cstat-no" title="statement not covered" >uiSourceCode.removeDecorationsForType(PerfUI.LineLevelProfile.LineDecorator.type))</span>;<span class="cstat-no" title="statement not covered" >f</span>or(const fileInfo of this._files){const url=(<span class="cstat-no" title="statement not covered" >fileInfo[0])</span>;const uiSourceCode=<span class="cstat-no" title="statement not covered" >Workspace.workspace.uiSourceCodeForURL(url);<span class="cstat-no" title="statement not covered" ></span>if(!uiSourceCode)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst target=<span class="cstat-no" title="statement not covered" >Bindings.NetworkProject.targetForUISourceCode(uiSourceCode)||SDK.targetManager.mainTarget();</span>const debuggerModel=<span class="cstat-no" title="statement not covered" >target?target.model(SDK.DebuggerModel):null;<span class="cstat-no" title="statement not covered" ></span>if(!debuggerModel)</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span>or(const lineInfo of fileInfo[1]){const line=<span class="cstat-no" title="statement not covered" >lineInfo[0]-1;</span>const time=<span class="cstat-no" title="statement not covered" >lineInfo[1];</span>const rawLocation=<span class="cstat-no" title="statement not covered" >debuggerModel.createRawLocationByURL(url,line,0);<span class="cstat-no" title="statement not covered" ></span>if(rawLocation)</span></span>
<span class="cstat-no" title="statement not covered" >new PerfUI.LineLevelProfile.Presentation(rawLocation,time,this._locationPool);e</span>lse <span class="cstat-no" title="statement not covered" >if(uiSourceCode)</span>
<span class="cstat-no" title="statement not covered" >uiSourceCode.addLineDecoration(line,PerfUI.LineLevelProfile.LineDecorator.type,time);}</span>}}};<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile.Presentation=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(rawLocation,time,locationPool){<span class="cstat-no" title="statement not covered" >this._time=time;<span class="cstat-no" title="statement not covered" >B</span>indings.debuggerWorkspaceBinding.createLiveLocation(rawLocation,this.updateLocation.bind(this),locationPool);}</span></span>
<span class="fstat-no" title="function not covered" >up</span>dateLocation(liveLocation){<span class="cstat-no" title="statement not covered" >if(this._uiLocation)</span>
<span class="cstat-no" title="statement not covered" >this._uiLocation.uiSourceCode.removeDecorationsForType(PerfUI.LineLevelProfile.LineDecorator.type);<span class="cstat-no" title="statement not covered" >t</span>his._uiLocation=liveLocation.uiLocation();<span class="cstat-no" title="statement not covered" >i</span>f(this._uiLocation){<span class="cstat-no" title="statement not covered" >this._uiLocation.uiSourceCode.addLineDecoration(this._uiLocation.lineNumber,PerfUI.LineLevelProfile.LineDecorator.type,this._time);}</span>}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile.LineDecorator=class{<span class="fstat-no" title="function not covered" >de</span>corate(uiSourceCode,textEditor){const gutterType=<span class="cstat-no" title="statement not covered" >'CodeMirror-gutter-performance';</span>const decorations=<span class="cstat-no" title="statement not covered" >uiSourceCode.decorationsForType(PerfUI.LineLevelProfile.LineDecorator.type);<span class="cstat-no" title="statement not covered" ></span>textEditor.uninstallGutter(gutterType);<span class="cstat-no" title="statement not covered" >i</span>f(!decorations||!decorations.size)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>extEditor.installGutter(gutterType,false);<span class="cstat-no" title="statement not covered" >f</span>or(const decoration of decorations){const time=(<span class="cstat-no" title="statement not covered" >decoration.data())</span>;const text=<span class="cstat-no" title="statement not covered" >Common.UIString('%.1f\xa0ms',time);</span>const intensity=<span class="cstat-no" title="statement not covered" >Number.constrain(Math.log10(1+2*time)/5,0.02,1);</span>const element=<span class="cstat-no" title="statement not covered" >createElementWithClass('div','text-editor-line-marker-performance');<span class="cstat-no" title="statement not covered" ></span>element.textContent=text;<span class="cstat-no" title="statement not covered" >e</span>lement.style.backgroundColor=`hsla(44, 100%, 50%, ${intensity.toFixed(3)})`;<span class="cstat-no" title="statement not covered" >t</span>extEditor.setGutterDecoration(decoration.range().startLine,gutterType,element);}</span>}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.LineLevelProfile.LineDecorator.type='performance';;<span class="cstat-no" title="statement not covered" ></span>PerfUI.uiLabelForNetworkPriority=<span class="fstat-no" title="function not covered" >fu</span>nction(priority){<span class="cstat-no" title="statement not covered" >return PerfUI._priorityUILabelMap().get(priority)||'';}</span>;<span class="cstat-no" title="statement not covered" >P</span>erfUI.uiLabelToNetworkPriority=<span class="fstat-no" title="function not covered" >fu</span>nction(priorityLabel){<span class="cstat-no" title="statement not covered" >if(!PerfUI._uiLabelToPriorityMapInstance){<span class="cstat-no" title="statement not covered" >PerfUI._uiLabelToPriorityMapInstance=new Map();<span class="cstat-no" title="statement not covered" >P</span>erfUI._priorityUILabelMap().forEach(<span class="fstat-no" title="function not covered" >(v</span>alue,key)=&gt;<span class="cstat-no" title="statement not covered" >PerfUI._uiLabelToPriorityMapInstance.set(value,key))</span>;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return PerfUI._uiLabelToPriorityMapInstance.get(priorityLabel)||'';}</span>;<span class="cstat-no" title="statement not covered" >PerfUI._priorityUILabelMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(PerfUI._priorityUILabelMapInstance)</span></span>
<span class="cstat-no" title="statement not covered" >return PerfUI._priorityUILabelMapInstance;c</span>onst map=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>map.set(Protocol.Network.ResourcePriority.VeryLow,Common.UIString('Lowest'));<span class="cstat-no" title="statement not covered" >m</span>ap.set(Protocol.Network.ResourcePriority.Low,Common.UIString('Low'));<span class="cstat-no" title="statement not covered" >m</span>ap.set(Protocol.Network.ResourcePriority.Medium,Common.UIString('Medium'));<span class="cstat-no" title="statement not covered" >m</span>ap.set(Protocol.Network.ResourcePriority.High,Common.UIString('High'));<span class="cstat-no" title="statement not covered" >m</span>ap.set(Protocol.Network.ResourcePriority.VeryHigh,Common.UIString('Highest'));<span class="cstat-no" title="statement not covered" >P</span>erfUI._priorityUILabelMapInstance=map;<span class="cstat-no" title="statement not covered" >r</span>eturn map;}</span>;<span class="cstat-no" title="statement not covered" >PerfUI.networkPriorityWeight=<span class="fstat-no" title="function not covered" >fu</span>nction(priority){<span class="cstat-no" title="statement not covered" >if(!PerfUI._networkPriorityWeights){const priorityMap=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>priorityMap.set(Protocol.Network.ResourcePriority.VeryLow,1);<span class="cstat-no" title="statement not covered" >p</span>riorityMap.set(Protocol.Network.ResourcePriority.Low,2);<span class="cstat-no" title="statement not covered" >p</span>riorityMap.set(Protocol.Network.ResourcePriority.Medium,3);<span class="cstat-no" title="statement not covered" >p</span>riorityMap.set(Protocol.Network.ResourcePriority.High,4);<span class="cstat-no" title="statement not covered" >p</span>riorityMap.set(Protocol.Network.ResourcePriority.VeryHigh,5);<span class="cstat-no" title="statement not covered" >P</span>erfUI._networkPriorityWeights=priorityMap;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return PerfUI._networkPriorityWeights.get(priority)||0;}</span>;;<span class="cstat-no" title="statement not covered" >PerfUI.OverviewGrid=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(prefix){<span class="cstat-no" title="statement not covered" >this.element=createElement('div');<span class="cstat-no" title="statement not covered" >t</span>his.element.id=prefix+'-overview-container';<span class="cstat-no" title="statement not covered" >t</span>his._grid=new PerfUI.TimelineGrid();<span class="cstat-no" title="statement not covered" >t</span>his._grid.element.id=prefix+'-overview-grid';<span class="cstat-no" title="statement not covered" >t</span>his._grid.setScrollTop(0);<span class="cstat-no" title="statement not covered" >t</span>his.element.appendChild(this._grid.element);<span class="cstat-no" title="statement not covered" >t</span>his._window=new PerfUI.OverviewGrid.Window(this.element,this._grid.dividersLabelBarElement);}</span></span>
<span class="fstat-no" title="function not covered" >cl</span>ientWidth(){<span class="cstat-no" title="statement not covered" >return this.element.clientWidth;}</span>
<span class="fstat-no" title="function not covered" >up</span>dateDividers(calculator){<span class="cstat-no" title="statement not covered" >this._grid.updateDividers(calculator);}</span>
<span class="fstat-no" title="function not covered" >ad</span>dEventDividers(dividers){<span class="cstat-no" title="statement not covered" >this._grid.addEventDividers(dividers);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveEventDividers(){<span class="cstat-no" title="statement not covered" >this._grid.removeEventDividers();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._window.reset();}</span>
<span class="fstat-no" title="function not covered" >wi</span>ndowLeft(){<span class="cstat-no" title="statement not covered" >return this._window.windowLeft;}</span>
<span class="fstat-no" title="function not covered" >wi</span>ndowRight(){<span class="cstat-no" title="statement not covered" >return this._window.windowRight;}</span>
<span class="fstat-no" title="function not covered" >se</span>tWindow(left,right){<span class="cstat-no" title="statement not covered" >this._window._setWindow(left,right);}</span>
<span class="fstat-no" title="function not covered" >ad</span>dEventListener(eventType,listener,thisObject){<span class="cstat-no" title="statement not covered" >return this._window.addEventListener(eventType,listener,thisObject);}</span>
<span class="fstat-no" title="function not covered" >se</span>tClickHandler(clickHandler){<span class="cstat-no" title="statement not covered" >this._window.setClickHandler(clickHandler);}</span>
<span class="fstat-no" title="function not covered" >zo</span>om(zoomFactor,referencePoint){<span class="cstat-no" title="statement not covered" >this._window._zoom(zoomFactor,referencePoint);}</span>
<span class="fstat-no" title="function not covered" >se</span>tResizeEnabled(enabled){<span class="cstat-no" title="statement not covered" >this._window.setEnabled(enabled);}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.OverviewGrid.MinSelectableSize=14;<span class="cstat-no" title="statement not covered" >P</span>erfUI.OverviewGrid.WindowScrollSpeedFactor=.3;<span class="cstat-no" title="statement not covered" >P</span>erfUI.OverviewGrid.ResizerOffset=3.5;<span class="cstat-no" title="statement not covered" >P</span>erfUI.OverviewGrid.Window=class extends Common.Object{<span class="fstat-no" title="function not covered" >co</span>nstructor(parentElement,dividersLabelBarElement){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._parentElement=parentElement;<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(this._parentElement,this._startWindowSelectorDragging.bind(this),this._windowSelectorDragging.bind(this),this._endWindowSelectorDragging.bind(this),'text',null);<span class="cstat-no" title="statement not covered" >i</span>f(dividersLabelBarElement){<span class="cstat-no" title="statement not covered" >UI.installDragHandle(dividersLabelBarElement,this._startWindowDragging.bind(this),this._windowDragging.bind(this),null,'-webkit-grabbing','-webkit-grab');}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._parentElement.addEventListener('mousewheel',this._onMouseWheel.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._parentElement.addEventListener('dblclick',this._resizeWindowMaximum.bind(this),true);<span class="cstat-no" title="statement not covered" >U</span>I.appendStyle(this._parentElement,'perf_ui/overviewGrid.css');<span class="cstat-no" title="statement not covered" >t</span>his._leftResizeElement=parentElement.createChild('div','overview-grid-window-resizer');<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(this._leftResizeElement,this._resizerElementStartDragging.bind(this),this._leftResizeElementDragging.bind(this),null,'ew-resize');<span class="cstat-no" title="statement not covered" >t</span>his._rightResizeElement=parentElement.createChild('div','overview-grid-window-resizer');<span class="cstat-no" title="statement not covered" >U</span>I.installDragHandle(this._rightResizeElement,this._resizerElementStartDragging.bind(this),this._rightResizeElementDragging.bind(this),null,'ew-resize');<span class="cstat-no" title="statement not covered" >t</span>his._leftCurtainElement=parentElement.createChild('div','window-curtain-left');<span class="cstat-no" title="statement not covered" >t</span>his._rightCurtainElement=parentElement.createChild('div','window-curtain-right');<span class="cstat-no" title="statement not covered" >t</span>his.reset();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this.windowLeft=0.0;<span class="cstat-no" title="statement not covered" >t</span>his.windowRight=1.0;<span class="cstat-no" title="statement not covered" >t</span>his.setEnabled(true);<span class="cstat-no" title="statement not covered" >t</span>his._updateCurtains();}</span>
<span class="fstat-no" title="function not covered" >se</span>tEnabled(enabled){<span class="cstat-no" title="statement not covered" >this._enabled=enabled;}</span>
<span class="fstat-no" title="function not covered" >se</span>tClickHandler(clickHandler){<span class="cstat-no" title="statement not covered" >this._clickHandler=clickHandler;}</span>
<span class="fstat-no" title="function not covered" >_r</span>esizerElementStartDragging(event){<span class="cstat-no" title="statement not covered" >if(!this._enabled)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his._resizerParentOffsetLeft=event.pageX-event.offsetX-event.target.offsetLeft;<span class="cstat-no" title="statement not covered" >e</span>vent.stopPropagation();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_l</span>eftResizeElementDragging(event){<span class="cstat-no" title="statement not covered" >this._resizeWindowLeft(event.pageX-this._resizerParentOffsetLeft);<span class="cstat-no" title="statement not covered" >e</span>vent.preventDefault();}</span>
<span class="fstat-no" title="function not covered" >_r</span>ightResizeElementDragging(event){<span class="cstat-no" title="statement not covered" >this._resizeWindowRight(event.pageX-this._resizerParentOffsetLeft);<span class="cstat-no" title="statement not covered" >e</span>vent.preventDefault();}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartWindowSelectorDragging(event){<span class="cstat-no" title="statement not covered" >if(!this._enabled)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >t</span>his._offsetLeft=this._parentElement.totalOffsetLeft();c</span>onst position=<span class="cstat-no" title="statement not covered" >event.x-this._offsetLeft;<span class="cstat-no" title="statement not covered" ></span>this._overviewWindowSelector=new PerfUI.OverviewGrid.WindowSelector(this._parentElement,position);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_w</span>indowSelectorDragging(event){<span class="cstat-no" title="statement not covered" >this._overviewWindowSelector._updatePosition(event.x-this._offsetLeft);<span class="cstat-no" title="statement not covered" >e</span>vent.preventDefault();}</span>
<span class="fstat-no" title="function not covered" >_e</span>ndWindowSelectorDragging(event){const window=<span class="cstat-no" title="statement not covered" >this._overviewWindowSelector._close(event.x-this._offsetLeft);<span class="cstat-no" title="statement not covered" ></span>delete this._overviewWindowSelector;c</span>onst clickThreshold=<span class="cstat-no" title="statement not covered" >3;<span class="cstat-no" title="statement not covered" ></span>if(window.end-window.start&lt;clickThreshold){<span class="cstat-no" title="statement not covered" >if(this._clickHandler&amp;&amp;this._clickHandler.call(null,event))</span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst middle=<span class="cstat-no" title="statement not covered" >window.end;<span class="cstat-no" title="statement not covered" ></span>window.start=Math.max(0,middle-PerfUI.OverviewGrid.MinSelectableSize/2);<span class="cstat-no" title="statement not covered" >w</span>indow.end=Math.min(this._parentElement.clientWidth,middle+PerfUI.OverviewGrid.MinSelectableSize/2);}</span>else <span class="cstat-no" title="statement not covered" >if(window.end-window.start&lt;PerfUI.OverviewGrid.MinSelectableSize){<span class="cstat-no" title="statement not covered" >if(this._parentElement.clientWidth-window.end&gt;PerfUI.OverviewGrid.MinSelectableSize)</span></span>
<span class="cstat-no" title="statement not covered" >window.end=window.start+PerfUI.OverviewGrid.MinSelectableSize;e</span>lse
<span class="cstat-no" title="statement not covered" >window.start=window.end-PerfUI.OverviewGrid.MinSelectableSize;}</span>
<span class="cstat-no" title="statement not covered" >this._setWindowPosition(window.start,window.end);}</span>
<span class="fstat-no" title="function not covered" >_s</span>tartWindowDragging(event){<span class="cstat-no" title="statement not covered" >this._dragStartPoint=event.pageX;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartLeft=this.windowLeft;<span class="cstat-no" title="statement not covered" >t</span>his._dragStartRight=this.windowRight;<span class="cstat-no" title="statement not covered" >e</span>vent.stopPropagation();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_w</span>indowDragging(event){<span class="cstat-no" title="statement not covered" >event.preventDefault();l</span>et delta=<span class="cstat-no" title="statement not covered" >(event.pageX-this._dragStartPoint)/this._parentElement.clientWidth;<span class="cstat-no" title="statement not covered" ></span>if(this._dragStartLeft+delta&lt;0)</span>
<span class="cstat-no" title="statement not covered" >delta=-this._dragStartLeft;<span class="cstat-no" title="statement not covered" >i</span>f(this._dragStartRight+delta&gt;1)</span>
<span class="cstat-no" title="statement not covered" >delta=1-this._dragStartRight;<span class="cstat-no" title="statement not covered" >t</span>his._setWindow(this._dragStartLeft+delta,this._dragStartRight+delta);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esizeWindowLeft(start){<span class="cstat-no" title="statement not covered" >if(start&lt;10)</span>
<span class="cstat-no" title="statement not covered" >start=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(start&gt;this._rightResizeElement.offsetLeft-4)</span>
<span class="cstat-no" title="statement not covered" >start=this._rightResizeElement.offsetLeft-4;<span class="cstat-no" title="statement not covered" >t</span>his._setWindowPosition(start,null);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esizeWindowRight(end){<span class="cstat-no" title="statement not covered" >if(end&gt;this._parentElement.clientWidth-10)</span>
<span class="cstat-no" title="statement not covered" >end=this._parentElement.clientWidth;e</span>lse <span class="cstat-no" title="statement not covered" >if(end&lt;this._leftResizeElement.offsetLeft+PerfUI.OverviewGrid.MinSelectableSize)</span>
<span class="cstat-no" title="statement not covered" >end=this._leftResizeElement.offsetLeft+PerfUI.OverviewGrid.MinSelectableSize;<span class="cstat-no" title="statement not covered" >t</span>his._setWindowPosition(null,end);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esizeWindowMaximum(){<span class="cstat-no" title="statement not covered" >this._setWindowPosition(0,this._parentElement.clientWidth);}</span>
<span class="fstat-no" title="function not covered" >_s</span>etWindow(windowLeft,windowRight){<span class="cstat-no" title="statement not covered" >this.windowLeft=windowLeft;<span class="cstat-no" title="statement not covered" >t</span>his.windowRight=windowRight;<span class="cstat-no" title="statement not covered" >t</span>his._updateCurtains();<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(PerfUI.OverviewGrid.Events.WindowChanged);}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateCurtains(){let left=<span class="cstat-no" title="statement not covered" >this.windowLeft;</span>let right=<span class="cstat-no" title="statement not covered" >this.windowRight;</span>const width=<span class="cstat-no" title="statement not covered" >right-left;</span>const widthInPixels=<span class="cstat-no" title="statement not covered" >width*this._parentElement.clientWidth;</span>const minWidthInPixels=<span class="cstat-no" title="statement not covered" >PerfUI.OverviewGrid.MinSelectableSize/2;<span class="cstat-no" title="statement not covered" ></span>if(widthInPixels&lt;minWidthInPixels){const factor=<span class="cstat-no" title="statement not covered" >minWidthInPixels/widthInPixels;<span class="cstat-no" title="statement not covered" ></span>left=((this.windowRight+this.windowLeft)-width*factor)/2;<span class="cstat-no" title="statement not covered" >r</span>ight=((this.windowRight+this.windowLeft)+width*factor)/2;}</span></span>
<span class="cstat-no" title="statement not covered" >this._leftResizeElement.style.left=(100*left).toFixed(2)+'%';<span class="cstat-no" title="statement not covered" >t</span>his._rightResizeElement.style.left=(100*right).toFixed(2)+'%';<span class="cstat-no" title="statement not covered" >t</span>his._leftCurtainElement.style.width=(100*left).toFixed(2)+'%';<span class="cstat-no" title="statement not covered" >t</span>his._rightCurtainElement.style.width=(100*(1-right)).toFixed(2)+'%';}</span>
<span class="fstat-no" title="function not covered" >_s</span>etWindowPosition(start,end){const clientWidth=<span class="cstat-no" title="statement not covered" >this._parentElement.clientWidth;</span>const windowLeft=<span class="cstat-no" title="statement not covered" >typeof start==='number'?start/clientWidth:this.windowLeft;</span>const windowRight=<span class="cstat-no" title="statement not covered" >typeof end==='number'?end/clientWidth:this.windowRight;<span class="cstat-no" title="statement not covered" ></span>this._setWindow(windowLeft,windowRight);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseWheel(event){<span class="cstat-no" title="statement not covered" >if(!this._enabled)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(typeof event.wheelDeltaY==='number'&amp;&amp;event.wheelDeltaY){const zoomFactor=<span class="cstat-no" title="statement not covered" >1.1;</span>const mouseWheelZoomSpeed=<span class="cstat-no" title="statement not covered" >1/120;</span>const reference=<span class="cstat-no" title="statement not covered" >event.offsetX/event.target.clientWidth;<span class="cstat-no" title="statement not covered" ></span>this._zoom(Math.pow(zoomFactor,-event.wheelDeltaY*mouseWheelZoomSpeed),reference);}</span></span>
<span class="cstat-no" title="statement not covered" >if(typeof event.wheelDeltaX==='number'&amp;&amp;event.wheelDeltaX){let offset=<span class="cstat-no" title="statement not covered" >Math.round(event.wheelDeltaX*PerfUI.OverviewGrid.WindowScrollSpeedFactor);</span>const windowLeft=<span class="cstat-no" title="statement not covered" >this._leftResizeElement.offsetLeft+PerfUI.OverviewGrid.ResizerOffset;</span>const windowRight=<span class="cstat-no" title="statement not covered" >this._rightResizeElement.offsetLeft+PerfUI.OverviewGrid.ResizerOffset;<span class="cstat-no" title="statement not covered" ></span>if(windowLeft-offset&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >offset=windowLeft;<span class="cstat-no" title="statement not covered" >i</span>f(windowRight-offset&gt;this._parentElement.clientWidth)</span>
<span class="cstat-no" title="statement not covered" >offset=windowRight-this._parentElement.clientWidth;<span class="cstat-no" title="statement not covered" >t</span>his._setWindowPosition(windowLeft-offset,windowRight-offset);<span class="cstat-no" title="statement not covered" >e</span>vent.preventDefault();}</span>}
<span class="fstat-no" title="function not covered" >_z</span>oom(factor,reference){let left=<span class="cstat-no" title="statement not covered" >this.windowLeft;</span>let right=<span class="cstat-no" title="statement not covered" >this.windowRight;</span>const windowSize=<span class="cstat-no" title="statement not covered" >right-left;</span>let newWindowSize=<span class="cstat-no" title="statement not covered" >factor*windowSize;<span class="cstat-no" title="statement not covered" ></span>if(newWindowSize&gt;1){<span class="cstat-no" title="statement not covered" >newWindowSize=1;<span class="cstat-no" title="statement not covered" >f</span>actor=newWindowSize/windowSize;}</span></span>
<span class="cstat-no" title="statement not covered" >left=reference+(left-reference)*factor;<span class="cstat-no" title="statement not covered" >l</span>eft=Number.constrain(left,0,1-newWindowSize);<span class="cstat-no" title="statement not covered" >r</span>ight=reference+(right-reference)*factor;<span class="cstat-no" title="statement not covered" >r</span>ight=Number.constrain(right,newWindowSize,1);<span class="cstat-no" title="statement not covered" >t</span>his._setWindow(left,right);}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.OverviewGrid.Events={WindowChanged:Symbol('WindowChanged')};<span class="cstat-no" title="statement not covered" >P</span>erfUI.OverviewGrid.WindowSelector=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(parent,position){<span class="cstat-no" title="statement not covered" >this._startPosition=position;<span class="cstat-no" title="statement not covered" >t</span>his._width=parent.offsetWidth;<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector=createElement('div');<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector.className='overview-grid-window-selector';<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector.style.left=this._startPosition+'px';<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector.style.right=this._width-this._startPosition+'px';<span class="cstat-no" title="statement not covered" >p</span>arent.appendChild(this._windowSelector);}</span></span>
<span class="fstat-no" title="function not covered" >_c</span>lose(position){<span class="cstat-no" title="statement not covered" >position=Math.max(0,Math.min(position,this._width));<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector.remove();<span class="cstat-no" title="statement not covered" >r</span>eturn this._startPosition&lt;position?{start:this._startPosition,end:position}:{start:position,end:this._startPosition};}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdatePosition(position){<span class="cstat-no" title="statement not covered" >position=Math.max(0,Math.min(position,this._width));<span class="cstat-no" title="statement not covered" >i</span>f(position&lt;this._startPosition){<span class="cstat-no" title="statement not covered" >this._windowSelector.style.left=position+'px';<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector.style.right=this._width-this._startPosition+'px';}</span>else{<span class="cstat-no" title="statement not covered" >this._windowSelector.style.left=this._startPosition+'px';<span class="cstat-no" title="statement not covered" >t</span>his._windowSelector.style.right=this._width-position+'px';}</span>}</span>};;<span class="cstat-no" title="statement not covered" >PerfUI.PieChart=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(size,formatter,showTotal){<span class="cstat-no" title="statement not covered" >this.element=createElement('div');<span class="cstat-no" title="statement not covered" >t</span>his._shadowRoot=UI.createShadowRootWithCoreStyles(this.element,'perf_ui/pieChart.css');c</span>onst root=<span class="cstat-no" title="statement not covered" >this._shadowRoot.createChild('div','root');</span>const svg=<span class="cstat-no" title="statement not covered" >this._createSVGChild(root,'svg');<span class="cstat-no" title="statement not covered" ></span>this._group=this._createSVGChild(svg,'g');<span class="cstat-no" title="statement not covered" >t</span>his._innerR=0.618;c</span>onst strokeWidth=<span class="cstat-no" title="statement not covered" >1/size;</span>let circle=<span class="cstat-no" title="statement not covered" >this._createSVGChild(this._group,'circle');<span class="cstat-no" title="statement not covered" ></span>circle.setAttribute('r',1);<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('stroke','hsl(0, 0%, 80%)');<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('fill','transparent');<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('stroke-width',strokeWidth);<span class="cstat-no" title="statement not covered" >c</span>ircle=this._createSVGChild(this._group,'circle');<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('r',this._innerR);<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('stroke','hsl(0, 0%, 80%)');<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('fill','transparent');<span class="cstat-no" title="statement not covered" >c</span>ircle.setAttribute('stroke-width',strokeWidth);<span class="cstat-no" title="statement not covered" >t</span>his._foregroundElement=root.createChild('div','pie-chart-foreground');<span class="cstat-no" title="statement not covered" >i</span>f(showTotal)</span></span>
<span class="cstat-no" title="statement not covered" >this._totalElement=this._foregroundElement.createChild('div','pie-chart-total');<span class="cstat-no" title="statement not covered" >t</span>his._formatter=formatter;<span class="cstat-no" title="statement not covered" >t</span>his._slices=[];<span class="cstat-no" title="statement not covered" >t</span>his._lastAngle=-Math.PI/2;<span class="cstat-no" title="statement not covered" >t</span>his._setSize(size);}</span>
<span class="fstat-no" title="function not covered" >se</span>tTotal(totalValue){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._slices.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._slices[i].remove();<span class="cstat-no" title="statement not covered" >t</span>his._slices=[];<span class="cstat-no" title="statement not covered" >t</span>his._totalValue=totalValue;<span class="cstat-no" title="statement not covered" >t</span>his._lastAngle=-Math.PI/2;l</span>et totalString;<span class="cstat-no" title="statement not covered" >if(totalValue)</span>
<span class="cstat-no" title="statement not covered" >totalString=this._formatter?this._formatter(totalValue):totalValue;e</span>lse
<span class="cstat-no" title="statement not covered" >totalString='';<span class="cstat-no" title="statement not covered" >i</span>f(this._totalElement)</span>
<span class="cstat-no" title="statement not covered" >this._totalElement.textContent=totalString;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etSize(value){<span class="cstat-no" title="statement not covered" >this._group.setAttribute('transform','scale('+(value/2)+') translate(1, 1) scale(0.99, 0.99)');c</span>onst size=<span class="cstat-no" title="statement not covered" >value+'px';<span class="cstat-no" title="statement not covered" ></span>this.element.style.width=size;<span class="cstat-no" title="statement not covered" >t</span>his.element.style.height=size;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dSlice(value,color){let sliceAngle=<span class="cstat-no" title="statement not covered" >value/this._totalValue*2*Math.PI;<span class="cstat-no" title="statement not covered" ></span>if(!isFinite(sliceAngle))</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span>liceAngle=Math.min(sliceAngle,2*Math.PI*0.9999);c</span>onst path=<span class="cstat-no" title="statement not covered" >this._createSVGChild(this._group,'path');</span>const x1=<span class="cstat-no" title="statement not covered" >Math.cos(this._lastAngle);</span>const y1=<span class="cstat-no" title="statement not covered" >Math.sin(this._lastAngle);<span class="cstat-no" title="statement not covered" ></span>this._lastAngle+=sliceAngle;c</span>onst x2=<span class="cstat-no" title="statement not covered" >Math.cos(this._lastAngle);</span>const y2=<span class="cstat-no" title="statement not covered" >Math.sin(this._lastAngle);</span>const r2=<span class="cstat-no" title="statement not covered" >this._innerR;</span>const x3=<span class="cstat-no" title="statement not covered" >x2*r2;</span>const y3=<span class="cstat-no" title="statement not covered" >y2*r2;</span>const x4=<span class="cstat-no" title="statement not covered" >x1*r2;</span>const y4=<span class="cstat-no" title="statement not covered" >y1*r2;</span>const largeArc=<span class="cstat-no" title="statement not covered" >sliceAngle&gt;Math.PI?1:0;<span class="cstat-no" title="statement not covered" ></span>path.setAttribute('d',`M${x1},${y1} A1,1,0,${largeArc},1,${x2},${y2} L${x3},${y3} A${r2},${r2},0,${largeArc},0,${x4},${y4} Z`);<span class="cstat-no" title="statement not covered" >p</span>ath.setAttribute('fill',color);<span class="cstat-no" title="statement not covered" >t</span>his._slices.push(path);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateSVGChild(parent,childType){const child=<span class="cstat-no" title="statement not covered" >parent.ownerDocument.createElementNS('http://www.w3.org/2000/svg',childType);<span class="cstat-no" title="statement not covered" ></span>parent.appendChild(child);<span class="cstat-no" title="statement not covered" >r</span>eturn child;}</span>};;<span class="cstat-no" title="statement not covered" >PerfUI.TimelineGrid=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.element=createElement('div');<span class="cstat-no" title="statement not covered" >U</span>I.appendStyle(this.element,'perf_ui/timelineGrid.css');<span class="cstat-no" title="statement not covered" >t</span>his._dividersElement=this.element.createChild('div','resources-dividers');<span class="cstat-no" title="statement not covered" >t</span>his._gridHeaderElement=createElement('div');<span class="cstat-no" title="statement not covered" >t</span>his._gridHeaderElement.classList.add('timeline-grid-header');<span class="cstat-no" title="statement not covered" >t</span>his._eventDividersElement=this._gridHeaderElement.createChild('div','resources-event-dividers');<span class="cstat-no" title="statement not covered" >t</span>his._dividersLabelBarElement=this._gridHeaderElement.createChild('div','resources-dividers-label-bar');<span class="cstat-no" title="statement not covered" >t</span>his.element.appendChild(this._gridHeaderElement);}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic calculateGridOffsets(calculator,freeZoneAtLeft){const minGridSlicePx=<span class="cstat-no" title="statement not covered" >64;</span>const clientWidth=<span class="cstat-no" title="statement not covered" >calculator.computePosition(calculator.maximumBoundary());</span>let dividersCount=<span class="cstat-no" title="statement not covered" >clientWidth/minGridSlicePx;</span>let gridSliceTime=<span class="cstat-no" title="statement not covered" >calculator.boundarySpan()/dividersCount;</span>const pixelsPerTime=<span class="cstat-no" title="statement not covered" >clientWidth/calculator.boundarySpan();</span>const logGridSliceTime=<span class="cstat-no" title="statement not covered" >Math.ceil(Math.log(gridSliceTime)/Math.LN10);<span class="cstat-no" title="statement not covered" ></span>gridSliceTime=Math.pow(10,logGridSliceTime);<span class="cstat-no" title="statement not covered" >i</span>f(gridSliceTime*pixelsPerTime&gt;=5*minGridSlicePx)</span>
<span class="cstat-no" title="statement not covered" >gridSliceTime=gridSliceTime/5;<span class="cstat-no" title="statement not covered" >i</span>f(gridSliceTime*pixelsPerTime&gt;=2*minGridSlicePx)</span>
<span class="cstat-no" title="statement not covered" >gridSliceTime=gridSliceTime/2;c</span>onst firstDividerTime=<span class="cstat-no" title="statement not covered" >Math.ceil((calculator.minimumBoundary()-calculator.zeroTime())/gridSliceTime)*gridSliceTime+</span>
calculator.zeroTime();let lastDividerTime=<span class="cstat-no" title="statement not covered" >calculator.maximumBoundary();<span class="cstat-no" title="statement not covered" ></span>lastDividerTime+=minGridSlicePx/pixelsPerTime;<span class="cstat-no" title="statement not covered" >d</span>ividersCount=Math.ceil((lastDividerTime-firstDividerTime)/gridSliceTime);<span class="cstat-no" title="statement not covered" >i</span>f(!gridSliceTime)</span>
<span class="cstat-no" title="statement not covered" >dividersCount=0;c</span>onst offsets=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;dividersCount;++i){const time=<span class="cstat-no" title="statement not covered" >firstDividerTime+gridSliceTime*i;<span class="cstat-no" title="statement not covered" ></span>if(calculator.computePosition(time)&lt;freeZoneAtLeft)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >o</span>ffsets.push({position:Math.floor(calculator.computePosition(time)),time:time});}</span>
<span class="cstat-no" title="statement not covered" >return{offsets:offsets,precision:Math.max(0,-Math.floor(Math.log(gridSliceTime*1.01)/Math.LN10))};}</span>
<span class="fstat-no" title="function not covered" >st</span>atic drawCanvasGrid(context,dividersData){<span class="cstat-no" title="statement not covered" >context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.scale(window.devicePixelRatio,window.devicePixelRatio);c</span>onst height=<span class="cstat-no" title="statement not covered" >Math.floor(context.canvas.height/window.devicePixelRatio);<span class="cstat-no" title="statement not covered" ></span>context.strokeStyle=UI.themeSupport.patchColorText('rgba(0, 0, 0, 0.1)',UI.ThemeSupport.ColorUsage.Foreground);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineWidth=1;<span class="cstat-no" title="statement not covered" >c</span>ontext.translate(0.5,0.5);<span class="cstat-no" title="statement not covered" >c</span>ontext.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const offsetInfo of dividersData.offsets){<span class="cstat-no" title="statement not covered" >context.moveTo(offsetInfo.position,0);<span class="cstat-no" title="statement not covered" >c</span>ontext.lineTo(offsetInfo.position,height);}</span></span>
<span class="cstat-no" title="statement not covered" >context.stroke();<span class="cstat-no" title="statement not covered" >c</span>ontext.restore();}</span>
<span class="fstat-no" title="function not covered" >st</span>atic drawCanvasHeaders(context,dividersData,formatTimeFunction,paddingTop,headerHeight,freeZoneAtLeft){<span class="cstat-no" title="statement not covered" >context.save();<span class="cstat-no" title="statement not covered" >c</span>ontext.scale(window.devicePixelRatio,window.devicePixelRatio);c</span>onst width=<span class="cstat-no" title="statement not covered" >Math.ceil(context.canvas.width/window.devicePixelRatio);<span class="cstat-no" title="statement not covered" ></span>context.beginPath();<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=UI.themeSupport.patchColorText('rgba(255, 255, 255, 0.5)',UI.ThemeSupport.ColorUsage.Background);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillRect(0,0,width,headerHeight);<span class="cstat-no" title="statement not covered" >c</span>ontext.fillStyle=UI.themeSupport.patchColorText('#333',UI.ThemeSupport.ColorUsage.Foreground);<span class="cstat-no" title="statement not covered" >c</span>ontext.textBaseline='hanging';<span class="cstat-no" title="statement not covered" >c</span>ontext.font='11px '+Host.fontFamily();c</span>onst paddingRight=<span class="cstat-no" title="statement not covered" >4;<span class="cstat-no" title="statement not covered" ></span>for(const offsetInfo of dividersData.offsets){const text=<span class="cstat-no" title="statement not covered" >formatTimeFunction(offsetInfo.time);</span>const textWidth=<span class="cstat-no" title="statement not covered" >context.measureText(text).width;</span>const textPosition=<span class="cstat-no" title="statement not covered" >offsetInfo.position-textWidth-paddingRight;<span class="cstat-no" title="statement not covered" ></span>if(!freeZoneAtLeft||freeZoneAtLeft&lt;textPosition)</span></span>
<span class="cstat-no" title="statement not covered" >context.fillText(text,textPosition,paddingTop);}</span>
<span class="cstat-no" title="statement not covered" >context.restore();}</span>
<span class="fstat-no" title="function not covered" >ge</span>t dividersElement(){<span class="cstat-no" title="statement not covered" >return this._dividersElement;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t dividersLabelBarElement(){<span class="cstat-no" title="statement not covered" >return this._dividersLabelBarElement;}</span>
<span class="fstat-no" title="function not covered" >re</span>moveDividers(){<span class="cstat-no" title="statement not covered" >this._dividersElement.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._dividersLabelBarElement.removeChildren();}</span>
<span class="fstat-no" title="function not covered" >up</span>dateDividers(calculator,freeZoneAtLeft){const dividersData=<span class="cstat-no" title="statement not covered" >PerfUI.TimelineGrid.calculateGridOffsets(calculator,freeZoneAtLeft);</span>const dividerOffsets=<span class="cstat-no" title="statement not covered" >dividersData.offsets;</span>const precision=<span class="cstat-no" title="statement not covered" >dividersData.precision;</span>const dividersElementClientWidth=<span class="cstat-no" title="statement not covered" >this._dividersElement.clientWidth;</span>let divider=(<span class="cstat-no" title="statement not covered" >this._dividersElement.firstChild)</span>;let dividerLabelBar=(<span class="cstat-no" title="statement not covered" >this._dividersLabelBarElement.firstChild)</span>;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;dividerOffsets.length;++i){<span class="cstat-no" title="statement not covered" >if(!divider){<span class="cstat-no" title="statement not covered" >divider=createElement('div');<span class="cstat-no" title="statement not covered" >d</span>ivider.className='resources-divider';<span class="cstat-no" title="statement not covered" >t</span>his._dividersElement.appendChild(divider);<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar=createElement('div');<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar.className='resources-divider';c</span>onst label=<span class="cstat-no" title="statement not covered" >createElement('div');<span class="cstat-no" title="statement not covered" ></span>label.className='resources-divider-label';<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar._labelElement=label;<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar.appendChild(label);<span class="cstat-no" title="statement not covered" >t</span>his._dividersLabelBarElement.appendChild(dividerLabelBar);}</span></span></span>
const time=<span class="cstat-no" title="statement not covered" >dividerOffsets[i].time;</span>const position=<span class="cstat-no" title="statement not covered" >dividerOffsets[i].position;<span class="cstat-no" title="statement not covered" ></span>dividerLabelBar._labelElement.textContent=calculator.formatValue(time,precision);c</span>onst percentLeft=<span class="cstat-no" title="statement not covered" >100*position/dividersElementClientWidth;<span class="cstat-no" title="statement not covered" ></span>divider.style.left=percentLeft+'%';<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar.style.left=percentLeft+'%';<span class="cstat-no" title="statement not covered" >d</span>ivider=(divider.nextSibling);<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar=(dividerLabelBar.nextSibling);}</span>
<span class="cstat-no" title="statement not covered" >while(divider){const nextDivider=<span class="cstat-no" title="statement not covered" >divider.nextSibling;<span class="cstat-no" title="statement not covered" ></span>this._dividersElement.removeChild(divider);<span class="cstat-no" title="statement not covered" >d</span>ivider=nextDivider;}</span></span>
<span class="cstat-no" title="statement not covered" >while(dividerLabelBar){const nextDivider=<span class="cstat-no" title="statement not covered" >dividerLabelBar.nextSibling;<span class="cstat-no" title="statement not covered" ></span>this._dividersLabelBarElement.removeChild(dividerLabelBar);<span class="cstat-no" title="statement not covered" >d</span>ividerLabelBar=nextDivider;}</span></span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dEventDivider(divider){<span class="cstat-no" title="statement not covered" >this._eventDividersElement.appendChild(divider);}</span>
<span class="fstat-no" title="function not covered" >ad</span>dEventDividers(dividers){<span class="cstat-no" title="statement not covered" >this._gridHeaderElement.removeChild(this._eventDividersElement);<span class="cstat-no" title="statement not covered" >f</span>or(const divider of dividers)</span>
<span class="cstat-no" title="statement not covered" >this._eventDividersElement.appendChild(divider);<span class="cstat-no" title="statement not covered" >t</span>his._gridHeaderElement.appendChild(this._eventDividersElement);}</span>
<span class="fstat-no" title="function not covered" >re</span>moveEventDividers(){<span class="cstat-no" title="statement not covered" >this._eventDividersElement.removeChildren();}</span>
<span class="fstat-no" title="function not covered" >hi</span>deEventDividers(){<span class="cstat-no" title="statement not covered" >this._eventDividersElement.classList.add('hidden');}</span>
<span class="fstat-no" title="function not covered" >sh</span>owEventDividers(){<span class="cstat-no" title="statement not covered" >this._eventDividersElement.classList.remove('hidden');}</span>
<span class="fstat-no" title="function not covered" >hi</span>deDividers(){<span class="cstat-no" title="statement not covered" >this._dividersElement.classList.add('hidden');}</span>
<span class="fstat-no" title="function not covered" >sh</span>owDividers(){<span class="cstat-no" title="statement not covered" >this._dividersElement.classList.remove('hidden');}</span>
<span class="fstat-no" title="function not covered" >se</span>tScrollTop(scrollTop){<span class="cstat-no" title="statement not covered" >this._dividersLabelBarElement.style.top=scrollTop+'px';<span class="cstat-no" title="statement not covered" >t</span>his._eventDividersElement.style.top=scrollTop+'px';}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.TimelineGrid.DividersData;<span class="cstat-no" title="statement not covered" >P</span>erfUI.TimelineGrid.Calculator=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>erfUI.TimelineGrid.Calculator.prototype={computePosition(time){},formatValue(time,precision){},minimumBoundary(){},zeroTime(){},maximumBoundary(){},boundarySpan(){}};;<span class="cstat-no" title="statement not covered" ></span>PerfUI.TimelineOverviewPane=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(prefix){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.element.id=prefix+'-overview-pane';<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator=new PerfUI.TimelineOverviewCalculator();<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid=new PerfUI.OverviewGrid(prefix);<span class="cstat-no" title="statement not covered" >t</span>his.element.appendChild(this._overviewGrid.element);<span class="cstat-no" title="statement not covered" >t</span>his._cursorArea=this._overviewGrid.element.createChild('div','overview-grid-cursor-area');<span class="cstat-no" title="statement not covered" >t</span>his._cursorElement=this._overviewGrid.element.createChild('div','overview-grid-cursor-position');<span class="cstat-no" title="statement not covered" >t</span>his._cursorArea.addEventListener('mousemove',this._onMouseMove.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._cursorArea.addEventListener('mouseleave',this._hideCursor.bind(this),true);<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.setResizeEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.addEventListener(PerfUI.OverviewGrid.Events.WindowChanged,this._onWindowChanged,this);<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.setClickHandler(this._onClick.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._overviewControls=[];<span class="cstat-no" title="statement not covered" >t</span>his._markers=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._overviewInfo=new PerfUI.TimelineOverviewPane.OverviewInfo(this._cursorElement);<span class="cstat-no" title="statement not covered" >t</span>his._updateThrottler=new Common.Throttler(100);<span class="cstat-no" title="statement not covered" >t</span>his._cursorEnabled=false;<span class="cstat-no" title="statement not covered" >t</span>his._cursorPosition=0;<span class="cstat-no" title="statement not covered" >t</span>his._lastWidth=0;}</span></span>
<span class="fstat-no" title="function not covered" >_o</span>nMouseMove(event){<span class="cstat-no" title="statement not covered" >if(!this._cursorEnabled)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._cursorPosition=event.offsetX+event.target.offsetLeft;<span class="cstat-no" title="statement not covered" >t</span>his._cursorElement.style.left=this._cursorPosition+'px';<span class="cstat-no" title="statement not covered" >t</span>his._cursorElement.style.visibility='visible';<span class="cstat-no" title="statement not covered" >t</span>his._overviewInfo.setContent(this._buildOverviewInfo());}</span>
<span class="fstat-no" title="function not covered" >as</span>ync _buildOverviewInfo(){const document=<span class="cstat-no" title="statement not covered" >this.element.ownerDocument;</span>const x=<span class="cstat-no" title="statement not covered" >this._cursorPosition;</span>const elements=<span class="cstat-no" title="statement not covered" >await Promise.all(this._overviewControls.map(<span class="fstat-no" title="function not covered" >co</span>ntrol=&gt;<span class="cstat-no" title="statement not covered" >control.overviewInfoPromise(x))</span>);</span>const fragment=<span class="cstat-no" title="statement not covered" >document.createDocumentFragment();<span class="cstat-no" title="statement not covered" ></span>elements.remove(null);<span class="cstat-no" title="statement not covered" >f</span>ragment.appendChildren.apply(fragment,elements);<span class="cstat-no" title="statement not covered" >r</span>eturn fragment;}</span>
<span class="fstat-no" title="function not covered" >_h</span>ideCursor(){<span class="cstat-no" title="statement not covered" >this._cursorElement.style.visibility='hidden';<span class="cstat-no" title="statement not covered" >t</span>his._overviewInfo.hide();}</span>
<span class="fstat-no" title="function not covered" >wa</span>sShown(){<span class="cstat-no" title="statement not covered" >this._update();}</span>
<span class="fstat-no" title="function not covered" >wi</span>llHide(){<span class="cstat-no" title="statement not covered" >this._overviewInfo.hide();}</span>
<span class="fstat-no" title="function not covered" >on</span>Resize(){const width=<span class="cstat-no" title="statement not covered" >this.element.offsetWidth;<span class="cstat-no" title="statement not covered" ></span>if(width===this._lastWidth)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._lastWidth=width;<span class="cstat-no" title="statement not covered" >t</span>his.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >se</span>tOverviewControls(overviewControls){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._overviewControls.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._overviewControls[i].dispose();<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;overviewControls.length;++i){<span class="cstat-no" title="statement not covered" >overviewControls[i].setCalculator(this._overviewCalculator);<span class="cstat-no" title="statement not covered" >o</span>verviewControls[i].show(this._overviewGrid.element);}</span></span>
<span class="cstat-no" title="statement not covered" >this._overviewControls=overviewControls;<span class="cstat-no" title="statement not covered" >t</span>his._update();}</span>
<span class="fstat-no" title="function not covered" >se</span>tBounds(minimumBoundary,maximumBoundary){<span class="cstat-no" title="statement not covered" >this._overviewCalculator.setBounds(minimumBoundary,maximumBoundary);<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.setResizeEnabled(true);<span class="cstat-no" title="statement not covered" >t</span>his._cursorEnabled=true;}</span>
<span class="fstat-no" title="function not covered" >sc</span>heduleUpdate(){<span class="cstat-no" title="statement not covered" >this._updateThrottler.schedule(process.bind(this));f</span>unction <span class="fstat-no" title="function not covered" >process(</span>){<span class="cstat-no" title="statement not covered" >this._update();<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve();}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdate(){<span class="cstat-no" title="statement not covered" >if(!this.isShowing())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator.setDisplayWidth(this._overviewGrid.clientWidth());<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this._overviewControls.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._overviewControls[i].update();<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.updateDividers(this._overviewCalculator);<span class="cstat-no" title="statement not covered" >t</span>his._updateMarkers();<span class="cstat-no" title="statement not covered" >t</span>his._updateWindow();}</span>
<span class="fstat-no" title="function not covered" >se</span>tMarkers(markers){<span class="cstat-no" title="statement not covered" >this._markers=markers;}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateMarkers(){const filteredMarkers=<span class="cstat-no" title="statement not covered" >new Map();<span class="cstat-no" title="statement not covered" ></span>for(const time of this._markers.keys()){const marker=<span class="cstat-no" title="statement not covered" >this._markers.get(time);</span>const position=<span class="cstat-no" title="statement not covered" >Math.round(this._overviewCalculator.computePosition(time));<span class="cstat-no" title="statement not covered" ></span>if(filteredMarkers.has(position))</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span>ilteredMarkers.set(position,marker);<span class="cstat-no" title="statement not covered" >m</span>arker.style.left=position+'px';}</span>
<span class="cstat-no" title="statement not covered" >this._overviewGrid.removeEventDividers();<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.addEventDividers(filteredMarkers.valuesArray());}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this._windowStartTime=0;<span class="cstat-no" title="statement not covered" >t</span>his._windowEndTime=Infinity;<span class="cstat-no" title="statement not covered" >t</span>his._overviewCalculator.reset();<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.reset();<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.setResizeEnabled(false);<span class="cstat-no" title="statement not covered" >t</span>his._cursorEnabled=false;<span class="cstat-no" title="statement not covered" >t</span>his._hideCursor();<span class="cstat-no" title="statement not covered" >t</span>his._markers=new Map();<span class="cstat-no" title="statement not covered" >f</span>or(const control of this._overviewControls)</span>
<span class="cstat-no" title="statement not covered" >control.reset();<span class="cstat-no" title="statement not covered" >t</span>his._overviewInfo.hide();<span class="cstat-no" title="statement not covered" >t</span>his.scheduleUpdate();}</span>
<span class="fstat-no" title="function not covered" >_o</span>nClick(event){<span class="cstat-no" title="statement not covered" >return this._overviewControls.some(<span class="fstat-no" title="function not covered" >co</span>ntrol=&gt;<span class="cstat-no" title="statement not covered" >control.onClick(event))</span>;}</span>
<span class="fstat-no" title="function not covered" >_o</span>nWindowChanged(event){<span class="cstat-no" title="statement not covered" >if(this._muteOnWindowChanged)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!this._overviewControls.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst absoluteMin=<span class="cstat-no" title="statement not covered" >this._overviewCalculator.minimumBoundary();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >this._overviewCalculator.maximumBoundary()-absoluteMin;</span>const windowTimes=<span class="cstat-no" title="statement not covered" >{startTime:absoluteMin+timeSpan*this._overviewGrid.windowLeft(),endTime:absoluteMin+timeSpan*this._overviewGrid.windowRight()};<span class="cstat-no" title="statement not covered" ></span>this._windowStartTime=windowTimes.startTime;<span class="cstat-no" title="statement not covered" >t</span>his._windowEndTime=windowTimes.endTime;<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(PerfUI.TimelineOverviewPane.Events.WindowChanged,windowTimes);}</span>
<span class="fstat-no" title="function not covered" >se</span>tWindowTimes(startTime,endTime){<span class="cstat-no" title="statement not covered" >if(startTime===this._windowStartTime&amp;&amp;endTime===this._windowEndTime)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._windowStartTime=startTime;<span class="cstat-no" title="statement not covered" >t</span>his._windowEndTime=endTime;<span class="cstat-no" title="statement not covered" >t</span>his._updateWindow();<span class="cstat-no" title="statement not covered" >t</span>his.dispatchEventToListeners(PerfUI.TimelineOverviewPane.Events.WindowChanged,{startTime:startTime,endTime:endTime});}</span>
<span class="fstat-no" title="function not covered" >_u</span>pdateWindow(){<span class="cstat-no" title="statement not covered" >if(!this._overviewControls.length)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst absoluteMin=<span class="cstat-no" title="statement not covered" >this._overviewCalculator.minimumBoundary();</span>const timeSpan=<span class="cstat-no" title="statement not covered" >this._overviewCalculator.maximumBoundary()-absoluteMin;</span>const haveRecords=<span class="cstat-no" title="statement not covered" >absoluteMin&gt;0;</span>const left=<span class="cstat-no" title="statement not covered" >haveRecords&amp;&amp;this._windowStartTime?Math.min((this._windowStartTime-absoluteMin)/timeSpan,1):0;</span>const right=<span class="cstat-no" title="statement not covered" >haveRecords&amp;&amp;this._windowEndTime&lt;Infinity?(this._windowEndTime-absoluteMin)/timeSpan:1;<span class="cstat-no" title="statement not covered" ></span>this._muteOnWindowChanged=true;<span class="cstat-no" title="statement not covered" >t</span>his._overviewGrid.setWindow(left,right);<span class="cstat-no" title="statement not covered" >t</span>his._muteOnWindowChanged=false;}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.TimelineOverviewPane.Events={WindowChanged:Symbol('WindowChanged')};<span class="cstat-no" title="statement not covered" >P</span>erfUI.TimelineOverviewCalculator=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.reset();}</span></span>
<span class="fstat-no" title="function not covered" >co</span>mputePosition(time){<span class="cstat-no" title="statement not covered" >return(time-this._minimumBoundary)/this.boundarySpan()*this._workingArea;}</span>
<span class="fstat-no" title="function not covered" >po</span>sitionToTime(position){<span class="cstat-no" title="statement not covered" >return position/this._workingArea*this.boundarySpan()+this._minimumBoundary;}</span>
<span class="fstat-no" title="function not covered" >se</span>tBounds(minimumBoundary,maximumBoundary){<span class="cstat-no" title="statement not covered" >this._minimumBoundary=minimumBoundary;<span class="cstat-no" title="statement not covered" >t</span>his._maximumBoundary=maximumBoundary;}</span>
<span class="fstat-no" title="function not covered" >se</span>tDisplayWidth(clientWidth){<span class="cstat-no" title="statement not covered" >this._workingArea=clientWidth;}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){<span class="cstat-no" title="statement not covered" >this.setBounds(0,100);}</span>
<span class="fstat-no" title="function not covered" >fo</span>rmatValue(value,precision){<span class="cstat-no" title="statement not covered" >return Number.preciseMillisToString(value-this.zeroTime(),precision);}</span>
<span class="fstat-no" title="function not covered" >ma</span>ximumBoundary(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundary;}</span>
<span class="fstat-no" title="function not covered" >mi</span>nimumBoundary(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundary;}</span>
<span class="fstat-no" title="function not covered" >ze</span>roTime(){<span class="cstat-no" title="statement not covered" >return this._minimumBoundary;}</span>
<span class="fstat-no" title="function not covered" >bo</span>undarySpan(){<span class="cstat-no" title="statement not covered" >return this._maximumBoundary-this._minimumBoundary;}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.TimelineOverview=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >P</span>erfUI.TimelineOverview.prototype={show(parentElement,insertBefore){},update(){},dispose(){},reset(){},overviewInfoPromise(x){},onClick(event){},};<span class="cstat-no" title="statement not covered" >P</span>erfUI.TimelineOverviewBase=class extends UI.VBox{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._calculator=null;<span class="cstat-no" title="statement not covered" >t</span>his._canvas=this.element.createChild('canvas','fill');<span class="cstat-no" title="statement not covered" >t</span>his._context=this._canvas.getContext('2d');}</span></span>
<span class="fstat-no" title="function not covered" >wi</span>dth(){<span class="cstat-no" title="statement not covered" >return this._canvas.width;}</span>
<span class="fstat-no" title="function not covered" >he</span>ight(){<span class="cstat-no" title="statement not covered" >return this._canvas.height;}</span>
<span class="fstat-no" title="function not covered" >co</span>ntext(){<span class="cstat-no" title="statement not covered" >return this._context;}</span>
<span class="fstat-no" title="function not covered" >ca</span>lculator(){<span class="cstat-no" title="statement not covered" >return this._calculator;}</span>
<span class="fstat-no" title="function not covered" >up</span>date(){<span class="cstat-no" title="statement not covered" >this.resetCanvas();}</span>
<span class="fstat-no" title="function not covered" >di</span>spose(){<span class="cstat-no" title="statement not covered" >this.detach();}</span>
<span class="fstat-no" title="function not covered" >re</span>set(){}
<span class="fstat-no" title="function not covered" >ov</span>erviewInfoPromise(x){<span class="cstat-no" title="statement not covered" >return Promise.resolve((null));}</span>
<span class="fstat-no" title="function not covered" >se</span>tCalculator(calculator){<span class="cstat-no" title="statement not covered" >this._calculator=calculator;}</span>
<span class="fstat-no" title="function not covered" >on</span>Click(event){<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >re</span>setCanvas(){<span class="cstat-no" title="statement not covered" >if(this.element.clientWidth)</span>
<span class="cstat-no" title="statement not covered" >this.setCanvasSize(this.element.clientWidth,this.element.clientHeight);}</span>
<span class="fstat-no" title="function not covered" >se</span>tCanvasSize(width,height){<span class="cstat-no" title="statement not covered" >this._canvas.width=width*window.devicePixelRatio;<span class="cstat-no" title="statement not covered" >t</span>his._canvas.height=height*window.devicePixelRatio;}</span>};<span class="cstat-no" title="statement not covered" >PerfUI.TimelineOverviewPane.OverviewInfo=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(anchor){<span class="cstat-no" title="statement not covered" >this._anchorElement=anchor;<span class="cstat-no" title="statement not covered" >t</span>his._glassPane=new UI.GlassPane();<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setPointerEventsBehavior(UI.GlassPane.PointerEventsBehavior.PierceContents);<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setMarginBehavior(UI.GlassPane.MarginBehavior.Arrow);<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setSizeBehavior(UI.GlassPane.SizeBehavior.MeasureContent);<span class="cstat-no" title="statement not covered" >t</span>his._visible=false;<span class="cstat-no" title="statement not covered" >t</span>his._element=UI.createShadowRootWithCoreStyles(this._glassPane.contentElement,'perf_ui/timelineOverviewInfo.css').createChild('div','overview-info');}</span></span>
<span class="fstat-no" title="function not covered" >as</span>ync setContent(contentPromise){<span class="cstat-no" title="statement not covered" >this._visible=true;c</span>onst content=<span class="cstat-no" title="statement not covered" >await contentPromise;<span class="cstat-no" title="statement not covered" ></span>if(!this._visible)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._element.removeChildren();<span class="cstat-no" title="statement not covered" >t</span>his._element.appendChild(content);<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.setContentAnchorBox(this._anchorElement.boxInWindow());<span class="cstat-no" title="statement not covered" >i</span>f(!this._glassPane.isShowing())</span>
<span class="cstat-no" title="statement not covered" >this._glassPane.show((this._anchorElement.ownerDocument));}</span>
<span class="fstat-no" title="function not covered" >hi</span>de(){<span class="cstat-no" title="statement not covered" >this._visible=false;<span class="cstat-no" title="statement not covered" >t</span>his._glassPane.hide();}</span>};;<span class="cstat-no" title="statement not covered" >Runtime.cachedResources["perf_ui/chartViewport.css"]="/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.chart-viewport-v-scroll {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    overflow-x: hidden;\n    z-index: 200;\n    padding-left: 1px;\n}\n\n.chart-viewport-v-scroll.always-show-scrollbar {\n    overflow-y: scroll;\n}\n\n/* force non overlay scrollbars for Mac */\n:host-context(.platform-mac) .chart-viewport-v-scroll {\n    right: 2px;\n    top: 3px;\n    bottom: 3px;\n}\n\n:host-context(.platform-mac) ::-webkit-scrollbar {\n    width: 8px;\n}\n\n:host-context(.platform-mac) ::-webkit-scrollbar-thumb {\n    background-color: hsla(0, 0%, 56%, 0.6);\n    border-radius: 50px;\n}\n\n:host-context(.platform-mac) .chart-viewport-v-scroll:hover::-webkit-scrollbar-thumb {\n    background-color: hsla(0, 0%, 25%, 0.6);\n}\n\n/* force non overlay scrollbars for Aura Overlay Scrollbar enabled */\n:host-context(.overlay-scrollbar-enabled) ::-webkit-scrollbar {\n    width: 10px;\n}\n\n:host-context(.overlay-scrollbar-enabled) ::-webkit-scrollbar-thumb {\n    background-color: hsla(0, 0%, 0%, 0.5);\n}\n\n:host-context(.overlay-scrollbar-enabled) .chart-viewport-v-scroll:hover::-webkit-scrollbar-thumb {\n    background-color: hsla(0, 0%, 0%, 0.7);\n}\n\n.chart-viewport-selection-overlay {\n    position: absolute;\n    z-index: 100;\n    background-color: rgba(56, 121, 217, 0.3);\n    border-color: rgb(16, 81, 177);\n    border-width: 0 1px;\n    border-style: solid;\n    pointer-events: none;\n    top: 0;\n    bottom: 0;\n    text-align: center;\n}\n\n.chart-viewport-selection-overlay .time-span {\n    white-space: nowrap;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\n/*# sourceURL=perf_ui/chartViewport.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["perf_ui/filmStripView.css"]="/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.film-strip-view {\n    overflow-x: auto;\n    overflow-y: hidden;\n    align-content: flex-start;\n    min-height: 81px;\n}\n\n.film-strip-view.time-based .frame .time {\n    display: none;\n}\n\n.film-strip-view .label {\n    margin: auto;\n    font-size: 18px;\n    color: #999;\n}\n\n.film-strip-view .frame {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 4px;\n    flex: none;\n    cursor: pointer;\n}\n\n.film-strip-view .frame-limit-reached {\n    font-size: 24px;\n    color: #888;\n    justify-content: center;\n    display: inline-flex;\n    flex-direction: column;\n    flex: none;\n}\n\n.film-strip-view .frame .thumbnail {\n    min-width: 24px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    pointer-events: none;\n    margin: 4px 0 2px;\n    border: 2px solid transparent;\n}\n\n.film-strip-view .frame:hover .thumbnail {\n    border-color: #FBCA46;\n}\n\n.film-strip-view .frame .thumbnail img {\n    height: auto;\n    width: auto;\n    max-width: 80px;\n    max-height: 50px;\n    pointer-events: none;\n    box-shadow: 0 0 3px #bbb;\n    flex: 0 0 auto;\n}\n\n.film-strip-view .frame:hover .thumbnail img {\n    box-shadow: none;\n}\n\n.film-strip-view .frame .time {\n    font-size: 10px;\n    margin-top: 2px;\n}\n\n/*# sourceURL=perf_ui/filmStripView.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["perf_ui/flameChart.css"]="/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.flame-chart-main-pane {\n    overflow: hidden;\n}\n\n.flame-chart-marker-highlight-element {\n    position: absolute;\n    top: 1px;\n    height: 18px;\n    width: 6px;\n    margin: 0 -3px;\n    content: \"\";\n    display: block;\n}\n\n.flame-chart-highlight-element {\n    position: absolute;\n    pointer-events: none;\n    background-color: rgba(56, 121, 217, 0.1);\n}\n\n.flame-chart-selected-element {\n    position: absolute;\n    pointer-events: none;\n    outline: 2px solid var(--selection-bg-color);\n    background-color: rgba(56, 121, 217, 0.1);\n}\n\n.chart-cursor-element {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    z-index: 100;\n    width: 2px;\n    background-color: var(--selection-bg-color);\n    pointer-events: none;\n}\n\n.flame-chart-entry-info:not(:empty) {\n    z-index: 2000;\n    position: absolute;\n    background-color: white;\n    pointer-events: none;\n    padding: 4px 8px;\n    white-space: nowrap;\n    max-width: 80%;\n    box-shadow: var(--drop-shadow);\n}\n\n.flame-chart-entry-info table tr td:empty {\n    padding: 0;\n}\n\n.flame-chart-entry-info table tr td:not(:empty) {\n    padding: 0 5px;\n    white-space: nowrap;\n}\n\n.flame-chart-entry-info table tr td:first-child {\n    font-weight: bold;\n}\n\n.flame-chart-entry-info table tr td span {\n    margin-right: 5px;\n}\n\n/*# sourceURL=perf_ui/flameChart.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["perf_ui/overviewGrid.css"]="/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.overview-grid-window-selector {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    background-color: rgba(125, 173, 217, 0.5);\n    z-index: 250;\n    pointer-events: none;\n}\n\n.overview-grid-window-resizer {\n    position: absolute;\n    top: -1px;\n    height: 20px;\n    width: 6px;\n    margin-left: -3px;\n    background-color: rgb(153, 153, 153);\n    border: 1px solid white;\n    z-index: 500;\n}\n\n.overview-grid-cursor-area {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 20px;\n    bottom: 0;\n    z-index: 500;\n    cursor: text;\n}\n\n.overview-grid-cursor-position {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 2px;\n    background-color: hsla(220, 95%, 50%, 0.7);\n    z-index: 500;\n    pointer-events: none;\n    visibility: hidden;\n    overflow: hidden;\n}\n\n.window-curtain-left, .window-curtain-right {\n    background-color: hsla(0, 0%, 80%, 0.5);\n    position: absolute;\n    top: 0;\n    height: 100%;\n    z-index: 300;\n    pointer-events: none;\n    border: 1px none hsla(0, 0%, 70%, 0.5);\n}\n\n.window-curtain-left {\n    left: 0;\n    border-right-style: solid;\n}\n\n.window-curtain-right {\n    right: 0;\n    border-left-style: solid;\n}\n\n/*# sourceURL=perf_ui/overviewGrid.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["perf_ui/pieChart.css"]="/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.root {\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\n\n.pie-chart-foreground {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 10;\n    top: 0;\n    display: flex;\n}\n\n.pie-chart-total {\n    margin: auto;\n    padding: 2px 5px;\n    background-color: rgba(255, 255, 255, 0.6);\n}\n\n/*# sourceURL=perf_ui/pieChart.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["perf_ui/timelineGrid.css"]="/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.resources-dividers {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: -100;\n    bottom: 0;\n}\n\n.resources-event-dividers {\n    position: absolute;\n    left: 0;\n    right: 0;\n    height: 100%;\n    top: 0;\n    z-index: 300;\n    pointer-events: none;\n}\n\n.resources-dividers-label-bar {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    background-color: rgba(255, 255, 255, 0.85);\n    background-clip: padding-box;\n    height: 20px;\n    z-index: 200;\n    pointer-events: none;\n    overflow: hidden;\n}\n\n.resources-divider {\n    position: absolute;\n    width: 1px;\n    top: 0;\n    bottom: 0;\n    background-color: rgba(0, 0, 0, 0.1);\n}\n\n.resources-event-divider {\n    position: absolute;\n    width: 1px;\n    top: 0;\n    bottom: 0;\n    z-index: 300;\n}\n\n.resources-divider-label {\n    position: absolute;\n    top: 4px;\n    right: 3px;\n    font-size: 80%;\n    white-space: nowrap;\n    pointer-events: none;\n}\n\n.timeline-grid-header {\n    height: 20px;\n    pointer-events: none;\n}\n\n/*# sourceURL=perf_ui/timelineGrid.css */";<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources["perf_ui/timelineOverviewInfo.css"]="/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.overview-info:not(:empty) {\n    display: flex;\n    background: white;\n    box-shadow: var(--drop-shadow);\n    padding: 3px;\n}\n\n.overview-info .frame .time {\n    display: none;\n}\n\n.overview-info .frame .thumbnail img {\n    max-width: 50vw;\n    max-height: 50vh;\n}\n\n/*# sourceURL=perf_ui/timelineOverviewInfo.css */";</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:03:43 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../../sorter.js"></script>
<script src="../../../../../block-navigation.js"></script>
</body>
</html>
