<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for build/win-unpacked/resources/inspector/formatter_worker.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../index.html">All files</a> / <a href="index.html">build/win-unpacked/resources/inspector</a> formatter_worker.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/7137</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/4940</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/843</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/1749</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a>
<a name='L559'></a><a href='#L559'>559</a>
<a name='L560'></a><a href='#L560'>560</a>
<a name='L561'></a><a href='#L561'>561</a>
<a name='L562'></a><a href='#L562'>562</a>
<a name='L563'></a><a href='#L563'>563</a>
<a name='L564'></a><a href='#L564'>564</a>
<a name='L565'></a><a href='#L565'>565</a>
<a name='L566'></a><a href='#L566'>566</a>
<a name='L567'></a><a href='#L567'>567</a>
<a name='L568'></a><a href='#L568'>568</a>
<a name='L569'></a><a href='#L569'>569</a>
<a name='L570'></a><a href='#L570'>570</a>
<a name='L571'></a><a href='#L571'>571</a>
<a name='L572'></a><a href='#L572'>572</a>
<a name='L573'></a><a href='#L573'>573</a>
<a name='L574'></a><a href='#L574'>574</a>
<a name='L575'></a><a href='#L575'>575</a>
<a name='L576'></a><a href='#L576'>576</a>
<a name='L577'></a><a href='#L577'>577</a>
<a name='L578'></a><a href='#L578'>578</a>
<a name='L579'></a><a href='#L579'>579</a>
<a name='L580'></a><a href='#L580'>580</a>
<a name='L581'></a><a href='#L581'>581</a>
<a name='L582'></a><a href='#L582'>582</a>
<a name='L583'></a><a href='#L583'>583</a>
<a name='L584'></a><a href='#L584'>584</a>
<a name='L585'></a><a href='#L585'>585</a>
<a name='L586'></a><a href='#L586'>586</a>
<a name='L587'></a><a href='#L587'>587</a>
<a name='L588'></a><a href='#L588'>588</a>
<a name='L589'></a><a href='#L589'>589</a>
<a name='L590'></a><a href='#L590'>590</a>
<a name='L591'></a><a href='#L591'>591</a>
<a name='L592'></a><a href='#L592'>592</a>
<a name='L593'></a><a href='#L593'>593</a>
<a name='L594'></a><a href='#L594'>594</a>
<a name='L595'></a><a href='#L595'>595</a>
<a name='L596'></a><a href='#L596'>596</a>
<a name='L597'></a><a href='#L597'>597</a>
<a name='L598'></a><a href='#L598'>598</a>
<a name='L599'></a><a href='#L599'>599</a>
<a name='L600'></a><a href='#L600'>600</a>
<a name='L601'></a><a href='#L601'>601</a>
<a name='L602'></a><a href='#L602'>602</a>
<a name='L603'></a><a href='#L603'>603</a>
<a name='L604'></a><a href='#L604'>604</a>
<a name='L605'></a><a href='#L605'>605</a>
<a name='L606'></a><a href='#L606'>606</a>
<a name='L607'></a><a href='#L607'>607</a>
<a name='L608'></a><a href='#L608'>608</a>
<a name='L609'></a><a href='#L609'>609</a>
<a name='L610'></a><a href='#L610'>610</a>
<a name='L611'></a><a href='#L611'>611</a>
<a name='L612'></a><a href='#L612'>612</a>
<a name='L613'></a><a href='#L613'>613</a>
<a name='L614'></a><a href='#L614'>614</a>
<a name='L615'></a><a href='#L615'>615</a>
<a name='L616'></a><a href='#L616'>616</a>
<a name='L617'></a><a href='#L617'>617</a>
<a name='L618'></a><a href='#L618'>618</a>
<a name='L619'></a><a href='#L619'>619</a>
<a name='L620'></a><a href='#L620'>620</a>
<a name='L621'></a><a href='#L621'>621</a>
<a name='L622'></a><a href='#L622'>622</a>
<a name='L623'></a><a href='#L623'>623</a>
<a name='L624'></a><a href='#L624'>624</a>
<a name='L625'></a><a href='#L625'>625</a>
<a name='L626'></a><a href='#L626'>626</a>
<a name='L627'></a><a href='#L627'>627</a>
<a name='L628'></a><a href='#L628'>628</a>
<a name='L629'></a><a href='#L629'>629</a>
<a name='L630'></a><a href='#L630'>630</a>
<a name='L631'></a><a href='#L631'>631</a>
<a name='L632'></a><a href='#L632'>632</a>
<a name='L633'></a><a href='#L633'>633</a>
<a name='L634'></a><a href='#L634'>634</a>
<a name='L635'></a><a href='#L635'>635</a>
<a name='L636'></a><a href='#L636'>636</a>
<a name='L637'></a><a href='#L637'>637</a>
<a name='L638'></a><a href='#L638'>638</a>
<a name='L639'></a><a href='#L639'>639</a>
<a name='L640'></a><a href='#L640'>640</a>
<a name='L641'></a><a href='#L641'>641</a>
<a name='L642'></a><a href='#L642'>642</a>
<a name='L643'></a><a href='#L643'>643</a>
<a name='L644'></a><a href='#L644'>644</a>
<a name='L645'></a><a href='#L645'>645</a>
<a name='L646'></a><a href='#L646'>646</a>
<a name='L647'></a><a href='#L647'>647</a>
<a name='L648'></a><a href='#L648'>648</a>
<a name='L649'></a><a href='#L649'>649</a>
<a name='L650'></a><a href='#L650'>650</a>
<a name='L651'></a><a href='#L651'>651</a>
<a name='L652'></a><a href='#L652'>652</a>
<a name='L653'></a><a href='#L653'>653</a>
<a name='L654'></a><a href='#L654'>654</a>
<a name='L655'></a><a href='#L655'>655</a>
<a name='L656'></a><a href='#L656'>656</a>
<a name='L657'></a><a href='#L657'>657</a>
<a name='L658'></a><a href='#L658'>658</a>
<a name='L659'></a><a href='#L659'>659</a>
<a name='L660'></a><a href='#L660'>660</a>
<a name='L661'></a><a href='#L661'>661</a>
<a name='L662'></a><a href='#L662'>662</a>
<a name='L663'></a><a href='#L663'>663</a>
<a name='L664'></a><a href='#L664'>664</a>
<a name='L665'></a><a href='#L665'>665</a>
<a name='L666'></a><a href='#L666'>666</a>
<a name='L667'></a><a href='#L667'>667</a>
<a name='L668'></a><a href='#L668'>668</a>
<a name='L669'></a><a href='#L669'>669</a>
<a name='L670'></a><a href='#L670'>670</a>
<a name='L671'></a><a href='#L671'>671</a>
<a name='L672'></a><a href='#L672'>672</a>
<a name='L673'></a><a href='#L673'>673</a>
<a name='L674'></a><a href='#L674'>674</a>
<a name='L675'></a><a href='#L675'>675</a>
<a name='L676'></a><a href='#L676'>676</a>
<a name='L677'></a><a href='#L677'>677</a>
<a name='L678'></a><a href='#L678'>678</a>
<a name='L679'></a><a href='#L679'>679</a>
<a name='L680'></a><a href='#L680'>680</a>
<a name='L681'></a><a href='#L681'>681</a>
<a name='L682'></a><a href='#L682'>682</a>
<a name='L683'></a><a href='#L683'>683</a>
<a name='L684'></a><a href='#L684'>684</a>
<a name='L685'></a><a href='#L685'>685</a>
<a name='L686'></a><a href='#L686'>686</a>
<a name='L687'></a><a href='#L687'>687</a>
<a name='L688'></a><a href='#L688'>688</a>
<a name='L689'></a><a href='#L689'>689</a>
<a name='L690'></a><a href='#L690'>690</a>
<a name='L691'></a><a href='#L691'>691</a>
<a name='L692'></a><a href='#L692'>692</a>
<a name='L693'></a><a href='#L693'>693</a>
<a name='L694'></a><a href='#L694'>694</a>
<a name='L695'></a><a href='#L695'>695</a>
<a name='L696'></a><a href='#L696'>696</a>
<a name='L697'></a><a href='#L697'>697</a>
<a name='L698'></a><a href='#L698'>698</a>
<a name='L699'></a><a href='#L699'>699</a>
<a name='L700'></a><a href='#L700'>700</a>
<a name='L701'></a><a href='#L701'>701</a>
<a name='L702'></a><a href='#L702'>702</a>
<a name='L703'></a><a href='#L703'>703</a>
<a name='L704'></a><a href='#L704'>704</a>
<a name='L705'></a><a href='#L705'>705</a>
<a name='L706'></a><a href='#L706'>706</a>
<a name='L707'></a><a href='#L707'>707</a>
<a name='L708'></a><a href='#L708'>708</a>
<a name='L709'></a><a href='#L709'>709</a>
<a name='L710'></a><a href='#L710'>710</a>
<a name='L711'></a><a href='#L711'>711</a>
<a name='L712'></a><a href='#L712'>712</a>
<a name='L713'></a><a href='#L713'>713</a>
<a name='L714'></a><a href='#L714'>714</a>
<a name='L715'></a><a href='#L715'>715</a>
<a name='L716'></a><a href='#L716'>716</a>
<a name='L717'></a><a href='#L717'>717</a>
<a name='L718'></a><a href='#L718'>718</a>
<a name='L719'></a><a href='#L719'>719</a>
<a name='L720'></a><a href='#L720'>720</a>
<a name='L721'></a><a href='#L721'>721</a>
<a name='L722'></a><a href='#L722'>722</a>
<a name='L723'></a><a href='#L723'>723</a>
<a name='L724'></a><a href='#L724'>724</a>
<a name='L725'></a><a href='#L725'>725</a>
<a name='L726'></a><a href='#L726'>726</a>
<a name='L727'></a><a href='#L727'>727</a>
<a name='L728'></a><a href='#L728'>728</a>
<a name='L729'></a><a href='#L729'>729</a>
<a name='L730'></a><a href='#L730'>730</a>
<a name='L731'></a><a href='#L731'>731</a>
<a name='L732'></a><a href='#L732'>732</a>
<a name='L733'></a><a href='#L733'>733</a>
<a name='L734'></a><a href='#L734'>734</a>
<a name='L735'></a><a href='#L735'>735</a>
<a name='L736'></a><a href='#L736'>736</a>
<a name='L737'></a><a href='#L737'>737</a>
<a name='L738'></a><a href='#L738'>738</a>
<a name='L739'></a><a href='#L739'>739</a>
<a name='L740'></a><a href='#L740'>740</a>
<a name='L741'></a><a href='#L741'>741</a>
<a name='L742'></a><a href='#L742'>742</a>
<a name='L743'></a><a href='#L743'>743</a>
<a name='L744'></a><a href='#L744'>744</a>
<a name='L745'></a><a href='#L745'>745</a>
<a name='L746'></a><a href='#L746'>746</a>
<a name='L747'></a><a href='#L747'>747</a>
<a name='L748'></a><a href='#L748'>748</a>
<a name='L749'></a><a href='#L749'>749</a>
<a name='L750'></a><a href='#L750'>750</a>
<a name='L751'></a><a href='#L751'>751</a>
<a name='L752'></a><a href='#L752'>752</a>
<a name='L753'></a><a href='#L753'>753</a>
<a name='L754'></a><a href='#L754'>754</a>
<a name='L755'></a><a href='#L755'>755</a>
<a name='L756'></a><a href='#L756'>756</a>
<a name='L757'></a><a href='#L757'>757</a>
<a name='L758'></a><a href='#L758'>758</a>
<a name='L759'></a><a href='#L759'>759</a>
<a name='L760'></a><a href='#L760'>760</a>
<a name='L761'></a><a href='#L761'>761</a>
<a name='L762'></a><a href='#L762'>762</a>
<a name='L763'></a><a href='#L763'>763</a>
<a name='L764'></a><a href='#L764'>764</a>
<a name='L765'></a><a href='#L765'>765</a>
<a name='L766'></a><a href='#L766'>766</a>
<a name='L767'></a><a href='#L767'>767</a>
<a name='L768'></a><a href='#L768'>768</a>
<a name='L769'></a><a href='#L769'>769</a>
<a name='L770'></a><a href='#L770'>770</a>
<a name='L771'></a><a href='#L771'>771</a>
<a name='L772'></a><a href='#L772'>772</a>
<a name='L773'></a><a href='#L773'>773</a>
<a name='L774'></a><a href='#L774'>774</a>
<a name='L775'></a><a href='#L775'>775</a>
<a name='L776'></a><a href='#L776'>776</a>
<a name='L777'></a><a href='#L777'>777</a>
<a name='L778'></a><a href='#L778'>778</a>
<a name='L779'></a><a href='#L779'>779</a>
<a name='L780'></a><a href='#L780'>780</a>
<a name='L781'></a><a href='#L781'>781</a>
<a name='L782'></a><a href='#L782'>782</a>
<a name='L783'></a><a href='#L783'>783</a>
<a name='L784'></a><a href='#L784'>784</a>
<a name='L785'></a><a href='#L785'>785</a>
<a name='L786'></a><a href='#L786'>786</a>
<a name='L787'></a><a href='#L787'>787</a>
<a name='L788'></a><a href='#L788'>788</a>
<a name='L789'></a><a href='#L789'>789</a>
<a name='L790'></a><a href='#L790'>790</a>
<a name='L791'></a><a href='#L791'>791</a>
<a name='L792'></a><a href='#L792'>792</a>
<a name='L793'></a><a href='#L793'>793</a>
<a name='L794'></a><a href='#L794'>794</a>
<a name='L795'></a><a href='#L795'>795</a>
<a name='L796'></a><a href='#L796'>796</a>
<a name='L797'></a><a href='#L797'>797</a>
<a name='L798'></a><a href='#L798'>798</a>
<a name='L799'></a><a href='#L799'>799</a>
<a name='L800'></a><a href='#L800'>800</a>
<a name='L801'></a><a href='#L801'>801</a>
<a name='L802'></a><a href='#L802'>802</a>
<a name='L803'></a><a href='#L803'>803</a>
<a name='L804'></a><a href='#L804'>804</a>
<a name='L805'></a><a href='#L805'>805</a>
<a name='L806'></a><a href='#L806'>806</a>
<a name='L807'></a><a href='#L807'>807</a>
<a name='L808'></a><a href='#L808'>808</a>
<a name='L809'></a><a href='#L809'>809</a>
<a name='L810'></a><a href='#L810'>810</a>
<a name='L811'></a><a href='#L811'>811</a>
<a name='L812'></a><a href='#L812'>812</a>
<a name='L813'></a><a href='#L813'>813</a>
<a name='L814'></a><a href='#L814'>814</a>
<a name='L815'></a><a href='#L815'>815</a>
<a name='L816'></a><a href='#L816'>816</a>
<a name='L817'></a><a href='#L817'>817</a>
<a name='L818'></a><a href='#L818'>818</a>
<a name='L819'></a><a href='#L819'>819</a>
<a name='L820'></a><a href='#L820'>820</a>
<a name='L821'></a><a href='#L821'>821</a>
<a name='L822'></a><a href='#L822'>822</a>
<a name='L823'></a><a href='#L823'>823</a>
<a name='L824'></a><a href='#L824'>824</a>
<a name='L825'></a><a href='#L825'>825</a>
<a name='L826'></a><a href='#L826'>826</a>
<a name='L827'></a><a href='#L827'>827</a>
<a name='L828'></a><a href='#L828'>828</a>
<a name='L829'></a><a href='#L829'>829</a>
<a name='L830'></a><a href='#L830'>830</a>
<a name='L831'></a><a href='#L831'>831</a>
<a name='L832'></a><a href='#L832'>832</a>
<a name='L833'></a><a href='#L833'>833</a>
<a name='L834'></a><a href='#L834'>834</a>
<a name='L835'></a><a href='#L835'>835</a>
<a name='L836'></a><a href='#L836'>836</a>
<a name='L837'></a><a href='#L837'>837</a>
<a name='L838'></a><a href='#L838'>838</a>
<a name='L839'></a><a href='#L839'>839</a>
<a name='L840'></a><a href='#L840'>840</a>
<a name='L841'></a><a href='#L841'>841</a>
<a name='L842'></a><a href='#L842'>842</a>
<a name='L843'></a><a href='#L843'>843</a>
<a name='L844'></a><a href='#L844'>844</a>
<a name='L845'></a><a href='#L845'>845</a>
<a name='L846'></a><a href='#L846'>846</a>
<a name='L847'></a><a href='#L847'>847</a>
<a name='L848'></a><a href='#L848'>848</a>
<a name='L849'></a><a href='#L849'>849</a>
<a name='L850'></a><a href='#L850'>850</a>
<a name='L851'></a><a href='#L851'>851</a>
<a name='L852'></a><a href='#L852'>852</a>
<a name='L853'></a><a href='#L853'>853</a>
<a name='L854'></a><a href='#L854'>854</a>
<a name='L855'></a><a href='#L855'>855</a>
<a name='L856'></a><a href='#L856'>856</a>
<a name='L857'></a><a href='#L857'>857</a>
<a name='L858'></a><a href='#L858'>858</a>
<a name='L859'></a><a href='#L859'>859</a>
<a name='L860'></a><a href='#L860'>860</a>
<a name='L861'></a><a href='#L861'>861</a>
<a name='L862'></a><a href='#L862'>862</a>
<a name='L863'></a><a href='#L863'>863</a>
<a name='L864'></a><a href='#L864'>864</a>
<a name='L865'></a><a href='#L865'>865</a>
<a name='L866'></a><a href='#L866'>866</a>
<a name='L867'></a><a href='#L867'>867</a>
<a name='L868'></a><a href='#L868'>868</a>
<a name='L869'></a><a href='#L869'>869</a>
<a name='L870'></a><a href='#L870'>870</a>
<a name='L871'></a><a href='#L871'>871</a>
<a name='L872'></a><a href='#L872'>872</a>
<a name='L873'></a><a href='#L873'>873</a>
<a name='L874'></a><a href='#L874'>874</a>
<a name='L875'></a><a href='#L875'>875</a>
<a name='L876'></a><a href='#L876'>876</a>
<a name='L877'></a><a href='#L877'>877</a>
<a name='L878'></a><a href='#L878'>878</a>
<a name='L879'></a><a href='#L879'>879</a>
<a name='L880'></a><a href='#L880'>880</a>
<a name='L881'></a><a href='#L881'>881</a>
<a name='L882'></a><a href='#L882'>882</a>
<a name='L883'></a><a href='#L883'>883</a>
<a name='L884'></a><a href='#L884'>884</a>
<a name='L885'></a><a href='#L885'>885</a>
<a name='L886'></a><a href='#L886'>886</a>
<a name='L887'></a><a href='#L887'>887</a>
<a name='L888'></a><a href='#L888'>888</a>
<a name='L889'></a><a href='#L889'>889</a>
<a name='L890'></a><a href='#L890'>890</a>
<a name='L891'></a><a href='#L891'>891</a>
<a name='L892'></a><a href='#L892'>892</a>
<a name='L893'></a><a href='#L893'>893</a>
<a name='L894'></a><a href='#L894'>894</a>
<a name='L895'></a><a href='#L895'>895</a>
<a name='L896'></a><a href='#L896'>896</a>
<a name='L897'></a><a href='#L897'>897</a>
<a name='L898'></a><a href='#L898'>898</a>
<a name='L899'></a><a href='#L899'>899</a>
<a name='L900'></a><a href='#L900'>900</a>
<a name='L901'></a><a href='#L901'>901</a>
<a name='L902'></a><a href='#L902'>902</a>
<a name='L903'></a><a href='#L903'>903</a>
<a name='L904'></a><a href='#L904'>904</a>
<a name='L905'></a><a href='#L905'>905</a>
<a name='L906'></a><a href='#L906'>906</a>
<a name='L907'></a><a href='#L907'>907</a>
<a name='L908'></a><a href='#L908'>908</a>
<a name='L909'></a><a href='#L909'>909</a>
<a name='L910'></a><a href='#L910'>910</a>
<a name='L911'></a><a href='#L911'>911</a>
<a name='L912'></a><a href='#L912'>912</a>
<a name='L913'></a><a href='#L913'>913</a>
<a name='L914'></a><a href='#L914'>914</a>
<a name='L915'></a><a href='#L915'>915</a>
<a name='L916'></a><a href='#L916'>916</a>
<a name='L917'></a><a href='#L917'>917</a>
<a name='L918'></a><a href='#L918'>918</a>
<a name='L919'></a><a href='#L919'>919</a>
<a name='L920'></a><a href='#L920'>920</a>
<a name='L921'></a><a href='#L921'>921</a>
<a name='L922'></a><a href='#L922'>922</a>
<a name='L923'></a><a href='#L923'>923</a>
<a name='L924'></a><a href='#L924'>924</a>
<a name='L925'></a><a href='#L925'>925</a>
<a name='L926'></a><a href='#L926'>926</a>
<a name='L927'></a><a href='#L927'>927</a>
<a name='L928'></a><a href='#L928'>928</a>
<a name='L929'></a><a href='#L929'>929</a>
<a name='L930'></a><a href='#L930'>930</a>
<a name='L931'></a><a href='#L931'>931</a>
<a name='L932'></a><a href='#L932'>932</a>
<a name='L933'></a><a href='#L933'>933</a>
<a name='L934'></a><a href='#L934'>934</a>
<a name='L935'></a><a href='#L935'>935</a>
<a name='L936'></a><a href='#L936'>936</a>
<a name='L937'></a><a href='#L937'>937</a>
<a name='L938'></a><a href='#L938'>938</a>
<a name='L939'></a><a href='#L939'>939</a>
<a name='L940'></a><a href='#L940'>940</a>
<a name='L941'></a><a href='#L941'>941</a>
<a name='L942'></a><a href='#L942'>942</a>
<a name='L943'></a><a href='#L943'>943</a>
<a name='L944'></a><a href='#L944'>944</a>
<a name='L945'></a><a href='#L945'>945</a>
<a name='L946'></a><a href='#L946'>946</a>
<a name='L947'></a><a href='#L947'>947</a>
<a name='L948'></a><a href='#L948'>948</a>
<a name='L949'></a><a href='#L949'>949</a>
<a name='L950'></a><a href='#L950'>950</a>
<a name='L951'></a><a href='#L951'>951</a>
<a name='L952'></a><a href='#L952'>952</a>
<a name='L953'></a><a href='#L953'>953</a>
<a name='L954'></a><a href='#L954'>954</a>
<a name='L955'></a><a href='#L955'>955</a>
<a name='L956'></a><a href='#L956'>956</a>
<a name='L957'></a><a href='#L957'>957</a>
<a name='L958'></a><a href='#L958'>958</a>
<a name='L959'></a><a href='#L959'>959</a>
<a name='L960'></a><a href='#L960'>960</a>
<a name='L961'></a><a href='#L961'>961</a>
<a name='L962'></a><a href='#L962'>962</a>
<a name='L963'></a><a href='#L963'>963</a>
<a name='L964'></a><a href='#L964'>964</a>
<a name='L965'></a><a href='#L965'>965</a>
<a name='L966'></a><a href='#L966'>966</a>
<a name='L967'></a><a href='#L967'>967</a>
<a name='L968'></a><a href='#L968'>968</a>
<a name='L969'></a><a href='#L969'>969</a>
<a name='L970'></a><a href='#L970'>970</a>
<a name='L971'></a><a href='#L971'>971</a>
<a name='L972'></a><a href='#L972'>972</a>
<a name='L973'></a><a href='#L973'>973</a>
<a name='L974'></a><a href='#L974'>974</a>
<a name='L975'></a><a href='#L975'>975</a>
<a name='L976'></a><a href='#L976'>976</a>
<a name='L977'></a><a href='#L977'>977</a>
<a name='L978'></a><a href='#L978'>978</a>
<a name='L979'></a><a href='#L979'>979</a>
<a name='L980'></a><a href='#L980'>980</a>
<a name='L981'></a><a href='#L981'>981</a>
<a name='L982'></a><a href='#L982'>982</a>
<a name='L983'></a><a href='#L983'>983</a>
<a name='L984'></a><a href='#L984'>984</a>
<a name='L985'></a><a href='#L985'>985</a>
<a name='L986'></a><a href='#L986'>986</a>
<a name='L987'></a><a href='#L987'>987</a>
<a name='L988'></a><a href='#L988'>988</a>
<a name='L989'></a><a href='#L989'>989</a>
<a name='L990'></a><a href='#L990'>990</a>
<a name='L991'></a><a href='#L991'>991</a>
<a name='L992'></a><a href='#L992'>992</a>
<a name='L993'></a><a href='#L993'>993</a>
<a name='L994'></a><a href='#L994'>994</a>
<a name='L995'></a><a href='#L995'>995</a>
<a name='L996'></a><a href='#L996'>996</a>
<a name='L997'></a><a href='#L997'>997</a>
<a name='L998'></a><a href='#L998'>998</a>
<a name='L999'></a><a href='#L999'>999</a>
<a name='L1000'></a><a href='#L1000'>1000</a>
<a name='L1001'></a><a href='#L1001'>1001</a>
<a name='L1002'></a><a href='#L1002'>1002</a>
<a name='L1003'></a><a href='#L1003'>1003</a>
<a name='L1004'></a><a href='#L1004'>1004</a>
<a name='L1005'></a><a href='#L1005'>1005</a>
<a name='L1006'></a><a href='#L1006'>1006</a>
<a name='L1007'></a><a href='#L1007'>1007</a>
<a name='L1008'></a><a href='#L1008'>1008</a>
<a name='L1009'></a><a href='#L1009'>1009</a>
<a name='L1010'></a><a href='#L1010'>1010</a>
<a name='L1011'></a><a href='#L1011'>1011</a>
<a name='L1012'></a><a href='#L1012'>1012</a>
<a name='L1013'></a><a href='#L1013'>1013</a>
<a name='L1014'></a><a href='#L1014'>1014</a>
<a name='L1015'></a><a href='#L1015'>1015</a>
<a name='L1016'></a><a href='#L1016'>1016</a>
<a name='L1017'></a><a href='#L1017'>1017</a>
<a name='L1018'></a><a href='#L1018'>1018</a>
<a name='L1019'></a><a href='#L1019'>1019</a>
<a name='L1020'></a><a href='#L1020'>1020</a>
<a name='L1021'></a><a href='#L1021'>1021</a>
<a name='L1022'></a><a href='#L1022'>1022</a>
<a name='L1023'></a><a href='#L1023'>1023</a>
<a name='L1024'></a><a href='#L1024'>1024</a>
<a name='L1025'></a><a href='#L1025'>1025</a>
<a name='L1026'></a><a href='#L1026'>1026</a>
<a name='L1027'></a><a href='#L1027'>1027</a>
<a name='L1028'></a><a href='#L1028'>1028</a>
<a name='L1029'></a><a href='#L1029'>1029</a>
<a name='L1030'></a><a href='#L1030'>1030</a>
<a name='L1031'></a><a href='#L1031'>1031</a>
<a name='L1032'></a><a href='#L1032'>1032</a>
<a name='L1033'></a><a href='#L1033'>1033</a>
<a name='L1034'></a><a href='#L1034'>1034</a>
<a name='L1035'></a><a href='#L1035'>1035</a>
<a name='L1036'></a><a href='#L1036'>1036</a>
<a name='L1037'></a><a href='#L1037'>1037</a>
<a name='L1038'></a><a href='#L1038'>1038</a>
<a name='L1039'></a><a href='#L1039'>1039</a>
<a name='L1040'></a><a href='#L1040'>1040</a>
<a name='L1041'></a><a href='#L1041'>1041</a>
<a name='L1042'></a><a href='#L1042'>1042</a>
<a name='L1043'></a><a href='#L1043'>1043</a>
<a name='L1044'></a><a href='#L1044'>1044</a>
<a name='L1045'></a><a href='#L1045'>1045</a>
<a name='L1046'></a><a href='#L1046'>1046</a>
<a name='L1047'></a><a href='#L1047'>1047</a>
<a name='L1048'></a><a href='#L1048'>1048</a>
<a name='L1049'></a><a href='#L1049'>1049</a>
<a name='L1050'></a><a href='#L1050'>1050</a>
<a name='L1051'></a><a href='#L1051'>1051</a>
<a name='L1052'></a><a href='#L1052'>1052</a>
<a name='L1053'></a><a href='#L1053'>1053</a>
<a name='L1054'></a><a href='#L1054'>1054</a>
<a name='L1055'></a><a href='#L1055'>1055</a>
<a name='L1056'></a><a href='#L1056'>1056</a>
<a name='L1057'></a><a href='#L1057'>1057</a>
<a name='L1058'></a><a href='#L1058'>1058</a>
<a name='L1059'></a><a href='#L1059'>1059</a>
<a name='L1060'></a><a href='#L1060'>1060</a>
<a name='L1061'></a><a href='#L1061'>1061</a>
<a name='L1062'></a><a href='#L1062'>1062</a>
<a name='L1063'></a><a href='#L1063'>1063</a>
<a name='L1064'></a><a href='#L1064'>1064</a>
<a name='L1065'></a><a href='#L1065'>1065</a>
<a name='L1066'></a><a href='#L1066'>1066</a>
<a name='L1067'></a><a href='#L1067'>1067</a>
<a name='L1068'></a><a href='#L1068'>1068</a>
<a name='L1069'></a><a href='#L1069'>1069</a>
<a name='L1070'></a><a href='#L1070'>1070</a>
<a name='L1071'></a><a href='#L1071'>1071</a>
<a name='L1072'></a><a href='#L1072'>1072</a>
<a name='L1073'></a><a href='#L1073'>1073</a>
<a name='L1074'></a><a href='#L1074'>1074</a>
<a name='L1075'></a><a href='#L1075'>1075</a>
<a name='L1076'></a><a href='#L1076'>1076</a>
<a name='L1077'></a><a href='#L1077'>1077</a>
<a name='L1078'></a><a href='#L1078'>1078</a>
<a name='L1079'></a><a href='#L1079'>1079</a>
<a name='L1080'></a><a href='#L1080'>1080</a>
<a name='L1081'></a><a href='#L1081'>1081</a>
<a name='L1082'></a><a href='#L1082'>1082</a>
<a name='L1083'></a><a href='#L1083'>1083</a>
<a name='L1084'></a><a href='#L1084'>1084</a>
<a name='L1085'></a><a href='#L1085'>1085</a>
<a name='L1086'></a><a href='#L1086'>1086</a>
<a name='L1087'></a><a href='#L1087'>1087</a>
<a name='L1088'></a><a href='#L1088'>1088</a>
<a name='L1089'></a><a href='#L1089'>1089</a>
<a name='L1090'></a><a href='#L1090'>1090</a>
<a name='L1091'></a><a href='#L1091'>1091</a>
<a name='L1092'></a><a href='#L1092'>1092</a>
<a name='L1093'></a><a href='#L1093'>1093</a>
<a name='L1094'></a><a href='#L1094'>1094</a>
<a name='L1095'></a><a href='#L1095'>1095</a>
<a name='L1096'></a><a href='#L1096'>1096</a>
<a name='L1097'></a><a href='#L1097'>1097</a>
<a name='L1098'></a><a href='#L1098'>1098</a>
<a name='L1099'></a><a href='#L1099'>1099</a>
<a name='L1100'></a><a href='#L1100'>1100</a>
<a name='L1101'></a><a href='#L1101'>1101</a>
<a name='L1102'></a><a href='#L1102'>1102</a>
<a name='L1103'></a><a href='#L1103'>1103</a>
<a name='L1104'></a><a href='#L1104'>1104</a>
<a name='L1105'></a><a href='#L1105'>1105</a>
<a name='L1106'></a><a href='#L1106'>1106</a>
<a name='L1107'></a><a href='#L1107'>1107</a>
<a name='L1108'></a><a href='#L1108'>1108</a>
<a name='L1109'></a><a href='#L1109'>1109</a>
<a name='L1110'></a><a href='#L1110'>1110</a>
<a name='L1111'></a><a href='#L1111'>1111</a>
<a name='L1112'></a><a href='#L1112'>1112</a>
<a name='L1113'></a><a href='#L1113'>1113</a>
<a name='L1114'></a><a href='#L1114'>1114</a>
<a name='L1115'></a><a href='#L1115'>1115</a>
<a name='L1116'></a><a href='#L1116'>1116</a>
<a name='L1117'></a><a href='#L1117'>1117</a>
<a name='L1118'></a><a href='#L1118'>1118</a>
<a name='L1119'></a><a href='#L1119'>1119</a>
<a name='L1120'></a><a href='#L1120'>1120</a>
<a name='L1121'></a><a href='#L1121'>1121</a>
<a name='L1122'></a><a href='#L1122'>1122</a>
<a name='L1123'></a><a href='#L1123'>1123</a>
<a name='L1124'></a><a href='#L1124'>1124</a>
<a name='L1125'></a><a href='#L1125'>1125</a>
<a name='L1126'></a><a href='#L1126'>1126</a>
<a name='L1127'></a><a href='#L1127'>1127</a>
<a name='L1128'></a><a href='#L1128'>1128</a>
<a name='L1129'></a><a href='#L1129'>1129</a>
<a name='L1130'></a><a href='#L1130'>1130</a>
<a name='L1131'></a><a href='#L1131'>1131</a>
<a name='L1132'></a><a href='#L1132'>1132</a>
<a name='L1133'></a><a href='#L1133'>1133</a>
<a name='L1134'></a><a href='#L1134'>1134</a>
<a name='L1135'></a><a href='#L1135'>1135</a>
<a name='L1136'></a><a href='#L1136'>1136</a>
<a name='L1137'></a><a href='#L1137'>1137</a>
<a name='L1138'></a><a href='#L1138'>1138</a>
<a name='L1139'></a><a href='#L1139'>1139</a>
<a name='L1140'></a><a href='#L1140'>1140</a>
<a name='L1141'></a><a href='#L1141'>1141</a>
<a name='L1142'></a><a href='#L1142'>1142</a>
<a name='L1143'></a><a href='#L1143'>1143</a>
<a name='L1144'></a><a href='#L1144'>1144</a>
<a name='L1145'></a><a href='#L1145'>1145</a>
<a name='L1146'></a><a href='#L1146'>1146</a>
<a name='L1147'></a><a href='#L1147'>1147</a>
<a name='L1148'></a><a href='#L1148'>1148</a>
<a name='L1149'></a><a href='#L1149'>1149</a>
<a name='L1150'></a><a href='#L1150'>1150</a>
<a name='L1151'></a><a href='#L1151'>1151</a>
<a name='L1152'></a><a href='#L1152'>1152</a>
<a name='L1153'></a><a href='#L1153'>1153</a>
<a name='L1154'></a><a href='#L1154'>1154</a>
<a name='L1155'></a><a href='#L1155'>1155</a>
<a name='L1156'></a><a href='#L1156'>1156</a>
<a name='L1157'></a><a href='#L1157'>1157</a>
<a name='L1158'></a><a href='#L1158'>1158</a>
<a name='L1159'></a><a href='#L1159'>1159</a>
<a name='L1160'></a><a href='#L1160'>1160</a>
<a name='L1161'></a><a href='#L1161'>1161</a>
<a name='L1162'></a><a href='#L1162'>1162</a>
<a name='L1163'></a><a href='#L1163'>1163</a>
<a name='L1164'></a><a href='#L1164'>1164</a>
<a name='L1165'></a><a href='#L1165'>1165</a>
<a name='L1166'></a><a href='#L1166'>1166</a>
<a name='L1167'></a><a href='#L1167'>1167</a>
<a name='L1168'></a><a href='#L1168'>1168</a>
<a name='L1169'></a><a href='#L1169'>1169</a>
<a name='L1170'></a><a href='#L1170'>1170</a>
<a name='L1171'></a><a href='#L1171'>1171</a>
<a name='L1172'></a><a href='#L1172'>1172</a>
<a name='L1173'></a><a href='#L1173'>1173</a>
<a name='L1174'></a><a href='#L1174'>1174</a>
<a name='L1175'></a><a href='#L1175'>1175</a>
<a name='L1176'></a><a href='#L1176'>1176</a>
<a name='L1177'></a><a href='#L1177'>1177</a>
<a name='L1178'></a><a href='#L1178'>1178</a>
<a name='L1179'></a><a href='#L1179'>1179</a>
<a name='L1180'></a><a href='#L1180'>1180</a>
<a name='L1181'></a><a href='#L1181'>1181</a>
<a name='L1182'></a><a href='#L1182'>1182</a>
<a name='L1183'></a><a href='#L1183'>1183</a>
<a name='L1184'></a><a href='#L1184'>1184</a>
<a name='L1185'></a><a href='#L1185'>1185</a>
<a name='L1186'></a><a href='#L1186'>1186</a>
<a name='L1187'></a><a href='#L1187'>1187</a>
<a name='L1188'></a><a href='#L1188'>1188</a>
<a name='L1189'></a><a href='#L1189'>1189</a>
<a name='L1190'></a><a href='#L1190'>1190</a>
<a name='L1191'></a><a href='#L1191'>1191</a>
<a name='L1192'></a><a href='#L1192'>1192</a>
<a name='L1193'></a><a href='#L1193'>1193</a>
<a name='L1194'></a><a href='#L1194'>1194</a>
<a name='L1195'></a><a href='#L1195'>1195</a>
<a name='L1196'></a><a href='#L1196'>1196</a>
<a name='L1197'></a><a href='#L1197'>1197</a>
<a name='L1198'></a><a href='#L1198'>1198</a>
<a name='L1199'></a><a href='#L1199'>1199</a>
<a name='L1200'></a><a href='#L1200'>1200</a>
<a name='L1201'></a><a href='#L1201'>1201</a>
<a name='L1202'></a><a href='#L1202'>1202</a>
<a name='L1203'></a><a href='#L1203'>1203</a>
<a name='L1204'></a><a href='#L1204'>1204</a>
<a name='L1205'></a><a href='#L1205'>1205</a>
<a name='L1206'></a><a href='#L1206'>1206</a>
<a name='L1207'></a><a href='#L1207'>1207</a>
<a name='L1208'></a><a href='#L1208'>1208</a>
<a name='L1209'></a><a href='#L1209'>1209</a>
<a name='L1210'></a><a href='#L1210'>1210</a>
<a name='L1211'></a><a href='#L1211'>1211</a>
<a name='L1212'></a><a href='#L1212'>1212</a>
<a name='L1213'></a><a href='#L1213'>1213</a>
<a name='L1214'></a><a href='#L1214'>1214</a>
<a name='L1215'></a><a href='#L1215'>1215</a>
<a name='L1216'></a><a href='#L1216'>1216</a>
<a name='L1217'></a><a href='#L1217'>1217</a>
<a name='L1218'></a><a href='#L1218'>1218</a>
<a name='L1219'></a><a href='#L1219'>1219</a>
<a name='L1220'></a><a href='#L1220'>1220</a>
<a name='L1221'></a><a href='#L1221'>1221</a>
<a name='L1222'></a><a href='#L1222'>1222</a>
<a name='L1223'></a><a href='#L1223'>1223</a>
<a name='L1224'></a><a href='#L1224'>1224</a>
<a name='L1225'></a><a href='#L1225'>1225</a>
<a name='L1226'></a><a href='#L1226'>1226</a>
<a name='L1227'></a><a href='#L1227'>1227</a>
<a name='L1228'></a><a href='#L1228'>1228</a>
<a name='L1229'></a><a href='#L1229'>1229</a>
<a name='L1230'></a><a href='#L1230'>1230</a>
<a name='L1231'></a><a href='#L1231'>1231</a>
<a name='L1232'></a><a href='#L1232'>1232</a>
<a name='L1233'></a><a href='#L1233'>1233</a>
<a name='L1234'></a><a href='#L1234'>1234</a>
<a name='L1235'></a><a href='#L1235'>1235</a>
<a name='L1236'></a><a href='#L1236'>1236</a>
<a name='L1237'></a><a href='#L1237'>1237</a>
<a name='L1238'></a><a href='#L1238'>1238</a>
<a name='L1239'></a><a href='#L1239'>1239</a>
<a name='L1240'></a><a href='#L1240'>1240</a>
<a name='L1241'></a><a href='#L1241'>1241</a>
<a name='L1242'></a><a href='#L1242'>1242</a>
<a name='L1243'></a><a href='#L1243'>1243</a>
<a name='L1244'></a><a href='#L1244'>1244</a>
<a name='L1245'></a><a href='#L1245'>1245</a>
<a name='L1246'></a><a href='#L1246'>1246</a>
<a name='L1247'></a><a href='#L1247'>1247</a>
<a name='L1248'></a><a href='#L1248'>1248</a>
<a name='L1249'></a><a href='#L1249'>1249</a>
<a name='L1250'></a><a href='#L1250'>1250</a>
<a name='L1251'></a><a href='#L1251'>1251</a>
<a name='L1252'></a><a href='#L1252'>1252</a>
<a name='L1253'></a><a href='#L1253'>1253</a>
<a name='L1254'></a><a href='#L1254'>1254</a>
<a name='L1255'></a><a href='#L1255'>1255</a>
<a name='L1256'></a><a href='#L1256'>1256</a>
<a name='L1257'></a><a href='#L1257'>1257</a>
<a name='L1258'></a><a href='#L1258'>1258</a>
<a name='L1259'></a><a href='#L1259'>1259</a>
<a name='L1260'></a><a href='#L1260'>1260</a>
<a name='L1261'></a><a href='#L1261'>1261</a>
<a name='L1262'></a><a href='#L1262'>1262</a>
<a name='L1263'></a><a href='#L1263'>1263</a>
<a name='L1264'></a><a href='#L1264'>1264</a>
<a name='L1265'></a><a href='#L1265'>1265</a>
<a name='L1266'></a><a href='#L1266'>1266</a>
<a name='L1267'></a><a href='#L1267'>1267</a>
<a name='L1268'></a><a href='#L1268'>1268</a>
<a name='L1269'></a><a href='#L1269'>1269</a>
<a name='L1270'></a><a href='#L1270'>1270</a>
<a name='L1271'></a><a href='#L1271'>1271</a>
<a name='L1272'></a><a href='#L1272'>1272</a>
<a name='L1273'></a><a href='#L1273'>1273</a>
<a name='L1274'></a><a href='#L1274'>1274</a>
<a name='L1275'></a><a href='#L1275'>1275</a>
<a name='L1276'></a><a href='#L1276'>1276</a>
<a name='L1277'></a><a href='#L1277'>1277</a>
<a name='L1278'></a><a href='#L1278'>1278</a>
<a name='L1279'></a><a href='#L1279'>1279</a>
<a name='L1280'></a><a href='#L1280'>1280</a>
<a name='L1281'></a><a href='#L1281'>1281</a>
<a name='L1282'></a><a href='#L1282'>1282</a>
<a name='L1283'></a><a href='#L1283'>1283</a>
<a name='L1284'></a><a href='#L1284'>1284</a>
<a name='L1285'></a><a href='#L1285'>1285</a>
<a name='L1286'></a><a href='#L1286'>1286</a>
<a name='L1287'></a><a href='#L1287'>1287</a>
<a name='L1288'></a><a href='#L1288'>1288</a>
<a name='L1289'></a><a href='#L1289'>1289</a>
<a name='L1290'></a><a href='#L1290'>1290</a>
<a name='L1291'></a><a href='#L1291'>1291</a>
<a name='L1292'></a><a href='#L1292'>1292</a>
<a name='L1293'></a><a href='#L1293'>1293</a>
<a name='L1294'></a><a href='#L1294'>1294</a>
<a name='L1295'></a><a href='#L1295'>1295</a>
<a name='L1296'></a><a href='#L1296'>1296</a>
<a name='L1297'></a><a href='#L1297'>1297</a>
<a name='L1298'></a><a href='#L1298'>1298</a>
<a name='L1299'></a><a href='#L1299'>1299</a>
<a name='L1300'></a><a href='#L1300'>1300</a>
<a name='L1301'></a><a href='#L1301'>1301</a>
<a name='L1302'></a><a href='#L1302'>1302</a>
<a name='L1303'></a><a href='#L1303'>1303</a>
<a name='L1304'></a><a href='#L1304'>1304</a>
<a name='L1305'></a><a href='#L1305'>1305</a>
<a name='L1306'></a><a href='#L1306'>1306</a>
<a name='L1307'></a><a href='#L1307'>1307</a>
<a name='L1308'></a><a href='#L1308'>1308</a>
<a name='L1309'></a><a href='#L1309'>1309</a>
<a name='L1310'></a><a href='#L1310'>1310</a>
<a name='L1311'></a><a href='#L1311'>1311</a>
<a name='L1312'></a><a href='#L1312'>1312</a>
<a name='L1313'></a><a href='#L1313'>1313</a>
<a name='L1314'></a><a href='#L1314'>1314</a>
<a name='L1315'></a><a href='#L1315'>1315</a>
<a name='L1316'></a><a href='#L1316'>1316</a>
<a name='L1317'></a><a href='#L1317'>1317</a>
<a name='L1318'></a><a href='#L1318'>1318</a>
<a name='L1319'></a><a href='#L1319'>1319</a>
<a name='L1320'></a><a href='#L1320'>1320</a>
<a name='L1321'></a><a href='#L1321'>1321</a>
<a name='L1322'></a><a href='#L1322'>1322</a>
<a name='L1323'></a><a href='#L1323'>1323</a>
<a name='L1324'></a><a href='#L1324'>1324</a>
<a name='L1325'></a><a href='#L1325'>1325</a>
<a name='L1326'></a><a href='#L1326'>1326</a>
<a name='L1327'></a><a href='#L1327'>1327</a>
<a name='L1328'></a><a href='#L1328'>1328</a>
<a name='L1329'></a><a href='#L1329'>1329</a>
<a name='L1330'></a><a href='#L1330'>1330</a>
<a name='L1331'></a><a href='#L1331'>1331</a>
<a name='L1332'></a><a href='#L1332'>1332</a>
<a name='L1333'></a><a href='#L1333'>1333</a>
<a name='L1334'></a><a href='#L1334'>1334</a>
<a name='L1335'></a><a href='#L1335'>1335</a>
<a name='L1336'></a><a href='#L1336'>1336</a>
<a name='L1337'></a><a href='#L1337'>1337</a>
<a name='L1338'></a><a href='#L1338'>1338</a>
<a name='L1339'></a><a href='#L1339'>1339</a>
<a name='L1340'></a><a href='#L1340'>1340</a>
<a name='L1341'></a><a href='#L1341'>1341</a>
<a name='L1342'></a><a href='#L1342'>1342</a>
<a name='L1343'></a><a href='#L1343'>1343</a>
<a name='L1344'></a><a href='#L1344'>1344</a>
<a name='L1345'></a><a href='#L1345'>1345</a>
<a name='L1346'></a><a href='#L1346'>1346</a>
<a name='L1347'></a><a href='#L1347'>1347</a>
<a name='L1348'></a><a href='#L1348'>1348</a>
<a name='L1349'></a><a href='#L1349'>1349</a>
<a name='L1350'></a><a href='#L1350'>1350</a>
<a name='L1351'></a><a href='#L1351'>1351</a>
<a name='L1352'></a><a href='#L1352'>1352</a>
<a name='L1353'></a><a href='#L1353'>1353</a>
<a name='L1354'></a><a href='#L1354'>1354</a>
<a name='L1355'></a><a href='#L1355'>1355</a>
<a name='L1356'></a><a href='#L1356'>1356</a>
<a name='L1357'></a><a href='#L1357'>1357</a>
<a name='L1358'></a><a href='#L1358'>1358</a>
<a name='L1359'></a><a href='#L1359'>1359</a>
<a name='L1360'></a><a href='#L1360'>1360</a>
<a name='L1361'></a><a href='#L1361'>1361</a>
<a name='L1362'></a><a href='#L1362'>1362</a>
<a name='L1363'></a><a href='#L1363'>1363</a>
<a name='L1364'></a><a href='#L1364'>1364</a>
<a name='L1365'></a><a href='#L1365'>1365</a>
<a name='L1366'></a><a href='#L1366'>1366</a>
<a name='L1367'></a><a href='#L1367'>1367</a>
<a name='L1368'></a><a href='#L1368'>1368</a>
<a name='L1369'></a><a href='#L1369'>1369</a>
<a name='L1370'></a><a href='#L1370'>1370</a>
<a name='L1371'></a><a href='#L1371'>1371</a>
<a name='L1372'></a><a href='#L1372'>1372</a>
<a name='L1373'></a><a href='#L1373'>1373</a>
<a name='L1374'></a><a href='#L1374'>1374</a>
<a name='L1375'></a><a href='#L1375'>1375</a>
<a name='L1376'></a><a href='#L1376'>1376</a>
<a name='L1377'></a><a href='#L1377'>1377</a>
<a name='L1378'></a><a href='#L1378'>1378</a>
<a name='L1379'></a><a href='#L1379'>1379</a>
<a name='L1380'></a><a href='#L1380'>1380</a>
<a name='L1381'></a><a href='#L1381'>1381</a>
<a name='L1382'></a><a href='#L1382'>1382</a>
<a name='L1383'></a><a href='#L1383'>1383</a>
<a name='L1384'></a><a href='#L1384'>1384</a>
<a name='L1385'></a><a href='#L1385'>1385</a>
<a name='L1386'></a><a href='#L1386'>1386</a>
<a name='L1387'></a><a href='#L1387'>1387</a>
<a name='L1388'></a><a href='#L1388'>1388</a>
<a name='L1389'></a><a href='#L1389'>1389</a>
<a name='L1390'></a><a href='#L1390'>1390</a>
<a name='L1391'></a><a href='#L1391'>1391</a>
<a name='L1392'></a><a href='#L1392'>1392</a>
<a name='L1393'></a><a href='#L1393'>1393</a>
<a name='L1394'></a><a href='#L1394'>1394</a>
<a name='L1395'></a><a href='#L1395'>1395</a>
<a name='L1396'></a><a href='#L1396'>1396</a>
<a name='L1397'></a><a href='#L1397'>1397</a>
<a name='L1398'></a><a href='#L1398'>1398</a>
<a name='L1399'></a><a href='#L1399'>1399</a>
<a name='L1400'></a><a href='#L1400'>1400</a>
<a name='L1401'></a><a href='#L1401'>1401</a>
<a name='L1402'></a><a href='#L1402'>1402</a>
<a name='L1403'></a><a href='#L1403'>1403</a>
<a name='L1404'></a><a href='#L1404'>1404</a>
<a name='L1405'></a><a href='#L1405'>1405</a>
<a name='L1406'></a><a href='#L1406'>1406</a>
<a name='L1407'></a><a href='#L1407'>1407</a>
<a name='L1408'></a><a href='#L1408'>1408</a>
<a name='L1409'></a><a href='#L1409'>1409</a>
<a name='L1410'></a><a href='#L1410'>1410</a>
<a name='L1411'></a><a href='#L1411'>1411</a>
<a name='L1412'></a><a href='#L1412'>1412</a>
<a name='L1413'></a><a href='#L1413'>1413</a>
<a name='L1414'></a><a href='#L1414'>1414</a>
<a name='L1415'></a><a href='#L1415'>1415</a>
<a name='L1416'></a><a href='#L1416'>1416</a>
<a name='L1417'></a><a href='#L1417'>1417</a>
<a name='L1418'></a><a href='#L1418'>1418</a>
<a name='L1419'></a><a href='#L1419'>1419</a>
<a name='L1420'></a><a href='#L1420'>1420</a>
<a name='L1421'></a><a href='#L1421'>1421</a>
<a name='L1422'></a><a href='#L1422'>1422</a>
<a name='L1423'></a><a href='#L1423'>1423</a>
<a name='L1424'></a><a href='#L1424'>1424</a>
<a name='L1425'></a><a href='#L1425'>1425</a>
<a name='L1426'></a><a href='#L1426'>1426</a>
<a name='L1427'></a><a href='#L1427'>1427</a>
<a name='L1428'></a><a href='#L1428'>1428</a>
<a name='L1429'></a><a href='#L1429'>1429</a>
<a name='L1430'></a><a href='#L1430'>1430</a>
<a name='L1431'></a><a href='#L1431'>1431</a>
<a name='L1432'></a><a href='#L1432'>1432</a>
<a name='L1433'></a><a href='#L1433'>1433</a>
<a name='L1434'></a><a href='#L1434'>1434</a>
<a name='L1435'></a><a href='#L1435'>1435</a>
<a name='L1436'></a><a href='#L1436'>1436</a>
<a name='L1437'></a><a href='#L1437'>1437</a>
<a name='L1438'></a><a href='#L1438'>1438</a>
<a name='L1439'></a><a href='#L1439'>1439</a>
<a name='L1440'></a><a href='#L1440'>1440</a>
<a name='L1441'></a><a href='#L1441'>1441</a>
<a name='L1442'></a><a href='#L1442'>1442</a>
<a name='L1443'></a><a href='#L1443'>1443</a>
<a name='L1444'></a><a href='#L1444'>1444</a>
<a name='L1445'></a><a href='#L1445'>1445</a>
<a name='L1446'></a><a href='#L1446'>1446</a>
<a name='L1447'></a><a href='#L1447'>1447</a>
<a name='L1448'></a><a href='#L1448'>1448</a>
<a name='L1449'></a><a href='#L1449'>1449</a>
<a name='L1450'></a><a href='#L1450'>1450</a>
<a name='L1451'></a><a href='#L1451'>1451</a>
<a name='L1452'></a><a href='#L1452'>1452</a>
<a name='L1453'></a><a href='#L1453'>1453</a>
<a name='L1454'></a><a href='#L1454'>1454</a>
<a name='L1455'></a><a href='#L1455'>1455</a>
<a name='L1456'></a><a href='#L1456'>1456</a>
<a name='L1457'></a><a href='#L1457'>1457</a>
<a name='L1458'></a><a href='#L1458'>1458</a>
<a name='L1459'></a><a href='#L1459'>1459</a>
<a name='L1460'></a><a href='#L1460'>1460</a>
<a name='L1461'></a><a href='#L1461'>1461</a>
<a name='L1462'></a><a href='#L1462'>1462</a>
<a name='L1463'></a><a href='#L1463'>1463</a>
<a name='L1464'></a><a href='#L1464'>1464</a>
<a name='L1465'></a><a href='#L1465'>1465</a>
<a name='L1466'></a><a href='#L1466'>1466</a>
<a name='L1467'></a><a href='#L1467'>1467</a>
<a name='L1468'></a><a href='#L1468'>1468</a>
<a name='L1469'></a><a href='#L1469'>1469</a>
<a name='L1470'></a><a href='#L1470'>1470</a>
<a name='L1471'></a><a href='#L1471'>1471</a>
<a name='L1472'></a><a href='#L1472'>1472</a>
<a name='L1473'></a><a href='#L1473'>1473</a>
<a name='L1474'></a><a href='#L1474'>1474</a>
<a name='L1475'></a><a href='#L1475'>1475</a>
<a name='L1476'></a><a href='#L1476'>1476</a>
<a name='L1477'></a><a href='#L1477'>1477</a>
<a name='L1478'></a><a href='#L1478'>1478</a>
<a name='L1479'></a><a href='#L1479'>1479</a>
<a name='L1480'></a><a href='#L1480'>1480</a>
<a name='L1481'></a><a href='#L1481'>1481</a>
<a name='L1482'></a><a href='#L1482'>1482</a>
<a name='L1483'></a><a href='#L1483'>1483</a>
<a name='L1484'></a><a href='#L1484'>1484</a>
<a name='L1485'></a><a href='#L1485'>1485</a>
<a name='L1486'></a><a href='#L1486'>1486</a>
<a name='L1487'></a><a href='#L1487'>1487</a>
<a name='L1488'></a><a href='#L1488'>1488</a>
<a name='L1489'></a><a href='#L1489'>1489</a>
<a name='L1490'></a><a href='#L1490'>1490</a>
<a name='L1491'></a><a href='#L1491'>1491</a>
<a name='L1492'></a><a href='#L1492'>1492</a>
<a name='L1493'></a><a href='#L1493'>1493</a>
<a name='L1494'></a><a href='#L1494'>1494</a>
<a name='L1495'></a><a href='#L1495'>1495</a>
<a name='L1496'></a><a href='#L1496'>1496</a>
<a name='L1497'></a><a href='#L1497'>1497</a>
<a name='L1498'></a><a href='#L1498'>1498</a>
<a name='L1499'></a><a href='#L1499'>1499</a>
<a name='L1500'></a><a href='#L1500'>1500</a>
<a name='L1501'></a><a href='#L1501'>1501</a>
<a name='L1502'></a><a href='#L1502'>1502</a>
<a name='L1503'></a><a href='#L1503'>1503</a>
<a name='L1504'></a><a href='#L1504'>1504</a>
<a name='L1505'></a><a href='#L1505'>1505</a>
<a name='L1506'></a><a href='#L1506'>1506</a>
<a name='L1507'></a><a href='#L1507'>1507</a>
<a name='L1508'></a><a href='#L1508'>1508</a>
<a name='L1509'></a><a href='#L1509'>1509</a>
<a name='L1510'></a><a href='#L1510'>1510</a>
<a name='L1511'></a><a href='#L1511'>1511</a>
<a name='L1512'></a><a href='#L1512'>1512</a>
<a name='L1513'></a><a href='#L1513'>1513</a>
<a name='L1514'></a><a href='#L1514'>1514</a>
<a name='L1515'></a><a href='#L1515'>1515</a>
<a name='L1516'></a><a href='#L1516'>1516</a>
<a name='L1517'></a><a href='#L1517'>1517</a>
<a name='L1518'></a><a href='#L1518'>1518</a>
<a name='L1519'></a><a href='#L1519'>1519</a>
<a name='L1520'></a><a href='#L1520'>1520</a>
<a name='L1521'></a><a href='#L1521'>1521</a>
<a name='L1522'></a><a href='#L1522'>1522</a>
<a name='L1523'></a><a href='#L1523'>1523</a>
<a name='L1524'></a><a href='#L1524'>1524</a>
<a name='L1525'></a><a href='#L1525'>1525</a>
<a name='L1526'></a><a href='#L1526'>1526</a>
<a name='L1527'></a><a href='#L1527'>1527</a>
<a name='L1528'></a><a href='#L1528'>1528</a>
<a name='L1529'></a><a href='#L1529'>1529</a>
<a name='L1530'></a><a href='#L1530'>1530</a>
<a name='L1531'></a><a href='#L1531'>1531</a>
<a name='L1532'></a><a href='#L1532'>1532</a>
<a name='L1533'></a><a href='#L1533'>1533</a>
<a name='L1534'></a><a href='#L1534'>1534</a>
<a name='L1535'></a><a href='#L1535'>1535</a>
<a name='L1536'></a><a href='#L1536'>1536</a>
<a name='L1537'></a><a href='#L1537'>1537</a>
<a name='L1538'></a><a href='#L1538'>1538</a>
<a name='L1539'></a><a href='#L1539'>1539</a>
<a name='L1540'></a><a href='#L1540'>1540</a>
<a name='L1541'></a><a href='#L1541'>1541</a>
<a name='L1542'></a><a href='#L1542'>1542</a>
<a name='L1543'></a><a href='#L1543'>1543</a>
<a name='L1544'></a><a href='#L1544'>1544</a>
<a name='L1545'></a><a href='#L1545'>1545</a>
<a name='L1546'></a><a href='#L1546'>1546</a>
<a name='L1547'></a><a href='#L1547'>1547</a>
<a name='L1548'></a><a href='#L1548'>1548</a>
<a name='L1549'></a><a href='#L1549'>1549</a>
<a name='L1550'></a><a href='#L1550'>1550</a>
<a name='L1551'></a><a href='#L1551'>1551</a>
<a name='L1552'></a><a href='#L1552'>1552</a>
<a name='L1553'></a><a href='#L1553'>1553</a>
<a name='L1554'></a><a href='#L1554'>1554</a>
<a name='L1555'></a><a href='#L1555'>1555</a>
<a name='L1556'></a><a href='#L1556'>1556</a>
<a name='L1557'></a><a href='#L1557'>1557</a>
<a name='L1558'></a><a href='#L1558'>1558</a>
<a name='L1559'></a><a href='#L1559'>1559</a>
<a name='L1560'></a><a href='#L1560'>1560</a>
<a name='L1561'></a><a href='#L1561'>1561</a>
<a name='L1562'></a><a href='#L1562'>1562</a>
<a name='L1563'></a><a href='#L1563'>1563</a>
<a name='L1564'></a><a href='#L1564'>1564</a>
<a name='L1565'></a><a href='#L1565'>1565</a>
<a name='L1566'></a><a href='#L1566'>1566</a>
<a name='L1567'></a><a href='#L1567'>1567</a>
<a name='L1568'></a><a href='#L1568'>1568</a>
<a name='L1569'></a><a href='#L1569'>1569</a>
<a name='L1570'></a><a href='#L1570'>1570</a>
<a name='L1571'></a><a href='#L1571'>1571</a>
<a name='L1572'></a><a href='#L1572'>1572</a>
<a name='L1573'></a><a href='#L1573'>1573</a>
<a name='L1574'></a><a href='#L1574'>1574</a>
<a name='L1575'></a><a href='#L1575'>1575</a>
<a name='L1576'></a><a href='#L1576'>1576</a>
<a name='L1577'></a><a href='#L1577'>1577</a>
<a name='L1578'></a><a href='#L1578'>1578</a>
<a name='L1579'></a><a href='#L1579'>1579</a>
<a name='L1580'></a><a href='#L1580'>1580</a>
<a name='L1581'></a><a href='#L1581'>1581</a>
<a name='L1582'></a><a href='#L1582'>1582</a>
<a name='L1583'></a><a href='#L1583'>1583</a>
<a name='L1584'></a><a href='#L1584'>1584</a>
<a name='L1585'></a><a href='#L1585'>1585</a>
<a name='L1586'></a><a href='#L1586'>1586</a>
<a name='L1587'></a><a href='#L1587'>1587</a>
<a name='L1588'></a><a href='#L1588'>1588</a>
<a name='L1589'></a><a href='#L1589'>1589</a>
<a name='L1590'></a><a href='#L1590'>1590</a>
<a name='L1591'></a><a href='#L1591'>1591</a>
<a name='L1592'></a><a href='#L1592'>1592</a>
<a name='L1593'></a><a href='#L1593'>1593</a>
<a name='L1594'></a><a href='#L1594'>1594</a>
<a name='L1595'></a><a href='#L1595'>1595</a>
<a name='L1596'></a><a href='#L1596'>1596</a>
<a name='L1597'></a><a href='#L1597'>1597</a>
<a name='L1598'></a><a href='#L1598'>1598</a>
<a name='L1599'></a><a href='#L1599'>1599</a>
<a name='L1600'></a><a href='#L1600'>1600</a>
<a name='L1601'></a><a href='#L1601'>1601</a>
<a name='L1602'></a><a href='#L1602'>1602</a>
<a name='L1603'></a><a href='#L1603'>1603</a>
<a name='L1604'></a><a href='#L1604'>1604</a>
<a name='L1605'></a><a href='#L1605'>1605</a>
<a name='L1606'></a><a href='#L1606'>1606</a>
<a name='L1607'></a><a href='#L1607'>1607</a>
<a name='L1608'></a><a href='#L1608'>1608</a>
<a name='L1609'></a><a href='#L1609'>1609</a>
<a name='L1610'></a><a href='#L1610'>1610</a>
<a name='L1611'></a><a href='#L1611'>1611</a>
<a name='L1612'></a><a href='#L1612'>1612</a>
<a name='L1613'></a><a href='#L1613'>1613</a>
<a name='L1614'></a><a href='#L1614'>1614</a>
<a name='L1615'></a><a href='#L1615'>1615</a>
<a name='L1616'></a><a href='#L1616'>1616</a>
<a name='L1617'></a><a href='#L1617'>1617</a>
<a name='L1618'></a><a href='#L1618'>1618</a>
<a name='L1619'></a><a href='#L1619'>1619</a>
<a name='L1620'></a><a href='#L1620'>1620</a>
<a name='L1621'></a><a href='#L1621'>1621</a>
<a name='L1622'></a><a href='#L1622'>1622</a>
<a name='L1623'></a><a href='#L1623'>1623</a>
<a name='L1624'></a><a href='#L1624'>1624</a>
<a name='L1625'></a><a href='#L1625'>1625</a>
<a name='L1626'></a><a href='#L1626'>1626</a>
<a name='L1627'></a><a href='#L1627'>1627</a>
<a name='L1628'></a><a href='#L1628'>1628</a>
<a name='L1629'></a><a href='#L1629'>1629</a>
<a name='L1630'></a><a href='#L1630'>1630</a>
<a name='L1631'></a><a href='#L1631'>1631</a>
<a name='L1632'></a><a href='#L1632'>1632</a>
<a name='L1633'></a><a href='#L1633'>1633</a>
<a name='L1634'></a><a href='#L1634'>1634</a>
<a name='L1635'></a><a href='#L1635'>1635</a>
<a name='L1636'></a><a href='#L1636'>1636</a>
<a name='L1637'></a><a href='#L1637'>1637</a>
<a name='L1638'></a><a href='#L1638'>1638</a>
<a name='L1639'></a><a href='#L1639'>1639</a>
<a name='L1640'></a><a href='#L1640'>1640</a>
<a name='L1641'></a><a href='#L1641'>1641</a>
<a name='L1642'></a><a href='#L1642'>1642</a>
<a name='L1643'></a><a href='#L1643'>1643</a>
<a name='L1644'></a><a href='#L1644'>1644</a>
<a name='L1645'></a><a href='#L1645'>1645</a>
<a name='L1646'></a><a href='#L1646'>1646</a>
<a name='L1647'></a><a href='#L1647'>1647</a>
<a name='L1648'></a><a href='#L1648'>1648</a>
<a name='L1649'></a><a href='#L1649'>1649</a>
<a name='L1650'></a><a href='#L1650'>1650</a>
<a name='L1651'></a><a href='#L1651'>1651</a>
<a name='L1652'></a><a href='#L1652'>1652</a>
<a name='L1653'></a><a href='#L1653'>1653</a>
<a name='L1654'></a><a href='#L1654'>1654</a>
<a name='L1655'></a><a href='#L1655'>1655</a>
<a name='L1656'></a><a href='#L1656'>1656</a>
<a name='L1657'></a><a href='#L1657'>1657</a>
<a name='L1658'></a><a href='#L1658'>1658</a>
<a name='L1659'></a><a href='#L1659'>1659</a>
<a name='L1660'></a><a href='#L1660'>1660</a>
<a name='L1661'></a><a href='#L1661'>1661</a>
<a name='L1662'></a><a href='#L1662'>1662</a>
<a name='L1663'></a><a href='#L1663'>1663</a>
<a name='L1664'></a><a href='#L1664'>1664</a>
<a name='L1665'></a><a href='#L1665'>1665</a>
<a name='L1666'></a><a href='#L1666'>1666</a>
<a name='L1667'></a><a href='#L1667'>1667</a>
<a name='L1668'></a><a href='#L1668'>1668</a>
<a name='L1669'></a><a href='#L1669'>1669</a>
<a name='L1670'></a><a href='#L1670'>1670</a>
<a name='L1671'></a><a href='#L1671'>1671</a>
<a name='L1672'></a><a href='#L1672'>1672</a>
<a name='L1673'></a><a href='#L1673'>1673</a>
<a name='L1674'></a><a href='#L1674'>1674</a>
<a name='L1675'></a><a href='#L1675'>1675</a>
<a name='L1676'></a><a href='#L1676'>1676</a>
<a name='L1677'></a><a href='#L1677'>1677</a>
<a name='L1678'></a><a href='#L1678'>1678</a>
<a name='L1679'></a><a href='#L1679'>1679</a>
<a name='L1680'></a><a href='#L1680'>1680</a>
<a name='L1681'></a><a href='#L1681'>1681</a>
<a name='L1682'></a><a href='#L1682'>1682</a>
<a name='L1683'></a><a href='#L1683'>1683</a>
<a name='L1684'></a><a href='#L1684'>1684</a>
<a name='L1685'></a><a href='#L1685'>1685</a>
<a name='L1686'></a><a href='#L1686'>1686</a>
<a name='L1687'></a><a href='#L1687'>1687</a>
<a name='L1688'></a><a href='#L1688'>1688</a>
<a name='L1689'></a><a href='#L1689'>1689</a>
<a name='L1690'></a><a href='#L1690'>1690</a>
<a name='L1691'></a><a href='#L1691'>1691</a>
<a name='L1692'></a><a href='#L1692'>1692</a>
<a name='L1693'></a><a href='#L1693'>1693</a>
<a name='L1694'></a><a href='#L1694'>1694</a>
<a name='L1695'></a><a href='#L1695'>1695</a>
<a name='L1696'></a><a href='#L1696'>1696</a>
<a name='L1697'></a><a href='#L1697'>1697</a>
<a name='L1698'></a><a href='#L1698'>1698</a>
<a name='L1699'></a><a href='#L1699'>1699</a>
<a name='L1700'></a><a href='#L1700'>1700</a>
<a name='L1701'></a><a href='#L1701'>1701</a>
<a name='L1702'></a><a href='#L1702'>1702</a>
<a name='L1703'></a><a href='#L1703'>1703</a>
<a name='L1704'></a><a href='#L1704'>1704</a>
<a name='L1705'></a><a href='#L1705'>1705</a>
<a name='L1706'></a><a href='#L1706'>1706</a>
<a name='L1707'></a><a href='#L1707'>1707</a>
<a name='L1708'></a><a href='#L1708'>1708</a>
<a name='L1709'></a><a href='#L1709'>1709</a>
<a name='L1710'></a><a href='#L1710'>1710</a>
<a name='L1711'></a><a href='#L1711'>1711</a>
<a name='L1712'></a><a href='#L1712'>1712</a>
<a name='L1713'></a><a href='#L1713'>1713</a>
<a name='L1714'></a><a href='#L1714'>1714</a>
<a name='L1715'></a><a href='#L1715'>1715</a>
<a name='L1716'></a><a href='#L1716'>1716</a>
<a name='L1717'></a><a href='#L1717'>1717</a>
<a name='L1718'></a><a href='#L1718'>1718</a>
<a name='L1719'></a><a href='#L1719'>1719</a>
<a name='L1720'></a><a href='#L1720'>1720</a>
<a name='L1721'></a><a href='#L1721'>1721</a>
<a name='L1722'></a><a href='#L1722'>1722</a>
<a name='L1723'></a><a href='#L1723'>1723</a>
<a name='L1724'></a><a href='#L1724'>1724</a>
<a name='L1725'></a><a href='#L1725'>1725</a>
<a name='L1726'></a><a href='#L1726'>1726</a>
<a name='L1727'></a><a href='#L1727'>1727</a>
<a name='L1728'></a><a href='#L1728'>1728</a>
<a name='L1729'></a><a href='#L1729'>1729</a>
<a name='L1730'></a><a href='#L1730'>1730</a>
<a name='L1731'></a><a href='#L1731'>1731</a>
<a name='L1732'></a><a href='#L1732'>1732</a>
<a name='L1733'></a><a href='#L1733'>1733</a>
<a name='L1734'></a><a href='#L1734'>1734</a>
<a name='L1735'></a><a href='#L1735'>1735</a>
<a name='L1736'></a><a href='#L1736'>1736</a>
<a name='L1737'></a><a href='#L1737'>1737</a>
<a name='L1738'></a><a href='#L1738'>1738</a>
<a name='L1739'></a><a href='#L1739'>1739</a>
<a name='L1740'></a><a href='#L1740'>1740</a>
<a name='L1741'></a><a href='#L1741'>1741</a>
<a name='L1742'></a><a href='#L1742'>1742</a>
<a name='L1743'></a><a href='#L1743'>1743</a>
<a name='L1744'></a><a href='#L1744'>1744</a>
<a name='L1745'></a><a href='#L1745'>1745</a>
<a name='L1746'></a><a href='#L1746'>1746</a>
<a name='L1747'></a><a href='#L1747'>1747</a>
<a name='L1748'></a><a href='#L1748'>1748</a>
<a name='L1749'></a><a href='#L1749'>1749</a>
<a name='L1750'></a><a href='#L1750'>1750</a>
<a name='L1751'></a><a href='#L1751'>1751</a>
<a name='L1752'></a><a href='#L1752'>1752</a>
<a name='L1753'></a><a href='#L1753'>1753</a>
<a name='L1754'></a><a href='#L1754'>1754</a>
<a name='L1755'></a><a href='#L1755'>1755</a>
<a name='L1756'></a><a href='#L1756'>1756</a>
<a name='L1757'></a><a href='#L1757'>1757</a>
<a name='L1758'></a><a href='#L1758'>1758</a>
<a name='L1759'></a><a href='#L1759'>1759</a>
<a name='L1760'></a><a href='#L1760'>1760</a>
<a name='L1761'></a><a href='#L1761'>1761</a>
<a name='L1762'></a><a href='#L1762'>1762</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">const allDescriptors=<span class="cstat-no" title="statement not covered" >[];</span>let applicationDescriptor;const _loadedScripts=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const k of[]){}</span>
<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){const baseUrl=<span class="cstat-no" title="statement not covered" >self.location?self.location.origin+self.location.pathname:'';<span class="cstat-no" title="statement not covered" ></span>self._importScriptPathPrefix=baseUrl.substring(0,baseUrl.lastIndexOf('/')+1);}</span>)();c</span>onst REMOTE_MODULE_FALLBACK_REVISION=<span class="cstat-no" title="statement not covered" >'@010ddcfda246975d194964ccf20038ebbdec6084';</span>var Runtime=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(descriptors){<span class="cstat-no" title="statement not covered" >this._modules=[];<span class="cstat-no" title="statement not covered" >t</span>his._modulesMap={};<span class="cstat-no" title="statement not covered" >t</span>his._extensions=[];<span class="cstat-no" title="statement not covered" >t</span>his._cachedTypeClasses={};<span class="cstat-no" title="statement not covered" >t</span>his._descriptorsMap={};<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;descriptors.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this._registerModule(descriptors[i]);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic loadResourcePromise(url){<span class="cstat-no" title="statement not covered" >return new Promise(load);f</span>unction <span class="fstat-no" title="function not covered" >load(</span>fulfill,reject){const xhr=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest();<span class="cstat-no" title="statement not covered" ></span>xhr.open('GET',url,true);<span class="cstat-no" title="statement not covered" >x</span>hr.onreadystatechange=onreadystatechange;f</span>unction <span class="fstat-no" title="function not covered" >onreadystatechange(</span>e){<span class="cstat-no" title="statement not covered" >if(xhr.readyState!==XMLHttpRequest.DONE)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst status=<span class="cstat-no" title="statement not covered" >/^HTTP\/1.1 404/.test(e.target.response)?404:xhr.status;<span class="cstat-no" title="statement not covered" ></span>if([0,200,304].indexOf(status)===-1)</span>
<span class="cstat-no" title="statement not covered" >reject(new Error('While loading from url '+url+' server responded with a status of '+status));e</span>lse
<span class="cstat-no" title="statement not covered" >fulfill(e.target.response);}</span>
<span class="cstat-no" title="statement not covered" >xhr.send(null);}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic loadResourcePromiseWithFallback(url){<span class="cstat-no" title="statement not covered" >return Runtime.loadResourcePromise(url).catch(<span class="fstat-no" title="function not covered" >er</span>r=&gt;{const urlWithFallbackVersion=<span class="cstat-no" title="statement not covered" >url.replace(/@[0-9a-f]{40}/,REMOTE_MODULE_FALLBACK_REVISION);<span class="cstat-no" title="statement not covered" ></span>if(urlWithFallbackVersion===url||!url.includes('audits2_worker_module'))</span></span>
<span class="cstat-no" title="statement not covered" >throw err;<span class="cstat-no" title="statement not covered" >r</span>eturn Runtime.loadResourcePromise(urlWithFallbackVersion);}</span>);}
<span class="fstat-no" title="function not covered" >st</span>atic normalizePath(path){<span class="cstat-no" title="statement not covered" >if(path.indexOf('..')===-1&amp;&amp;path.indexOf('.')===-1)</span>
<span class="cstat-no" title="statement not covered" >return path;c</span>onst normalizedSegments=<span class="cstat-no" title="statement not covered" >[];</span>const segments=<span class="cstat-no" title="statement not covered" >path.split('/');<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;segments.length;i++){const segment=<span class="cstat-no" title="statement not covered" >segments[i];<span class="cstat-no" title="statement not covered" ></span>if(segment==='.')</span></span>
<span class="cstat-no" title="statement not covered" >continue;e</span>lse <span class="cstat-no" title="statement not covered" >if(segment==='..')</span>
<span class="cstat-no" title="statement not covered" >normalizedSegments.pop();e</span>lse <span class="cstat-no" title="statement not covered" >if(segment)</span>
<span class="cstat-no" title="statement not covered" >normalizedSegments.push(segment);}</span>
let normalizedPath=<span class="cstat-no" title="statement not covered" >normalizedSegments.join('/');<span class="cstat-no" title="statement not covered" ></span>if(normalizedPath[normalizedPath.length-1]==='/')</span>
<span class="cstat-no" title="statement not covered" >return normalizedPath;<span class="cstat-no" title="statement not covered" >i</span>f(path[0]==='/'&amp;&amp;normalizedPath)</span>
<span class="cstat-no" title="statement not covered" >normalizedPath='/'+normalizedPath;<span class="cstat-no" title="statement not covered" >i</span>f((path[path.length-1]==='/')||(segments[segments.length-1]==='.')||(segments[segments.length-1]==='..'))</span>
<span class="cstat-no" title="statement not covered" >normalizedPath=normalizedPath+'/';<span class="cstat-no" title="statement not covered" >r</span>eturn normalizedPath;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _loadScriptsPromise(scriptNames,base){const promises=<span class="cstat-no" title="statement not covered" >[];</span>const urls=<span class="cstat-no" title="statement not covered" >[];</span>const sources=<span class="cstat-no" title="statement not covered" >new Array(scriptNames.length);</span>let scriptToEval=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;scriptNames.length;++i){const scriptName=<span class="cstat-no" title="statement not covered" >scriptNames[i];</span>let sourceURL=<span class="cstat-no" title="statement not covered" >(base||self._importScriptPathPrefix)+scriptName;</span>const schemaIndex=<span class="cstat-no" title="statement not covered" >sourceURL.indexOf('://')+3;</span>let pathIndex=<span class="cstat-no" title="statement not covered" >sourceURL.indexOf('/',schemaIndex);<span class="cstat-no" title="statement not covered" ></span>if(pathIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >pathIndex=sourceURL.length;<span class="cstat-no" title="statement not covered" >s</span>ourceURL=sourceURL.substring(0,pathIndex)+Runtime.normalizePath(sourceURL.substring(pathIndex));<span class="cstat-no" title="statement not covered" >i</span>f(_loadedScripts[sourceURL])</span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >u</span>rls.push(sourceURL);c</span>onst loadResourcePromise=<span class="cstat-no" title="statement not covered" >base?Runtime.loadResourcePromiseWithFallback(sourceURL):Runtime.loadResourcePromise(sourceURL);<span class="cstat-no" title="statement not covered" ></span>promises.push(loadResourcePromise.then(scriptSourceLoaded.bind(null,i),scriptSourceLoaded.bind(null,i,undefined)));}</span>
<span class="cstat-no" title="statement not covered" >return Promise.all(promises).then(undefined);f</span>unction <span class="fstat-no" title="function not covered" >scriptSourceLoaded(</span>scriptNumber,scriptSource){<span class="cstat-no" title="statement not covered" >sources[scriptNumber]=scriptSource||'';<span class="cstat-no" title="statement not covered" >w</span>hile(typeof sources[scriptToEval]!=='undefined'){<span class="cstat-no" title="statement not covered" >evaluateScript(urls[scriptToEval],sources[scriptToEval]);<span class="cstat-no" title="statement not covered" >+</span>+scriptToEval;}</span>}</span>
function <span class="fstat-no" title="function not covered" >evaluateScript(</span>sourceURL,scriptSource){<span class="cstat-no" title="statement not covered" >_loadedScripts[sourceURL]=true;<span class="cstat-no" title="statement not covered" >i</span>f(!scriptSource){<span class="cstat-no" title="statement not covered" >console.error('Empty response arrived for script \''+sourceURL+'\'');<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >self.eval(scriptSource+'\n//# sourceURL='+sourceURL);}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic _loadResourceIntoCache(url,appendSourceURL){<span class="cstat-no" title="statement not covered" >return Runtime.loadResourcePromise(url).then(cacheResource.bind(this,url),cacheResource.bind(this,url,undefined));f</span>unction <span class="fstat-no" title="function not covered" >cacheResource(</span>path,content){<span class="cstat-no" title="statement not covered" >if(!content){<span class="cstat-no" title="statement not covered" >console.error('Failed to load resource: '+path);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const sourceURL=<span class="cstat-no" title="statement not covered" >appendSourceURL?Runtime.resolveSourceURL(path):'';<span class="cstat-no" title="statement not covered" ></span>Runtime.cachedResources[path]=content+sourceURL;}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic async appStarted(){<span class="cstat-no" title="statement not covered" >return Runtime._appStartedPromise;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic async startApplication(appName){<span class="cstat-no" title="statement not covered" >console.timeStamp('Runtime.startApplication');c</span>onst allDescriptorsByName=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;allDescriptors.length;++i){const d=<span class="cstat-no" title="statement not covered" >allDescriptors[i];<span class="cstat-no" title="statement not covered" ></span>allDescriptorsByName[d['name']]=d;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!applicationDescriptor){let data=<span class="cstat-no" title="statement not covered" >await Runtime.loadResourcePromise(appName+'.json');<span class="cstat-no" title="statement not covered" ></span>applicationDescriptor=JSON.parse(data);l</span>et descriptor=<span class="cstat-no" title="statement not covered" >applicationDescriptor;<span class="cstat-no" title="statement not covered" ></span>while(descriptor.extends){<span class="cstat-no" title="statement not covered" >data=await Runtime.loadResourcePromise(descriptor.extends+'.json');<span class="cstat-no" title="statement not covered" >d</span>escriptor=JSON.parse(data);<span class="cstat-no" title="statement not covered" >a</span>pplicationDescriptor.modules=descriptor.modules.concat(applicationDescriptor.modules);}</span>}</span></span>
const configuration=<span class="cstat-no" title="statement not covered" >applicationDescriptor.modules;</span>const moduleJSONPromises=<span class="cstat-no" title="statement not covered" >[];</span>const coreModuleNames=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;configuration.length;++i){const descriptor=<span class="cstat-no" title="statement not covered" >configuration[i];</span>const name=<span class="cstat-no" title="statement not covered" >descriptor['name'];</span>const moduleJSON=<span class="cstat-no" title="statement not covered" >allDescriptorsByName[name];<span class="cstat-no" title="statement not covered" ></span>if(moduleJSON)</span></span>
<span class="cstat-no" title="statement not covered" >moduleJSONPromises.push(Promise.resolve(moduleJSON));e</span>lse
<span class="cstat-no" title="statement not covered" >moduleJSONPromises.push(Runtime.loadResourcePromise(name+'/module.json').then(JSON.parse.bind(JSON)));<span class="cstat-no" title="statement not covered" >i</span>f(descriptor['type']==='autostart')</span>
<span class="cstat-no" title="statement not covered" >coreModuleNames.push(name);}</span>
const moduleDescriptors=<span class="cstat-no" title="statement not covered" >await Promise.all(moduleJSONPromises);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;moduleDescriptors.length;++i){<span class="cstat-no" title="statement not covered" >moduleDescriptors[i].name=configuration[i]['name'];<span class="cstat-no" title="statement not covered" >m</span>oduleDescriptors[i].condition=configuration[i]['condition'];<span class="cstat-no" title="statement not covered" >m</span>oduleDescriptors[i].remote=configuration[i]['type']==='remote';}</span></span>
<span class="cstat-no" title="statement not covered" >self.runtime=new Runtime(moduleDescriptors);<span class="cstat-no" title="statement not covered" >i</span>f(coreModuleNames)</span>
<span class="cstat-no" title="statement not covered" >await self.runtime._loadAutoStartModules(coreModuleNames);<span class="cstat-no" title="statement not covered" >R</span>untime._appStartedPromiseCallback();}</span>
<span class="fstat-no" title="function not covered" >st</span>atic startWorker(appName){<span class="cstat-no" title="statement not covered" >return Runtime.startApplication(appName).then(sendWorkerReady);f</span>unction <span class="fstat-no" title="function not covered" >sendWorkerReady(</span>){<span class="cstat-no" title="statement not covered" >self.postMessage('workerReady');}</span>}
<span class="fstat-no" title="function not covered" >st</span>atic queryParam(name){<span class="cstat-no" title="statement not covered" >return Runtime._queryParamsObject.get(name);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic queryParamsString(){<span class="cstat-no" title="statement not covered" >return location.search;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _experimentsSetting(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return(JSON.parse(self.localStorage&amp;&amp;self.localStorage['experiments']?self.localStorage['experiments']:'{}'));}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.error('Failed to parse localStorage[\'experiments\']');<span class="cstat-no" title="statement not covered" >r</span>eturn{};}</span>}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _assert(value,message){<span class="cstat-no" title="statement not covered" >if(value)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >R</span>untime._originalAssert.call(Runtime._console,value,message+' '+new Error().stack);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic setPlatform(platform){<span class="cstat-no" title="statement not covered" >Runtime._platform=platform;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic _isDescriptorEnabled(descriptor){const activatorExperiment=<span class="cstat-no" title="statement not covered" >descriptor['experiment'];<span class="cstat-no" title="statement not covered" ></span>if(activatorExperiment==='*')</span>
<span class="cstat-no" title="statement not covered" >return Runtime.experiments.supportEnabled();<span class="cstat-no" title="statement not covered" >i</span>f(activatorExperiment&amp;&amp;activatorExperiment.startsWith('!')&amp;&amp;Runtime.experiments.isEnabled(activatorExperiment.substring(1)))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(activatorExperiment&amp;&amp;!activatorExperiment.startsWith('!')&amp;&amp;!Runtime.experiments.isEnabled(activatorExperiment))</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst condition=<span class="cstat-no" title="statement not covered" >descriptor['condition'];<span class="cstat-no" title="statement not covered" ></span>if(condition&amp;&amp;!condition.startsWith('!')&amp;&amp;!Runtime.queryParam(condition))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(condition&amp;&amp;condition.startsWith('!')&amp;&amp;Runtime.queryParam(condition.substring(1)))</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >st</span>atic resolveSourceURL(path){let sourceURL=<span class="cstat-no" title="statement not covered" >self.location.href;<span class="cstat-no" title="statement not covered" ></span>if(self.location.search)</span>
<span class="cstat-no" title="statement not covered" >sourceURL=sourceURL.replace(self.location.search,'');<span class="cstat-no" title="statement not covered" >s</span>ourceURL=sourceURL.substring(0,sourceURL.lastIndexOf('/')+1)+path;<span class="cstat-no" title="statement not covered" >r</span>eturn'\n/*# sourceURL='+sourceURL+' */';}</span>
<span class="fstat-no" title="function not covered" >us</span>eTestBase(){<span class="cstat-no" title="statement not covered" >Runtime._remoteBase='http://localhost:8000/inspector-sources/';<span class="cstat-no" title="statement not covered" >i</span>f(Runtime.queryParam('debugFrontend'))</span>
<span class="cstat-no" title="statement not covered" >Runtime._remoteBase+='debug/';}</span>
<span class="fstat-no" title="function not covered" >_r</span>egisterModule(descriptor){const module=<span class="cstat-no" title="statement not covered" >new Runtime.Module(this,descriptor);<span class="cstat-no" title="statement not covered" ></span>this._modules.push(module);<span class="cstat-no" title="statement not covered" >t</span>his._modulesMap[descriptor['name']]=module;}</span>
<span class="fstat-no" title="function not covered" >lo</span>adModulePromise(moduleName){<span class="cstat-no" title="statement not covered" >return this._modulesMap[moduleName]._loadPromise();}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadAutoStartModules(moduleNames){const promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;moduleNames.length;++i)</span>
<span class="cstat-no" title="statement not covered" >promises.push(this.loadModulePromise(moduleNames[i]));<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.all(promises);}</span>
<span class="fstat-no" title="function not covered" >_c</span>heckExtensionApplicability(extension,predicate){<span class="cstat-no" title="statement not covered" >if(!predicate)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst contextTypes=<span class="cstat-no" title="statement not covered" >extension.descriptor().contextTypes;<span class="cstat-no" title="statement not covered" ></span>if(!contextTypes)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;contextTypes.length;++i){const contextType=<span class="cstat-no" title="statement not covered" >this._resolve(contextTypes[i]);</span>const isMatching=<span class="cstat-no" title="statement not covered" >!!contextType&amp;&amp;predicate(contextType);<span class="cstat-no" title="statement not covered" ></span>if(isMatching)</span></span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="fstat-no" title="function not covered" >is</span>ExtensionApplicableToContext(extension,context){<span class="cstat-no" title="statement not covered" >if(!context)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span>eturn this._checkExtensionApplicability(extension,isInstanceOf);f</span>unction <span class="fstat-no" title="function not covered" >isInstanceOf(</span>targetType){<span class="cstat-no" title="statement not covered" >return context instanceof targetType;}</span>}
<span class="fstat-no" title="function not covered" >is</span>ExtensionApplicableToContextTypes(extension,currentContextTypes){<span class="cstat-no" title="statement not covered" >if(!extension.descriptor().contextTypes)</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span>eturn this._checkExtensionApplicability(extension,currentContextTypes?isContextTypeKnown:null);f</span>unction <span class="fstat-no" title="function not covered" >isContextTypeKnown(</span>targetType){<span class="cstat-no" title="statement not covered" >return currentContextTypes.has(targetType);}</span>}
<span class="fstat-no" title="function not covered" >ex</span>tensions(type,context,sortByTitle){<span class="cstat-no" title="statement not covered" >return this._extensions.filter(filter).sort(sortByTitle?titleComparator:orderComparator);f</span>unction <span class="fstat-no" title="function not covered" >filter(</span>extension){<span class="cstat-no" title="statement not covered" >if(extension._type!==type&amp;&amp;extension._typeClass()!==type)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(!extension.enabled())</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn!context||extension.isApplicable(context);}</span>
function <span class="fstat-no" title="function not covered" >orderComparator(</span>extension1,extension2){const order1=<span class="cstat-no" title="statement not covered" >extension1.descriptor()['order']||0;</span>const order2=<span class="cstat-no" title="statement not covered" >extension2.descriptor()['order']||0;<span class="cstat-no" title="statement not covered" ></span>return order1-order2;}</span>
function <span class="fstat-no" title="function not covered" >titleComparator(</span>extension1,extension2){const title1=<span class="cstat-no" title="statement not covered" >extension1.title()||'';</span>const title2=<span class="cstat-no" title="statement not covered" >extension2.title()||'';<span class="cstat-no" title="statement not covered" ></span>return title1.localeCompare(title2);}</span>}
<span class="fstat-no" title="function not covered" >ex</span>tension(type,context){<span class="cstat-no" title="statement not covered" >return this.extensions(type,context)[0]||null;}</span>
<span class="fstat-no" title="function not covered" >al</span>lInstances(type,context){<span class="cstat-no" title="statement not covered" >return Promise.all(this.extensions(type,context).map(<span class="fstat-no" title="function not covered" >ex</span>tension=&gt;<span class="cstat-no" title="statement not covered" >extension.instance())</span>);}</span>
<span class="fstat-no" title="function not covered" >_r</span>esolve(typeName){<span class="cstat-no" title="statement not covered" >if(!this._cachedTypeClasses[typeName]){const path=<span class="cstat-no" title="statement not covered" >typeName.split('.');</span>let object=<span class="cstat-no" title="statement not covered" >self;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;object&amp;&amp;(i&lt;path.length);++i)</span></span>
<span class="cstat-no" title="statement not covered" >object=object[path[i]];<span class="cstat-no" title="statement not covered" >i</span>f(object)</span>
<span class="cstat-no" title="statement not covered" >this._cachedTypeClasses[typeName]=(object);}</span>
<span class="cstat-no" title="statement not covered" >return this._cachedTypeClasses[typeName]||null;}</span>
<span class="fstat-no" title="function not covered" >sh</span>aredInstance(constructorFunction){<span class="cstat-no" title="statement not covered" >if(Runtime._instanceSymbol in constructorFunction&amp;&amp;Object.getOwnPropertySymbols(constructorFunction).includes(Runtime._instanceSymbol))</span>
<span class="cstat-no" title="statement not covered" >return constructorFunction[Runtime._instanceSymbol];c</span>onst instance=<span class="cstat-no" title="statement not covered" >new constructorFunction();<span class="cstat-no" title="statement not covered" ></span>constructorFunction[Runtime._instanceSymbol]=instance;<span class="cstat-no" title="statement not covered" >r</span>eturn instance;}</span>};<span class="cstat-no" title="statement not covered" >Runtime._queryParamsObject=new URLSearchParams(Runtime.queryParamsString());<span class="cstat-no" title="statement not covered" >R</span>untime._instanceSymbol=Symbol('instance');<span class="cstat-no" title="statement not covered" >R</span>untime.cachedResources={__proto__:null};<span class="cstat-no" title="statement not covered" >R</span>untime._console=console;<span class="cstat-no" title="statement not covered" >R</span>untime._originalAssert=console.assert;<span class="cstat-no" title="statement not covered" >R</span>untime._platform='';<span class="cstat-no" title="statement not covered" >R</span>untime.ModuleDescriptor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.name;<span class="cstat-no" title="statement not covered" >t</span>his.extensions;<span class="cstat-no" title="statement not covered" >t</span>his.dependencies;<span class="cstat-no" title="statement not covered" >t</span>his.scripts;<span class="cstat-no" title="statement not covered" >t</span>his.condition;<span class="cstat-no" title="statement not covered" >t</span>his.remote;}</span>};<span class="cstat-no" title="statement not covered" >R</span>untime.ExtensionDescriptor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.type;<span class="cstat-no" title="statement not covered" >t</span>his.className;<span class="cstat-no" title="statement not covered" >t</span>his.factoryName;<span class="cstat-no" title="statement not covered" >t</span>his.contextTypes;}</span>};<span class="cstat-no" title="statement not covered" >R</span>untime.Module=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(manager,descriptor){<span class="cstat-no" title="statement not covered" >this._manager=manager;<span class="cstat-no" title="statement not covered" >t</span>his._descriptor=descriptor;<span class="cstat-no" title="statement not covered" >t</span>his._name=descriptor.name;<span class="cstat-no" title="statement not covered" >t</span>his._extensions=[];<span class="cstat-no" title="statement not covered" >t</span>his._extensionsByClassName=new Map();c</span>onst extensions=(<span class="cstat-no" title="statement not covered" >descriptor.extensions)</span>;<span class="cstat-no" title="statement not covered" >for(let i=0;extensions&amp;&amp;i&lt;extensions.length;++i){const extension=<span class="cstat-no" title="statement not covered" >new Runtime.Extension(this,extensions[i]);<span class="cstat-no" title="statement not covered" ></span>this._manager._extensions.push(extension);<span class="cstat-no" title="statement not covered" >t</span>his._extensions.push(extension);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._loadedForTest=false;}</span>
<span class="fstat-no" title="function not covered" >na</span>me(){<span class="cstat-no" title="statement not covered" >return this._name;}</span>
<span class="fstat-no" title="function not covered" >en</span>abled(){<span class="cstat-no" title="statement not covered" >return Runtime._isDescriptorEnabled(this._descriptor);}</span>
<span class="fstat-no" title="function not covered" >re</span>source(name){const fullName=<span class="cstat-no" title="statement not covered" >this._name+'/'+name;</span>const content=<span class="cstat-no" title="statement not covered" >Runtime.cachedResources[fullName];<span class="cstat-no" title="statement not covered" ></span>if(!content)</span>
<span class="cstat-no" title="statement not covered" >throw new Error(fullName+' not preloaded. Check module.json');<span class="cstat-no" title="statement not covered" >r</span>eturn content;}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadPromise(){<span class="cstat-no" title="statement not covered" >if(!this.enabled())</span>
<span class="cstat-no" title="statement not covered" >return Promise.reject(new Error('Module '+this._name+' is not enabled'));<span class="cstat-no" title="statement not covered" >i</span>f(this._pendingLoadPromise)</span>
<span class="cstat-no" title="statement not covered" >return this._pendingLoadPromise;c</span>onst dependencies=<span class="cstat-no" title="statement not covered" >this._descriptor.dependencies;</span>const dependencyPromises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;dependencies&amp;&amp;i&lt;dependencies.length;++i)</span>
<span class="cstat-no" title="statement not covered" >dependencyPromises.push(this._manager._modulesMap[dependencies[i]]._loadPromise());<span class="cstat-no" title="statement not covered" >t</span>his._pendingLoadPromise=Promise.all(dependencyPromises).then(this._loadResources.bind(this)).then(this._loadScripts.bind(this)).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._loadedForTest=true)</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this._pendingLoadPromise;}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadResources(){const resources=<span class="cstat-no" title="statement not covered" >this._descriptor['resources'];<span class="cstat-no" title="statement not covered" ></span>if(!resources||!resources.length)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();c</span>onst promises=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;resources.length;++i){const url=<span class="cstat-no" title="statement not covered" >this._modularizeURL(resources[i]);<span class="cstat-no" title="statement not covered" ></span>promises.push(Runtime._loadResourceIntoCache(url,true));}</span></span>
<span class="cstat-no" title="statement not covered" >return Promise.all(promises).then(undefined);}</span>
<span class="fstat-no" title="function not covered" >_l</span>oadScripts(){<span class="cstat-no" title="statement not covered" >if(!this._descriptor.scripts||!this._descriptor.scripts.length)</span>
<span class="cstat-no" title="statement not covered" >return Promise.resolve();c</span>onst specialCases=<span class="cstat-no" title="statement not covered" >{'sdk':'SDK','js_sdk':'JSSDK','browser_sdk':'BrowserSDK','ui':'UI','object_ui':'ObjectUI','javascript_metadata':'JavaScriptMetadata','perf_ui':'PerfUI','har_importer':'HARImporter','sdk_test_runner':'SDKTestRunner','cpu_profiler_test_runner':'CPUProfilerTestRunner'};</span>const namespace=<span class="cstat-no" title="statement not covered" >specialCases[this._name]||this._name.split('_').map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a.substring(0,1).toUpperCase()+a.substring(1))</span>.join('');<span class="cstat-no" title="statement not covered" ></span>self[namespace]=self[namespace]||{};<span class="cstat-no" title="statement not covered" >r</span>eturn Runtime._loadScriptsPromise(this._descriptor.scripts.map(this._modularizeURL,this),this._remoteBase());}</span>
<span class="fstat-no" title="function not covered" >_m</span>odularizeURL(resourceName){<span class="cstat-no" title="statement not covered" >return Runtime.normalizePath(this._name+'/'+resourceName);}</span>
<span class="fstat-no" title="function not covered" >_r</span>emoteBase(){<span class="cstat-no" title="statement not covered" >return!Runtime.queryParam('debugFrontend')&amp;&amp;this._descriptor.remote&amp;&amp;Runtime._remoteBase||undefined;}</span>
<span class="fstat-no" title="function not covered" >su</span>bstituteURL(value){const base=<span class="cstat-no" title="statement not covered" >this._remoteBase()||'';<span class="cstat-no" title="statement not covered" ></span>return value.replace(/@url\(([^\)]*?)\)/g,convertURL.bind(this));f</span>unction <span class="fstat-no" title="function not covered" >convertURL(</span>match,url){<span class="cstat-no" title="statement not covered" >return base+this._modularizeURL(url);}</span>}};<span class="cstat-no" title="statement not covered" >Runtime.Extension=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(module,descriptor){<span class="cstat-no" title="statement not covered" >this._module=module;<span class="cstat-no" title="statement not covered" >t</span>his._descriptor=descriptor;<span class="cstat-no" title="statement not covered" >t</span>his._type=descriptor.type;<span class="cstat-no" title="statement not covered" >t</span>his._hasTypeClass=this._type.charAt(0)==='@';<span class="cstat-no" title="statement not covered" >t</span>his._className=descriptor.className||null;<span class="cstat-no" title="statement not covered" >t</span>his._factoryName=descriptor.factoryName||null;}</span></span>
<span class="fstat-no" title="function not covered" >de</span>scriptor(){<span class="cstat-no" title="statement not covered" >return this._descriptor;}</span>
<span class="fstat-no" title="function not covered" >mo</span>dule(){<span class="cstat-no" title="statement not covered" >return this._module;}</span>
<span class="fstat-no" title="function not covered" >en</span>abled(){<span class="cstat-no" title="statement not covered" >return this._module.enabled()&amp;&amp;Runtime._isDescriptorEnabled(this.descriptor());}</span>
<span class="fstat-no" title="function not covered" >_t</span>ypeClass(){<span class="cstat-no" title="statement not covered" >if(!this._hasTypeClass)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this._module._manager._resolve(this._type.substring(1));}</span>
<span class="fstat-no" title="function not covered" >is</span>Applicable(context){<span class="cstat-no" title="statement not covered" >return this._module._manager.isExtensionApplicableToContext(this,context);}</span>
<span class="fstat-no" title="function not covered" >in</span>stance(){<span class="cstat-no" title="statement not covered" >return this._module._loadPromise().then(this._createInstance.bind(this));}</span>
<span class="fstat-no" title="function not covered" >ca</span>nInstantiate(){<span class="cstat-no" title="statement not covered" >return!!(this._className||this._factoryName);}</span>
<span class="fstat-no" title="function not covered" >_c</span>reateInstance(){const className=<span class="cstat-no" title="statement not covered" >this._className||this._factoryName;<span class="cstat-no" title="statement not covered" ></span>if(!className)</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Could not instantiate extension with no class');c</span>onst constructorFunction=<span class="cstat-no" title="statement not covered" >self.eval((className));<span class="cstat-no" title="statement not covered" ></span>if(!(constructorFunction instanceof Function))</span>
<span class="cstat-no" title="statement not covered" >throw new Error('Could not instantiate: '+className);<span class="cstat-no" title="statement not covered" >i</span>f(this._className)</span>
<span class="cstat-no" title="statement not covered" >return this._module._manager.sharedInstance(constructorFunction);<span class="cstat-no" title="statement not covered" >r</span>eturn new constructorFunction(this);}</span>
<span class="fstat-no" title="function not covered" >ti</span>tle(){<span class="cstat-no" title="statement not covered" >return this._descriptor['title-'+Runtime._platform]||this._descriptor['title'];}</span>
<span class="fstat-no" title="function not covered" >ha</span>sContextType(contextType){const contextTypes=<span class="cstat-no" title="statement not covered" >this.descriptor().contextTypes;<span class="cstat-no" title="statement not covered" ></span>if(!contextTypes)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;contextTypes.length;++i){<span class="cstat-no" title="statement not covered" >if(contextType===this._module._manager._resolve(contextTypes[i]))</span></span>
<span class="cstat-no" title="statement not covered" >return true;}</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>};<span class="cstat-no" title="statement not covered" >Runtime.ExperimentsSupport=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._supportEnabled=Runtime.queryParam('experiments')!==null;<span class="cstat-no" title="statement not covered" >t</span>his._experiments=[];<span class="cstat-no" title="statement not covered" >t</span>his._experimentNames={};<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently={};}</span></span>
<span class="fstat-no" title="function not covered" >al</span>lConfigurableExperiments(){const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._experiments.length;i++){const experiment=<span class="cstat-no" title="statement not covered" >this._experiments[i];<span class="cstat-no" title="statement not covered" ></span>if(!this._enabledTransiently[experiment.name])</span></span>
<span class="cstat-no" title="statement not covered" >result.push(experiment);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="fstat-no" title="function not covered" >su</span>pportEnabled(){<span class="cstat-no" title="statement not covered" >return this._supportEnabled;}</span>
<span class="fstat-no" title="function not covered" >_s</span>etExperimentsSetting(value){<span class="cstat-no" title="statement not covered" >if(!self.localStorage)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span>elf.localStorage['experiments']=JSON.stringify(value);}</span>
<span class="fstat-no" title="function not covered" >re</span>gister(experimentName,experimentTitle,hidden){<span class="cstat-no" title="statement not covered" >Runtime._assert(!this._experimentNames[experimentName],'Duplicate registration of experiment '+experimentName);<span class="cstat-no" title="statement not covered" >t</span>his._experimentNames[experimentName]=true;<span class="cstat-no" title="statement not covered" >t</span>his._experiments.push(new Runtime.Experiment(this,experimentName,experimentTitle,!!hidden));}</span>
<span class="fstat-no" title="function not covered" >is</span>Enabled(experimentName){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentName);<span class="cstat-no" title="statement not covered" >i</span>f(Runtime._experimentsSetting()[experimentName]===false)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(this._enabledTransiently[experimentName])</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >i</span>f(!this.supportEnabled())</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn!!Runtime._experimentsSetting()[experimentName];}</span>
<span class="fstat-no" title="function not covered" >se</span>tEnabled(experimentName,enabled){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentName);c</span>onst experimentsSetting=<span class="cstat-no" title="statement not covered" >Runtime._experimentsSetting();<span class="cstat-no" title="statement not covered" ></span>experimentsSetting[experimentName]=enabled;<span class="cstat-no" title="statement not covered" >t</span>his._setExperimentsSetting(experimentsSetting);}</span>
<span class="fstat-no" title="function not covered" >se</span>tDefaultExperiments(experimentNames){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;experimentNames.length;++i){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentNames[i]);<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently[experimentNames[i]]=true;}</span>}</span>
<span class="fstat-no" title="function not covered" >en</span>ableForTest(experimentName){<span class="cstat-no" title="statement not covered" >this._checkExperiment(experimentName);<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently[experimentName]=true;}</span>
<span class="fstat-no" title="function not covered" >cl</span>earForTest(){<span class="cstat-no" title="statement not covered" >this._experiments=[];<span class="cstat-no" title="statement not covered" >t</span>his._experimentNames={};<span class="cstat-no" title="statement not covered" >t</span>his._enabledTransiently={};}</span>
<span class="fstat-no" title="function not covered" >cl</span>eanUpStaleExperiments(){const experimentsSetting=<span class="cstat-no" title="statement not covered" >Runtime._experimentsSetting();</span>const cleanedUpExperimentSetting=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._experiments.length;++i){const experimentName=<span class="cstat-no" title="statement not covered" >this._experiments[i].name;<span class="cstat-no" title="statement not covered" ></span>if(experimentsSetting[experimentName])</span></span>
<span class="cstat-no" title="statement not covered" >cleanedUpExperimentSetting[experimentName]=true;}</span>
<span class="cstat-no" title="statement not covered" >this._setExperimentsSetting(cleanedUpExperimentSetting);}</span>
<span class="fstat-no" title="function not covered" >_c</span>heckExperiment(experimentName){<span class="cstat-no" title="statement not covered" >Runtime._assert(this._experimentNames[experimentName],'Unknown experiment '+experimentName);}</span>};<span class="cstat-no" title="statement not covered" >Runtime.Experiment=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(experiments,name,title,hidden){<span class="cstat-no" title="statement not covered" >this.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.title=title;<span class="cstat-no" title="statement not covered" >t</span>his.hidden=hidden;<span class="cstat-no" title="statement not covered" >t</span>his._experiments=experiments;}</span></span>
<span class="fstat-no" title="function not covered" >is</span>Enabled(){<span class="cstat-no" title="statement not covered" >return this._experiments.isEnabled(this.name);}</span>
<span class="fstat-no" title="function not covered" >se</span>tEnabled(enabled){<span class="cstat-no" title="statement not covered" >this._experiments.setEnabled(this.name,enabled);}</span>};<span class="cstat-no" title="statement not covered" >Runtime.experiments=new Runtime.ExperimentsSupport();<span class="cstat-no" title="statement not covered" >R</span>untime._appStartedPromiseCallback;<span class="cstat-no" title="statement not covered" >R</span>untime._appStartedPromise=new Promise(<span class="fstat-no" title="function not covered" >fu</span>lfil=&gt;<span class="cstat-no" title="statement not covered" >Runtime._appStartedPromiseCallback=fulfil)</span>;<span class="cstat-no" title="statement not covered" >R</span>untime._remoteBase;<span class="cstat-no" title="statement not covered" >(</span>function <span class="fstat-no" title="function not covered" >validateRemoteBase(</span>){<span class="cstat-no" title="statement not covered" >if(location.href.startsWith('chrome-devtools://devtools/bundled/')&amp;&amp;Runtime.queryParam('remoteBase')){const versionMatch=<span class="cstat-no" title="statement not covered" >/\/serve_file\/(@[0-9a-zA-Z]+)\/?$/.exec(Runtime.queryParam('remoteBase'));<span class="cstat-no" title="statement not covered" ></span>if(versionMatch)</span></span></span>
<span class="cstat-no" title="statement not covered" >Runtime._remoteBase=`${location.origin}/remote/serve_file/${versionMatch[1]}/`;}</span>})();function <span class="fstat-no" title="function not covered" >ServicePort(</span>){}
<span class="cstat-no" title="statement not covered" >ServicePort.prototype={setHandlers(messageHandler,closeHandler){},send(message){},close(){}};v</span>ar runtime;<span class="cstat-no" title="statement not covered" >allDescriptors.push(...[{"dependencies":[],"name":"platform"},{"skip_compilation":["acorn/acorn.js","acorn/acorn_loose.js","../cm_web_modes/css.js","../cm_web_modes/xml.js"],"dependencies":["platform","text_utils","cm_headless"],"name":"formatter_worker"},{"dependencies":["platform"],"name":"text_utils"},{"skip_compilation":["headlesscodemirror.js"],"name":"cm_headless"}]);<span class="cstat-no" title="statement not covered" >a</span>pplicationDescriptor={"has_html":false,"modules":[{"type":"autostart","name":"platform"},{"type":"autostart","name":"formatter_worker"},{"type":"autostart","name":"text_utils"},{"type":"autostart","name":"cm_headless"}]}</span>
<span class="cstat-no" title="statement not covered" >self['Platform']=self['Platform']||{};l</span>et ArrayLike;function <span class="fstat-no" title="function not covered" >mod(</span>m,n){<span class="cstat-no" title="statement not covered" >return((m%n)+n)%n;}</span>
<span class="cstat-no" title="statement not covered" >String.prototype.findAll=<span class="fstat-no" title="function not covered" >fu</span>nction(string){const matches=<span class="cstat-no" title="statement not covered" >[];</span>let i=<span class="cstat-no" title="statement not covered" >this.indexOf(string);<span class="cstat-no" title="statement not covered" ></span>while(i!==-1){<span class="cstat-no" title="statement not covered" >matches.push(i);<span class="cstat-no" title="statement not covered" >i</span>=this.indexOf(string,i+string.length);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return matches;}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.reverse=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.split('').reverse().join('');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.replaceControlCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/[\u0000-\u0008\u000b\u000c\u000e-\u001f\u0080-\u009f]/g,'');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.isWhitespace=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return/^\s*$/.test(this);}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.computeLineEndings=<span class="fstat-no" title="function not covered" >fu</span>nction(){const endings=<span class="cstat-no" title="statement not covered" >this.findAll('\n');<span class="cstat-no" title="statement not covered" ></span>endings.push(this.length);<span class="cstat-no" title="statement not covered" >r</span>eturn endings;}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.escapeCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(chars){let foundChar=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;chars.length;++i){<span class="cstat-no" title="statement not covered" >if(this.indexOf(chars.charAt(i))!==-1){<span class="cstat-no" title="statement not covered" >foundChar=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!foundChar)</span>
<span class="cstat-no" title="statement not covered" >return String(this);l</span>et result=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this.length;++i){<span class="cstat-no" title="statement not covered" >if(chars.indexOf(this.charAt(i))!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >result+='\\';<span class="cstat-no" title="statement not covered" >r</span>esult+=this.charAt(i);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >String.regexSpecialCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'^[]{}()\\.^$*+?|-,';}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.escapeForRegExp=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.escapeCharacters(String.regexSpecialCharacters());}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.filterRegex=<span class="fstat-no" title="function not covered" >fu</span>nction(query){const toEscape=<span class="cstat-no" title="statement not covered" >String.regexSpecialCharacters();</span>let regexString=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;query.length;++i){let c=<span class="cstat-no" title="statement not covered" >query.charAt(i);<span class="cstat-no" title="statement not covered" ></span>if(toEscape.indexOf(c)!==-1)</span></span></span>
<span class="cstat-no" title="statement not covered" >c='\\'+c;<span class="cstat-no" title="statement not covered" >i</span>f(i)</span>
<span class="cstat-no" title="statement not covered" >regexString+='[^\\0'+c+']*';<span class="cstat-no" title="statement not covered" >r</span>egexString+=c;}</span>
<span class="cstat-no" title="statement not covered" >return new RegExp(regexString,'i');}</span>;<span class="cstat-no" title="statement not covered" >String.escapeInvalidUnicodeCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >if(!String._invalidCharactersRegExp){let invalidCharacters=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0xfffe;i&lt;=0x10ffff;i+=0x10000)</span></span></span>
<span class="cstat-no" title="statement not covered" >invalidCharacters+=String.fromCodePoint(i,i+1);<span class="cstat-no" title="statement not covered" >S</span>tring._invalidCharactersRegExp=new RegExp(`[${invalidCharacters}\uD800-\uDFFF\uFDD0-\uFDEF]`,'gu');}</span>
let result=<span class="cstat-no" title="statement not covered" >'';</span>let lastPos=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(true){const match=<span class="cstat-no" title="statement not covered" >String._invalidCharactersRegExp.exec(text);<span class="cstat-no" title="statement not covered" ></span>if(!match)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span>esult+=text.substring(lastPos,match.index)+'\\u'+text.charCodeAt(match.index).toString(16);<span class="cstat-no" title="statement not covered" >i</span>f(match.index+1&lt;String._invalidCharactersRegExp.lastIndex)</span>
<span class="cstat-no" title="statement not covered" >result+='\\u'+text.charCodeAt(match.index+1).toString(16);<span class="cstat-no" title="statement not covered" >l</span>astPos=String._invalidCharactersRegExp.lastIndex;}</span>
<span class="cstat-no" title="statement not covered" >return result+text.substring(lastPos);}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.escapeHTML=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/&amp;/g,'&amp;amp;').replace(/&lt;/g,'&amp;lt;').replace(/&gt;/g,'&amp;gt;').replace(/"/g,'&amp;quot;');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.unescapeHTML=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/&amp;lt;/g,'&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;#58;/g,':').replace(/&amp;quot;/g,'"').replace(/&amp;#60;/g,'&lt;').replace(/&amp;#62;/g,'&gt;').replace(/&amp;amp;/g,'&amp;');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.collapseWhitespace=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.replace(/[\s\xA0]+/g,' ');}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.trimMiddle=<span class="fstat-no" title="function not covered" >fu</span>nction(maxLength){<span class="cstat-no" title="statement not covered" >if(this.length&lt;=maxLength)</span></span>
<span class="cstat-no" title="statement not covered" >return String(this);l</span>et leftHalf=<span class="cstat-no" title="statement not covered" >maxLength&gt;&gt;1;</span>let rightHalf=<span class="cstat-no" title="statement not covered" >maxLength-leftHalf-1;<span class="cstat-no" title="statement not covered" ></span>if(this.codePointAt(this.length-rightHalf-1)&gt;=0x10000){<span class="cstat-no" title="statement not covered" >--rightHalf;<span class="cstat-no" title="statement not covered" >+</span>+leftHalf;}</span></span>
<span class="cstat-no" title="statement not covered" >if(leftHalf&gt;0&amp;&amp;this.codePointAt(leftHalf-1)&gt;=0x10000)</span>
<span class="cstat-no" title="statement not covered" >--leftHalf;<span class="cstat-no" title="statement not covered" >r</span>eturn this.substr(0,leftHalf)+'\u2026'+this.substr(this.length-rightHalf,rightHalf);}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.trimEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(maxLength){<span class="cstat-no" title="statement not covered" >if(this.length&lt;=maxLength)</span></span>
<span class="cstat-no" title="statement not covered" >return String(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this.substr(0,maxLength-1)+'\u2026';}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.trimURL=<span class="fstat-no" title="function not covered" >fu</span>nction(baseURLDomain){let result=<span class="cstat-no" title="statement not covered" >this.replace(/^(https|http|file):\/\//i,'');<span class="cstat-no" title="statement not covered" ></span>if(baseURLDomain){<span class="cstat-no" title="statement not covered" >if(result.toLowerCase().startsWith(baseURLDomain.toLowerCase()))</span></span></span>
<span class="cstat-no" title="statement not covered" >result=result.substr(baseURLDomain.length);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.toTitleCase=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.substring(0,1).toUpperCase()+this.substring(1);}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.compareTo=<span class="fstat-no" title="function not covered" >fu</span>nction(other){<span class="cstat-no" title="statement not covered" >if(this&gt;other)</span></span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(this&lt;other)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>;<span class="cstat-no" title="statement not covered" >String.prototype.removeURLFragment=<span class="fstat-no" title="function not covered" >fu</span>nction(){let fragmentIndex=<span class="cstat-no" title="statement not covered" >this.indexOf('#');<span class="cstat-no" title="statement not covered" ></span>if(fragmentIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >fragmentIndex=this.length;<span class="cstat-no" title="statement not covered" >r</span>eturn this.substring(0,fragmentIndex);}</span>;<span class="cstat-no" title="statement not covered" >String.hashCode=<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >if(!string)</span></span>
<span class="cstat-no" title="statement not covered" >return 0;c</span>onst p=(<span class="cstat-no" title="statement not covered" >(1&lt;&lt;30)*4-5)</span>;const z=<span class="cstat-no" title="statement not covered" >0x5033d967;</span>const z2=<span class="cstat-no" title="statement not covered" >0x59d2f15d;</span>let s=<span class="cstat-no" title="statement not covered" >0;</span>let zi=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;string.length;i++){const xi=<span class="cstat-no" title="statement not covered" >string.charCodeAt(i)*z2;<span class="cstat-no" title="statement not covered" ></span>s=(s+zi*xi)%p;<span class="cstat-no" title="statement not covered" >z</span>i=(zi*z)%p;}</span></span>
<span class="cstat-no" title="statement not covered" >s=(s+zi*(p-1))%p;<span class="cstat-no" title="statement not covered" >r</span>eturn Math.abs(s|0);}</span>;<span class="cstat-no" title="statement not covered" >String.isDigitAt=<span class="fstat-no" title="function not covered" >fu</span>nction(string,index){const c=<span class="cstat-no" title="statement not covered" >string.charCodeAt(index);<span class="cstat-no" title="statement not covered" ></span>return(48&lt;=c&amp;&amp;c&lt;=57);}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.prototype.toBase64=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >encodeBits(</span>b){<span class="cstat-no" title="statement not covered" >return b&lt;26?b+65:b&lt;52?b+71:b&lt;62?b-4:b===62?43:b===63?47:65;}</span></span>
const encoder=<span class="cstat-no" title="statement not covered" >new TextEncoder();</span>const data=<span class="cstat-no" title="statement not covered" >encoder.encode(this.toString());</span>const n=<span class="cstat-no" title="statement not covered" >data.length;</span>let encoded=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(n===0)</span>
<span class="cstat-no" title="statement not covered" >return encoded;l</span>et shift;let v=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;n;i++){<span class="cstat-no" title="statement not covered" >shift=i%3;<span class="cstat-no" title="statement not covered" >v</span>|=data[i]&lt;&lt;(16&gt;&gt;&gt;shift&amp;24);<span class="cstat-no" title="statement not covered" >i</span>f(shift===2){<span class="cstat-no" title="statement not covered" >encoded+=String.fromCharCode(encodeBits(v&gt;&gt;&gt;18&amp;63),encodeBits(v&gt;&gt;&gt;12&amp;63),encodeBits(v&gt;&gt;&gt;6&amp;63),encodeBits(v&amp;63));<span class="cstat-no" title="statement not covered" >v</span>=0;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(shift===0)</span>
<span class="cstat-no" title="statement not covered" >encoded+=String.fromCharCode(encodeBits(v&gt;&gt;&gt;18&amp;63),encodeBits(v&gt;&gt;&gt;12&amp;63),61,61);e</span>lse <span class="cstat-no" title="statement not covered" >if(shift===1)</span>
<span class="cstat-no" title="statement not covered" >encoded+=String.fromCharCode(encodeBits(v&gt;&gt;&gt;18&amp;63),encodeBits(v&gt;&gt;&gt;12&amp;63),encodeBits(v&gt;&gt;&gt;6&amp;63),61);<span class="cstat-no" title="statement not covered" >r</span>eturn encoded;}</span>;<span class="cstat-no" title="statement not covered" >String.naturalOrderComparator=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){const chunk=<span class="cstat-no" title="statement not covered" >/^\d+|^\D+/;</span>let chunka,chunkb,anum,bnum;<span class="cstat-no" title="statement not covered" >while(1){<span class="cstat-no" title="statement not covered" >if(a){<span class="cstat-no" title="statement not covered" >if(!b)</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return 1;}</span>else{<span class="cstat-no" title="statement not covered" >if(b)</span>
<span class="cstat-no" title="statement not covered" >return-1;e</span>lse
<span class="cstat-no" title="statement not covered" >return 0;}</span>
<span class="cstat-no" title="statement not covered" >chunka=a.match(chunk)[0];<span class="cstat-no" title="statement not covered" >c</span>hunkb=b.match(chunk)[0];<span class="cstat-no" title="statement not covered" >a</span>num=!isNaN(chunka);<span class="cstat-no" title="statement not covered" >b</span>num=!isNaN(chunkb);<span class="cstat-no" title="statement not covered" >i</span>f(anum&amp;&amp;!bnum)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(bnum&amp;&amp;!anum)</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(anum&amp;&amp;bnum){const diff=<span class="cstat-no" title="statement not covered" >chunka-chunkb;<span class="cstat-no" title="statement not covered" ></span>if(diff)</span></span>
<span class="cstat-no" title="statement not covered" >return diff;<span class="cstat-no" title="statement not covered" >i</span>f(chunka.length!==chunkb.length){<span class="cstat-no" title="statement not covered" >if(!+chunka&amp;&amp;!+chunkb)</span></span>
<span class="cstat-no" title="statement not covered" >return chunka.length-chunkb.length;e</span>lse
<span class="cstat-no" title="statement not covered" >return chunkb.length-chunka.length;}</span>}else <span class="cstat-no" title="statement not covered" >if(chunka!==chunkb){<span class="cstat-no" title="statement not covered" >return(chunka&lt;chunkb)?-1:1;}</span></span>
<span class="cstat-no" title="statement not covered" >a=a.substring(chunka.length);<span class="cstat-no" title="statement not covered" >b</span>=b.substring(chunkb.length);}</span>};<span class="cstat-no" title="statement not covered" >String.caseInsensetiveComparator=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >a=a.toUpperCase();<span class="cstat-no" title="statement not covered" >b</span>=b.toUpperCase();<span class="cstat-no" title="statement not covered" >i</span>f(a===b)</span></span>
<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >r</span>eturn a&gt;b?1:-1;}</span>;<span class="cstat-no" title="statement not covered" >Number.constrain=<span class="fstat-no" title="function not covered" >fu</span>nction(num,min,max){<span class="cstat-no" title="statement not covered" >if(num&lt;min)</span></span>
<span class="cstat-no" title="statement not covered" >num=min;e</span>lse <span class="cstat-no" title="statement not covered" >if(num&gt;max)</span>
<span class="cstat-no" title="statement not covered" >num=max;<span class="cstat-no" title="statement not covered" >r</span>eturn num;}</span>;<span class="cstat-no" title="statement not covered" >Number.gcd=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >if(b===0)</span></span>
<span class="cstat-no" title="statement not covered" >return a;e</span>lse
<span class="cstat-no" title="statement not covered" >return Number.gcd(b,a%b);}</span>;<span class="cstat-no" title="statement not covered" >Number.toFixedIfFloating=<span class="fstat-no" title="function not covered" >fu</span>nction(value){<span class="cstat-no" title="statement not covered" >if(!value||isNaN(value))</span></span>
<span class="cstat-no" title="statement not covered" >return value;c</span>onst number=<span class="cstat-no" title="statement not covered" >Number(value);<span class="cstat-no" title="statement not covered" ></span>return number%1?number.toFixed(3):String(number);}</span>;<span class="cstat-no" title="statement not covered" >Date.prototype.isValid=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!isNaN(this.getTime());}</span>;<span class="cstat-no" title="statement not covered" >D</span>ate.prototype.toISO8601Compact=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >leadZero(</span>x){<span class="cstat-no" title="statement not covered" >return(x&gt;9?'':'0')+x;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.getFullYear()+leadZero(this.getMonth()+1)+leadZero(this.getDate())+'T'+</span>
leadZero(this.getHours())+leadZero(this.getMinutes())+leadZero(this.getSeconds());};<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'remove',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(value,firstOnly){let index=<span class="cstat-no" title="statement not covered" >this.indexOf(value);<span class="cstat-no" title="statement not covered" ></span>if(index===-1)</span></span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(firstOnly){<span class="cstat-no" title="statement not covered" >this.splice(index,1);<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span></span>
<span class="cstat-no" title="statement not covered" >for(let i=index+1,n=this.length;i&lt;n;++i){<span class="cstat-no" title="statement not covered" >if(this[i]!==value)</span></span>
<span class="cstat-no" title="statement not covered" >this[index++]=this[i];}</span>
<span class="cstat-no" title="statement not covered" >this.length=index;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'pushAll',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(array){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;array.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this.push(array[i]);}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'rotate',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(index){const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=index;i&lt;index+this.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >result.push(this[i%this.length]);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'sortNumbers',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >numericComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a-b;}</span></span>
<span class="cstat-no" title="statement not covered" >this.sort(numericComparator);}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Uint32Array.prototype,'sort',{value:Array.prototype.sort});<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(){const partition=<span class="cstat-no" title="statement not covered" >{value:<span class="fstat-no" title="function not covered" >fu</span>nction(comparator,left,right,pivotIndex){function <span class="fstat-no" title="function not covered" >swap(</span>array,i1,i2){const temp=<span class="cstat-no" title="statement not covered" >array[i1];<span class="cstat-no" title="statement not covered" ></span>array[i1]=array[i2];<span class="cstat-no" title="statement not covered" >a</span>rray[i2]=temp;}</span></span></span>
const pivotValue=<span class="cstat-no" title="statement not covered" >this[pivotIndex];<span class="cstat-no" title="statement not covered" ></span>swap(this,right,pivotIndex);l</span>et storeIndex=<span class="cstat-no" title="statement not covered" >left;<span class="cstat-no" title="statement not covered" ></span>for(let i=left;i&lt;right;++i){<span class="cstat-no" title="statement not covered" >if(comparator(this[i],pivotValue)&lt;0){<span class="cstat-no" title="statement not covered" >swap(this,storeIndex,i);<span class="cstat-no" title="statement not covered" >+</span>+storeIndex;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >swap(this,right,storeIndex);<span class="cstat-no" title="statement not covered" >r</span>eturn storeIndex;}</span>};<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'partition',partition);<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Uint32Array.prototype,'partition',partition);c</span>onst sortRange=<span class="cstat-no" title="statement not covered" >{value:<span class="fstat-no" title="function not covered" >fu</span>nction(comparator,leftBound,rightBound,sortWindowLeft,sortWindowRight){function <span class="fstat-no" title="function not covered" >quickSortRange(</span>array,comparator,left,right,sortWindowLeft,sortWindowRight){<span class="cstat-no" title="statement not covered" >if(right&lt;=left)</span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst pivotIndex=<span class="cstat-no" title="statement not covered" >Math.floor(Math.random()*(right-left))+left;</span>const pivotNewIndex=<span class="cstat-no" title="statement not covered" >array.partition(comparator,left,right,pivotIndex);<span class="cstat-no" title="statement not covered" ></span>if(sortWindowLeft&lt;pivotNewIndex)</span>
<span class="cstat-no" title="statement not covered" >quickSortRange(array,comparator,left,pivotNewIndex-1,sortWindowLeft,sortWindowRight);<span class="cstat-no" title="statement not covered" >i</span>f(pivotNewIndex&lt;sortWindowRight)</span>
<span class="cstat-no" title="statement not covered" >quickSortRange(array,comparator,pivotNewIndex+1,right,sortWindowLeft,sortWindowRight);}</span>
<span class="cstat-no" title="statement not covered" >if(leftBound===0&amp;&amp;rightBound===(this.length-1)&amp;&amp;sortWindowLeft===0&amp;&amp;sortWindowRight&gt;=rightBound)</span>
<span class="cstat-no" title="statement not covered" >this.sort(comparator);e</span>lse
<span class="cstat-no" title="statement not covered" >quickSortRange(this,comparator,leftBound,rightBound,sortWindowLeft,sortWindowRight);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>};<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'sortRange',sortRange);<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Uint32Array.prototype,'sortRange',sortRange);}</span>)();<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'stableSort',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(comparator){function <span class="fstat-no" title="function not covered" >defaultComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a&lt;b?-1:(a&gt;b?1:0);}</span></span>
<span class="cstat-no" title="statement not covered" >comparator=comparator||defaultComparator;c</span>onst indices=<span class="cstat-no" title="statement not covered" >new Array(this.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this.length;++i)</span>
<span class="cstat-no" title="statement not covered" >indices[i]=i;c</span>onst self=<span class="cstat-no" title="statement not covered" >this;</span>function <span class="fstat-no" title="function not covered" >indexComparator(</span>a,b){const result=<span class="cstat-no" title="statement not covered" >comparator(self[a],self[b]);<span class="cstat-no" title="statement not covered" ></span>return result?result:a-b;}</span>
<span class="cstat-no" title="statement not covered" >indices.sort(indexComparator);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;this.length;++i){<span class="cstat-no" title="statement not covered" >if(indices[i]&lt;0||i===indices[i])</span></span>
<span class="cstat-no" title="statement not covered" >continue;l</span>et cyclical=<span class="cstat-no" title="statement not covered" >i;</span>const saved=<span class="cstat-no" title="statement not covered" >this[i];<span class="cstat-no" title="statement not covered" ></span>while(true){const next=<span class="cstat-no" title="statement not covered" >indices[cyclical];<span class="cstat-no" title="statement not covered" ></span>indices[cyclical]=-1;<span class="cstat-no" title="statement not covered" >i</span>f(next===i){<span class="cstat-no" title="statement not covered" >this[cyclical]=saved;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else{<span class="cstat-no" title="statement not covered" >this[cyclical]=this[next];<span class="cstat-no" title="statement not covered" >c</span>yclical=next;}</span>}</span>}</span>
<span class="cstat-no" title="statement not covered" >return this;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'qselect',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(k,comparator){<span class="cstat-no" title="statement not covered" >if(k&lt;0||k&gt;=this.length)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(!comparator){<span class="cstat-no" title="statement not covered" >comparator=<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return a-b;}</span>;}</span></span>
let low=<span class="cstat-no" title="statement not covered" >0;</span>let high=<span class="cstat-no" title="statement not covered" >this.length-1;<span class="cstat-no" title="statement not covered" ></span>for(;;){const pivotPosition=<span class="cstat-no" title="statement not covered" >this.partition(comparator,low,high,Math.floor((high+low)/2));<span class="cstat-no" title="statement not covered" ></span>if(pivotPosition===k)</span></span>
<span class="cstat-no" title="statement not covered" >return this[k];e</span>lse <span class="cstat-no" title="statement not covered" >if(pivotPosition&gt;k)</span>
<span class="cstat-no" title="statement not covered" >high=pivotPosition-1;e</span>lse
<span class="cstat-no" title="statement not covered" >low=pivotPosition+1;}</span>}});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'lowerBound',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(object,comparator,left,right){function <span class="fstat-no" title="function not covered" >defaultComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a&lt;b?-1:(a&gt;b?1:0);}</span></span>
<span class="cstat-no" title="statement not covered" >comparator=comparator||defaultComparator;l</span>et l=<span class="cstat-no" title="statement not covered" >left||0;</span>let r=<span class="cstat-no" title="statement not covered" >right!==undefined?right:this.length;<span class="cstat-no" title="statement not covered" ></span>while(l&lt;r){const m=<span class="cstat-no" title="statement not covered" >(l+r)&gt;&gt;1;<span class="cstat-no" title="statement not covered" ></span>if(comparator(object,this[m])&gt;0)</span></span>
<span class="cstat-no" title="statement not covered" >l=m+1;e</span>lse
<span class="cstat-no" title="statement not covered" >r=m;}</span>
<span class="cstat-no" title="statement not covered" >return r;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'upperBound',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(object,comparator,left,right){function <span class="fstat-no" title="function not covered" >defaultComparator(</span>a,b){<span class="cstat-no" title="statement not covered" >return a&lt;b?-1:(a&gt;b?1:0);}</span></span>
<span class="cstat-no" title="statement not covered" >comparator=comparator||defaultComparator;l</span>et l=<span class="cstat-no" title="statement not covered" >left||0;</span>let r=<span class="cstat-no" title="statement not covered" >right!==undefined?right:this.length;<span class="cstat-no" title="statement not covered" ></span>while(l&lt;r){const m=<span class="cstat-no" title="statement not covered" >(l+r)&gt;&gt;1;<span class="cstat-no" title="statement not covered" ></span>if(comparator(object,this[m])&gt;=0)</span></span>
<span class="cstat-no" title="statement not covered" >l=m+1;e</span>lse
<span class="cstat-no" title="statement not covered" >r=m;}</span>
<span class="cstat-no" title="statement not covered" >return r;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Uint32Array.prototype,'lowerBound',{value:Array.prototype.lowerBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Uint32Array.prototype,'upperBound',{value:Array.prototype.upperBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Int32Array.prototype,'lowerBound',{value:Array.prototype.lowerBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Int32Array.prototype,'upperBound',{value:Array.prototype.upperBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Float64Array.prototype,'lowerBound',{value:Array.prototype.lowerBound});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Array.prototype,'binaryIndexOf',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(value,comparator){const index=<span class="cstat-no" title="statement not covered" >this.lowerBound(value,comparator);<span class="cstat-no" title="statement not covered" ></span>return index&lt;this.length&amp;&amp;comparator(value,this[index])===0?index:-1;}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Array.prototype,'select',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(field){const result=<span class="cstat-no" title="statement not covered" >new Array(this.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this.length;++i)</span></span>
<span class="cstat-no" title="statement not covered" >result[i]=this[i][field];<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>});<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'peekLast',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this[this.length-1];}</span>});<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(){function <span class="fstat-no" title="function not covered" >mergeOrIntersect(</span>array1,array2,comparator,mergeNotIntersect){const result=<span class="cstat-no" title="statement not covered" >[];</span>let i=<span class="cstat-no" title="statement not covered" >0;</span>let j=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(i&lt;array1.length&amp;&amp;j&lt;array2.length){const compareValue=<span class="cstat-no" title="statement not covered" >comparator(array1[i],array2[j]);<span class="cstat-no" title="statement not covered" ></span>if(mergeNotIntersect||!compareValue)</span></span></span>
<span class="cstat-no" title="statement not covered" >result.push(compareValue&lt;=0?array1[i]:array2[j]);<span class="cstat-no" title="statement not covered" >i</span>f(compareValue&lt;=0)</span>
<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >i</span>f(compareValue&gt;=0)</span>
<span class="cstat-no" title="statement not covered" >j++;}</span>
<span class="cstat-no" title="statement not covered" >if(mergeNotIntersect){<span class="cstat-no" title="statement not covered" >while(i&lt;array1.length)</span></span>
<span class="cstat-no" title="statement not covered" >result.push(array1[i++]);<span class="cstat-no" title="statement not covered" >w</span>hile(j&lt;array2.length)</span>
<span class="cstat-no" title="statement not covered" >result.push(array2[j++]);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
<span class="cstat-no" title="statement not covered" >Object.defineProperty(Array.prototype,'intersectOrdered',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(array,comparator){<span class="cstat-no" title="statement not covered" >return mergeOrIntersect(this,array,comparator,false);}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(Array.prototype,'mergeOrdered',{value:<span class="fstat-no" title="function not covered" >fu</span>nction(array,comparator){<span class="cstat-no" title="statement not covered" >return mergeOrIntersect(this,array,comparator,true);}</span>});}</span>)();<span class="cstat-no" title="statement not covered" >String.sprintf=<span class="fstat-no" title="function not covered" >fu</span>nction(format,var_arg){<span class="cstat-no" title="statement not covered" >return String.vsprintf(format,Array.prototype.slice.call(arguments,1));}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.tokenizeFormatString=<span class="fstat-no" title="function not covered" >fu</span>nction(format,formatters){const tokens=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >addStringToken(</span>str){<span class="cstat-no" title="statement not covered" >if(!str)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(tokens.length&amp;&amp;tokens[tokens.length-1].type==='string')</span>
<span class="cstat-no" title="statement not covered" >tokens[tokens.length-1].value+=str;e</span>lse
<span class="cstat-no" title="statement not covered" >tokens.push({type:'string',value:str});}</span>
function <span class="fstat-no" title="function not covered" >addSpecifierToken(</span>specifier,precision,substitutionIndex){<span class="cstat-no" title="statement not covered" >tokens.push({type:'specifier',specifier:specifier,precision:precision,substitutionIndex:substitutionIndex});}</span>
function <span class="fstat-no" title="function not covered" >addAnsiColor(</span>code){const types=<span class="cstat-no" title="statement not covered" >{3:'color',9:'colorLight',4:'bgColor',10:'bgColorLight'};</span>const colorCodes=<span class="cstat-no" title="statement not covered" >['black','red','green','yellow','blue','magenta','cyan','lightGray','','default'];</span>const colorCodesLight=<span class="cstat-no" title="statement not covered" >['darkGray','lightRed','lightGreen','lightYellow','lightBlue','lightMagenta','lightCyan','white',''];</span>const colors=<span class="cstat-no" title="statement not covered" >{color:colorCodes,colorLight:colorCodesLight,bgColor:colorCodes,bgColorLight:colorCodesLight};</span>const type=<span class="cstat-no" title="statement not covered" >types[Math.floor(code/10)];<span class="cstat-no" title="statement not covered" ></span>if(!type)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst color=<span class="cstat-no" title="statement not covered" >colors[type][code%10];<span class="cstat-no" title="statement not covered" ></span>if(!color)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>okens.push({type:'specifier',specifier:'c',value:{description:(type.startsWith('bg')?'background : ':'color: ')+color}});}</span>
let textStart=<span class="cstat-no" title="statement not covered" >0;</span>let substitutionIndex=<span class="cstat-no" title="statement not covered" >0;</span>const re=<span class="cstat-no" title="statement not covered" >new RegExp(`%%|%(?:(\\d+)\\$)?(?:\\.(\\d*))?([${Object.keys(formatters).join('')}])|\\u001b\\[(\\d+)m`,'g');<span class="cstat-no" title="statement not covered" ></span>for(let match=re.exec(format);!!match;match=re.exec(format)){const matchStart=<span class="cstat-no" title="statement not covered" >match.index;<span class="cstat-no" title="statement not covered" ></span>if(matchStart&gt;textStart)</span></span>
<span class="cstat-no" title="statement not covered" >addStringToken(format.substring(textStart,matchStart));<span class="cstat-no" title="statement not covered" >i</span>f(match[0]==='%%'){<span class="cstat-no" title="statement not covered" >addStringToken('%');}</span>else <span class="cstat-no" title="statement not covered" >if(match[0].startsWith('%')){const[_,substitionString,precisionString,specifierString]=<span class="cstat-no" title="statement not covered" >match;<span class="cstat-no" title="statement not covered" ></span>if(substitionString&amp;&amp;Number(substitionString)&gt;0)</span></span></span>
<span class="cstat-no" title="statement not covered" >substitutionIndex=Number(substitionString)-1;c</span>onst precision=<span class="cstat-no" title="statement not covered" >precisionString?Number(precisionString):-1;<span class="cstat-no" title="statement not covered" ></span>addSpecifierToken(specifierString,precision,substitutionIndex);<span class="cstat-no" title="statement not covered" >+</span>+substitutionIndex;}</span>else{const code=<span class="cstat-no" title="statement not covered" >Number(match[4]);<span class="cstat-no" title="statement not covered" ></span>addAnsiColor(code);}</span>
<span class="cstat-no" title="statement not covered" >textStart=matchStart+match[0].length;}</span>
<span class="cstat-no" title="statement not covered" >addStringToken(format.substring(textStart));<span class="cstat-no" title="statement not covered" >r</span>eturn tokens;}</span>;<span class="cstat-no" title="statement not covered" >String.standardFormatters={d:<span class="fstat-no" title="function not covered" >fu</span>nction(substitution){<span class="cstat-no" title="statement not covered" >return!isNaN(substitution)?substitution:0;}</span>,f:<span class="fstat-no" title="function not covered" >fu</span>nction(substitution,token){<span class="cstat-no" title="statement not covered" >if(substitution&amp;&amp;token.precision&gt;-1)</span></span>
<span class="cstat-no" title="statement not covered" >substitution=substitution.toFixed(token.precision);<span class="cstat-no" title="statement not covered" >r</span>eturn!isNaN(substitution)?substitution:(token.precision&gt;-1?Number(0).toFixed(token.precision):0);}</span>,s:<span class="fstat-no" title="function not covered" >fu</span>nction(substitution){<span class="cstat-no" title="statement not covered" >return substitution;}</span>};<span class="cstat-no" title="statement not covered" >String.vsprintf=<span class="fstat-no" title="function not covered" >fu</span>nction(format,substitutions){<span class="cstat-no" title="statement not covered" >return String.format(format,substitutions,String.standardFormatters,'',<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return a+b;}</span>).formattedResult;}</span>;<span class="cstat-no" title="statement not covered" >S</span>tring.format=<span class="fstat-no" title="function not covered" >fu</span>nction(format,substitutions,formatters,initialValue,append,tokenizedFormat){<span class="cstat-no" title="statement not covered" >if(!format||((!substitutions||!substitutions.length)&amp;&amp;format.search(/\u001b\[(\d+)m/)===-1))</span></span>
<span class="cstat-no" title="statement not covered" >return{formattedResult:append(initialValue,format),unusedSubstitutions:substitutions};f</span>unction <span class="fstat-no" title="function not covered" >prettyFunctionName(</span>){<span class="cstat-no" title="statement not covered" >return'String.format("'+format+'", "'+Array.prototype.join.call(substitutions,'", "')+'")';}</span>
function <span class="fstat-no" title="function not covered" >warn(</span>msg){<span class="cstat-no" title="statement not covered" >console.warn(prettyFunctionName()+': '+msg);}</span>
function <span class="fstat-no" title="function not covered" >error(</span>msg){<span class="cstat-no" title="statement not covered" >console.error(prettyFunctionName()+': '+msg);}</span>
let result=<span class="cstat-no" title="statement not covered" >initialValue;</span>const tokens=<span class="cstat-no" title="statement not covered" >tokenizedFormat||String.tokenizeFormatString(format,formatters);</span>const usedSubstitutionIndexes=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;tokens.length;++i){const token=<span class="cstat-no" title="statement not covered" >tokens[i];<span class="cstat-no" title="statement not covered" ></span>if(token.type==='string'){<span class="cstat-no" title="statement not covered" >result=append(result,token.value);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(token.type!=='specifier'){<span class="cstat-no" title="statement not covered" >error('Unknown token type "'+token.type+'" found.');<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!token.value&amp;&amp;token.substitutionIndex&gt;=substitutions.length){<span class="cstat-no" title="statement not covered" >error('not enough substitution arguments. Had '+substitutions.length+' but needed '+</span></span>
(token.substitutionIndex+1)+', so substitution was skipped.');<span class="cstat-no" title="statement not covered" >result=append(result,'%'+(token.precision&gt;-1?token.precision:'')+token.specifier);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span>
<span class="cstat-no" title="statement not covered" >if(!token.value)</span>
<span class="cstat-no" title="statement not covered" >usedSubstitutionIndexes[token.substitutionIndex]=true;<span class="cstat-no" title="statement not covered" >i</span>f(!(token.specifier in formatters)){<span class="cstat-no" title="statement not covered" >warn('unsupported format character \u201C'+token.specifier+'\u201D. Treating as a string.');<span class="cstat-no" title="statement not covered" >r</span>esult=append(result,token.value?'':substitutions[token.substitutionIndex]);<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >result=append(result,formatters[token.specifier](token.value||substitutions[token.substitutionIndex],token));}</span>
const unusedSubstitutions=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;substitutions.length;++i){<span class="cstat-no" title="statement not covered" >if(i in usedSubstitutionIndexes)</span></span>
<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >u</span>nusedSubstitutions.push(substitutions[i]);}</span>
<span class="cstat-no" title="statement not covered" >return{formattedResult:result,unusedSubstitutions:unusedSubstitutions};}</span>;function <span class="fstat-no" title="function not covered" >createSearchRegex(</span>query,caseSensitive,isRegex){const regexFlags=<span class="cstat-no" title="statement not covered" >caseSensitive?'g':'gi';</span>let regexObject;<span class="cstat-no" title="statement not covered" >if(isRegex){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >regexObject=new RegExp(query,regexFlags);}</span>catch(e){}}</span></span>
<span class="cstat-no" title="statement not covered" >if(!regexObject)</span>
<span class="cstat-no" title="statement not covered" >regexObject=createPlainTextSearchRegex(query,regexFlags);<span class="cstat-no" title="statement not covered" >r</span>eturn regexObject;}</span>
function <span class="fstat-no" title="function not covered" >createPlainTextSearchRegex(</span>query,flags){const regexSpecialCharacters=<span class="cstat-no" title="statement not covered" >String.regexSpecialCharacters();</span>let regex=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;query.length;++i){const c=<span class="cstat-no" title="statement not covered" >query.charAt(i);<span class="cstat-no" title="statement not covered" ></span>if(regexSpecialCharacters.indexOf(c)!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >regex+='\\';<span class="cstat-no" title="statement not covered" >r</span>egex+=c;}</span>
<span class="cstat-no" title="statement not covered" >return new RegExp(regex,flags||'');}</span>
function <span class="fstat-no" title="function not covered" >countRegexMatches(</span>regex,content){let text=<span class="cstat-no" title="statement not covered" >content;</span>let result=<span class="cstat-no" title="statement not covered" >0;</span>let match;<span class="cstat-no" title="statement not covered" >while(text&amp;&amp;(match=regex.exec(text))){<span class="cstat-no" title="statement not covered" >if(match[0].length&gt;0)</span></span>
<span class="cstat-no" title="statement not covered" >++result;<span class="cstat-no" title="statement not covered" >t</span>ext=text.substring(match.index+1);}</span>
<span class="cstat-no" title="statement not covered" >return result;}</span>
function <span class="fstat-no" title="function not covered" >spacesPadding(</span>spacesCount){<span class="cstat-no" title="statement not covered" >return'\u00a0'.repeat(spacesCount);}</span>
function <span class="fstat-no" title="function not covered" >numberToStringWithSpacesPadding(</span>value,symbolsCount){const numberString=<span class="cstat-no" title="statement not covered" >value.toString();</span>const paddingLength=<span class="cstat-no" title="statement not covered" >Math.max(0,symbolsCount-numberString.length);<span class="cstat-no" title="statement not covered" ></span>return spacesPadding(paddingLength)+numberString;}</span>
<span class="cstat-no" title="statement not covered" >Set.prototype.valuesArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Array.from(this.values());}</span>;<span class="cstat-no" title="statement not covered" >S</span>et.prototype.firstValue=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.size)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.values().next().value;}</span>;<span class="cstat-no" title="statement not covered" >Set.prototype.addAll=<span class="fstat-no" title="function not covered" >fu</span>nction(iterable){<span class="cstat-no" title="statement not covered" >for(const e of iterable)</span></span>
<span class="cstat-no" title="statement not covered" >this.add(e);}</span>;<span class="cstat-no" title="statement not covered" >Set.prototype.containsAll=<span class="fstat-no" title="function not covered" >fu</span>nction(iterable){<span class="cstat-no" title="statement not covered" >for(const e of iterable){<span class="cstat-no" title="statement not covered" >if(!this.has(e))</span></span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>;<span class="cstat-no" title="statement not covered" >Map.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(key){const value=<span class="cstat-no" title="statement not covered" >this.get(key);<span class="cstat-no" title="statement not covered" ></span>this.delete(key);<span class="cstat-no" title="statement not covered" >r</span>eturn value;}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.valuesArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Array.from(this.values());}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.keysArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Array.from(this.keys());}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.inverse=<span class="fstat-no" title="function not covered" >fu</span>nction(){const result=<span class="cstat-no" title="statement not covered" >new Multimap();<span class="cstat-no" title="statement not covered" ></span>for(const key of this.keys()){const value=<span class="cstat-no" title="statement not covered" >this.get(key);<span class="cstat-no" title="statement not covered" ></span>result.set(value,key);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return result;}</span>;var Multimap=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._map=new Map();}</span>;<span class="cstat-no" title="statement not covered" ></span>Multimap.prototype={set:<span class="fstat-no" title="function not covered" >fu</span>nction(key,value){let set=<span class="cstat-no" title="statement not covered" >this._map.get(key);<span class="cstat-no" title="statement not covered" ></span>if(!set){<span class="cstat-no" title="statement not covered" >set=new Set();<span class="cstat-no" title="statement not covered" >t</span>his._map.set(key,set);}</span></span></span>
<span class="cstat-no" title="statement not covered" >set.add(value);}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >return this._map.get(key)||new Set();}</span>,has:<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >return this._map.has(key);}</span>,hasValue:<span class="fstat-no" title="function not covered" >fu</span>nction(key,value){const set=<span class="cstat-no" title="statement not covered" >this._map.get(key);<span class="cstat-no" title="statement not covered" ></span>if(!set)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn set.has(value);}</span>,get size(){<span class="cstat-no" title="statement not covered" >return this._map.size;}</span>,delete:<span class="fstat-no" title="function not covered" >fu</span>nction(key,value){const values=<span class="cstat-no" title="statement not covered" >this.get(key);<span class="cstat-no" title="statement not covered" ></span>if(!values)</span>
<span class="cstat-no" title="statement not covered" >return false;c</span>onst result=<span class="cstat-no" title="statement not covered" >values.delete(value);<span class="cstat-no" title="statement not covered" ></span>if(!values.size)</span>
<span class="cstat-no" title="statement not covered" >this._map.delete(key);<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>,deleteAll:<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >this._map.delete(key);}</span>,keysArray:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._map.keysArray();}</span>,valuesArray:<span class="fstat-no" title="function not covered" >fu</span>nction(){const result=<span class="cstat-no" title="statement not covered" >[];</span>const keys=<span class="cstat-no" title="statement not covered" >this.keysArray();<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;keys.length;++i)</span>
<span class="cstat-no" title="statement not covered" >result.pushAll(this.get(keys[i]).valuesArray());<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._map.clear();}</span>};function <span class="fstat-no" title="function not covered" >loadXHR(</span>url){<span class="cstat-no" title="statement not covered" >return new Promise(load);f</span>unction <span class="fstat-no" title="function not covered" >load(</span>successCallback,failureCallback){function <span class="fstat-no" title="function not covered" >onReadyStateChanged(</span>){<span class="cstat-no" title="statement not covered" >if(xhr.readyState!==XMLHttpRequest.DONE)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(xhr.status!==200){<span class="cstat-no" title="statement not covered" >xhr.onreadystatechange=null;<span class="cstat-no" title="statement not covered" >f</span>ailureCallback(new Error(xhr.status));<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >xhr.onreadystatechange=null;<span class="cstat-no" title="statement not covered" >s</span>uccessCallback(xhr.responseText);}</span>
const xhr=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest();<span class="cstat-no" title="statement not covered" ></span>xhr.withCredentials=false;<span class="cstat-no" title="statement not covered" >x</span>hr.open('GET',url,true);<span class="cstat-no" title="statement not covered" >x</span>hr.onreadystatechange=onReadyStateChanged;<span class="cstat-no" title="statement not covered" >x</span>hr.send(null);}</span>}
function <span class="fstat-no" title="function not covered" >suppressUnused(</span>value){}
<span class="cstat-no" title="statement not covered" >self.setImmediate=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){const args=<span class="cstat-no" title="statement not covered" >[...arguments].slice(1);<span class="cstat-no" title="statement not covered" ></span>Promise.resolve().then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >callback(...args))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>;<span class="cstat-no" title="statement not covered" >P</span>romise.prototype.spread=<span class="fstat-no" title="function not covered" >fu</span>nction(callback){<span class="cstat-no" title="statement not covered" >return this.then(spreadPromise);f</span>unction <span class="fstat-no" title="function not covered" >spreadPromise(</span>arg){<span class="cstat-no" title="statement not covered" >return callback.apply(null,arg);}</span>};<span class="cstat-no" title="statement not covered" >P</span>romise.prototype.catchException=<span class="fstat-no" title="function not covered" >fu</span>nction(defaultValue){<span class="cstat-no" title="statement not covered" >return this.catch(<span class="fstat-no" title="function not covered" >fu</span>nction(error){<span class="cstat-no" title="statement not covered" >console.error(error);<span class="cstat-no" title="statement not covered" >r</span>eturn defaultValue;}</span>);}</span>;<span class="cstat-no" title="statement not covered" >M</span>ap.prototype.diff=<span class="fstat-no" title="function not covered" >fu</span>nction(other,isEqual){const leftKeys=<span class="cstat-no" title="statement not covered" >this.keysArray();</span>const rightKeys=<span class="cstat-no" title="statement not covered" >other.keysArray();<span class="cstat-no" title="statement not covered" ></span>leftKeys.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a-b)</span>;<span class="cstat-no" title="statement not covered" >r</span>ightKeys.sort(<span class="fstat-no" title="function not covered" >(a</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >a-b)</span>;c</span>onst removed=<span class="cstat-no" title="statement not covered" >[];</span>const added=<span class="cstat-no" title="statement not covered" >[];</span>const equal=<span class="cstat-no" title="statement not covered" >[];</span>let leftIndex=<span class="cstat-no" title="statement not covered" >0;</span>let rightIndex=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(leftIndex&lt;leftKeys.length&amp;&amp;rightIndex&lt;rightKeys.length){const leftKey=<span class="cstat-no" title="statement not covered" >leftKeys[leftIndex];</span>const rightKey=<span class="cstat-no" title="statement not covered" >rightKeys[rightIndex];<span class="cstat-no" title="statement not covered" ></span>if(leftKey===rightKey&amp;&amp;isEqual(this.get(leftKey),other.get(rightKey))){<span class="cstat-no" title="statement not covered" >equal.push(this.get(leftKey));<span class="cstat-no" title="statement not covered" >+</span>+leftIndex;<span class="cstat-no" title="statement not covered" >+</span>+rightIndex;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(leftKey&lt;=rightKey){<span class="cstat-no" title="statement not covered" >removed.push(this.get(leftKey));<span class="cstat-no" title="statement not covered" >+</span>+leftIndex;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span>
<span class="cstat-no" title="statement not covered" >added.push(other.get(rightKey));<span class="cstat-no" title="statement not covered" >+</span>+rightIndex;}</span>
<span class="cstat-no" title="statement not covered" >while(leftIndex&lt;leftKeys.length){const leftKey=<span class="cstat-no" title="statement not covered" >leftKeys[leftIndex++];<span class="cstat-no" title="statement not covered" ></span>removed.push(this.get(leftKey));}</span></span>
<span class="cstat-no" title="statement not covered" >while(rightIndex&lt;rightKeys.length){const rightKey=<span class="cstat-no" title="statement not covered" >rightKeys[rightIndex++];<span class="cstat-no" title="statement not covered" ></span>added.push(other.get(rightKey));}</span></span>
<span class="cstat-no" title="statement not covered" >return{added:added,removed:removed,equal:equal};}</span>;function <span class="fstat-no" title="function not covered" >runOnWindowLoad(</span>callback){function <span class="fstat-no" title="function not covered" >windowLoaded(</span>){<span class="cstat-no" title="statement not covered" >self.removeEventListener('DOMContentLoaded',windowLoaded,false);<span class="cstat-no" title="statement not covered" >c</span>allback();}</span>
<span class="cstat-no" title="statement not covered" >if(document.readyState==='complete'||document.readyState==='interactive')</span>
<span class="cstat-no" title="statement not covered" >callback();e</span>lse
<span class="cstat-no" title="statement not covered" >self.addEventListener('DOMContentLoaded',windowLoaded,false);}</span>
const _singletonSymbol=<span class="cstat-no" title="statement not covered" >Symbol('singleton');</span>function <span class="fstat-no" title="function not covered" >singleton(</span>constructorFunction){<span class="cstat-no" title="statement not covered" >if(_singletonSymbol in constructorFunction)</span>
<span class="cstat-no" title="statement not covered" >return constructorFunction[_singletonSymbol];c</span>onst instance=<span class="cstat-no" title="statement not covered" >new constructorFunction();<span class="cstat-no" title="statement not covered" ></span>constructorFunction[_singletonSymbol]=instance;<span class="cstat-no" title="statement not covered" >r</span>eturn instance;}</span>;<span class="cstat-no" title="statement not covered" >self['TextUtils']=self['TextUtils']||{};<span class="cstat-no" title="statement not covered" >T</span>extUtils.Text=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(value){<span class="cstat-no" title="statement not covered" >this._value=value;}</span></span>
<span class="fstat-no" title="function not covered" >li</span>neEndings(){<span class="cstat-no" title="statement not covered" >if(!this._lineEndings)</span>
<span class="cstat-no" title="statement not covered" >this._lineEndings=this._value.computeLineEndings();<span class="cstat-no" title="statement not covered" >r</span>eturn this._lineEndings;}</span>
<span class="fstat-no" title="function not covered" >va</span>lue(){<span class="cstat-no" title="statement not covered" >return this._value;}</span>
<span class="fstat-no" title="function not covered" >li</span>neCount(){const lineEndings=<span class="cstat-no" title="statement not covered" >this.lineEndings();<span class="cstat-no" title="statement not covered" ></span>return lineEndings.length;}</span>
<span class="fstat-no" title="function not covered" >of</span>fsetFromPosition(lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >return(lineNumber?this.lineEndings()[lineNumber-1]+1:0)+columnNumber;}</span>
<span class="fstat-no" title="function not covered" >po</span>sitionFromOffset(offset){const lineEndings=<span class="cstat-no" title="statement not covered" >this.lineEndings();</span>const lineNumber=<span class="cstat-no" title="statement not covered" >lineEndings.lowerBound(offset);<span class="cstat-no" title="statement not covered" ></span>return{lineNumber:lineNumber,columnNumber:offset-(lineNumber&amp;&amp;(lineEndings[lineNumber-1]+1))};}</span>
<span class="fstat-no" title="function not covered" >li</span>neAt(lineNumber){const lineEndings=<span class="cstat-no" title="statement not covered" >this.lineEndings();</span>const lineStart=<span class="cstat-no" title="statement not covered" >lineNumber&gt;0?lineEndings[lineNumber-1]+1:0;</span>const lineEnd=<span class="cstat-no" title="statement not covered" >lineEndings[lineNumber];</span>let lineContent=<span class="cstat-no" title="statement not covered" >this._value.substring(lineStart,lineEnd);<span class="cstat-no" title="statement not covered" ></span>if(lineContent.length&gt;0&amp;&amp;lineContent.charAt(lineContent.length-1)==='\r')</span>
<span class="cstat-no" title="statement not covered" >lineContent=lineContent.substring(0,lineContent.length-1);<span class="cstat-no" title="statement not covered" >r</span>eturn lineContent;}</span>
<span class="fstat-no" title="function not covered" >to</span>SourceRange(range){const start=<span class="cstat-no" title="statement not covered" >this.offsetFromPosition(range.startLine,range.startColumn);</span>const end=<span class="cstat-no" title="statement not covered" >this.offsetFromPosition(range.endLine,range.endColumn);<span class="cstat-no" title="statement not covered" ></span>return new TextUtils.SourceRange(start,end-start);}</span>
<span class="fstat-no" title="function not covered" >to</span>TextRange(sourceRange){const cursor=<span class="cstat-no" title="statement not covered" >new TextUtils.TextCursor(this.lineEndings());</span>const result=<span class="cstat-no" title="statement not covered" >TextUtils.TextRange.createFromLocation(0,0);<span class="cstat-no" title="statement not covered" ></span>cursor.resetTo(sourceRange.offset);<span class="cstat-no" title="statement not covered" >r</span>esult.startLine=cursor.lineNumber();<span class="cstat-no" title="statement not covered" >r</span>esult.startColumn=cursor.columnNumber();<span class="cstat-no" title="statement not covered" >c</span>ursor.advance(sourceRange.offset+sourceRange.length);<span class="cstat-no" title="statement not covered" >r</span>esult.endLine=cursor.lineNumber();<span class="cstat-no" title="statement not covered" >r</span>esult.endColumn=cursor.columnNumber();<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>
<span class="fstat-no" title="function not covered" >re</span>placeRange(range,replacement){const sourceRange=<span class="cstat-no" title="statement not covered" >this.toSourceRange(range);<span class="cstat-no" title="statement not covered" ></span>return this._value.substring(0,sourceRange.offset)+replacement+</span>
this._value.substring(sourceRange.offset+sourceRange.length);}
<span class="fstat-no" title="function not covered" >ex</span>tract(range){const sourceRange=<span class="cstat-no" title="statement not covered" >this.toSourceRange(range);<span class="cstat-no" title="statement not covered" ></span>return this._value.substr(sourceRange.offset,sourceRange.length);}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.Text.Position;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextCursor=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(lineEndings){<span class="cstat-no" title="statement not covered" >this._lineEndings=lineEndings;<span class="cstat-no" title="statement not covered" >t</span>his._offset=0;<span class="cstat-no" title="statement not covered" >t</span>his._lineNumber=0;<span class="cstat-no" title="statement not covered" >t</span>his._columnNumber=0;}</span></span>
<span class="fstat-no" title="function not covered" >ad</span>vance(offset){<span class="cstat-no" title="statement not covered" >this._offset=offset;<span class="cstat-no" title="statement not covered" >w</span>hile(this._lineNumber&lt;this._lineEndings.length&amp;&amp;this._lineEndings[this._lineNumber]&lt;this._offset)</span>
<span class="cstat-no" title="statement not covered" >++this._lineNumber;<span class="cstat-no" title="statement not covered" >t</span>his._columnNumber=this._lineNumber?this._offset-this._lineEndings[this._lineNumber-1]-1:this._offset;}</span>
<span class="fstat-no" title="function not covered" >of</span>fset(){<span class="cstat-no" title="statement not covered" >return this._offset;}</span>
<span class="fstat-no" title="function not covered" >re</span>setTo(offset){<span class="cstat-no" title="statement not covered" >this._offset=offset;<span class="cstat-no" title="statement not covered" >t</span>his._lineNumber=this._lineEndings.lowerBound(offset);<span class="cstat-no" title="statement not covered" >t</span>his._columnNumber=this._lineNumber?this._offset-this._lineEndings[this._lineNumber-1]-1:this._offset;}</span>
<span class="fstat-no" title="function not covered" >li</span>neNumber(){<span class="cstat-no" title="statement not covered" >return this._lineNumber;}</span>
<span class="fstat-no" title="function not covered" >co</span>lumnNumber(){<span class="cstat-no" title="statement not covered" >return this._columnNumber;}</span>};;<span class="cstat-no" title="statement not covered" >TextUtils.TextUtils={isStopChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return(char&gt;' '&amp;&amp;char&lt;'0')||(char&gt;'9'&amp;&amp;char&lt;'A')||(char&gt;'Z'&amp;&amp;char&lt;'_')||(char&gt;'_'&amp;&amp;char&lt;'a')||(char&gt;'z'&amp;&amp;char&lt;='~');}</span>,isWordChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return!TextUtils.TextUtils.isStopChar(char)&amp;&amp;!TextUtils.TextUtils.isSpaceChar(char);}</span>,isSpaceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return TextUtils.TextUtils._SpaceCharRegex.test(char);}</span>,isWord:<span class="fstat-no" title="function not covered" >fu</span>nction(word){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;word.length;++i){<span class="cstat-no" title="statement not covered" >if(!TextUtils.TextUtils.isWordChar(word.charAt(i)))</span></span></span>
<span class="cstat-no" title="statement not covered" >return false;}</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>,isOpeningBraceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return char==='('||char==='{';}</span>,isClosingBraceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return char===')'||char==='}';}</span>,isBraceChar:<span class="fstat-no" title="function not covered" >fu</span>nction(char){<span class="cstat-no" title="statement not covered" >return TextUtils.TextUtils.isOpeningBraceChar(char)||TextUtils.TextUtils.isClosingBraceChar(char);}</span>,textToWords:<span class="fstat-no" title="function not covered" >fu</span>nction(text,isWordChar,wordCallback){let startWord=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;text.length;++i){<span class="cstat-no" title="statement not covered" >if(!isWordChar(text.charAt(i))){<span class="cstat-no" title="statement not covered" >if(startWord!==-1)</span></span></span>
<span class="cstat-no" title="statement not covered" >wordCallback(text.substring(startWord,i));<span class="cstat-no" title="statement not covered" >s</span>tartWord=-1;}</span>else <span class="cstat-no" title="statement not covered" >if(startWord===-1){<span class="cstat-no" title="statement not covered" >startWord=i;}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(startWord!==-1)</span>
<span class="cstat-no" title="statement not covered" >wordCallback(text.substring(startWord));}</span>,lineIndent:<span class="fstat-no" title="function not covered" >fu</span>nction(line){let indentation=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(indentation&lt;line.length&amp;&amp;TextUtils.TextUtils.isSpaceChar(line.charAt(indentation)))</span>
<span class="cstat-no" title="statement not covered" >++indentation;<span class="cstat-no" title="statement not covered" >r</span>eturn line.substr(0,indentation);}</span>,isUpperCase:<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >return text===text.toUpperCase();}</span>,isLowerCase:<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >return text===text.toLowerCase();}</span>,splitStringByRegexes(text,regexes){const matches=<span class="cstat-no" title="statement not covered" >[];</span>const globalRegexes=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;regexes.length;i++){const regex=<span class="cstat-no" title="statement not covered" >regexes[i];<span class="cstat-no" title="statement not covered" ></span>if(!regex.global)</span></span>
<span class="cstat-no" title="statement not covered" >globalRegexes.push(new RegExp(regex.source,regex.flags?regex.flags+'g':'g'));e</span>lse
<span class="cstat-no" title="statement not covered" >globalRegexes.push(regex);}</span>
<span class="cstat-no" title="statement not covered" >doSplit(text,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn matches;f</span>unction <span class="fstat-no" title="function not covered" >doSplit(</span>text,regexIndex,startIndex){<span class="cstat-no" title="statement not covered" >if(regexIndex&gt;=globalRegexes.length){<span class="cstat-no" title="statement not covered" >matches.push({value:text,position:startIndex,regexIndex:-1,captureGroups:[]});<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const regex=<span class="cstat-no" title="statement not covered" >globalRegexes[regexIndex];</span>let currentIndex=<span class="cstat-no" title="statement not covered" >0;</span>let result;<span class="cstat-no" title="statement not covered" >regex.lastIndex=0;<span class="cstat-no" title="statement not covered" >w</span>hile((result=regex.exec(text))!==null){const stringBeforeMatch=<span class="cstat-no" title="statement not covered" >text.substring(currentIndex,result.index);<span class="cstat-no" title="statement not covered" ></span>if(stringBeforeMatch)</span></span>
<span class="cstat-no" title="statement not covered" >doSplit(stringBeforeMatch,regexIndex+1,startIndex+currentIndex);c</span>onst match=<span class="cstat-no" title="statement not covered" >result[0];<span class="cstat-no" title="statement not covered" ></span>matches.push({value:match,position:startIndex+result.index,regexIndex:regexIndex,captureGroups:result.slice(1)});<span class="cstat-no" title="statement not covered" >c</span>urrentIndex=result.index+match.length;}</span>
const stringAfterMatches=<span class="cstat-no" title="statement not covered" >text.substring(currentIndex);<span class="cstat-no" title="statement not covered" ></span>if(stringAfterMatches)</span>
<span class="cstat-no" title="statement not covered" >doSplit(stringAfterMatches,regexIndex+1,startIndex+currentIndex);}</span>}};<span class="cstat-no" title="statement not covered" >TextUtils.FilterParser=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(keys){<span class="cstat-no" title="statement not covered" >this._keys=keys;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic cloneFilter(filter){<span class="cstat-no" title="statement not covered" >return{key:filter.key,text:filter.text,regex:filter.regex,negative:filter.negative};}</span>
<span class="fstat-no" title="function not covered" >pa</span>rse(query){const splitResult=<span class="cstat-no" title="statement not covered" >TextUtils.TextUtils.splitStringByRegexes(query,[TextUtils.TextUtils._keyValueFilterRegex,TextUtils.TextUtils._regexFilterRegex,TextUtils.TextUtils._textFilterRegex]);</span>const filters=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;splitResult.length;i++){const regexIndex=<span class="cstat-no" title="statement not covered" >splitResult[i].regexIndex;<span class="cstat-no" title="statement not covered" ></span>if(regexIndex===-1)</span></span>
<span class="cstat-no" title="statement not covered" >continue;c</span>onst result=<span class="cstat-no" title="statement not covered" >splitResult[i].captureGroups;<span class="cstat-no" title="statement not covered" ></span>if(regexIndex===0){<span class="cstat-no" title="statement not covered" >if(this._keys.indexOf((result[1]))!==-1)</span></span>
<span class="cstat-no" title="statement not covered" >filters.push({key:result[1],text:result[2],negative:!!result[0]});e</span>lse
<span class="cstat-no" title="statement not covered" >filters.push({text:result[1]+':'+result[2],negative:!!result[0]});}</span>else <span class="cstat-no" title="statement not covered" >if(regexIndex===1){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >filters.push({regex:new RegExp(result[1],'i'),negative:!!result[0]});}</span>catch(e){<span class="cstat-no" title="statement not covered" >filters.push({text:'/'+result[1]+'/',negative:!!result[0]});}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(regexIndex===2){<span class="cstat-no" title="statement not covered" >filters.push({text:result[1],negative:!!result[0]});}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return filters;}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.FilterParser.ParsedFilter;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._keyValueFilterRegex=/(?:^|\s)(\-)?([\w\-]+):([^\s]+)/;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._regexFilterRegex=/(?:^|\s)(\-)?\/([^\s]+)\//;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._textFilterRegex=/(?:^|\s)(\-)?([^\s]+)/;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils._SpaceCharRegex=/\s/;<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils.Indent={TwoSpaces:'  ',FourSpaces:'    ',EightSpaces:'        ',TabCharacter:'\t'};<span class="cstat-no" title="statement not covered" >T</span>extUtils.TextUtils.BalancedJSONTokenizer=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(callback,findMultiple){<span class="cstat-no" title="statement not covered" >this._callback=callback;<span class="cstat-no" title="statement not covered" >t</span>his._index=0;<span class="cstat-no" title="statement not covered" >t</span>his._balance=0;<span class="cstat-no" title="statement not covered" >t</span>his._buffer='';<span class="cstat-no" title="statement not covered" >t</span>his._findMultiple=findMultiple||false;<span class="cstat-no" title="statement not covered" >t</span>his._closingDoubleQuoteRegex=/[^\\](?:\\\\)*"/g;}</span></span>
<span class="fstat-no" title="function not covered" >wr</span>ite(chunk){<span class="cstat-no" title="statement not covered" >this._buffer+=chunk;c</span>onst lastIndex=<span class="cstat-no" title="statement not covered" >this._buffer.length;</span>const buffer=<span class="cstat-no" title="statement not covered" >this._buffer;</span>let index;<span class="cstat-no" title="statement not covered" >for(index=this._index;index&lt;lastIndex;++index){const character=<span class="cstat-no" title="statement not covered" >buffer[index];<span class="cstat-no" title="statement not covered" ></span>if(character==='"'){<span class="cstat-no" title="statement not covered" >this._closingDoubleQuoteRegex.lastIndex=index;<span class="cstat-no" title="statement not covered" >i</span>f(!this._closingDoubleQuoteRegex.test(buffer))</span></span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span>ndex=this._closingDoubleQuoteRegex.lastIndex-1;}</span>else <span class="cstat-no" title="statement not covered" >if(character==='{'){<span class="cstat-no" title="statement not covered" >++this._balance;}</span>else <span class="cstat-no" title="statement not covered" >if(character==='}'){<span class="cstat-no" title="statement not covered" >--this._balance;<span class="cstat-no" title="statement not covered" >i</span>f(this._balance&lt;0){<span class="cstat-no" title="statement not covered" >this._reportBalanced();<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(!this._balance){<span class="cstat-no" title="statement not covered" >this._lastBalancedIndex=index+1;<span class="cstat-no" title="statement not covered" >i</span>f(!this._findMultiple)</span></span>
<span class="cstat-no" title="statement not covered" >break;}</span>}else <span class="cstat-no" title="statement not covered" >if(character===']'&amp;&amp;!this._balance){<span class="cstat-no" title="statement not covered" >this._reportBalanced();<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>}</span>
<span class="cstat-no" title="statement not covered" >this._index=index;<span class="cstat-no" title="statement not covered" >t</span>his._reportBalanced();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>
<span class="fstat-no" title="function not covered" >_r</span>eportBalanced(){<span class="cstat-no" title="statement not covered" >if(!this._lastBalancedIndex)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._callback(this._buffer.slice(0,this._lastBalancedIndex));<span class="cstat-no" title="statement not covered" >t</span>his._buffer=this._buffer.slice(this._lastBalancedIndex);<span class="cstat-no" title="statement not covered" >t</span>his._index-=this._lastBalancedIndex;<span class="cstat-no" title="statement not covered" >t</span>his._lastBalancedIndex=0;}</span>
<span class="fstat-no" title="function not covered" >re</span>mainder(){<span class="cstat-no" title="statement not covered" >return this._buffer;}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.TokenizerFactory=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >T</span>extUtils.TokenizerFactory.prototype={createTokenizer(mimeType){}};<span class="cstat-no" title="statement not covered" >T</span>extUtils.isMinified=<span class="fstat-no" title="function not covered" >fu</span>nction(text){const kMaxNonMinifiedLength=<span class="cstat-no" title="statement not covered" >500;</span>let linesToCheck=<span class="cstat-no" title="statement not covered" >10;</span>let lastPosition=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>do{let eolIndex=<span class="cstat-no" title="statement not covered" >text.indexOf('\n',lastPosition);<span class="cstat-no" title="statement not covered" ></span>if(eolIndex&lt;0)</span></span></span>
<span class="cstat-no" title="statement not covered" >eolIndex=text.length;<span class="cstat-no" title="statement not covered" >i</span>f(eolIndex-lastPosition&gt;kMaxNonMinifiedLength&amp;&amp;text.substr(lastPosition,3)!=='//#')</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >l</span>astPosition=eolIndex+1;}</span>while(--linesToCheck&gt;=0&amp;&amp;lastPosition&lt;text.length);<span class="cstat-no" title="statement not covered" >linesToCheck=10;<span class="cstat-no" title="statement not covered" >l</span>astPosition=text.length;<span class="cstat-no" title="statement not covered" >d</span>o{let eolIndex=<span class="cstat-no" title="statement not covered" >text.lastIndexOf('\n',lastPosition);<span class="cstat-no" title="statement not covered" ></span>if(eolIndex&lt;0)</span></span>
<span class="cstat-no" title="statement not covered" >eolIndex=0;<span class="cstat-no" title="statement not covered" >i</span>f(lastPosition-eolIndex&gt;kMaxNonMinifiedLength&amp;&amp;text.substr(lastPosition,3)!=='//#')</span>
<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >l</span>astPosition=eolIndex-1;}</span>while(--linesToCheck&gt;=0&amp;&amp;lastPosition&gt;0);<span class="cstat-no" title="statement not covered" >return false;}</span>;;<span class="cstat-no" title="statement not covered" >TextUtils.TextRange=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(startLine,startColumn,endLine,endColumn){<span class="cstat-no" title="statement not covered" >this.startLine=startLine;<span class="cstat-no" title="statement not covered" >t</span>his.startColumn=startColumn;<span class="cstat-no" title="statement not covered" >t</span>his.endLine=endLine;<span class="cstat-no" title="statement not covered" >t</span>his.endColumn=endColumn;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic createFromLocation(line,column){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(line,column,line,column);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromObject(serializedTextRange){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(serializedTextRange.startLine,serializedTextRange.startColumn,serializedTextRange.endLine,serializedTextRange.endColumn);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic comparator(range1,range2){<span class="cstat-no" title="statement not covered" >return range1.compareTo(range2);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic fromEdit(oldRange,newText){let endLine=<span class="cstat-no" title="statement not covered" >oldRange.startLine;</span>let endColumn=<span class="cstat-no" title="statement not covered" >oldRange.startColumn+newText.length;</span>const lineEndings=<span class="cstat-no" title="statement not covered" >newText.computeLineEndings();<span class="cstat-no" title="statement not covered" ></span>if(lineEndings.length&gt;1){<span class="cstat-no" title="statement not covered" >endLine=oldRange.startLine+lineEndings.length-1;c</span>onst len=<span class="cstat-no" title="statement not covered" >lineEndings.length;<span class="cstat-no" title="statement not covered" ></span>endColumn=lineEndings[len-1]-lineEndings[len-2]-1;}</span></span>
<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(oldRange.startLine,oldRange.startColumn,endLine,endColumn);}</span>
<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this.startLine===this.endLine&amp;&amp;this.startColumn===this.endColumn;}</span>
<span class="fstat-no" title="function not covered" >im</span>mediatelyPrecedes(range){<span class="cstat-no" title="statement not covered" >if(!range)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn this.endLine===range.startLine&amp;&amp;this.endColumn===range.startColumn;}</span>
<span class="fstat-no" title="function not covered" >im</span>mediatelyFollows(range){<span class="cstat-no" title="statement not covered" >if(!range)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn range.immediatelyPrecedes(this);}</span>
<span class="fstat-no" title="function not covered" >fo</span>llows(range){<span class="cstat-no" title="statement not covered" >return(range.endLine===this.startLine&amp;&amp;range.endColumn&lt;=this.startColumn)||range.endLine&lt;this.startLine;}</span>
<span class="fstat-no" title="function not covered" >ge</span>t linesCount(){<span class="cstat-no" title="statement not covered" >return this.endLine-this.startLine;}</span>
<span class="fstat-no" title="function not covered" >co</span>llapseToEnd(){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.endLine,this.endColumn,this.endLine,this.endColumn);}</span>
<span class="fstat-no" title="function not covered" >co</span>llapseToStart(){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.startLine,this.startColumn,this.startLine,this.startColumn);}</span>
<span class="fstat-no" title="function not covered" >no</span>rmalize(){<span class="cstat-no" title="statement not covered" >if(this.startLine&gt;this.endLine||(this.startLine===this.endLine&amp;&amp;this.startColumn&gt;this.endColumn))</span>
<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.endLine,this.endColumn,this.startLine,this.startColumn);e</span>lse
<span class="cstat-no" title="statement not covered" >return this.clone();}</span>
<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return new TextUtils.TextRange(this.startLine,this.startColumn,this.endLine,this.endColumn);}</span>
<span class="fstat-no" title="function not covered" >se</span>rializeToObject(){const serializedTextRange=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>serializedTextRange.startLine=this.startLine;<span class="cstat-no" title="statement not covered" >s</span>erializedTextRange.startColumn=this.startColumn;<span class="cstat-no" title="statement not covered" >s</span>erializedTextRange.endLine=this.endLine;<span class="cstat-no" title="statement not covered" >s</span>erializedTextRange.endColumn=this.endColumn;<span class="cstat-no" title="statement not covered" >r</span>eturn serializedTextRange;}</span>
<span class="fstat-no" title="function not covered" >co</span>mpareTo(other){<span class="cstat-no" title="statement not covered" >if(this.startLine&gt;other.startLine)</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(this.startLine&lt;other.startLine)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(this.startColumn&gt;other.startColumn)</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span>f(this.startColumn&lt;other.startColumn)</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>
<span class="fstat-no" title="function not covered" >co</span>mpareToPosition(lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >if(lineNumber&lt;this.startLine||(lineNumber===this.startLine&amp;&amp;columnNumber&lt;this.startColumn))</span>
<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span>f(lineNumber&gt;this.endLine||(lineNumber===this.endLine&amp;&amp;columnNumber&gt;this.endColumn))</span>
<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span>eturn 0;}</span>
<span class="fstat-no" title="function not covered" >eq</span>ual(other){<span class="cstat-no" title="statement not covered" >return this.startLine===other.startLine&amp;&amp;this.endLine===other.endLine&amp;&amp;this.startColumn===other.startColumn&amp;&amp;this.endColumn===other.endColumn;}</span>
<span class="fstat-no" title="function not covered" >re</span>lativeTo(line,column){const relative=<span class="cstat-no" title="statement not covered" >this.clone();<span class="cstat-no" title="statement not covered" ></span>if(this.startLine===line)</span>
<span class="cstat-no" title="statement not covered" >relative.startColumn-=column;<span class="cstat-no" title="statement not covered" >i</span>f(this.endLine===line)</span>
<span class="cstat-no" title="statement not covered" >relative.endColumn-=column;<span class="cstat-no" title="statement not covered" >r</span>elative.startLine-=line;<span class="cstat-no" title="statement not covered" >r</span>elative.endLine-=line;<span class="cstat-no" title="statement not covered" >r</span>eturn relative;}</span>
<span class="fstat-no" title="function not covered" >re</span>lativeFrom(line,column){const relative=<span class="cstat-no" title="statement not covered" >this.clone();<span class="cstat-no" title="statement not covered" ></span>if(this.startLine===0)</span>
<span class="cstat-no" title="statement not covered" >relative.startColumn+=column;<span class="cstat-no" title="statement not covered" >i</span>f(this.endLine===0)</span>
<span class="cstat-no" title="statement not covered" >relative.endColumn+=column;<span class="cstat-no" title="statement not covered" >r</span>elative.startLine+=line;<span class="cstat-no" title="statement not covered" >r</span>elative.endLine+=line;<span class="cstat-no" title="statement not covered" >r</span>eturn relative;}</span>
<span class="fstat-no" title="function not covered" >re</span>baseAfterTextEdit(originalRange,editedRange){<span class="cstat-no" title="statement not covered" >console.assert(originalRange.startLine===editedRange.startLine);<span class="cstat-no" title="statement not covered" >c</span>onsole.assert(originalRange.startColumn===editedRange.startColumn);c</span>onst rebase=<span class="cstat-no" title="statement not covered" >this.clone();<span class="cstat-no" title="statement not covered" ></span>if(!this.follows(originalRange))</span>
<span class="cstat-no" title="statement not covered" >return rebase;c</span>onst lineDelta=<span class="cstat-no" title="statement not covered" >editedRange.endLine-originalRange.endLine;</span>const columnDelta=<span class="cstat-no" title="statement not covered" >editedRange.endColumn-originalRange.endColumn;<span class="cstat-no" title="statement not covered" ></span>rebase.startLine+=lineDelta;<span class="cstat-no" title="statement not covered" >r</span>ebase.endLine+=lineDelta;<span class="cstat-no" title="statement not covered" >i</span>f(rebase.startLine===editedRange.endLine)</span>
<span class="cstat-no" title="statement not covered" >rebase.startColumn+=columnDelta;<span class="cstat-no" title="statement not covered" >i</span>f(rebase.endLine===editedRange.endLine)</span>
<span class="cstat-no" title="statement not covered" >rebase.endColumn+=columnDelta;<span class="cstat-no" title="statement not covered" >r</span>eturn rebase;}</span>
<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return JSON.stringify(this);}</span>
<span class="fstat-no" title="function not covered" >co</span>ntainsLocation(lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >if(this.startLine===this.endLine)</span>
<span class="cstat-no" title="statement not covered" >return this.startLine===lineNumber&amp;&amp;this.startColumn&lt;=columnNumber&amp;&amp;columnNumber&lt;=this.endColumn;<span class="cstat-no" title="statement not covered" >i</span>f(this.startLine===lineNumber)</span>
<span class="cstat-no" title="statement not covered" >return this.startColumn&lt;=columnNumber;<span class="cstat-no" title="statement not covered" >i</span>f(this.endLine===lineNumber)</span>
<span class="cstat-no" title="statement not covered" >return columnNumber&lt;=this.endColumn;<span class="cstat-no" title="statement not covered" >r</span>eturn this.startLine&lt;lineNumber&amp;&amp;lineNumber&lt;this.endLine;}</span>};<span class="cstat-no" title="statement not covered" >TextUtils.SourceRange=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(offset,length){<span class="cstat-no" title="statement not covered" >this.offset=offset;<span class="cstat-no" title="statement not covered" >t</span>his.length=length;}</span>};<span class="cstat-no" title="statement not covered" >T</span>extUtils.SourceEdit=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(sourceURL,oldRange,newText){<span class="cstat-no" title="statement not covered" >this.sourceURL=sourceURL;<span class="cstat-no" title="statement not covered" >t</span>his.oldRange=oldRange;<span class="cstat-no" title="statement not covered" >t</span>his.newText=newText;}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic comparator(edit1,edit2){<span class="cstat-no" title="statement not covered" >return TextUtils.TextRange.comparator(edit1.oldRange,edit2.oldRange);}</span>
<span class="fstat-no" title="function not covered" >ne</span>wRange(){<span class="cstat-no" title="statement not covered" >return TextUtils.TextRange.fromEdit(this.oldRange,this.newText);}</span>};;<span class="cstat-no" title="statement not covered" >self['CmHeadless']=self['CmHeadless']||{};<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(window){<span class="cstat-no" title="statement not covered" >window.CodeMirror={};<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(){"use strict";function <span class="fstat-no" title="function not covered" >splitLines(</span>string){<span class="cstat-no" title="statement not covered" >return string.split(/\r?\n|\r/);}</span>;function <span class="fstat-no" title="function not covered" >StringStream(</span>string){<span class="cstat-no" title="statement not covered" >this.pos=this.start=0;<span class="cstat-no" title="statement not covered" >t</span>his.string=string;<span class="cstat-no" title="statement not covered" >t</span>his.lineStart=0;}</span></span></span>
<span class="cstat-no" title="statement not covered" >StringStream.prototype={eol:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos&gt;=this.string.length;}</span>,sol:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos==0;}</span>,peek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.string.charAt(this.pos)||null;}</span>,next:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.pos&lt;this.string.length)</span></span>
<span class="cstat-no" title="statement not covered" >return this.string.charAt(this.pos++);}</span>,eat:<span class="fstat-no" title="function not covered" >fu</span>nction(match){var ch=<span class="cstat-no" title="statement not covered" >this.string.charAt(this.pos);<span class="cstat-no" title="statement not covered" ></span>if(typeof match=="string")var ok=<span class="cstat-no" title="statement not covered" >ch==match;</span>else var ok=<span class="cstat-no" title="statement not covered" >ch&amp;&amp;(match.test?match.test(ch):match(ch));<span class="cstat-no" title="statement not covered" ></span>i</span>f(ok){<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn ch;}</span>}</span>,eatWhile:<span class="fstat-no" title="function not covered" >fu</span>nction(match){var start=<span class="cstat-no" title="statement not covered" >this.pos;<span class="cstat-no" title="statement not covered" ></span>while(this.eat(match)){}</span>
<span class="cstat-no" title="statement not covered" >return this.pos&gt;start;}</span>,eatSpace:<span class="fstat-no" title="function not covered" >fu</span>nction(){var start=<span class="cstat-no" title="statement not covered" >this.pos;<span class="cstat-no" title="statement not covered" ></span>while(/[\s\u00a0]/.test(this.string.charAt(this.pos)))<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.pos&gt;start;}</span>,skipToEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.pos=this.string.length;}</span>,skipTo:<span class="fstat-no" title="function not covered" >fu</span>nction(ch){var found=<span class="cstat-no" title="statement not covered" >this.string.indexOf(ch,this.pos);<span class="cstat-no" title="statement not covered" ></span>if(found&gt;-1){<span class="cstat-no" title="statement not covered" >this.pos=found;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}</span>,backUp:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >this.pos-=n;}</span>,column:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.start-this.lineStart;}</span>,indentation:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0;}</span>,match:<span class="fstat-no" title="function not covered" >fu</span>nction(pattern,consume,caseInsensitive){<span class="cstat-no" title="statement not covered" >if(typeof pattern=="string"){var cased=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(str){<span class="cstat-no" title="statement not covered" >return caseInsensitive?str.toLowerCase():str;}</span>;</span>var substr=<span class="cstat-no" title="statement not covered" >this.string.substr(this.pos,pattern.length);<span class="cstat-no" title="statement not covered" ></span>if(cased(substr)==cased(pattern)){<span class="cstat-no" title="statement not covered" >if(consume!==false)<span class="cstat-no" title="statement not covered" >this.pos+=pattern.length;<span class="cstat-no" title="statement not covered" >r</span></span>eturn true;}</span>}</span>else{var match=<span class="cstat-no" title="statement not covered" >this.string.slice(this.pos).match(pattern);<span class="cstat-no" title="statement not covered" ></span>if(match&amp;&amp;match.index&gt;0)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(match&amp;&amp;consume!==false)<span class="cstat-no" title="statement not covered" >this.pos+=match[0].length;<span class="cstat-no" title="statement not covered" >r</span></span>eturn match;}</span>}</span>,current:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.string.slice(this.start,this.pos);}</span>,hideFirstChars:<span class="fstat-no" title="function not covered" >fu</span>nction(n,inner){<span class="cstat-no" title="statement not covered" >this.lineStart+=n;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return inner();}</span></span>
finally{<span class="cstat-no" title="statement not covered" >this.lineStart-=n;}</span>},lookAhead:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return null}</span>};<span class="cstat-no" title="statement not covered" >CodeMirror.StringStream=StringStream;<span class="cstat-no" title="statement not covered" >C</span>odeMirror.startState=<span class="fstat-no" title="function not covered" >fu</span>nction(mode,a1,a2){<span class="cstat-no" title="statement not covered" >return mode.startState?mode.startState(a1,a2):true;}</span>;v</span>ar modes=<span class="cstat-no" title="statement not covered" >CodeMirror.modes={},</span>mimeModes=<span class="cstat-no" title="statement not covered" >CodeMirror.mimeModes={};<span class="cstat-no" title="statement not covered" ></span>CodeMirror.defineMode=<span class="fstat-no" title="function not covered" >fu</span>nction(name,mode){<span class="cstat-no" title="statement not covered" >if(arguments.length&gt;2)</span></span>
<span class="cstat-no" title="statement not covered" >mode.dependencies=Array.prototype.slice.call(arguments,2);<span class="cstat-no" title="statement not covered" >m</span>odes[name]=mode;}</span>;<span class="cstat-no" title="statement not covered" >CodeMirror.defineMIME=<span class="fstat-no" title="function not covered" >fu</span>nction(mime,spec){<span class="cstat-no" title="statement not covered" >mimeModes[mime]=spec;}</span>;<span class="cstat-no" title="statement not covered" >C</span>odeMirror.resolveMode=<span class="fstat-no" title="function not covered" >fu</span>nction(spec){<span class="cstat-no" title="statement not covered" >if(typeof spec=="string"&amp;&amp;mimeModes.hasOwnProperty(spec)){<span class="cstat-no" title="statement not covered" >spec=mimeModes[spec];}</span>else <span class="cstat-no" title="statement not covered" >if(spec&amp;&amp;typeof spec.name=="string"&amp;&amp;mimeModes.hasOwnProperty(spec.name)){<span class="cstat-no" title="statement not covered" >spec=mimeModes[spec.name];}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(typeof spec=="string")<span class="cstat-no" title="statement not covered" >return{name:spec};e</span>lse <span class="cstat-no" title="statement not covered" >return spec||{name:"null"};}</span></span>;<span class="cstat-no" title="statement not covered" >CodeMirror.getMode=<span class="fstat-no" title="function not covered" >fu</span>nction(options,spec){<span class="cstat-no" title="statement not covered" >spec=CodeMirror.resolveMode(spec);v</span>ar mfactory=<span class="cstat-no" title="statement not covered" >modes[spec.name];<span class="cstat-no" title="statement not covered" ></span>if(!mfactory)<span class="cstat-no" title="statement not covered" >throw new Error("Unknown mode: "+spec);<span class="cstat-no" title="statement not covered" >r</span></span>eturn mfactory(options,spec);}</span>;<span class="cstat-no" title="statement not covered" >C</span>odeMirror.registerHelper=CodeMirror.registerGlobalHelper=Math.min;<span class="cstat-no" title="statement not covered" >C</span>odeMirror.defineMode("null",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{token:<span class="fstat-no" title="function not covered" >fu</span>nction(stream){<span class="cstat-no" title="statement not covered" >stream.skipToEnd();}</span>};}</span>);<span class="cstat-no" title="statement not covered" >C</span>odeMirror.defineMIME("text/plain","null");<span class="cstat-no" title="statement not covered" >C</span>odeMirror.runMode=<span class="fstat-no" title="function not covered" >fu</span>nction(string,modespec,callback,options){var mode=<span class="cstat-no" title="statement not covered" >CodeMirror.getMode({indentUnit:2},modespec);<span class="cstat-no" title="statement not covered" ></span>if(callback.nodeType==1){var tabSize=<span class="cstat-no" title="statement not covered" >(options&amp;&amp;options.tabSize)||4;</span>var node=<span class="cstat-no" title="statement not covered" >callback,</span>col=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>node.innerHTML="";<span class="cstat-no" title="statement not covered" >c</span>allback=<span class="fstat-no" title="function not covered" >fu</span>nction(text,style){<span class="cstat-no" title="statement not covered" >if(text=="\n"){<span class="cstat-no" title="statement not covered" >node.appendChild(document.createElement("br"));<span class="cstat-no" title="statement not covered" >c</span>ol=0;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span></span></span>
var content=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(var pos=0;;){var idx=<span class="cstat-no" title="statement not covered" >text.indexOf("\t",pos);<span class="cstat-no" title="statement not covered" ></span>if(idx==-1){<span class="cstat-no" title="statement not covered" >content+=text.slice(pos);<span class="cstat-no" title="statement not covered" >c</span>ol+=text.length-pos;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else{<span class="cstat-no" title="statement not covered" >col+=idx-pos;<span class="cstat-no" title="statement not covered" >c</span>ontent+=text.slice(pos,idx);v</span>ar size=<span class="cstat-no" title="statement not covered" >tabSize-col%tabSize;<span class="cstat-no" title="statement not covered" ></span>col+=size;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;size;++i)<span class="cstat-no" title="statement not covered" >content+=" ";<span class="cstat-no" title="statement not covered" >p</span></span>os=idx+1;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(style){var sp=<span class="cstat-no" title="statement not covered" >node.appendChild(document.createElement("span"));<span class="cstat-no" title="statement not covered" ></span>sp.className="cm-"+style.replace(/ +/g," cm-");<span class="cstat-no" title="statement not covered" >s</span>p.appendChild(document.createTextNode(content));}</span>else{<span class="cstat-no" title="statement not covered" >node.appendChild(document.createTextNode(content));}</span>}</span>;}
var lines=<span class="cstat-no" title="statement not covered" >splitLines(string),</span>state=<span class="cstat-no" title="statement not covered" >(options&amp;&amp;options.state)||CodeMirror.startState(mode);<span class="cstat-no" title="statement not covered" ></span>for(var i=0,e=lines.length;i&lt;e;++i){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >callback("\n");v</span></span>ar stream=<span class="cstat-no" title="statement not covered" >new CodeMirror.StringStream(lines[i]);<span class="cstat-no" title="statement not covered" ></span>if(!stream.string&amp;&amp;mode.blankLine)<span class="cstat-no" title="statement not covered" >mode.blankLine(state);<span class="cstat-no" title="statement not covered" >w</span></span>hile(!stream.eol()){var style=<span class="cstat-no" title="statement not covered" >mode.token(stream,state);<span class="cstat-no" title="statement not covered" ></span>callback(stream.current(),style,i,stream.start,state);<span class="cstat-no" title="statement not covered" >s</span>tream.start=stream.pos;}</span>}</span>}</span>;})();}(this));<span class="cstat-no" title="statement not covered" >self['FormatterWorker']=self['FormatterWorker']||{};<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" ></span>fu</span>nction(mod){<span class="cstat-no" title="statement not covered" >if(typeof exports=="object"&amp;&amp;typeof module=="object")</span></span>
<span class="cstat-no" title="statement not covered" >mod(require("../../lib/codemirror"));e</span>lse <span class="cstat-no" title="statement not covered" >if(typeof define=="function"&amp;&amp;define.amd)</span>
<span class="cstat-no" title="statement not covered" >define(["../../lib/codemirror"],mod);e</span>lse
<span class="cstat-no" title="statement not covered" >mod(CodeMirror);}</span>)(<span class="fstat-no" title="function not covered" >fu</span>nction(CodeMirror){"use strict";<span class="cstat-no" title="statement not covered" >CodeMirror.defineMode("css",<span class="fstat-no" title="function not covered" >fu</span>nction(config,parserConfig){var inline=<span class="cstat-no" title="statement not covered" >parserConfig.inline</span></span>
<span class="cstat-no" title="statement not covered" >if(!parserConfig.propertyKeywords)<span class="cstat-no" title="statement not covered" >parserConfig=CodeMirror.resolveMode("text/css");v</span></span>ar indentUnit=<span class="cstat-no" title="statement not covered" >config.indentUnit,</span>tokenHooks=<span class="cstat-no" title="statement not covered" >parserConfig.tokenHooks,</span>documentTypes=<span class="cstat-no" title="statement not covered" >parserConfig.documentTypes||{},</span>mediaTypes=<span class="cstat-no" title="statement not covered" >parserConfig.mediaTypes||{},</span>mediaFeatures=<span class="cstat-no" title="statement not covered" >parserConfig.mediaFeatures||{},</span>mediaValueKeywords=<span class="cstat-no" title="statement not covered" >parserConfig.mediaValueKeywords||{},</span>propertyKeywords=<span class="cstat-no" title="statement not covered" >parserConfig.propertyKeywords||{},</span>nonStandardPropertyKeywords=<span class="cstat-no" title="statement not covered" >parserConfig.nonStandardPropertyKeywords||{},</span>fontProperties=<span class="cstat-no" title="statement not covered" >parserConfig.fontProperties||{},</span>counterDescriptors=<span class="cstat-no" title="statement not covered" >parserConfig.counterDescriptors||{},</span>colorKeywords=<span class="cstat-no" title="statement not covered" >parserConfig.colorKeywords||{},</span>valueKeywords=<span class="cstat-no" title="statement not covered" >parserConfig.valueKeywords||{},</span>allowNested=<span class="cstat-no" title="statement not covered" >parserConfig.allowNested,</span>lineComment=<span class="cstat-no" title="statement not covered" >parserConfig.lineComment,</span>supportsAtComponent=<span class="cstat-no" title="statement not covered" >parserConfig.supportsAtComponent===true;</span>var type,override;function <span class="fstat-no" title="function not covered" >ret(</span>style,tp){<span class="cstat-no" title="statement not covered" >type=tp;<span class="cstat-no" title="statement not covered" >r</span>eturn style;}</span>
function <span class="fstat-no" title="function not covered" >tokenBase(</span>stream,state){var ch=<span class="cstat-no" title="statement not covered" >stream.next();<span class="cstat-no" title="statement not covered" ></span>if(tokenHooks[ch]){var result=<span class="cstat-no" title="statement not covered" >tokenHooks[ch](stream,state);<span class="cstat-no" title="statement not covered" ></span>if(result!==false)<span class="cstat-no" title="statement not covered" >return result;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(ch=="@"){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w\\\-]/);<span class="cstat-no" title="statement not covered" >r</span>eturn ret("def",stream.current());}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="="||(ch=="~"||ch=="|")&amp;&amp;stream.eat("=")){<span class="cstat-no" title="statement not covered" >return ret(null,"compare");}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="\""||ch=="'"){<span class="cstat-no" title="statement not covered" >state.tokenize=tokenString(ch);<span class="cstat-no" title="statement not covered" >r</span>eturn state.tokenize(stream,state);}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="#"){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w\\\-]/);<span class="cstat-no" title="statement not covered" >r</span>eturn ret("atom","hash");}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="!"){<span class="cstat-no" title="statement not covered" >stream.match(/^\s*\w*/);<span class="cstat-no" title="statement not covered" >r</span>eturn ret("keyword","important");}</span>else <span class="cstat-no" title="statement not covered" >if(/\d/.test(ch)||ch=="."&amp;&amp;stream.eat(/\d/)){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w.%]/);<span class="cstat-no" title="statement not covered" >r</span>eturn ret("number","unit");}</span>else <span class="cstat-no" title="statement not covered" >if(ch==="-"){<span class="cstat-no" title="statement not covered" >if(/[\d.]/.test(stream.peek())){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w.%]/);<span class="cstat-no" title="statement not covered" >r</span>eturn ret("number","unit");}</span>else <span class="cstat-no" title="statement not covered" >if(stream.match(/^-[\w\\\-]*/)){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w\\\-]/);<span class="cstat-no" title="statement not covered" >i</span>f(stream.match(/^\s*:/,false))</span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return ret("variable-2","variable-definition");<span class="cstat-no" title="statement not covered" >r</span>eturn ret("variable-2","variable");}</span>else <span class="cstat-no" title="statement not covered" >if(stream.match(/^\w+-/)){<span class="cstat-no" title="statement not covered" >return ret("meta","meta");}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(/[,+&gt;*\/]/.test(ch)){<span class="cstat-no" title="statement not covered" >return ret(null,"select-op");}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="."&amp;&amp;stream.match(/^-?[_a-z][_a-z0-9-]*/i)){<span class="cstat-no" title="statement not covered" >return ret("qualifier","qualifier");}</span>else <span class="cstat-no" title="statement not covered" >if(/[:;{}\[\]\(\)]/.test(ch)){<span class="cstat-no" title="statement not covered" >return ret(null,ch);}</span>else <span class="cstat-no" title="statement not covered" >if(((ch=="u"||ch=="U")&amp;&amp;stream.match(/rl(-prefix)?\(/i))||((ch=="d"||ch=="D")&amp;&amp;stream.match("omain(",true,true))||((ch=="r"||ch=="R")&amp;&amp;stream.match("egexp(",true,true))){<span class="cstat-no" title="statement not covered" >stream.backUp(1);<span class="cstat-no" title="statement not covered" >s</span>tate.tokenize=tokenParenthesized;<span class="cstat-no" title="statement not covered" >r</span>eturn ret("property","word");}</span>else <span class="cstat-no" title="statement not covered" >if(/[\w\\\-]/.test(ch)){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w\\\-]/);<span class="cstat-no" title="statement not covered" >r</span>eturn ret("property","word");}</span>else{<span class="cstat-no" title="statement not covered" >return ret(null,null);}</span>}</span></span></span></span></span>
function <span class="fstat-no" title="function not covered" >tokenString(</span>quote){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){var escaped=<span class="cstat-no" title="statement not covered" >false,</span>ch;<span class="cstat-no" title="statement not covered" >while((ch=stream.next())!=null){<span class="cstat-no" title="statement not covered" >if(ch==quote&amp;&amp;!escaped){<span class="cstat-no" title="statement not covered" >if(quote==")")<span class="cstat-no" title="statement not covered" >stream.backUp(1);<span class="cstat-no" title="statement not covered" >b</span></span>reak;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >escaped=!escaped&amp;&amp;ch=="\\";}</span>
<span class="cstat-no" title="statement not covered" >if(ch==quote||!escaped&amp;&amp;quote!=")")<span class="cstat-no" title="statement not covered" >state.tokenize=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn ret("string","string");}</span>;}
function <span class="fstat-no" title="function not covered" >tokenParenthesized(</span>stream,state){<span class="cstat-no" title="statement not covered" >stream.next();<span class="cstat-no" title="statement not covered" >i</span>f(!stream.match(/\s*[\"\')]/,false))</span>
<span class="cstat-no" title="statement not covered" >state.tokenize=tokenString(")");e</span>lse
<span class="cstat-no" title="statement not covered" >state.tokenize=null;<span class="cstat-no" title="statement not covered" >r</span>eturn ret(null,"(");}</span>
function <span class="fstat-no" title="function not covered" >Context(</span>type,indent,prev){<span class="cstat-no" title="statement not covered" >this.type=type;<span class="cstat-no" title="statement not covered" >t</span>his.indent=indent;<span class="cstat-no" title="statement not covered" >t</span>his.prev=prev;}</span>
function <span class="fstat-no" title="function not covered" >pushContext(</span>state,stream,type,indent){<span class="cstat-no" title="statement not covered" >state.context=new Context(type,stream.indentation()+(indent===false?0:indentUnit),state.context);<span class="cstat-no" title="statement not covered" >r</span>eturn type;}</span>
function <span class="fstat-no" title="function not covered" >popContext(</span>state){<span class="cstat-no" title="statement not covered" >if(state.context.prev)</span>
<span class="cstat-no" title="statement not covered" >state.context=state.context.prev;<span class="cstat-no" title="statement not covered" >r</span>eturn state.context.type;}</span>
function <span class="fstat-no" title="function not covered" >pass(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >return states[state.context.type](type,stream,state);}</span>
function <span class="fstat-no" title="function not covered" >popAndPass(</span>type,stream,state,n){<span class="cstat-no" title="statement not covered" >for(var i=n||1;i&gt;0;i--)</span>
<span class="cstat-no" title="statement not covered" >state.context=state.context.prev;<span class="cstat-no" title="statement not covered" >r</span>eturn pass(type,stream,state);}</span>
function <span class="fstat-no" title="function not covered" >wordAsValue(</span>stream){var word=<span class="cstat-no" title="statement not covered" >stream.current().toLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(valueKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="atom";e</span>lse <span class="cstat-no" title="statement not covered" >if(colorKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="keyword";e</span>lse
<span class="cstat-no" title="statement not covered" >override="variable";}</span>
var states=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>states.top=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="{"){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"block");}</span>else <span class="cstat-no" title="statement not covered" >if(type=="}"&amp;&amp;state.context.prev){<span class="cstat-no" title="statement not covered" >return popContext(state);}</span>else <span class="cstat-no" title="statement not covered" >if(supportsAtComponent&amp;&amp;/@component/i.test(type)){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"atComponentBlock");}</span>else <span class="cstat-no" title="statement not covered" >if(/^@(-moz-)?document$/i.test(type)){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"documentTypes");}</span>else <span class="cstat-no" title="statement not covered" >if(/^@(media|supports|(-moz-)?document|import)$/i.test(type)){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"atBlock");}</span>else <span class="cstat-no" title="statement not covered" >if(/^@(font-face|counter-style)/i.test(type)){<span class="cstat-no" title="statement not covered" >state.stateArg=type;<span class="cstat-no" title="statement not covered" >r</span>eturn"restricted_atBlock_before";}</span>else <span class="cstat-no" title="statement not covered" >if(/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)){<span class="cstat-no" title="statement not covered" >return"keyframes";}</span>else <span class="cstat-no" title="statement not covered" >if(type&amp;&amp;type.charAt(0)=="@"){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"at");}</span>else <span class="cstat-no" title="statement not covered" >if(type=="hash"){<span class="cstat-no" title="statement not covered" >override="builtin";}</span>else <span class="cstat-no" title="statement not covered" >if(type=="word"){<span class="cstat-no" title="statement not covered" >override="tag";}</span>else <span class="cstat-no" title="statement not covered" >if(type=="variable-definition"){<span class="cstat-no" title="statement not covered" >return"maybeprop";}</span>else <span class="cstat-no" title="statement not covered" >if(type=="interpolation"){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"interpolation");}</span>else <span class="cstat-no" title="statement not covered" >if(type==":"){<span class="cstat-no" title="statement not covered" >return"pseudo";}</span>else <span class="cstat-no" title="statement not covered" >if(allowNested&amp;&amp;type=="("){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"parens");}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return state.context.type;}</span>;<span class="cstat-no" title="statement not covered" >states.block=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="word"){var word=<span class="cstat-no" title="statement not covered" >stream.current().toLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(propertyKeywords.hasOwnProperty(word)){<span class="cstat-no" title="statement not covered" >override="property";<span class="cstat-no" title="statement not covered" >r</span>eturn"maybeprop";}</span>else <span class="cstat-no" title="statement not covered" >if(nonStandardPropertyKeywords.hasOwnProperty(word)){<span class="cstat-no" title="statement not covered" >override="string-2";<span class="cstat-no" title="statement not covered" >r</span>eturn"maybeprop";}</span>else <span class="cstat-no" title="statement not covered" >if(allowNested){<span class="cstat-no" title="statement not covered" >override=stream.match(/^\s*:(?:\s|$)/,false)?"property":"tag";<span class="cstat-no" title="statement not covered" >r</span>eturn"block";}</span>else{<span class="cstat-no" title="statement not covered" >override+=" error";<span class="cstat-no" title="statement not covered" >r</span>eturn"maybeprop";}</span>}</span></span></span>else <span class="cstat-no" title="statement not covered" >if(type=="meta"){<span class="cstat-no" title="statement not covered" >return"block";}</span>else <span class="cstat-no" title="statement not covered" >if(!allowNested&amp;&amp;(type=="hash"||type=="qualifier")){<span class="cstat-no" title="statement not covered" >override="error";<span class="cstat-no" title="statement not covered" >r</span>eturn"block";}</span>else{<span class="cstat-no" title="statement not covered" >return states.top(type,stream,state);}</span>}</span></span></span>;<span class="cstat-no" title="statement not covered" >s</span>tates.maybeprop=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type==":")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"prop");<span class="cstat-no" title="statement not covered" >r</span></span>eturn pass(type,stream,state);}</span>;<span class="cstat-no" title="statement not covered" >s</span>tates.prop=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type==";")<span class="cstat-no" title="statement not covered" >return popContext(state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="{"&amp;&amp;allowNested)<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"propBlock");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="}"||type=="{")<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="(")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"parens");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="hash"&amp;&amp;!/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())){<span class="cstat-no" title="statement not covered" >override+=" error";}</span>else <span class="cstat-no" title="statement not covered" >if(type=="word"){<span class="cstat-no" title="statement not covered" >wordAsValue(stream);}</span>else <span class="cstat-no" title="statement not covered" >if(type=="interpolation"){<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"interpolation");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return"prop";}</span>;<span class="cstat-no" title="statement not covered" >states.propBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(type,_stream,state){<span class="cstat-no" title="statement not covered" >if(type=="}")<span class="cstat-no" title="statement not covered" >return popContext(state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word"){<span class="cstat-no" title="statement not covered" >override="property";<span class="cstat-no" title="statement not covered" >r</span>eturn"maybeprop";}</span></span></span>
<span class="cstat-no" title="statement not covered" >return state.context.type;}</span>;<span class="cstat-no" title="statement not covered" >states.parens=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="{"||type=="}")<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type==")")<span class="cstat-no" title="statement not covered" >return popContext(state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="(")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"parens");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="interpolation")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"interpolation");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word")<span class="cstat-no" title="statement not covered" >wordAsValue(stream);<span class="cstat-no" title="statement not covered" >r</span></span>eturn"parens";}</span>;<span class="cstat-no" title="statement not covered" >s</span>tates.pseudo=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="meta")<span class="cstat-no" title="statement not covered" >return"pseudo";<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word"){<span class="cstat-no" title="statement not covered" >override="variable-3";<span class="cstat-no" title="statement not covered" >r</span>eturn state.context.type;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return pass(type,stream,state);}</span>;<span class="cstat-no" title="statement not covered" >states.documentTypes=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="word"&amp;&amp;documentTypes.hasOwnProperty(stream.current())){<span class="cstat-no" title="statement not covered" >override="tag";<span class="cstat-no" title="statement not covered" >r</span>eturn state.context.type;}</span>else{<span class="cstat-no" title="statement not covered" >return states.atBlock(type,stream,state);}</span>}</span>;<span class="cstat-no" title="statement not covered" >s</span>tates.atBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="(")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"atBlock_parens");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="}"||type==";")<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="{")<span class="cstat-no" title="statement not covered" >return popContext(state)&amp;&amp;pushContext(state,stream,allowNested?"block":"top");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="interpolation")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"interpolation");<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word"){var word=<span class="cstat-no" title="statement not covered" >stream.current().toLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(word=="only"||word=="not"||word=="and"||word=="or")</span></span></span>
<span class="cstat-no" title="statement not covered" >override="keyword";e</span>lse <span class="cstat-no" title="statement not covered" >if(mediaTypes.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="attribute";e</span>lse <span class="cstat-no" title="statement not covered" >if(mediaFeatures.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="property";e</span>lse <span class="cstat-no" title="statement not covered" >if(mediaValueKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="keyword";e</span>lse <span class="cstat-no" title="statement not covered" >if(propertyKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="property";e</span>lse <span class="cstat-no" title="statement not covered" >if(nonStandardPropertyKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="string-2";e</span>lse <span class="cstat-no" title="statement not covered" >if(valueKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="atom";e</span>lse <span class="cstat-no" title="statement not covered" >if(colorKeywords.hasOwnProperty(word))</span>
<span class="cstat-no" title="statement not covered" >override="keyword";e</span>lse
<span class="cstat-no" title="statement not covered" >override="error";}</span>
<span class="cstat-no" title="statement not covered" >return state.context.type;}</span>;<span class="cstat-no" title="statement not covered" >states.atComponentBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="}")</span></span>
<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state);<span class="cstat-no" title="statement not covered" >i</span>f(type=="{")</span>
<span class="cstat-no" title="statement not covered" >return popContext(state)&amp;&amp;pushContext(state,stream,allowNested?"block":"top",false);<span class="cstat-no" title="statement not covered" >i</span>f(type=="word")</span>
<span class="cstat-no" title="statement not covered" >override="error";<span class="cstat-no" title="statement not covered" >r</span>eturn state.context.type;}</span>;<span class="cstat-no" title="statement not covered" >states.atBlock_parens=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type==")")<span class="cstat-no" title="statement not covered" >return popContext(state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="{"||type=="}")<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state,2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn states.atBlock(type,stream,state);}</span>;<span class="cstat-no" title="statement not covered" >s</span>tates.restricted_atBlock_before=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="{")</span></span>
<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"restricted_atBlock");<span class="cstat-no" title="statement not covered" >i</span>f(type=="word"&amp;&amp;state.stateArg=="@counter-style"){<span class="cstat-no" title="statement not covered" >override="variable";<span class="cstat-no" title="statement not covered" >r</span>eturn"restricted_atBlock_before";}</span></span>
<span class="cstat-no" title="statement not covered" >return pass(type,stream,state);}</span>;<span class="cstat-no" title="statement not covered" >states.restricted_atBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="}"){<span class="cstat-no" title="statement not covered" >state.stateArg=null;<span class="cstat-no" title="statement not covered" >r</span>eturn popContext(state);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(type=="word"){<span class="cstat-no" title="statement not covered" >if((state.stateArg=="@font-face"&amp;&amp;!fontProperties.hasOwnProperty(stream.current().toLowerCase()))||(state.stateArg=="@counter-style"&amp;&amp;!counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))</span></span>
<span class="cstat-no" title="statement not covered" >override="error";e</span>lse
<span class="cstat-no" title="statement not covered" >override="property";<span class="cstat-no" title="statement not covered" >r</span>eturn"maybeprop";}</span>
<span class="cstat-no" title="statement not covered" >return"restricted_atBlock";}</span>;<span class="cstat-no" title="statement not covered" >states.keyframes=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="word"){<span class="cstat-no" title="statement not covered" >override="variable";<span class="cstat-no" title="statement not covered" >r</span>eturn"keyframes";}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(type=="{")<span class="cstat-no" title="statement not covered" >return pushContext(state,stream,"top");<span class="cstat-no" title="statement not covered" >r</span></span>eturn pass(type,stream,state);}</span>;<span class="cstat-no" title="statement not covered" >states.at=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type==";")<span class="cstat-no" title="statement not covered" >return popContext(state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="{"||type=="}")<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word")<span class="cstat-no" title="statement not covered" >override="tag";e</span>lse <span class="cstat-no" title="statement not covered" >if(type=="hash")<span class="cstat-no" title="statement not covered" >override="builtin";<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn"at";}</span>;<span class="cstat-no" title="statement not covered" >s</span>tates.interpolation=<span class="fstat-no" title="function not covered" >fu</span>nction(type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="}")<span class="cstat-no" title="statement not covered" >return popContext(state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="{"||type==";")<span class="cstat-no" title="statement not covered" >return popAndPass(type,stream,state);<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word")<span class="cstat-no" title="statement not covered" >override="variable";e</span>lse <span class="cstat-no" title="statement not covered" >if(type!="variable"&amp;&amp;type!="("&amp;&amp;type!=")")<span class="cstat-no" title="statement not covered" >override="error";<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn"interpolation";}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn{startState:<span class="fstat-no" title="function not covered" >fu</span>nction(base){<span class="cstat-no" title="statement not covered" >return{tokenize:null,state:inline?"block":"top",stateArg:null,context:new Context(inline?"block":"top",base||0,null)};}</span>,token:<span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >if(!state.tokenize&amp;&amp;stream.eatSpace())<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar style=<span class="cstat-no" title="statement not covered" >(state.tokenize||tokenBase)(stream,state);<span class="cstat-no" title="statement not covered" ></span>if(style&amp;&amp;typeof style=="object"){<span class="cstat-no" title="statement not covered" >type=style[1];<span class="cstat-no" title="statement not covered" >s</span>tyle=style[0];}</span></span></span>
<span class="cstat-no" title="statement not covered" >override=style;<span class="cstat-no" title="statement not covered" >i</span>f(type!="comment")</span>
<span class="cstat-no" title="statement not covered" >state.state=states[state.state](type,stream,state);<span class="cstat-no" title="statement not covered" >r</span>eturn override;}</span>,indent:<span class="fstat-no" title="function not covered" >fu</span>nction(state,textAfter){var cx=<span class="cstat-no" title="statement not covered" >state.context,</span>ch=<span class="cstat-no" title="statement not covered" >textAfter&amp;&amp;textAfter.charAt(0);</span>var indent=<span class="cstat-no" title="statement not covered" >cx.indent;<span class="cstat-no" title="statement not covered" ></span>if(cx.type=="prop"&amp;&amp;(ch=="}"||ch==")"))<span class="cstat-no" title="statement not covered" >cx=cx.prev;<span class="cstat-no" title="statement not covered" >i</span></span>f(cx.prev){<span class="cstat-no" title="statement not covered" >if(ch=="}"&amp;&amp;(cx.type=="block"||cx.type=="top"||cx.type=="interpolation"||cx.type=="restricted_atBlock")){<span class="cstat-no" title="statement not covered" >cx=cx.prev;<span class="cstat-no" title="statement not covered" >i</span>ndent=cx.indent;}</span>else <span class="cstat-no" title="statement not covered" >if(ch==")"&amp;&amp;(cx.type=="parens"||cx.type=="atBlock_parens")||ch=="{"&amp;&amp;(cx.type=="at"||cx.type=="atBlock")){<span class="cstat-no" title="statement not covered" >indent=Math.max(0,cx.indent-indentUnit);}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >return indent;}</span>,electricChars:"}",blockCommentStart:"/*",blockCommentEnd:"*/",blockCommentContinue:" * ",lineComment:lineComment,fold:"brace"};});function <span class="fstat-no" title="function not covered" >keySet(</span>array){var keys=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;array.length;++i){<span class="cstat-no" title="statement not covered" >keys[array[i].toLowerCase()]=true;}</span></span>
<span class="cstat-no" title="statement not covered" >return keys;}</span>
var documentTypes_=<span class="cstat-no" title="statement not covered" >["domain","regexp","url","url-prefix"],</span>documentTypes=<span class="cstat-no" title="statement not covered" >keySet(documentTypes_);</span>var mediaTypes_=<span class="cstat-no" title="statement not covered" >["all","aural","braille","handheld","print","projection","screen","tty","tv","embossed"],</span>mediaTypes=<span class="cstat-no" title="statement not covered" >keySet(mediaTypes_);</span>var mediaFeatures_=<span class="cstat-no" title="statement not covered" >["width","min-width","max-width","height","min-height","max-height","device-width","min-device-width","max-device-width","device-height","min-device-height","max-device-height","aspect-ratio","min-aspect-ratio","max-aspect-ratio","device-aspect-ratio","min-device-aspect-ratio","max-device-aspect-ratio","color","min-color","max-color","color-index","min-color-index","max-color-index","monochrome","min-monochrome","max-monochrome","resolution","min-resolution","max-resolution","scan","grid","orientation","device-pixel-ratio","min-device-pixel-ratio","max-device-pixel-ratio","pointer","any-pointer","hover","any-hover"],</span>mediaFeatures=<span class="cstat-no" title="statement not covered" >keySet(mediaFeatures_);</span>var mediaValueKeywords_=<span class="cstat-no" title="statement not covered" >["landscape","portrait","none","coarse","fine","on-demand","hover","interlace","progressive"],</span>mediaValueKeywords=<span class="cstat-no" title="statement not covered" >keySet(mediaValueKeywords_);</span>var propertyKeywords_=<span class="cstat-no" title="statement not covered" >["align-content","align-items","align-self","alignment-adjust","alignment-baseline","anchor-point","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","appearance","azimuth","backface-visibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","baseline-shift","binding","bleed","bookmark-label","bookmark-level","bookmark-state","bookmark-target","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","caret-color","clear","clip","color","color-profile","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","content","counter-increment","counter-reset","crop","cue","cue-after","cue-before","cursor","direction","display","dominant-baseline","drop-initial-after-adjust","drop-initial-after-align","drop-initial-before-adjust","drop-initial-before-align","drop-initial-size","drop-initial-value","elevation","empty-cells","fit","fit-position","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","float-offset","flow-from","flow-into","font","font-feature-settings","font-family","font-kerning","font-language-override","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-weight","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-rows","grid-column","grid-column-end","grid-column-gap","grid-column-start","grid-gap","grid-row","grid-row-end","grid-row-gap","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","inline-box-align","justify-content","justify-items","justify-self","left","letter-spacing","line-break","line-height","line-stacking","line-stacking-ruby","line-stacking-shift","line-stacking-strategy","list-style","list-style-image","list-style-position","list-style-type","margin","margin-bottom","margin-left","margin-right","margin-top","marks","marquee-direction","marquee-loop","marquee-play-count","marquee-speed","marquee-style","max-height","max-width","min-height","min-width","mix-blend-mode","move-to","nav-down","nav-index","nav-left","nav-right","nav-up","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-style","overflow-wrap","overflow-x","overflow-y","padding","padding-bottom","padding-left","padding-right","padding-top","page","page-break-after","page-break-before","page-break-inside","page-policy","pause","pause-after","pause-before","perspective","perspective-origin","pitch","pitch-range","place-content","place-items","place-self","play-during","position","presentation-level","punctuation-trim","quotes","region-break-after","region-break-before","region-break-inside","region-fragment","rendering-intent","resize","rest","rest-after","rest-before","richness","right","rotation","rotation-point","ruby-align","ruby-overhang","ruby-position","ruby-span","shape-image-threshold","shape-inside","shape-margin","shape-outside","size","speak","speak-as","speak-header","speak-numeral","speak-punctuation","speech-rate","stress","string-set","tab-size","table-layout","target","target-name","target-new","target-position","text-align","text-align-last","text-decoration","text-decoration-color","text-decoration-line","text-decoration-skip","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-height","text-indent","text-justify","text-outline","text-overflow","text-shadow","text-size-adjust","text-space-collapse","text-transform","text-underline-position","text-wrap","top","transform","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","user-select","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","z-index","clip-path","clip-rule","mask","enable-background","filter","flood-color","flood-opacity","lighting-color","stop-color","stop-opacity","pointer-events","color-interpolation","color-interpolation-filters","color-rendering","fill","fill-opacity","fill-rule","image-rendering","marker","marker-end","marker-mid","marker-start","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-rendering","baseline-shift","dominant-baseline","glyph-orientation-horizontal","glyph-orientation-vertical","text-anchor","writing-mode"],</span>propertyKeywords=<span class="cstat-no" title="statement not covered" >keySet(propertyKeywords_);</span>var nonStandardPropertyKeywords_=<span class="cstat-no" title="statement not covered" >["scrollbar-arrow-color","scrollbar-base-color","scrollbar-dark-shadow-color","scrollbar-face-color","scrollbar-highlight-color","scrollbar-shadow-color","scrollbar-3d-light-color","scrollbar-track-color","shape-inside","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","zoom"],</span>nonStandardPropertyKeywords=<span class="cstat-no" title="statement not covered" >keySet(nonStandardPropertyKeywords_);</span>var fontProperties_=<span class="cstat-no" title="statement not covered" >["font-family","src","unicode-range","font-variant","font-feature-settings","font-stretch","font-weight","font-style"],</span>fontProperties=<span class="cstat-no" title="statement not covered" >keySet(fontProperties_);</span>var counterDescriptors_=<span class="cstat-no" title="statement not covered" >["additive-symbols","fallback","negative","pad","prefix","range","speak-as","suffix","symbols","system"],</span>counterDescriptors=<span class="cstat-no" title="statement not covered" >keySet(counterDescriptors_);</span>var colorKeywords_=<span class="cstat-no" title="statement not covered" >["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"],</span>colorKeywords=<span class="cstat-no" title="statement not covered" >keySet(colorKeywords_);</span>var valueKeywords_=<span class="cstat-no" title="statement not covered" >["above","absolute","activeborder","additive","activecaption","afar","after-white-space","ahead","alias","all","all-scroll","alphabetic","alternate","always","amharic","amharic-abegede","antialiased","appworkspace","arabic-indic","armenian","asterisks","attr","auto","auto-flow","avoid","avoid-column","avoid-page","avoid-region","background","backwards","baseline","below","bidi-override","binary","bengali","blink","block","block-axis","bold","bolder","border","border-box","both","bottom","break","break-all","break-word","bullets","button","button-bevel","buttonface","buttonhighlight","buttonshadow","buttontext","calc","cambodian","capitalize","caps-lock-indicator","caption","captiontext","caret","cell","center","checkbox","circle","cjk-decimal","cjk-earthly-branch","cjk-heavenly-stem","cjk-ideographic","clear","clip","close-quote","col-resize","collapse","color","color-burn","color-dodge","column","column-reverse","compact","condensed","contain","content","contents","content-box","context-menu","continuous","copy","counter","counters","cover","crop","cross","crosshair","currentcolor","cursive","cyclic","darken","dashed","decimal","decimal-leading-zero","default","default-button","dense","destination-atop","destination-in","destination-out","destination-over","devanagari","difference","disc","discard","disclosure-closed","disclosure-open","document","dot-dash","dot-dot-dash","dotted","double","down","e-resize","ease","ease-in","ease-in-out","ease-out","element","ellipse","ellipsis","embed","end","ethiopic","ethiopic-abegede","ethiopic-abegede-am-et","ethiopic-abegede-gez","ethiopic-abegede-ti-er","ethiopic-abegede-ti-et","ethiopic-halehame-aa-er","ethiopic-halehame-aa-et","ethiopic-halehame-am-et","ethiopic-halehame-gez","ethiopic-halehame-om-et","ethiopic-halehame-sid-et","ethiopic-halehame-so-et","ethiopic-halehame-ti-er","ethiopic-halehame-ti-et","ethiopic-halehame-tig","ethiopic-numeric","ew-resize","exclusion","expanded","extends","extra-condensed","extra-expanded","fantasy","fast","fill","fixed","flat","flex","flex-end","flex-start","footnotes","forwards","from","geometricPrecision","georgian","graytext","grid","groove","gujarati","gurmukhi","hand","hangul","hangul-consonant","hard-light","hebrew","help","hidden","hide","higher","highlight","highlighttext","hiragana","hiragana-iroha","horizontal","hsl","hsla","hue","icon","ignore","inactiveborder","inactivecaption","inactivecaptiontext","infinite","infobackground","infotext","inherit","initial","inline","inline-axis","inline-block","inline-flex","inline-grid","inline-table","inset","inside","intrinsic","invert","italic","japanese-formal","japanese-informal","justify","kannada","katakana","katakana-iroha","keep-all","khmer","korean-hangul-formal","korean-hanja-formal","korean-hanja-informal","landscape","lao","large","larger","left","level","lighter","lighten","line-through","linear","linear-gradient","lines","list-item","listbox","listitem","local","logical","loud","lower","lower-alpha","lower-armenian","lower-greek","lower-hexadecimal","lower-latin","lower-norwegian","lower-roman","lowercase","ltr","luminosity","malayalam","match","matrix","matrix3d","media-controls-background","media-current-time-display","media-fullscreen-button","media-mute-button","media-play-button","media-return-to-realtime-button","media-rewind-button","media-seek-back-button","media-seek-forward-button","media-slider","media-sliderthumb","media-time-remaining-display","media-volume-slider","media-volume-slider-container","media-volume-sliderthumb","medium","menu","menulist","menulist-button","menulist-text","menulist-textfield","menutext","message-box","middle","min-intrinsic","mix","mongolian","monospace","move","multiple","multiply","myanmar","n-resize","narrower","ne-resize","nesw-resize","no-close-quote","no-drop","no-open-quote","no-repeat","none","normal","not-allowed","nowrap","ns-resize","numbers","numeric","nw-resize","nwse-resize","oblique","octal","opacity","open-quote","optimizeLegibility","optimizeSpeed","oriya","oromo","outset","outside","outside-shape","overlay","overline","padding","padding-box","painted","page","paused","persian","perspective","plus-darker","plus-lighter","pointer","polygon","portrait","pre","pre-line","pre-wrap","preserve-3d","progress","push-button","radial-gradient","radio","read-only","read-write","read-write-plaintext-only","rectangle","region","relative","repeat","repeating-linear-gradient","repeating-radial-gradient","repeat-x","repeat-y","reset","reverse","rgb","rgba","ridge","right","rotate","rotate3d","rotateX","rotateY","rotateZ","round","row","row-resize","row-reverse","rtl","run-in","running","s-resize","sans-serif","saturation","scale","scale3d","scaleX","scaleY","scaleZ","screen","scroll","scrollbar","scroll-position","se-resize","searchfield","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","self-start","self-end","semi-condensed","semi-expanded","separate","serif","show","sidama","simp-chinese-formal","simp-chinese-informal","single","skew","skewX","skewY","skip-white-space","slide","slider-horizontal","slider-vertical","sliderthumb-horizontal","sliderthumb-vertical","slow","small","small-caps","small-caption","smaller","soft-light","solid","somali","source-atop","source-in","source-out","source-over","space","space-around","space-between","space-evenly","spell-out","square","square-button","start","static","status-bar","stretch","stroke","sub","subpixel-antialiased","super","sw-resize","symbolic","symbols","system-ui","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tamil","telugu","text","text-bottom","text-top","textarea","textfield","thai","thick","thin","threeddarkshadow","threedface","threedhighlight","threedlightshadow","threedshadow","tibetan","tigre","tigrinya-er","tigrinya-er-abegede","tigrinya-et","tigrinya-et-abegede","to","top","trad-chinese-formal","trad-chinese-informal","transform","translate","translate3d","translateX","translateY","translateZ","transparent","ultra-condensed","ultra-expanded","underline","unset","up","upper-alpha","upper-armenian","upper-greek","upper-hexadecimal","upper-latin","upper-norwegian","upper-roman","uppercase","urdu","url","var","vertical","vertical-text","visible","visibleFill","visiblePainted","visibleStroke","visual","w-resize","wait","wave","wider","window","windowframe","windowtext","words","wrap","wrap-reverse","x-large","x-small","xor","xx-large","xx-small"],</span>valueKeywords=<span class="cstat-no" title="statement not covered" >keySet(valueKeywords_);</span>var allWords=<span class="cstat-no" title="statement not covered" >documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);<span class="cstat-no" title="statement not covered" ></span>CodeMirror.registerHelper("hintWords","css",allWords);f</span>unction <span class="fstat-no" title="function not covered" >tokenCComment(</span>stream,state){var maybeEnd=<span class="cstat-no" title="statement not covered" >false,</span>ch;<span class="cstat-no" title="statement not covered" >while((ch=stream.next())!=null){<span class="cstat-no" title="statement not covered" >if(maybeEnd&amp;&amp;ch=="/"){<span class="cstat-no" title="statement not covered" >state.tokenize=null;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span>
<span class="cstat-no" title="statement not covered" >maybeEnd=(ch=="*");}</span>
<span class="cstat-no" title="statement not covered" >return["comment","comment"];}</span>
<span class="cstat-no" title="statement not covered" >CodeMirror.defineMIME("text/css",{documentTypes:documentTypes,mediaTypes:mediaTypes,mediaFeatures:mediaFeatures,mediaValueKeywords:mediaValueKeywords,propertyKeywords:propertyKeywords,nonStandardPropertyKeywords:nonStandardPropertyKeywords,fontProperties:fontProperties,counterDescriptors:counterDescriptors,colorKeywords:colorKeywords,valueKeywords:valueKeywords,tokenHooks:{"/":<span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >if(!stream.eat("*"))<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >s</span></span>tate.tokenize=tokenCComment;<span class="cstat-no" title="statement not covered" >r</span>eturn tokenCComment(stream,state);}</span>},name:"css"});<span class="cstat-no" title="statement not covered" >C</span>odeMirror.defineMIME("text/x-scss",{mediaTypes:mediaTypes,mediaFeatures:mediaFeatures,mediaValueKeywords:mediaValueKeywords,propertyKeywords:propertyKeywords,nonStandardPropertyKeywords:nonStandardPropertyKeywords,colorKeywords:colorKeywords,valueKeywords:valueKeywords,fontProperties:fontProperties,allowNested:true,lineComment:"//",tokenHooks:{"/":<span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >if(stream.eat("/")){<span class="cstat-no" title="statement not covered" >stream.skipToEnd();<span class="cstat-no" title="statement not covered" >r</span>eturn["comment","comment"];}</span>else <span class="cstat-no" title="statement not covered" >if(stream.eat("*")){<span class="cstat-no" title="statement not covered" >state.tokenize=tokenCComment;<span class="cstat-no" title="statement not covered" >r</span>eturn tokenCComment(stream,state);}</span>else{<span class="cstat-no" title="statement not covered" >return["operator","operator"];}</span>}</span></span>,":":<span class="fstat-no" title="function not covered" >fu</span>nction(stream){<span class="cstat-no" title="statement not covered" >if(stream.match(/\s*\{/,false))</span></span>
<span class="cstat-no" title="statement not covered" >return[null,null]</span>
<span class="cstat-no" title="statement not covered" >return false;}</span>,"$":<span class="fstat-no" title="function not covered" >fu</span>nction(stream){<span class="cstat-no" title="statement not covered" >stream.match(/^[\w-]+/);<span class="cstat-no" title="statement not covered" >i</span>f(stream.match(/^\s*:/,false))</span>
<span class="cstat-no" title="statement not covered" >return["variable-2","variable-definition"];<span class="cstat-no" title="statement not covered" >r</span>eturn["variable-2","variable"];}</span>,"#":<span class="fstat-no" title="function not covered" >fu</span>nction(stream){<span class="cstat-no" title="statement not covered" >if(!stream.eat("{"))<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span></span>eturn[null,"interpolation"];}</span>},name:"css",helperType:"scss"});<span class="cstat-no" title="statement not covered" >CodeMirror.defineMIME("text/x-less",{mediaTypes:mediaTypes,mediaFeatures:mediaFeatures,mediaValueKeywords:mediaValueKeywords,propertyKeywords:propertyKeywords,nonStandardPropertyKeywords:nonStandardPropertyKeywords,colorKeywords:colorKeywords,valueKeywords:valueKeywords,fontProperties:fontProperties,allowNested:true,lineComment:"//",tokenHooks:{"/":<span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >if(stream.eat("/")){<span class="cstat-no" title="statement not covered" >stream.skipToEnd();<span class="cstat-no" title="statement not covered" >r</span>eturn["comment","comment"];}</span>else <span class="cstat-no" title="statement not covered" >if(stream.eat("*")){<span class="cstat-no" title="statement not covered" >state.tokenize=tokenCComment;<span class="cstat-no" title="statement not covered" >r</span>eturn tokenCComment(stream,state);}</span>else{<span class="cstat-no" title="statement not covered" >return["operator","operator"];}</span>}</span></span>,"@":<span class="fstat-no" title="function not covered" >fu</span>nction(stream){<span class="cstat-no" title="statement not covered" >if(stream.eat("{"))<span class="cstat-no" title="statement not covered" >return[null,"interpolation"];<span class="cstat-no" title="statement not covered" >i</span></span>f(stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i,false))<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >s</span></span>tream.eatWhile(/[\w\\\-]/);<span class="cstat-no" title="statement not covered" >i</span>f(stream.match(/^\s*:/,false))</span></span>
<span class="cstat-no" title="statement not covered" >return["variable-2","variable-definition"];<span class="cstat-no" title="statement not covered" >r</span>eturn["variable-2","variable"];}</span>,"&amp;":<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return["atom","atom"];}</span>},name:"css",helperType:"less"});<span class="cstat-no" title="statement not covered" >CodeMirror.defineMIME("text/x-gss",{documentTypes:documentTypes,mediaTypes:mediaTypes,mediaFeatures:mediaFeatures,propertyKeywords:propertyKeywords,nonStandardPropertyKeywords:nonStandardPropertyKeywords,fontProperties:fontProperties,counterDescriptors:counterDescriptors,colorKeywords:colorKeywords,valueKeywords:valueKeywords,supportsAtComponent:true,tokenHooks:{"/":<span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >if(!stream.eat("*"))<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >s</span></span>tate.tokenize=tokenCComment;<span class="cstat-no" title="statement not covered" >r</span>eturn tokenCComment(stream,state);}</span>},name:"css",helperType:"gss"});}</span>);;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(mod){<span class="cstat-no" title="statement not covered" >if(typeof exports=="object"&amp;&amp;typeof module=="object")</span></span>
<span class="cstat-no" title="statement not covered" >mod(require("../../lib/codemirror"));e</span>lse <span class="cstat-no" title="statement not covered" >if(typeof define=="function"&amp;&amp;define.amd)</span>
<span class="cstat-no" title="statement not covered" >define(["../../lib/codemirror"],mod);e</span>lse
<span class="cstat-no" title="statement not covered" >mod(CodeMirror);}</span>)(<span class="fstat-no" title="function not covered" >fu</span>nction(CodeMirror){"use strict";var htmlConfig=<span class="cstat-no" title="statement not covered" >{autoSelfClosers:{'area':true,'base':true,'br':true,'col':true,'command':true,'embed':true,'frame':true,'hr':true,'img':true,'input':true,'keygen':true,'link':true,'meta':true,'param':true,'source':true,'track':true,'wbr':true,'menuitem':true},implicitlyClosed:{'dd':true,'li':true,'optgroup':true,'option':true,'p':true,'rp':true,'rt':true,'tbody':true,'td':true,'tfoot':true,'th':true,'tr':true},contextGrabbers:{'dd':{'dd':true,'dt':true},'dt':{'dd':true,'dt':true},'li':{'li':true},'option':{'option':true,'optgroup':true},'optgroup':{'optgroup':true},'p':{'address':true,'article':true,'aside':true,'blockquote':true,'dir':true,'div':true,'dl':true,'fieldset':true,'footer':true,'form':true,'h1':true,'h2':true,'h3':true,'h4':true,'h5':true,'h6':true,'header':true,'hgroup':true,'hr':true,'menu':true,'nav':true,'ol':true,'p':true,'pre':true,'section':true,'table':true,'ul':true},'rp':{'rp':true,'rt':true},'rt':{'rp':true,'rt':true},'tbody':{'tbody':true,'tfoot':true},'td':{'td':true,'th':true},'tfoot':{'tbody':true},'th':{'td':true,'th':true},'thead':{'tbody':true,'tfoot':true},'tr':{'tr':true}},doNotIndent:{"pre":true},allowUnquoted:true,allowMissing:true,caseFold:true}</span>
var xmlConfig=<span class="cstat-no" title="statement not covered" >{autoSelfClosers:{},implicitlyClosed:{},contextGrabbers:{},doNotIndent:{},allowUnquoted:false,allowMissing:false,allowMissingTagName:false,caseFold:false}</span>
<span class="cstat-no" title="statement not covered" >CodeMirror.defineMode("xml",<span class="fstat-no" title="function not covered" >fu</span>nction(editorConf,config_){var indentUnit=<span class="cstat-no" title="statement not covered" >editorConf.indentUnit</span></span>
var config=<span class="cstat-no" title="statement not covered" >{}</span>
var defaults=<span class="cstat-no" title="statement not covered" >config_.htmlMode?htmlConfig:xmlConfig</span>
<span class="cstat-no" title="statement not covered" >for(var prop in defaults)<span class="cstat-no" title="statement not covered" >config[prop]=defaults[prop]</span></span>
<span class="cstat-no" title="statement not covered" >for(var prop in config_)<span class="cstat-no" title="statement not covered" >config[prop]=config_[prop]</span></span>
var type,setStyle;function <span class="fstat-no" title="function not covered" >inText(</span>stream,state){function <span class="fstat-no" title="function not covered" >chain(</span>parser){<span class="cstat-no" title="statement not covered" >state.tokenize=parser;<span class="cstat-no" title="statement not covered" >r</span>eturn parser(stream,state);}</span>
var ch=<span class="cstat-no" title="statement not covered" >stream.next();<span class="cstat-no" title="statement not covered" ></span>if(ch=="&lt;"){<span class="cstat-no" title="statement not covered" >if(stream.eat("!")){<span class="cstat-no" title="statement not covered" >if(stream.eat("[")){<span class="cstat-no" title="statement not covered" >if(stream.match("CDATA["))<span class="cstat-no" title="statement not covered" >return chain(inBlock("atom","]]&gt;"));e</span>lse <span class="cstat-no" title="statement not covered" >return null;}</span></span>else <span class="cstat-no" title="statement not covered" >if(stream.match("--")){<span class="cstat-no" title="statement not covered" >return chain(inBlock("comment","--&gt;"));}</span>else <span class="cstat-no" title="statement not covered" >if(stream.match("DOCTYPE",true,true)){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w\._\-]/);<span class="cstat-no" title="statement not covered" >r</span>eturn chain(doctype(1));}</span>else{<span class="cstat-no" title="statement not covered" >return null;}</span>}</span></span></span>else <span class="cstat-no" title="statement not covered" >if(stream.eat("?")){<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[\w\._\-]/);<span class="cstat-no" title="statement not covered" >s</span>tate.tokenize=inBlock("meta","?&gt;");<span class="cstat-no" title="statement not covered" >r</span>eturn"meta";}</span>else{<span class="cstat-no" title="statement not covered" >type=stream.eat("/")?"closeTag":"openTag";<span class="cstat-no" title="statement not covered" >s</span>tate.tokenize=inTag;<span class="cstat-no" title="statement not covered" >r</span>eturn"tag bracket";}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >if(ch=="&amp;"){var ok;<span class="cstat-no" title="statement not covered" >if(stream.eat("#")){<span class="cstat-no" title="statement not covered" >if(stream.eat("x")){<span class="cstat-no" title="statement not covered" >ok=stream.eatWhile(/[a-fA-F\d]/)&amp;&amp;stream.eat(";");}</span>else{<span class="cstat-no" title="statement not covered" >ok=stream.eatWhile(/[\d]/)&amp;&amp;stream.eat(";");}</span>}</span>else{<span class="cstat-no" title="statement not covered" >ok=stream.eatWhile(/[\w\.\-:]/)&amp;&amp;stream.eat(";");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return ok?"atom":"error";}</span>else{<span class="cstat-no" title="statement not covered" >stream.eatWhile(/[^&amp;&lt;]/);<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>}
<span class="cstat-no" title="statement not covered" >inText.isInText=true;f</span>unction <span class="fstat-no" title="function not covered" >inTag(</span>stream,state){var ch=<span class="cstat-no" title="statement not covered" >stream.next();<span class="cstat-no" title="statement not covered" ></span>if(ch=="&gt;"||(ch=="/"&amp;&amp;stream.eat("&gt;"))){<span class="cstat-no" title="statement not covered" >state.tokenize=inText;<span class="cstat-no" title="statement not covered" >t</span>ype=ch=="&gt;"?"endTag":"selfcloseTag";<span class="cstat-no" title="statement not covered" >r</span>eturn"tag bracket";}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="="){<span class="cstat-no" title="statement not covered" >type="equals";<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="&lt;"){<span class="cstat-no" title="statement not covered" >state.tokenize=inText;<span class="cstat-no" title="statement not covered" >s</span>tate.state=baseState;<span class="cstat-no" title="statement not covered" >s</span>tate.tagName=state.tagStart=null;v</span>ar next=<span class="cstat-no" title="statement not covered" >state.tokenize(stream,state);<span class="cstat-no" title="statement not covered" ></span>return next?next+" tag error":"tag error";}</span>else <span class="cstat-no" title="statement not covered" >if(/[\'\"]/.test(ch)){<span class="cstat-no" title="statement not covered" >state.tokenize=inAttribute(ch);<span class="cstat-no" title="statement not covered" >s</span>tate.stringStartCol=stream.column();<span class="cstat-no" title="statement not covered" >r</span>eturn state.tokenize(stream,state);}</span>else{<span class="cstat-no" title="statement not covered" >stream.match(/^[^\s\u00a0=&lt;&gt;\"\']*[^\s\u00a0=&lt;&gt;\"\'\/]/);<span class="cstat-no" title="statement not covered" >r</span>eturn"word";}</span>}</span></span></span></span>
function <span class="fstat-no" title="function not covered" >inAttribute(</span>quote){var closure=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >while(!stream.eol()){<span class="cstat-no" title="statement not covered" >if(stream.next()==quote){<span class="cstat-no" title="statement not covered" >state.tokenize=inTag;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >return"string";}</span>;<span class="cstat-no" title="statement not covered" >closure.isInAttribute=true;<span class="cstat-no" title="statement not covered" >r</span>eturn closure;}</span>
function <span class="fstat-no" title="function not covered" >inBlock(</span>style,terminator){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >while(!stream.eol()){<span class="cstat-no" title="statement not covered" >if(stream.match(terminator)){<span class="cstat-no" title="statement not covered" >state.tokenize=inText;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >stream.next();}</span>
<span class="cstat-no" title="statement not covered" >return style;}</span>}
function <span class="fstat-no" title="function not covered" >doctype(</span>depth){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){var ch;<span class="cstat-no" title="statement not covered" >while((ch=stream.next())!=null){<span class="cstat-no" title="statement not covered" >if(ch=="&lt;"){<span class="cstat-no" title="statement not covered" >state.tokenize=doctype(depth+1);<span class="cstat-no" title="statement not covered" >r</span>eturn state.tokenize(stream,state);}</span>else <span class="cstat-no" title="statement not covered" >if(ch=="&gt;"){<span class="cstat-no" title="statement not covered" >if(depth==1){<span class="cstat-no" title="statement not covered" >state.tokenize=inText;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else{<span class="cstat-no" title="statement not covered" >state.tokenize=doctype(depth-1);<span class="cstat-no" title="statement not covered" >r</span>eturn state.tokenize(stream,state);}</span>}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return"meta";}</span>;}
function <span class="fstat-no" title="function not covered" >Context(</span>state,tagName,startOfLine){<span class="cstat-no" title="statement not covered" >this.prev=state.context;<span class="cstat-no" title="statement not covered" >t</span>his.tagName=tagName;<span class="cstat-no" title="statement not covered" >t</span>his.indent=state.indented;<span class="cstat-no" title="statement not covered" >t</span>his.startOfLine=startOfLine;<span class="cstat-no" title="statement not covered" >i</span>f(config.doNotIndent.hasOwnProperty(tagName)||(state.context&amp;&amp;state.context.noIndent))</span>
<span class="cstat-no" title="statement not covered" >this.noIndent=true;}</span>
function <span class="fstat-no" title="function not covered" >popContext(</span>state){<span class="cstat-no" title="statement not covered" >if(state.context)<span class="cstat-no" title="statement not covered" >state.context=state.context.prev;}</span></span>
function <span class="fstat-no" title="function not covered" >maybePopContext(</span>state,nextTagName){var parentTagName;<span class="cstat-no" title="statement not covered" >while(true){<span class="cstat-no" title="statement not covered" >if(!state.context){<span class="cstat-no" title="statement not covered" >return;}</span></span></span>
<span class="cstat-no" title="statement not covered" >parentTagName=state.context.tagName;<span class="cstat-no" title="statement not covered" >i</span>f(!config.contextGrabbers.hasOwnProperty(parentTagName)||!config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)){<span class="cstat-no" title="statement not covered" >return;}</span></span>
<span class="cstat-no" title="statement not covered" >popContext(state);}</span>}
function <span class="fstat-no" title="function not covered" >baseState(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="openTag"){<span class="cstat-no" title="statement not covered" >state.tagStart=stream.column();<span class="cstat-no" title="statement not covered" >r</span>eturn tagNameState;}</span>else <span class="cstat-no" title="statement not covered" >if(type=="closeTag"){<span class="cstat-no" title="statement not covered" >return closeTagNameState;}</span>else{<span class="cstat-no" title="statement not covered" >return baseState;}</span>}</span></span>
function <span class="fstat-no" title="function not covered" >tagNameState(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="word"){<span class="cstat-no" title="statement not covered" >state.tagName=stream.current();<span class="cstat-no" title="statement not covered" >s</span>etStyle="tag";<span class="cstat-no" title="statement not covered" >r</span>eturn attrState;}</span>else <span class="cstat-no" title="statement not covered" >if(config.allowMissingTagName&amp;&amp;type=="endTag"){<span class="cstat-no" title="statement not covered" >setStyle="tag bracket";<span class="cstat-no" title="statement not covered" >r</span>eturn attrState(type,stream,state);}</span>else{<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span>eturn tagNameState;}</span>}</span></span>
function <span class="fstat-no" title="function not covered" >closeTagNameState(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="word"){var tagName=<span class="cstat-no" title="statement not covered" >stream.current();<span class="cstat-no" title="statement not covered" ></span>if(state.context&amp;&amp;state.context.tagName!=tagName&amp;&amp;config.implicitlyClosed.hasOwnProperty(state.context.tagName))</span></span>
<span class="cstat-no" title="statement not covered" >popContext(state);<span class="cstat-no" title="statement not covered" >i</span>f((state.context&amp;&amp;state.context.tagName==tagName)||config.matchClosing===false){<span class="cstat-no" title="statement not covered" >setStyle="tag";<span class="cstat-no" title="statement not covered" >r</span>eturn closeState;}</span>else{<span class="cstat-no" title="statement not covered" >setStyle="tag error";<span class="cstat-no" title="statement not covered" >r</span>eturn closeStateErr;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(config.allowMissingTagName&amp;&amp;type=="endTag"){<span class="cstat-no" title="statement not covered" >setStyle="tag bracket";<span class="cstat-no" title="statement not covered" >r</span>eturn closeState(type,stream,state);}</span>else{<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span>eturn closeStateErr;}</span>}</span>
function <span class="fstat-no" title="function not covered" >closeState(</span>type,_stream,state){<span class="cstat-no" title="statement not covered" >if(type!="endTag"){<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span>eturn closeState;}</span></span>
<span class="cstat-no" title="statement not covered" >popContext(state);<span class="cstat-no" title="statement not covered" >r</span>eturn baseState;}</span>
function <span class="fstat-no" title="function not covered" >closeStateErr(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span>eturn closeState(type,stream,state);}</span>
function <span class="fstat-no" title="function not covered" >attrState(</span>type,_stream,state){<span class="cstat-no" title="statement not covered" >if(type=="word"){<span class="cstat-no" title="statement not covered" >setStyle="attribute";<span class="cstat-no" title="statement not covered" >r</span>eturn attrEqState;}</span>else <span class="cstat-no" title="statement not covered" >if(type=="endTag"||type=="selfcloseTag"){var tagName=<span class="cstat-no" title="statement not covered" >state.tagName,</span>tagStart=<span class="cstat-no" title="statement not covered" >state.tagStart;<span class="cstat-no" title="statement not covered" ></span>state.tagName=state.tagStart=null;<span class="cstat-no" title="statement not covered" >i</span>f(type=="selfcloseTag"||config.autoSelfClosers.hasOwnProperty(tagName)){<span class="cstat-no" title="statement not covered" >maybePopContext(state,tagName);}</span>else{<span class="cstat-no" title="statement not covered" >maybePopContext(state,tagName);<span class="cstat-no" title="statement not covered" >s</span>tate.context=new Context(state,tagName,tagStart==state.indented);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return baseState;}</span>
<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span>eturn attrState;}</span>
function <span class="fstat-no" title="function not covered" >attrEqState(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="equals")<span class="cstat-no" title="statement not covered" >return attrValueState;<span class="cstat-no" title="statement not covered" >i</span></span>f(!config.allowMissing)<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span></span>eturn attrState(type,stream,state);}</span>
function <span class="fstat-no" title="function not covered" >attrValueState(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="string")<span class="cstat-no" title="statement not covered" >return attrContinuedState;<span class="cstat-no" title="statement not covered" >i</span></span>f(type=="word"&amp;&amp;config.allowUnquoted){<span class="cstat-no" title="statement not covered" >setStyle="string";<span class="cstat-no" title="statement not covered" >r</span>eturn attrState;}</span></span>
<span class="cstat-no" title="statement not covered" >setStyle="error";<span class="cstat-no" title="statement not covered" >r</span>eturn attrState(type,stream,state);}</span>
function <span class="fstat-no" title="function not covered" >attrContinuedState(</span>type,stream,state){<span class="cstat-no" title="statement not covered" >if(type=="string")<span class="cstat-no" title="statement not covered" >return attrContinuedState;<span class="cstat-no" title="statement not covered" >r</span></span>eturn attrState(type,stream,state);}</span>
<span class="cstat-no" title="statement not covered" >return{startState:<span class="fstat-no" title="function not covered" >fu</span>nction(baseIndent){var state=<span class="cstat-no" title="statement not covered" >{tokenize:inText,state:baseState,indented:baseIndent||0,tagName:null,tagStart:null,context:null}</span></span>
<span class="cstat-no" title="statement not covered" >if(baseIndent!=null)<span class="cstat-no" title="statement not covered" >state.baseIndent=baseIndent</span></span>
<span class="cstat-no" title="statement not covered" >return state}</span>,token:<span class="fstat-no" title="function not covered" >fu</span>nction(stream,state){<span class="cstat-no" title="statement not covered" >if(!state.tagName&amp;&amp;stream.sol())</span>
<span class="cstat-no" title="statement not covered" >state.indented=stream.indentation();<span class="cstat-no" title="statement not covered" >i</span>f(stream.eatSpace())<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span></span>ype=null;v</span>ar style=<span class="cstat-no" title="statement not covered" >state.tokenize(stream,state);<span class="cstat-no" title="statement not covered" ></span>if((style||type)&amp;&amp;style!="comment"){<span class="cstat-no" title="statement not covered" >setStyle=null;<span class="cstat-no" title="statement not covered" >s</span>tate.state=state.state(type||style,stream,state);<span class="cstat-no" title="statement not covered" >i</span>f(setStyle)</span></span>
<span class="cstat-no" title="statement not covered" >style=setStyle=="error"?style+" error":setStyle;}</span>
<span class="cstat-no" title="statement not covered" >return style;}</span>,indent:<span class="fstat-no" title="function not covered" >fu</span>nction(state,textAfter,fullLine){var context=<span class="cstat-no" title="statement not covered" >state.context;<span class="cstat-no" title="statement not covered" ></span>if(state.tokenize.isInAttribute){<span class="cstat-no" title="statement not covered" >if(state.tagStart==state.indented)</span></span>
<span class="cstat-no" title="statement not covered" >return state.stringStartCol+1;e</span>lse
<span class="cstat-no" title="statement not covered" >return state.indented+indentUnit;}</span>
<span class="cstat-no" title="statement not covered" >if(context&amp;&amp;context.noIndent)<span class="cstat-no" title="statement not covered" >return CodeMirror.Pass;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.tokenize!=inTag&amp;&amp;state.tokenize!=inText)</span>
<span class="cstat-no" title="statement not covered" >return fullLine?fullLine.match(/^(\s*)/)[0].length:0;<span class="cstat-no" title="statement not covered" >i</span>f(state.tagName){<span class="cstat-no" title="statement not covered" >if(config.multilineTagIndentPastTag!==false)</span></span>
<span class="cstat-no" title="statement not covered" >return state.tagStart+state.tagName.length+2;e</span>lse
<span class="cstat-no" title="statement not covered" >return state.tagStart+indentUnit*(config.multilineTagIndentFactor||1);}</span>
<span class="cstat-no" title="statement not covered" >if(config.alignCDATA&amp;&amp;/&lt;!\[CDATA\[/.test(textAfter))<span class="cstat-no" title="statement not covered" >return 0;v</span></span>ar tagAfter=<span class="cstat-no" title="statement not covered" >textAfter&amp;&amp;/^&lt;(\/)?([\w_:\.-]*)/.exec(textAfter);<span class="cstat-no" title="statement not covered" ></span>if(tagAfter&amp;&amp;tagAfter[1]){<span class="cstat-no" title="statement not covered" >while(context){<span class="cstat-no" title="statement not covered" >if(context.tagName==tagAfter[2]){<span class="cstat-no" title="statement not covered" >context=context.prev;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else <span class="cstat-no" title="statement not covered" >if(config.implicitlyClosed.hasOwnProperty(context.tagName)){<span class="cstat-no" title="statement not covered" >context=context.prev;}</span>else{<span class="cstat-no" title="statement not covered" >break;}</span>}</span></span>}</span>else <span class="cstat-no" title="statement not covered" >if(tagAfter){<span class="cstat-no" title="statement not covered" >while(context){var grabbers=<span class="cstat-no" title="statement not covered" >config.contextGrabbers[context.tagName];<span class="cstat-no" title="statement not covered" ></span>if(grabbers&amp;&amp;grabbers.hasOwnProperty(tagAfter[2]))</span></span></span></span>
<span class="cstat-no" title="statement not covered" >context=context.prev;e</span>lse
<span class="cstat-no" title="statement not covered" >break;}</span>}
<span class="cstat-no" title="statement not covered" >while(context&amp;&amp;context.prev&amp;&amp;!context.startOfLine)</span>
<span class="cstat-no" title="statement not covered" >context=context.prev;<span class="cstat-no" title="statement not covered" >i</span>f(context)<span class="cstat-no" title="statement not covered" >return context.indent+indentUnit;e</span>lse <span class="cstat-no" title="statement not covered" >return state.baseIndent||0;}</span></span>,electricInput:/&lt;\/[\s\w:]+&gt;$/,blockCommentStart:"&lt;!--",blockCommentEnd:"--&gt;",configuration:config.htmlMode?"html":"xml",helperType:config.htmlMode?"html":"xml",skipAttribute:<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.state==attrValueState)</span>
<span class="cstat-no" title="statement not covered" >state.state=attrState}</span>};});<span class="cstat-no" title="statement not covered" >CodeMirror.defineMIME("text/xml","xml");<span class="cstat-no" title="statement not covered" >C</span>odeMirror.defineMIME("application/xml","xml");<span class="cstat-no" title="statement not covered" >i</span>f(!CodeMirror.mimeModes.hasOwnProperty("text/html"))</span>
<span class="cstat-no" title="statement not covered" >CodeMirror.defineMIME("text/html",{name:"xml",htmlMode:true});}</span>);;<span class="cstat-no" title="statement not covered" >FormatterWorker.ESTreeWalker=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(beforeVisit,afterVisit){<span class="cstat-no" title="statement not covered" >this._beforeVisit=beforeVisit;<span class="cstat-no" title="statement not covered" >t</span>his._afterVisit=afterVisit||new Function();<span class="cstat-no" title="statement not covered" >t</span>his._walkNulls=false;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tWalkNulls(value){<span class="cstat-no" title="statement not covered" >this._walkNulls=value;}</span>
<span class="fstat-no" title="function not covered" >wa</span>lk(ast){<span class="cstat-no" title="statement not covered" >this._innerWalk(ast,null);}</span>
<span class="fstat-no" title="function not covered" >_i</span>nnerWalk(node,parent){<span class="cstat-no" title="statement not covered" >if(!node&amp;&amp;parent&amp;&amp;this._walkNulls){const result=(<span class="cstat-no" title="statement not covered" >{raw:'null',value:null})</span>;<span class="cstat-no" title="statement not covered" >result.type='Literal';<span class="cstat-no" title="statement not covered" >n</span>ode=(result);}</span></span>
<span class="cstat-no" title="statement not covered" >if(!node)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span>ode.parent=parent;<span class="cstat-no" title="statement not covered" >i</span>f(this._beforeVisit.call(null,node)===FormatterWorker.ESTreeWalker.SkipSubtree){<span class="cstat-no" title="statement not covered" >this._afterVisit.call(null,node);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const walkOrder=<span class="cstat-no" title="statement not covered" >FormatterWorker.ESTreeWalker._walkOrder[node.type];<span class="cstat-no" title="statement not covered" ></span>if(!walkOrder){<span class="cstat-no" title="statement not covered" >console.error('Walk order not defined for '+node.type);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(node.type==='TemplateLiteral'){const templateLiteral=(<span class="cstat-no" title="statement not covered" >node)</span>;const expressionsLength=<span class="cstat-no" title="statement not covered" >templateLiteral.expressions.length;<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;expressionsLength;++i){<span class="cstat-no" title="statement not covered" >this._innerWalk(templateLiteral.quasis[i],templateLiteral);<span class="cstat-no" title="statement not covered" >t</span>his._innerWalk(templateLiteral.expressions[i],templateLiteral);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._innerWalk(templateLiteral.quasis[expressionsLength],templateLiteral);}</span>else{<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;walkOrder.length;++i){const entity=<span class="cstat-no" title="statement not covered" >node[walkOrder[i]];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(entity))</span></span>
<span class="cstat-no" title="statement not covered" >this._walkArray(entity,node);e</span>lse
<span class="cstat-no" title="statement not covered" >this._innerWalk(entity,node);}</span>}
<span class="cstat-no" title="statement not covered" >this._afterVisit.call(null,node);}</span>
<span class="fstat-no" title="function not covered" >_w</span>alkArray(nodeArray,parentNode){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;nodeArray.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._innerWalk(nodeArray[i],parentNode);}</span>};<span class="cstat-no" title="statement not covered" >FormatterWorker.ESTreeWalker.SkipSubtree={};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.ESTreeWalker._walkOrder={'AwaitExpression':['arguments'],'ArrayExpression':['elements'],'ArrayPattern':['elements'],'ArrowFunctionExpression':['params','body'],'AssignmentExpression':['left','right'],'AssignmentPattern':['left','right'],'BinaryExpression':['left','right'],'BlockStatement':['body'],'BreakStatement':['label'],'CallExpression':['callee','arguments'],'CatchClause':['param','body'],'ClassBody':['body'],'ClassDeclaration':['id','superClass','body'],'ClassExpression':['id','superClass','body'],'ConditionalExpression':['test','consequent','alternate'],'ContinueStatement':['label'],'DebuggerStatement':[],'DoWhileStatement':['body','test'],'EmptyStatement':[],'ExpressionStatement':['expression'],'ForInStatement':['left','right','body'],'ForOfStatement':['left','right','body'],'ForStatement':['init','test','update','body'],'FunctionDeclaration':['id','params','body'],'FunctionExpression':['id','params','body'],'Identifier':[],'IfStatement':['test','consequent','alternate'],'LabeledStatement':['label','body'],'Literal':[],'LogicalExpression':['left','right'],'MemberExpression':['object','property'],'MethodDefinition':['key','value'],'NewExpression':['callee','arguments'],'ObjectExpression':['properties'],'ObjectPattern':['properties'],'ParenthesizedExpression':['expression'],'Program':['body'],'Property':['key','value'],'ReturnStatement':['argument'],'SequenceExpression':['expressions'],'SpreadElement':['argument'],'Super':[],'SwitchCase':['test','consequent'],'SwitchStatement':['discriminant','cases'],'TaggedTemplateExpression':['tag','quasi'],'TemplateElement':[],'TemplateLiteral':['quasis','expressions'],'ThisExpression':[],'ThrowStatement':['argument'],'TryStatement':['block','handler','finalizer'],'UnaryExpression':['argument'],'UpdateExpression':['argument'],'VariableDeclaration':['declarations'],'VariableDeclarator':['id','init'],'WhileStatement':['test','body'],'WithStatement':['object','body'],'YieldExpression':['argument']};;<span class="cstat-no" title="statement not covered" ></span>FormatterWorker.createTokenizer=<span class="fstat-no" title="function not covered" >fu</span>nction(mimeType){const mode=<span class="cstat-no" title="statement not covered" >CodeMirror.getMode({indentUnit:2},mimeType);</span>const state=<span class="cstat-no" title="statement not covered" >CodeMirror.startState(mode);</span>function <span class="fstat-no" title="function not covered" >tokenize(</span>line,callback){const stream=<span class="cstat-no" title="statement not covered" >new CodeMirror.StringStream(line);<span class="cstat-no" title="statement not covered" ></span>while(!stream.eol()){const style=<span class="cstat-no" title="statement not covered" >mode.token(stream,state);</span>const value=<span class="cstat-no" title="statement not covered" >stream.current();<span class="cstat-no" title="statement not covered" ></span>if(callback(value,style,stream.start,stream.start+value.length)===FormatterWorker.AbortTokenization)</span></span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span>tream.start=stream.pos;}</span>}
<span class="cstat-no" title="statement not covered" >return tokenize;}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.AbortTokenization={};<span class="cstat-no" title="statement not covered" >s</span>elf.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(event){const method=(<span class="cstat-no" title="statement not covered" >event.data.method)</span>;const params=(<span class="cstat-no" title="statement not covered" >event.data.params)</span>;<span class="cstat-no" title="statement not covered" >if(!method)</span></span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span>witch(method){case'format':<span class="cstat-no" title="statement not covered" >FormatterWorker.format(params.mimeType,params.content,params.indentString);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'parseCSS':<span class="cstat-no" title="statement not covered" >FormatterWorker.parseCSS(params.content);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'parseSCSS':<span class="cstat-no" title="statement not covered" >FormatterWorker.FormatterWorkerContentParser.parse(params.content,'text/x-scss');<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'javaScriptOutline':<span class="cstat-no" title="statement not covered" >FormatterWorker.javaScriptOutline(params.content);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'javaScriptIdentifiers':<span class="cstat-no" title="statement not covered" >FormatterWorker.javaScriptIdentifiers(params.content);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'evaluatableJavaScriptSubstring':<span class="cstat-no" title="statement not covered" >FormatterWorker.evaluatableJavaScriptSubstring(params.content);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'parseJSONRelaxed':<span class="cstat-no" title="statement not covered" >FormatterWorker.parseJSONRelaxed(params.content);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'preprocessTopLevelAwaitExpressions':<span class="cstat-no" title="statement not covered" >FormatterWorker.preprocessTopLevelAwaitExpressions(params.content);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'findLastExpression':<span class="cstat-no" title="statement not covered" >postMessage(FormatterWorker.findLastExpression(params.content));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'findLastFunctionCall':<span class="cstat-no" title="statement not covered" >postMessage(FormatterWorker.findLastFunctionCall(params.content));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'argumentsList':<span class="cstat-no" title="statement not covered" >postMessage(FormatterWorker.argumentsList(params.content));<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >console.error('Unsupport method name: '+method);}</span>}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.parseJSONRelaxed=<span class="fstat-no" title="function not covered" >fu</span>nction(content){<span class="cstat-no" title="statement not covered" >postMessage(FormatterWorker.RelaxedJSONParser.parse(content));}</span>;<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.evaluatableJavaScriptSubstring=<span class="fstat-no" title="function not covered" >fu</span>nction(content){const tokenizer=<span class="cstat-no" title="statement not covered" >acorn.tokenizer(content,{ecmaVersion:9});</span>let result=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>try{let token=<span class="cstat-no" title="statement not covered" >tokenizer.getToken();<span class="cstat-no" title="statement not covered" ></span>while(token.type!==acorn.tokTypes.eof&amp;&amp;FormatterWorker.AcornTokenizer.punctuator(token))</span></span></span>
<span class="cstat-no" title="statement not covered" >token=tokenizer.getToken();c</span>onst startIndex=<span class="cstat-no" title="statement not covered" >token.start;</span>let endIndex=<span class="cstat-no" title="statement not covered" >token.end;</span>let openBracketsCounter=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(token.type!==acorn.tokTypes.eof){const isIdentifier=<span class="cstat-no" title="statement not covered" >FormatterWorker.AcornTokenizer.identifier(token);</span>const isThis=<span class="cstat-no" title="statement not covered" >FormatterWorker.AcornTokenizer.keyword(token,'this');</span>const isString=<span class="cstat-no" title="statement not covered" >token.type===acorn.tokTypes.string;<span class="cstat-no" title="statement not covered" ></span>if(!isThis&amp;&amp;!isIdentifier&amp;&amp;!isString)</span></span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >e</span>ndIndex=token.end;<span class="cstat-no" title="statement not covered" >t</span>oken=tokenizer.getToken();<span class="cstat-no" title="statement not covered" >w</span>hile(FormatterWorker.AcornTokenizer.punctuator(token,'.[]')){<span class="cstat-no" title="statement not covered" >if(FormatterWorker.AcornTokenizer.punctuator(token,'['))</span></span>
<span class="cstat-no" title="statement not covered" >openBracketsCounter++;<span class="cstat-no" title="statement not covered" >i</span>f(FormatterWorker.AcornTokenizer.punctuator(token,']')){<span class="cstat-no" title="statement not covered" >endIndex=openBracketsCounter&gt;0?token.end:endIndex;<span class="cstat-no" title="statement not covered" >o</span>penBracketsCounter--;}</span></span>
<span class="cstat-no" title="statement not covered" >token=tokenizer.getToken();}</span>}
<span class="cstat-no" title="statement not covered" >result=content.substring(startIndex,endIndex);}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.error(e);}</span>
<span class="cstat-no" title="statement not covered" >postMessage(result);}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.preprocessTopLevelAwaitExpressions=<span class="fstat-no" title="function not covered" >fu</span>nction(content){let wrapped=<span class="cstat-no" title="statement not covered" >'(async () =&gt; {'+content+'\n})()';</span>let root;let body;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >root=acorn.parse(wrapped,{ecmaVersion:10});<span class="cstat-no" title="statement not covered" >b</span>ody=root.body[0].expression.callee.body;}</span>catch(e){<span class="cstat-no" title="statement not covered" >postMessage('');<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
const changes=<span class="cstat-no" title="statement not covered" >[];</span>let containsAwait=<span class="cstat-no" title="statement not covered" >false;</span>let containsReturn=<span class="cstat-no" title="statement not covered" >false;</span>class Visitor{<span class="fstat-no" title="function not covered" >Cl</span>assDeclaration(node){<span class="cstat-no" title="statement not covered" >if(node.parent===body)</span>
<span class="cstat-no" title="statement not covered" >changes.push({text:node.id.name+'=',start:node.start,end:node.start});}</span>
<span class="fstat-no" title="function not covered" >Fu</span>nctionDeclaration(node){<span class="cstat-no" title="statement not covered" >changes.push({text:node.id.name+'=',start:node.start,end:node.start});<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.ESTreeWalker.SkipSubtree;}</span>
<span class="fstat-no" title="function not covered" >Fu</span>nctionExpression(node){<span class="cstat-no" title="statement not covered" >return FormatterWorker.ESTreeWalker.SkipSubtree;}</span>
<span class="fstat-no" title="function not covered" >Ar</span>rowFunctionExpression(node){<span class="cstat-no" title="statement not covered" >return FormatterWorker.ESTreeWalker.SkipSubtree;}</span>
<span class="fstat-no" title="function not covered" >Me</span>thodDefinition(node){<span class="cstat-no" title="statement not covered" >return FormatterWorker.ESTreeWalker.SkipSubtree;}</span>
<span class="fstat-no" title="function not covered" >Aw</span>aitExpression(node){<span class="cstat-no" title="statement not covered" >containsAwait=true;}</span>
<span class="fstat-no" title="function not covered" >Fo</span>rOfStatement(node){<span class="cstat-no" title="statement not covered" >if(node.await)</span>
<span class="cstat-no" title="statement not covered" >containsAwait=true;}</span>
<span class="fstat-no" title="function not covered" >Re</span>turnStatement(node){<span class="cstat-no" title="statement not covered" >containsReturn=true;}</span>
<span class="fstat-no" title="function not covered" >Va</span>riableDeclaration(node){<span class="cstat-no" title="statement not covered" >if(node.kind!=='var'&amp;&amp;node.parent!==body)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(node.parent.type==='ForOfStatement'&amp;&amp;node.parent.left===node)</span>
<span class="cstat-no" title="statement not covered" >return;c</span>onst onlyOneDeclaration=<span class="cstat-no" title="statement not covered" >node.declarations.length===1;<span class="cstat-no" title="statement not covered" ></span>changes.push({text:onlyOneDeclaration?'void':'void (',start:node.start,end:node.start+node.kind.length});<span class="cstat-no" title="statement not covered" >f</span>or(const declaration of node.declarations){<span class="cstat-no" title="statement not covered" >if(!declaration.init){<span class="cstat-no" title="statement not covered" >changes.push({text:'(',start:declaration.start,end:declaration.start});<span class="cstat-no" title="statement not covered" >c</span>hanges.push({text:'=undefined)',start:declaration.end,end:declaration.end});<span class="cstat-no" title="statement not covered" >c</span>ontinue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >changes.push({text:'(',start:declaration.start,end:declaration.start});<span class="cstat-no" title="statement not covered" >c</span>hanges.push({text:')',start:declaration.end,end:declaration.end});}</span>
<span class="cstat-no" title="statement not covered" >if(!onlyOneDeclaration){const last=<span class="cstat-no" title="statement not covered" >node.declarations.peekLast();<span class="cstat-no" title="statement not covered" ></span>changes.push({text:')',start:last.end,end:last.end});}</span>}</span>}
const walker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(visit.bind(new Visitor()));<span class="cstat-no" title="statement not covered" ></span>walker.walk(body);f</span>unction <span class="fstat-no" title="function not covered" >visit(</span>node){<span class="cstat-no" title="statement not covered" >if(node.type in this)</span>
<span class="cstat-no" title="statement not covered" >return this[node.type](node);}</span>
<span class="cstat-no" title="statement not covered" >if(!containsAwait||containsReturn){<span class="cstat-no" title="statement not covered" >postMessage('');<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const last=<span class="cstat-no" title="statement not covered" >body.body[body.body.length-1];<span class="cstat-no" title="statement not covered" ></span>if(last.type==='ExpressionStatement'){<span class="cstat-no" title="statement not covered" >changes.push({text:'return (',start:last.start,end:last.start});<span class="cstat-no" title="statement not covered" >i</span>f(wrapped[last.end-1]!==';')</span></span>
<span class="cstat-no" title="statement not covered" >changes.push({text:')',start:last.end,end:last.end});e</span>lse
<span class="cstat-no" title="statement not covered" >changes.push({text:')',start:last.end-1,end:last.end-1});}</span>
<span class="cstat-no" title="statement not covered" >while(changes.length){const change=<span class="cstat-no" title="statement not covered" >changes.pop();<span class="cstat-no" title="statement not covered" ></span>wrapped=wrapped.substr(0,change.start)+change.text+wrapped.substr(change.end);}</span></span>
<span class="cstat-no" title="statement not covered" >postMessage(wrapped);}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.javaScriptIdentifiers=<span class="fstat-no" title="function not covered" >fu</span>nction(content){let root=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >root=acorn.parse(content,{ranges:false,ecmaVersion:9});}</span>catch(e){}</span></span>
const identifiers=<span class="cstat-no" title="statement not covered" >[];</span>const walker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(beforeVisit);</span>function <span class="fstat-no" title="function not covered" >isFunction(</span>node){<span class="cstat-no" title="statement not covered" >return node.type==='FunctionDeclaration'||node.type==='FunctionExpression'||node.type==='ArrowFunctionExpression';}</span>
function <span class="fstat-no" title="function not covered" >beforeVisit(</span>node){<span class="cstat-no" title="statement not covered" >if(isFunction(node)){<span class="cstat-no" title="statement not covered" >if(node.id)</span></span>
<span class="cstat-no" title="statement not covered" >identifiers.push(node.id);<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.ESTreeWalker.SkipSubtree;}</span>
<span class="cstat-no" title="statement not covered" >if(node.type!=='Identifier')</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='MemberExpression'&amp;&amp;node.parent.property===node&amp;&amp;!node.parent.computed)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>dentifiers.push(node);}</span>
<span class="cstat-no" title="statement not covered" >if(!root||root.type!=='Program'||root.body.length!==1||!isFunction(root.body[0])){<span class="cstat-no" title="statement not covered" >postMessage([]);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const functionNode=<span class="cstat-no" title="statement not covered" >root.body[0];<span class="cstat-no" title="statement not covered" ></span>for(const param of functionNode.params)</span>
<span class="cstat-no" title="statement not covered" >walker.walk(param);<span class="cstat-no" title="statement not covered" >w</span>alker.walk(functionNode.body);c</span>onst reduced=<span class="cstat-no" title="statement not covered" >identifiers.map(<span class="fstat-no" title="function not covered" >id</span>=&gt;(<span class="cstat-no" title="statement not covered" >{name:id.name,offset:id.start})</span>);<span class="cstat-no" title="statement not covered" ></span>postMessage(reduced);}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.format=<span class="fstat-no" title="function not covered" >fu</span>nction(mimeType,text,indentString){<span class="cstat-no" title="statement not covered" >indentString=indentString||'    ';c</span>onst result=<span class="cstat-no" title="statement not covered" >{};</span>const builder=<span class="cstat-no" title="statement not covered" >new FormatterWorker.FormattedContentBuilder(indentString);</span>const lineEndings=<span class="cstat-no" title="statement not covered" >text.computeLineEndings();<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >switch(mimeType){case'text/html':{const formatter=<span class="cstat-no" title="statement not covered" >new FormatterWorker.HTMLFormatter(builder);<span class="cstat-no" title="statement not covered" ></span>formatter.format(text,lineEndings);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span></span></span>
case'text/css':{const formatter=<span class="cstat-no" title="statement not covered" >new FormatterWorker.CSSFormatter(builder);<span class="cstat-no" title="statement not covered" ></span>formatter.format(text,lineEndings,0,text.length);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case'text/javascript':{const formatter=<span class="cstat-no" title="statement not covered" >new FormatterWorker.JavaScriptFormatter(builder);<span class="cstat-no" title="statement not covered" ></span>formatter.format(text,lineEndings,0,text.length);<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
default:{const formatter=<span class="cstat-no" title="statement not covered" >new FormatterWorker.IdentityFormatter(builder);<span class="cstat-no" title="statement not covered" ></span>formatter.format(text,lineEndings,0,text.length);}</span>}
<span class="cstat-no" title="statement not covered" >result.mapping=builder.mapping();<span class="cstat-no" title="statement not covered" >r</span>esult.content=builder.content();}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.error(e);<span class="cstat-no" title="statement not covered" >r</span>esult.mapping={original:[0],formatted:[0]};<span class="cstat-no" title="statement not covered" >r</span>esult.content=text;}</span>
<span class="cstat-no" title="statement not covered" >postMessage(result);}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.findLastFunctionCall=<span class="fstat-no" title="function not covered" >fu</span>nction(content){<span class="cstat-no" title="statement not covered" >if(content.length&gt;10000)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span>ry{const tokenizer=<span class="cstat-no" title="statement not covered" >acorn.tokenizer(content,{ecmaVersion:9});<span class="cstat-no" title="statement not covered" ></span>while(tokenizer.getToken().type!==acorn.tokTypes.eof){}}</span>catch(e){<span class="cstat-no" title="statement not covered" >return null;}</span></span>
const suffix=<span class="cstat-no" title="statement not covered" >'000)';</span>const base=<span class="cstat-no" title="statement not covered" >FormatterWorker._lastCompleteExpression(content,suffix,new Set(['CallExpression','NewExpression']));<span class="cstat-no" title="statement not covered" ></span>if(!base)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst callee=<span class="cstat-no" title="statement not covered" >base.baseNode['callee'];</span>let functionName=<span class="cstat-no" title="statement not covered" >'';</span>const functionProperty=<span class="cstat-no" title="statement not covered" >callee.type==='Identifier'?callee:callee.property;<span class="cstat-no" title="statement not covered" ></span>if(functionProperty){<span class="cstat-no" title="statement not covered" >if(functionProperty.type==='Identifier')</span></span>
<span class="cstat-no" title="statement not covered" >functionName=functionProperty.name;e</span>lse <span class="cstat-no" title="statement not covered" >if(functionProperty.type==='Literal')</span>
<span class="cstat-no" title="statement not covered" >functionName=functionProperty.value;}</span>
const argumentIndex=<span class="cstat-no" title="statement not covered" >base.baseNode['arguments'].length-1;</span>const baseExpression=<span class="cstat-no" title="statement not covered" >`(${base.baseExpression.substring(callee.start - base.baseNode.start, callee.end - base.baseNode.start)})`;</span>const possibleSideEffects=<span class="cstat-no" title="statement not covered" >FormatterWorker._nodeHasPossibleSideEffects(callee);</span>let receiver=<span class="cstat-no" title="statement not covered" >'(function(){return this})()';<span class="cstat-no" title="statement not covered" ></span>if(callee.type==='MemberExpression'){const receiverBase=<span class="cstat-no" title="statement not covered" >callee['object'];<span class="cstat-no" title="statement not covered" ></span>receiver=base.baseExpression.substring(receiverBase.start-base.baseNode.start,receiverBase.end-base.baseNode.start);}</span></span>
<span class="cstat-no" title="statement not covered" >return{baseExpression,receiver,possibleSideEffects,argumentIndex,functionName};}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.argumentsList=<span class="fstat-no" title="function not covered" >fu</span>nction(content){<span class="cstat-no" title="statement not covered" >if(content.length&gt;10000)</span></span>
<span class="cstat-no" title="statement not covered" >return[];l</span>et parsed=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >parsed=acorn.parse(`(${content})`,{ecmaVersion:9});}</span>catch(e){}</span>
<span class="cstat-no" title="statement not covered" >if(!parsed){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >parsed=acorn.parse(`({${content}})`,{ecmaVersion:9});}</span>catch(e){}}</span></span>
<span class="cstat-no" title="statement not covered" >if(!parsed||!parsed.body||!parsed.body[0]||!parsed.body[0].expression)</span>
<span class="cstat-no" title="statement not covered" >return[];c</span>onst expression=<span class="cstat-no" title="statement not covered" >parsed.body[0].expression;</span>let params=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>switch(expression.type){case'ClassExpression':<span class="cstat-no" title="statement not covered" >if(!expression.body.body)</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst constructor=<span class="cstat-no" title="statement not covered" >expression.body.body.find(<span class="fstat-no" title="function not covered" >me</span>thod=&gt;<span class="cstat-no" title="statement not covered" >method.kind==='constructor')</span>;<span class="cstat-no" title="statement not covered" ></span>if(constructor)</span>
<span class="cstat-no" title="statement not covered" >params=constructor.value.params;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'ObjectExpression':<span class="cstat-no" title="statement not covered" >if(!expression.properties[0]||!expression.properties[0].value)</span>
<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >p</span>arams=expression.properties[0].value.params;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'FunctionExpression':case'ArrowFunctionExpression':<span class="cstat-no" title="statement not covered" >params=expression.params;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
<span class="cstat-no" title="statement not covered" >if(!params)</span>
<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >r</span>eturn params.map(paramName);f</span>unction <span class="fstat-no" title="function not covered" >paramName(</span>param){<span class="cstat-no" title="statement not covered" >switch(param.type){case'Identifier':<span class="cstat-no" title="statement not covered" >return param.name;c</span>ase'AssignmentPattern':<span class="cstat-no" title="statement not covered" >return'?'+paramName(param.left);c</span>ase'ObjectPattern':<span class="cstat-no" title="statement not covered" >return'obj';c</span>ase'ArrayPattern':<span class="cstat-no" title="statement not covered" >return'arr';c</span>ase'RestElement':<span class="cstat-no" title="statement not covered" >return'...'+paramName(param.argument);}</span></span>
<span class="cstat-no" title="statement not covered" >return'?';}</span>};<span class="cstat-no" title="statement not covered" >FormatterWorker.findLastExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(content){<span class="cstat-no" title="statement not covered" >if(content.length&gt;10000)</span></span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span>ry{const tokenizer=<span class="cstat-no" title="statement not covered" >acorn.tokenizer(content,{ecmaVersion:9});<span class="cstat-no" title="statement not covered" ></span>while(tokenizer.getToken().type!==acorn.tokTypes.eof){}}</span>catch(e){<span class="cstat-no" title="statement not covered" >return null;}</span></span>
const suffix=<span class="cstat-no" title="statement not covered" >'.DEVTOOLS';<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >acorn.parse(content+suffix,{ecmaVersion:9});}</span>catch(parseError){<span class="cstat-no" title="statement not covered" >if(parseError.message.startsWith('Unexpected token')&amp;&amp;parseError.pos===content.length)</span></span>
<span class="cstat-no" title="statement not covered" >return null;}</span>
const base=<span class="cstat-no" title="statement not covered" >FormatterWorker._lastCompleteExpression(content,suffix,new Set(['MemberExpression','Identifier']));<span class="cstat-no" title="statement not covered" ></span>if(!base)</span>
<span class="cstat-no" title="statement not covered" >return null;c</span>onst{baseExpression,baseNode}=<span class="cstat-no" title="statement not covered" >base;</span>const possibleSideEffects=<span class="cstat-no" title="statement not covered" >FormatterWorker._nodeHasPossibleSideEffects(baseNode);<span class="cstat-no" title="statement not covered" ></span>return{baseExpression,possibleSideEffects};}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker._lastCompleteExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(content,suffix,types){let ast;let parsedContent=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;content.length;i++){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >parsedContent=content[i]==='{'?`(${content.substring(i)})${suffix}`:`${content.substring(i)}${suffix}`;<span class="cstat-no" title="statement not covered" >a</span>st=acorn.parse(parsedContent,{ecmaVersion:9});<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>catch(e){}}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!ast)</span>
<span class="cstat-no" title="statement not covered" >return null;l</span>et baseNode=<span class="cstat-no" title="statement not covered" >null;</span>const walker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(<span class="fstat-no" title="function not covered" >no</span>de=&gt;{<span class="cstat-no" title="statement not covered" >if(baseNode||node.end&lt;ast.end)</span></span>
<span class="cstat-no" title="statement not covered" >return FormatterWorker.ESTreeWalker.SkipSubtree;<span class="cstat-no" title="statement not covered" >i</span>f(types.has(node.type))</span>
<span class="cstat-no" title="statement not covered" >baseNode=node;}</span>);<span class="cstat-no" title="statement not covered" >walker.walk(ast);<span class="cstat-no" title="statement not covered" >i</span>f(!baseNode)</span>
<span class="cstat-no" title="statement not covered" >return null;l</span>et baseExpression=<span class="cstat-no" title="statement not covered" >parsedContent.substring(baseNode.start,parsedContent.length-suffix.length);<span class="cstat-no" title="statement not covered" ></span>if(baseExpression.startsWith('{'))</span>
<span class="cstat-no" title="statement not covered" >baseExpression=`(${baseExpression})`;<span class="cstat-no" title="statement not covered" >r</span>eturn{baseNode,baseExpression};}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker._nodeHasPossibleSideEffects=<span class="fstat-no" title="function not covered" >fu</span>nction(baseNode){const sideEffectFreeTypes=<span class="cstat-no" title="statement not covered" >new Set(['MemberExpression','Identifier','BinaryExpression','Literal','TemplateLiteral','TemplateElement','ObjectExpression','ArrayExpression','Property','ThisExpression']);</span>let possibleSideEffects=<span class="cstat-no" title="statement not covered" >false;</span>const sideEffectwalker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(<span class="fstat-no" title="function not covered" >no</span>de=&gt;{<span class="cstat-no" title="statement not covered" >if(!possibleSideEffects&amp;&amp;!sideEffectFreeTypes.has(node.type))</span></span></span>
<span class="cstat-no" title="statement not covered" >possibleSideEffects=true;<span class="cstat-no" title="statement not covered" >i</span>f(possibleSideEffects)</span>
<span class="cstat-no" title="statement not covered" >return FormatterWorker.ESTreeWalker.SkipSubtree;}</span>);<span class="cstat-no" title="statement not covered" >sideEffectwalker.walk((baseNode));<span class="cstat-no" title="statement not covered" >r</span>eturn possibleSideEffects;}</span>;<span class="cstat-no" title="statement not covered" >FormatterWorker.FormatterWorkerContentParser=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.FormatterWorkerContentParser.prototype={parse(content){}};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.FormatterWorkerContentParser.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(content,mimeType){const extension=<span class="cstat-no" title="statement not covered" >self.runtime.extensions(FormatterWorker.FormatterWorkerContentParser).find(findExtension);<span class="cstat-no" title="statement not covered" ></span>console.assert(extension);<span class="cstat-no" title="statement not covered" >e</span>xtension.instance().then(<span class="fstat-no" title="function not covered" >in</span>stance=&gt;<span class="cstat-no" title="statement not covered" >instance.parse(content))</span>.catchException(null).then(postMessage);f</span>unction <span class="fstat-no" title="function not covered" >findExtension(</span>extension){<span class="cstat-no" title="statement not covered" >return extension.descriptor()['mimeType']===mimeType;}</span>};<span class="cstat-no" title="statement not covered" >(</span>function <span class="fstat-no" title="function not covered" >disableLoggingForTest(</span>){<span class="cstat-no" title="statement not covered" >if(Runtime.queryParam('test'))</span></span>
<span class="cstat-no" title="statement not covered" >console.error=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >undefined;</span>}</span>)();;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(global,factory){<span class="cstat-no" title="statement not covered" >typeof exports==='object'&amp;&amp;typeof module!=='undefined'?factory(exports):typeof define==='function'&amp;&amp;define.amd?define(['exports'],factory):(factory((global.acorn={})));}</span>(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(exports){'use strict';var reservedWords=<span class="cstat-no" title="statement not covered" >{3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"};</span>var ecma5AndLessKeywords=<span class="cstat-no" title="statement not covered" >"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";</span>var keywords=<span class="cstat-no" title="statement not covered" >{5:ecma5AndLessKeywords,6:ecma5AndLessKeywords+" const class extends export import super"};</span>var keywordRelationalOperator=<span class="cstat-no" title="statement not covered" >/^in(stanceof)?$/;</span>var nonASCIIidentifierStartChars=<span class="cstat-no" title="statement not covered" >"\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";</span>var nonASCIIidentifierChars=<span class="cstat-no" title="statement not covered" >"\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";</span>var nonASCIIidentifierStart=<span class="cstat-no" title="statement not covered" >new RegExp("["+nonASCIIidentifierStartChars+"]");</span>var nonASCIIidentifier=<span class="cstat-no" title="statement not covered" >new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");<span class="cstat-no" title="statement not covered" ></span>nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;v</span>ar astralIdentifierStartCodes=<span class="cstat-no" title="statement not covered" >[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];</span>var astralIdentifierCodes=<span class="cstat-no" title="statement not covered" >[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];</span>function <span class="fstat-no" title="function not covered" >isInAstralSet(</span>code,set){var pos=<span class="cstat-no" title="statement not covered" >0x10000;<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;set.length;i+=2){<span class="cstat-no" title="statement not covered" >pos+=set[i];<span class="cstat-no" title="statement not covered" >i</span>f(pos&gt;code){<span class="cstat-no" title="statement not covered" >return false}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >pos+=set[i+1];<span class="cstat-no" title="statement not covered" >i</span>f(pos&gt;=code){<span class="cstat-no" title="statement not covered" >return true}</span>}</span>}
function <span class="fstat-no" title="function not covered" >isIdentifierStart(</span>code,astral){<span class="cstat-no" title="statement not covered" >if(code&lt;65){<span class="cstat-no" title="statement not covered" >return code===36}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;91){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;97){<span class="cstat-no" title="statement not covered" >return code===95}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;123){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;=0xffff){<span class="cstat-no" title="statement not covered" >return code&gt;=0xaa&amp;&amp;nonASCIIidentifierStart.test(String.fromCharCode(code))}</span></span>
<span class="cstat-no" title="statement not covered" >if(astral===false){<span class="cstat-no" title="statement not covered" >return false}</span></span>
<span class="cstat-no" title="statement not covered" >return isInAstralSet(code,astralIdentifierStartCodes)}</span>
function <span class="fstat-no" title="function not covered" >isIdentifierChar(</span>code,astral){<span class="cstat-no" title="statement not covered" >if(code&lt;48){<span class="cstat-no" title="statement not covered" >return code===36}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;58){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;65){<span class="cstat-no" title="statement not covered" >return false}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;91){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;97){<span class="cstat-no" title="statement not covered" >return code===95}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;123){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(code&lt;=0xffff){<span class="cstat-no" title="statement not covered" >return code&gt;=0xaa&amp;&amp;nonASCIIidentifier.test(String.fromCharCode(code))}</span></span>
<span class="cstat-no" title="statement not covered" >if(astral===false){<span class="cstat-no" title="statement not covered" >return false}</span></span>
<span class="cstat-no" title="statement not covered" >return isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes)}</span>
var TokenType=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >TokenType(</span>label,conf){<span class="cstat-no" title="statement not covered" >if(conf===void 0)<span class="cstat-no" title="statement not covered" >conf={};<span class="cstat-no" title="statement not covered" >t</span></span>his.label=label;<span class="cstat-no" title="statement not covered" >t</span>his.keyword=conf.keyword;<span class="cstat-no" title="statement not covered" >t</span>his.beforeExpr=!!conf.beforeExpr;<span class="cstat-no" title="statement not covered" >t</span>his.startsExpr=!!conf.startsExpr;<span class="cstat-no" title="statement not covered" >t</span>his.isLoop=!!conf.isLoop;<span class="cstat-no" title="statement not covered" >t</span>his.isAssign=!!conf.isAssign;<span class="cstat-no" title="statement not covered" >t</span>his.prefix=!!conf.prefix;<span class="cstat-no" title="statement not covered" >t</span>his.postfix=!!conf.postfix;<span class="cstat-no" title="statement not covered" >t</span>his.binop=conf.binop||null;<span class="cstat-no" title="statement not covered" >t</span>his.updateContext=null;}</span>;</span>function <span class="fstat-no" title="function not covered" >binop(</span>name,prec){<span class="cstat-no" title="statement not covered" >return new TokenType(name,{beforeExpr:true,binop:prec})}</span>
var beforeExpr=<span class="cstat-no" title="statement not covered" >{beforeExpr:true};</span>var startsExpr=<span class="cstat-no" title="statement not covered" >{startsExpr:true};</span>var keywords$1=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >kw(</span>name,options){<span class="cstat-no" title="statement not covered" >if(options===void 0)<span class="cstat-no" title="statement not covered" >options={};<span class="cstat-no" title="statement not covered" >o</span></span>ptions.keyword=name;<span class="cstat-no" title="statement not covered" >r</span>eturn keywords$1[name]=new TokenType(name,options)}</span>
var types=<span class="cstat-no" title="statement not covered" >{num:new TokenType("num",startsExpr),regexp:new TokenType("regexp",startsExpr),string:new TokenType("string",startsExpr),name:new TokenType("name",startsExpr),eof:new TokenType("eof"),bracketL:new TokenType("[",{beforeExpr:true,startsExpr:true}),bracketR:new TokenType("]"),braceL:new TokenType("{",{beforeExpr:true,startsExpr:true}),braceR:new TokenType("}"),parenL:new TokenType("(",{beforeExpr:true,startsExpr:true}),parenR:new TokenType(")"),comma:new TokenType(",",beforeExpr),semi:new TokenType(";",beforeExpr),colon:new TokenType(":",beforeExpr),dot:new TokenType("."),question:new TokenType("?",beforeExpr),arrow:new TokenType("=&gt;",beforeExpr),template:new TokenType("template"),invalidTemplate:new TokenType("invalidTemplate"),ellipsis:new TokenType("...",beforeExpr),backQuote:new TokenType("`",startsExpr),dollarBraceL:new TokenType("${",{beforeExpr:true,startsExpr:true}),eq:new TokenType("=",{beforeExpr:true,isAssign:true}),assign:new TokenType("_=",{beforeExpr:true,isAssign:true}),incDec:new TokenType("++/--",{prefix:true,postfix:true,startsExpr:true}),prefix:new TokenType("!/~",{beforeExpr:true,prefix:true,startsExpr:true}),logicalOR:binop("||",1),logicalAND:binop("&amp;&amp;",2),bitwiseOR:binop("|",3),bitwiseXOR:binop("^",4),bitwiseAND:binop("&amp;",5),equality:binop("==/!=/===/!==",6),relational:binop("&lt;/&gt;/&lt;=/&gt;=",7),bitShift:binop("&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;",8),plusMin:new TokenType("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:binop("%",10),star:binop("*",10),slash:binop("/",10),starstar:new TokenType("**",{beforeExpr:true}),_break:kw("break"),_case:kw("case",beforeExpr),_catch:kw("catch"),_continue:kw("continue"),_debugger:kw("debugger"),_default:kw("default",beforeExpr),_do:kw("do",{isLoop:true,beforeExpr:true}),_else:kw("else",beforeExpr),_finally:kw("finally"),_for:kw("for",{isLoop:true}),_function:kw("function",startsExpr),_if:kw("if"),_return:kw("return",beforeExpr),_switch:kw("switch"),_throw:kw("throw",beforeExpr),_try:kw("try"),_var:kw("var"),_const:kw("const"),_while:kw("while",{isLoop:true}),_with:kw("with"),_new:kw("new",{beforeExpr:true,startsExpr:true}),_this:kw("this",startsExpr),_super:kw("super",startsExpr),_class:kw("class",startsExpr),_extends:kw("extends",beforeExpr),_export:kw("export"),_import:kw("import"),_null:kw("null",startsExpr),_true:kw("true",startsExpr),_false:kw("false",startsExpr),_in:kw("in",{beforeExpr:true,binop:7}),_instanceof:kw("instanceof",{beforeExpr:true,binop:7}),_typeof:kw("typeof",{beforeExpr:true,prefix:true,startsExpr:true}),_void:kw("void",{beforeExpr:true,prefix:true,startsExpr:true}),_delete:kw("delete",{beforeExpr:true,prefix:true,startsExpr:true})};</span>var lineBreak=<span class="cstat-no" title="statement not covered" >/\r\n?|\n|\u2028|\u2029/;</span>var lineBreakG=<span class="cstat-no" title="statement not covered" >new RegExp(lineBreak.source,"g");</span>function <span class="fstat-no" title="function not covered" >isNewLine(</span>code,ecma2019String){<span class="cstat-no" title="statement not covered" >return code===10||code===13||(!ecma2019String&amp;&amp;(code===0x2028||code===0x2029))}</span>
var nonASCIIwhitespace=<span class="cstat-no" title="statement not covered" >/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;</span>var skipWhiteSpace=<span class="cstat-no" title="statement not covered" >/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;</span>var ref=<span class="cstat-no" title="statement not covered" >Object.prototype;</span>var hasOwnProperty=<span class="cstat-no" title="statement not covered" >ref.hasOwnProperty;</span>var toString=<span class="cstat-no" title="statement not covered" >ref.toString;</span>function <span class="fstat-no" title="function not covered" >has(</span>obj,propName){<span class="cstat-no" title="statement not covered" >return hasOwnProperty.call(obj,propName)}</span>
var isArray=<span class="cstat-no" title="statement not covered" >Array.isArray||(<span class="fstat-no" title="function not covered" >fu</span>nction(obj){<span class="cstat-no" title="statement not covered" >return(toString.call(obj)==="[object Array]");}</span>);</span>var Position=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >Position(</span>line,col){<span class="cstat-no" title="statement not covered" >this.line=line;<span class="cstat-no" title="statement not covered" >t</span>his.column=col;}</span>;<span class="cstat-no" title="statement not covered" ></span>Position.prototype.offset=function <span class="fstat-no" title="function not covered" >offset(</span>n){<span class="cstat-no" title="statement not covered" >return new Position(this.line,this.column+n)}</span>;v</span>ar SourceLocation=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >SourceLocation(</span>p,start,end){<span class="cstat-no" title="statement not covered" >this.start=start;<span class="cstat-no" title="statement not covered" >t</span>his.end=end;<span class="cstat-no" title="statement not covered" >i</span>f(p.sourceFile!==null){<span class="cstat-no" title="statement not covered" >this.source=p.sourceFile;}</span>}</span>;</span>function <span class="fstat-no" title="function not covered" >getLineInfo(</span>input,offset){<span class="cstat-no" title="statement not covered" >for(var line=1,cur=0;;){<span class="cstat-no" title="statement not covered" >lineBreakG.lastIndex=cur;v</span>ar match=<span class="cstat-no" title="statement not covered" >lineBreakG.exec(input);<span class="cstat-no" title="statement not covered" ></span>if(match&amp;&amp;match.index&lt;offset){<span class="cstat-no" title="statement not covered" >++line;<span class="cstat-no" title="statement not covered" >c</span>ur=match.index+match[0].length;}</span>else{<span class="cstat-no" title="statement not covered" >return new Position(line,offset-cur)}</span>}</span>}</span>
var defaultOptions=<span class="cstat-no" title="statement not covered" >{ecmaVersion:9,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:false,allowImportExportEverywhere:false,allowAwaitOutsideFunction:false,allowHashBang:false,locations:false,onToken:null,onComment:null,ranges:false,program:null,sourceFile:null,directSourceFile:null,preserveParens:false};</span>function <span class="fstat-no" title="function not covered" >getOptions(</span>opts){var options=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var opt in defaultOptions)</span>
{<span class="cstat-no" title="statement not covered" >options[opt]=opts&amp;&amp;has(opts,opt)?opts[opt]:defaultOptions[opt];}</span>
<span class="cstat-no" title="statement not covered" >if(options.ecmaVersion&gt;=2015)</span>
{<span class="cstat-no" title="statement not covered" >options.ecmaVersion-=2009;}</span>
<span class="cstat-no" title="statement not covered" >if(options.allowReserved==null)</span>
{<span class="cstat-no" title="statement not covered" >options.allowReserved=options.ecmaVersion&lt;5;}</span>
<span class="cstat-no" title="statement not covered" >if(isArray(options.onToken)){var tokens=<span class="cstat-no" title="statement not covered" >options.onToken;<span class="cstat-no" title="statement not covered" ></span>options.onToken=<span class="fstat-no" title="function not covered" >fu</span>nction(token){<span class="cstat-no" title="statement not covered" >return tokens.push(token);}</span>;}</span></span>
<span class="cstat-no" title="statement not covered" >if(isArray(options.onComment))</span>
{<span class="cstat-no" title="statement not covered" >options.onComment=pushComment(options,options.onComment);}</span>
<span class="cstat-no" title="statement not covered" >return options}</span>
function <span class="fstat-no" title="function not covered" >pushComment(</span>options,array){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(block,text,start,end,startLoc,endLoc){var comment=<span class="cstat-no" title="statement not covered" >{type:block?"Block":"Line",value:text,start:start,end:end};<span class="cstat-no" title="statement not covered" ></span>if(options.locations)</span></span>
{<span class="cstat-no" title="statement not covered" >comment.loc=new SourceLocation(this,startLoc,endLoc);}</span>
<span class="cstat-no" title="statement not covered" >if(options.ranges)</span>
{<span class="cstat-no" title="statement not covered" >comment.range=[start,end];}</span>
<span class="cstat-no" title="statement not covered" >array.push(comment);}</span>}
var SCOPE_TOP=<span class="cstat-no" title="statement not covered" >1;</span>var SCOPE_FUNCTION=<span class="cstat-no" title="statement not covered" >2;</span>var SCOPE_VAR=<span class="cstat-no" title="statement not covered" >SCOPE_TOP|SCOPE_FUNCTION;</span>var SCOPE_ASYNC=<span class="cstat-no" title="statement not covered" >4;</span>var SCOPE_GENERATOR=<span class="cstat-no" title="statement not covered" >8;</span>var SCOPE_ARROW=<span class="cstat-no" title="statement not covered" >16;</span>var SCOPE_SIMPLE_CATCH=<span class="cstat-no" title="statement not covered" >32;</span>function <span class="fstat-no" title="function not covered" >functionFlags(</span>async,generator){<span class="cstat-no" title="statement not covered" >return SCOPE_FUNCTION|(async?SCOPE_ASYNC:0)|(generator?SCOPE_GENERATOR:0)}</span>
var BIND_NONE=<span class="cstat-no" title="statement not covered" >0;</span>var BIND_VAR=<span class="cstat-no" title="statement not covered" >1;</span>var BIND_LEXICAL=<span class="cstat-no" title="statement not covered" >2;</span>var BIND_FUNCTION=<span class="cstat-no" title="statement not covered" >3;</span>var BIND_SIMPLE_CATCH=<span class="cstat-no" title="statement not covered" >4;</span>var BIND_OUTSIDE=<span class="cstat-no" title="statement not covered" >5;</span>function <span class="fstat-no" title="function not covered" >keywordRegexp(</span>words){<span class="cstat-no" title="statement not covered" >return new RegExp("^(?:"+words.replace(/ /g,"|")+")$")}</span>
var Parser=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >Parser(</span>options,input,startPos){<span class="cstat-no" title="statement not covered" >this.options=options=getOptions(options);<span class="cstat-no" title="statement not covered" >t</span>his.sourceFile=options.sourceFile;<span class="cstat-no" title="statement not covered" >t</span>his.keywords=keywordRegexp(keywords[options.ecmaVersion&gt;=6?6:5]);v</span>ar reserved=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(!options.allowReserved){<span class="cstat-no" title="statement not covered" >for(var v=options.ecmaVersion;;v--)</span></span></span>
{<span class="cstat-no" title="statement not covered" >if(reserved=reservedWords[v]){<span class="cstat-no" title="statement not covered" >break}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(options.sourceType==="module"){<span class="cstat-no" title="statement not covered" >reserved+=" await";}</span>}</span>
<span class="cstat-no" title="statement not covered" >this.reservedWords=keywordRegexp(reserved);v</span>ar reservedStrict=<span class="cstat-no" title="statement not covered" >(reserved?reserved+" ":"")+reservedWords.strict;<span class="cstat-no" title="statement not covered" ></span>this.reservedWordsStrict=keywordRegexp(reservedStrict);<span class="cstat-no" title="statement not covered" >t</span>his.reservedWordsStrictBind=keywordRegexp(reservedStrict+" "+reservedWords.strictBind);<span class="cstat-no" title="statement not covered" >t</span>his.input=String(input);<span class="cstat-no" title="statement not covered" >t</span>his.containsEsc=false;<span class="cstat-no" title="statement not covered" >i</span>f(startPos){<span class="cstat-no" title="statement not covered" >this.pos=startPos;<span class="cstat-no" title="statement not covered" >t</span>his.lineStart=this.input.lastIndexOf("\n",startPos-1)+1;<span class="cstat-no" title="statement not covered" >t</span>his.curLine=this.input.slice(0,this.lineStart).split(lineBreak).length;}</span>else{<span class="cstat-no" title="statement not covered" >this.pos=this.lineStart=0;<span class="cstat-no" title="statement not covered" >t</span>his.curLine=1;}</span></span>
<span class="cstat-no" title="statement not covered" >this.type=types.eof;<span class="cstat-no" title="statement not covered" >t</span>his.value=null;<span class="cstat-no" title="statement not covered" >t</span>his.start=this.end=this.pos;<span class="cstat-no" title="statement not covered" >t</span>his.startLoc=this.endLoc=this.curPosition();<span class="cstat-no" title="statement not covered" >t</span>his.lastTokEndLoc=this.lastTokStartLoc=null;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokStart=this.lastTokEnd=this.pos;<span class="cstat-no" title="statement not covered" >t</span>his.context=this.initialContext();<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;<span class="cstat-no" title="statement not covered" >t</span>his.inModule=options.sourceType==="module";<span class="cstat-no" title="statement not covered" >t</span>his.strict=this.inModule||this.strictDirective(this.pos);<span class="cstat-no" title="statement not covered" >t</span>his.potentialArrowAt=-1;<span class="cstat-no" title="statement not covered" >t</span>his.yieldPos=this.awaitPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.labels=[];<span class="cstat-no" title="statement not covered" >i</span>f(this.pos===0&amp;&amp;options.allowHashBang&amp;&amp;this.input.slice(0,2)==="#!")</span>
{<span class="cstat-no" title="statement not covered" >this.skipLineComment(2);}</span>
<span class="cstat-no" title="statement not covered" >this.scopeStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.enterScope(SCOPE_TOP);<span class="cstat-no" title="statement not covered" >t</span>his.regexpState=null;}</span>;var prototypeAccessors=<span class="cstat-no" title="statement not covered" >{inFunction:{configurable:true},inGenerator:{configurable:true},inAsync:{configurable:true}};<span class="cstat-no" title="statement not covered" ></span>Parser.prototype.parse=function <span class="fstat-no" title="function not covered" >parse(</span>){var node=<span class="cstat-no" title="statement not covered" >this.options.program||this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.nextToken();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseTopLevel(node)}</span>;<span class="cstat-no" title="statement not covered" >p</span>rototypeAccessors.inFunction.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.currentVarScope().flags&amp;SCOPE_FUNCTION)&gt;0}</span>;<span class="cstat-no" title="statement not covered" >p</span>rototypeAccessors.inGenerator.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.currentVarScope().flags&amp;SCOPE_GENERATOR)&gt;0}</span>;<span class="cstat-no" title="statement not covered" >p</span>rototypeAccessors.inAsync.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.currentVarScope().flags&amp;SCOPE_ASYNC)&gt;0}</span>;<span class="cstat-no" title="statement not covered" >P</span>arser.extend=function <span class="fstat-no" title="function not covered" >extend(</span>){var plugins=<span class="cstat-no" title="statement not covered" >[],</span>len=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>while(len--)<span class="cstat-no" title="statement not covered" >plugins[len]=arguments[len];v</span></span>ar cls=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;plugins.length;i++){<span class="cstat-no" title="statement not covered" >cls=plugins[i](cls);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return cls}</span>;<span class="cstat-no" title="statement not covered" >Parser.parse=function <span class="fstat-no" title="function not covered" >parse(</span>input,options){<span class="cstat-no" title="statement not covered" >return new this(options,input).parse()}</span>;<span class="cstat-no" title="statement not covered" >P</span>arser.parseExpressionAt=function <span class="fstat-no" title="function not covered" >parseExpressionAt(</span>input,pos,options){var parser=<span class="cstat-no" title="statement not covered" >new this(options,input,pos);<span class="cstat-no" title="statement not covered" ></span>parser.nextToken();<span class="cstat-no" title="statement not covered" >r</span>eturn parser.parseExpression()}</span>;<span class="cstat-no" title="statement not covered" >P</span>arser.tokenizer=function <span class="fstat-no" title="function not covered" >tokenizer(</span>input,options){<span class="cstat-no" title="statement not covered" >return new this(options,input)}</span>;<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperties(Parser.prototype,prototypeAccessors);v</span>ar pp=<span class="cstat-no" title="statement not covered" >Parser.prototype;</span>var literal=<span class="cstat-no" title="statement not covered" >/^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;<span class="cstat-no" title="statement not covered" ></span>pp.strictDirective=<span class="fstat-no" title="function not covered" >fu</span>nction(start){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >skipWhiteSpace.lastIndex=start;<span class="cstat-no" title="statement not covered" >s</span>tart+=skipWhiteSpace.exec(this$1.input)[0].length;v</span>ar match=<span class="cstat-no" title="statement not covered" >literal.exec(this$1.input.slice(start));<span class="cstat-no" title="statement not covered" ></span>if(!match){<span class="cstat-no" title="statement not covered" >return false}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if((match[1]||match[2])==="use strict"){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >start+=match[0].length;}</span>};<span class="cstat-no" title="statement not covered" >pp.eat=<span class="fstat-no" title="function not covered" >fu</span>nction(type){<span class="cstat-no" title="statement not covered" >if(this.type===type){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>else{<span class="cstat-no" title="statement not covered" >return false}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p.isContextual=<span class="fstat-no" title="function not covered" >fu</span>nction(name){<span class="cstat-no" title="statement not covered" >return this.type===types.name&amp;&amp;this.value===name&amp;&amp;!this.containsEsc}</span>;<span class="cstat-no" title="statement not covered" >p</span>p.eatContextual=<span class="fstat-no" title="function not covered" >fu</span>nction(name){<span class="cstat-no" title="statement not covered" >if(!this.isContextual(name)){<span class="cstat-no" title="statement not covered" >return false}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>;<span class="cstat-no" title="statement not covered" >pp.expectContextual=<span class="fstat-no" title="function not covered" >fu</span>nction(name){<span class="cstat-no" title="statement not covered" >if(!this.eatContextual(name)){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p.canInsertSemicolon=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type===types.eof||this.type===types.braceR||lineBreak.test(this.input.slice(this.lastTokEnd,this.start))}</span>;<span class="cstat-no" title="statement not covered" >p</span>p.insertSemicolon=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >if(this.options.onInsertedSemicolon)</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc);}</span>
<span class="cstat-no" title="statement not covered" >return true}</span>};<span class="cstat-no" title="statement not covered" >pp.semicolon=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.eat(types.semi)&amp;&amp;!this.insertSemicolon()){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p.afterTrailingComma=<span class="fstat-no" title="function not covered" >fu</span>nction(tokType,notNext){<span class="cstat-no" title="statement not covered" >if(this.type===tokType){<span class="cstat-no" title="statement not covered" >if(this.options.onTrailingComma)</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc);}</span>
<span class="cstat-no" title="statement not covered" >if(!notNext)</span>
{<span class="cstat-no" title="statement not covered" >this.next();}</span>
<span class="cstat-no" title="statement not covered" >return true}</span>};<span class="cstat-no" title="statement not covered" >pp.expect=<span class="fstat-no" title="function not covered" >fu</span>nction(type){<span class="cstat-no" title="statement not covered" >this.eat(type)||this.unexpected();}</span>;<span class="cstat-no" title="statement not covered" >p</span>p.unexpected=<span class="fstat-no" title="function not covered" >fu</span>nction(pos){<span class="cstat-no" title="statement not covered" >this.raise(pos!=null?pos:this.start,"Unexpected token");}</span>;f</span>unction <span class="fstat-no" title="function not covered" >DestructuringErrors(</span>){<span class="cstat-no" title="statement not covered" >this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1;}</span>
<span class="cstat-no" title="statement not covered" >pp.checkPatternErrors=<span class="fstat-no" title="function not covered" >fu</span>nction(refDestructuringErrors,isAssign){<span class="cstat-no" title="statement not covered" >if(!refDestructuringErrors){<span class="cstat-no" title="statement not covered" >return}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.trailingComma&gt;-1)</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(refDestructuringErrors.trailingComma,"Comma is not permitted after the rest element");}</span>
var parens=<span class="cstat-no" title="statement not covered" >isAssign?refDestructuringErrors.parenthesizedAssign:refDestructuringErrors.parenthesizedBind;<span class="cstat-no" title="statement not covered" ></span>if(parens&gt;-1){<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(parens,"Parenthesized pattern");}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp.checkExpressionErrors=<span class="fstat-no" title="function not covered" >fu</span>nction(refDestructuringErrors,andThrow){<span class="cstat-no" title="statement not covered" >if(!refDestructuringErrors){<span class="cstat-no" title="statement not covered" >return false}</span></span></span>
var shorthandAssign=<span class="cstat-no" title="statement not covered" >refDestructuringErrors.shorthandAssign;</span>var doubleProto=<span class="cstat-no" title="statement not covered" >refDestructuringErrors.doubleProto;<span class="cstat-no" title="statement not covered" ></span>if(!andThrow){<span class="cstat-no" title="statement not covered" >return shorthandAssign&gt;=0||doubleProto&gt;=0}</span></span>
<span class="cstat-no" title="statement not covered" >if(shorthandAssign&gt;=0)</span>
{<span class="cstat-no" title="statement not covered" >this.raise(shorthandAssign,"Shorthand property assignments are valid only in destructuring patterns");}</span>
<span class="cstat-no" title="statement not covered" >if(doubleProto&gt;=0)</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(doubleProto,"Redefinition of __proto__ property");}</span>};<span class="cstat-no" title="statement not covered" >pp.checkYieldAwaitInDefaultParams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.yieldPos&amp;&amp;(!this.awaitPos||this.yieldPos&lt;this.awaitPos))</span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.yieldPos,"Yield expression cannot be a default value");}</span>
<span class="cstat-no" title="statement not covered" >if(this.awaitPos)</span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.awaitPos,"Await expression cannot be a default value");}</span>};<span class="cstat-no" title="statement not covered" >pp.isSimpleAssignTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(expr){<span class="cstat-no" title="statement not covered" >if(expr.type==="ParenthesizedExpression")</span></span>
{<span class="cstat-no" title="statement not covered" >return this.isSimpleAssignTarget(expr.expression)}</span>
<span class="cstat-no" title="statement not covered" >return expr.type==="Identifier"||expr.type==="MemberExpression"}</span>;var pp$1=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$1.parseTopLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(node){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var exports=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(!node.body){<span class="cstat-no" title="statement not covered" >node.body=[];}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(this.type!==types.eof){var stmt=<span class="cstat-no" title="statement not covered" >this$1.parseStatement(null,true,exports);<span class="cstat-no" title="statement not covered" ></span>node.body.push(stmt);}</span></span>
<span class="cstat-no" title="statement not covered" >this.adaptDirectivePrologue(node.body);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.sourceType=this.options.sourceType;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"Program")}</span>;var loopLabel=<span class="cstat-no" title="statement not covered" >{kind:"loop"};</span>var switchLabel=<span class="cstat-no" title="statement not covered" >{kind:"switch"};<span class="cstat-no" title="statement not covered" ></span>pp$1.isLet=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6||!this.isContextual("let")){<span class="cstat-no" title="statement not covered" >return false}</span></span></span>
<span class="cstat-no" title="statement not covered" >skipWhiteSpace.lastIndex=this.pos;v</span>ar skip=<span class="cstat-no" title="statement not covered" >skipWhiteSpace.exec(this.input);</span>var next=<span class="cstat-no" title="statement not covered" >this.pos+skip[0].length,</span>nextCh=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(next);<span class="cstat-no" title="statement not covered" ></span>if(nextCh===91||nextCh===123){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(isIdentifierStart(nextCh,true)){var pos=<span class="cstat-no" title="statement not covered" >next+1;<span class="cstat-no" title="statement not covered" ></span>while(isIdentifierChar(this.input.charCodeAt(pos),true)){<span class="cstat-no" title="statement not covered" >++pos;}</span></span></span>
var ident=<span class="cstat-no" title="statement not covered" >this.input.slice(next,pos);<span class="cstat-no" title="statement not covered" ></span>if(!keywordRelationalOperator.test(ident)){<span class="cstat-no" title="statement not covered" >return true}</span>}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$1.isAsyncFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;8||!this.isContextual("async"))</span></span>
{<span class="cstat-no" title="statement not covered" >return false}</span>
<span class="cstat-no" title="statement not covered" >skipWhiteSpace.lastIndex=this.pos;v</span>ar skip=<span class="cstat-no" title="statement not covered" >skipWhiteSpace.exec(this.input);</span>var next=<span class="cstat-no" title="statement not covered" >this.pos+skip[0].length;<span class="cstat-no" title="statement not covered" ></span>return!lineBreak.test(this.input.slice(this.pos,next))&amp;&amp;this.input.slice(next,next+8)==="function"&amp;&amp;(next+8===this.input.length||!isIdentifierChar(this.input.charAt(next+8)))}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(context,topLevel,exports){var starttype=<span class="cstat-no" title="statement not covered" >this.type,</span>node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>kind;<span class="cstat-no" title="statement not covered" >if(this.isLet()){<span class="cstat-no" title="statement not covered" >starttype=types._var;<span class="cstat-no" title="statement not covered" >k</span>ind="let";}</span></span></span>
<span class="cstat-no" title="statement not covered" >switch(starttype){case types._break:case types._continue:<span class="cstat-no" title="statement not covered" >return this.parseBreakContinueStatement(node,starttype.keyword)</span></span>
case types._debugger:<span class="cstat-no" title="statement not covered" >return this.parseDebuggerStatement(node)</span>
case types._do:<span class="cstat-no" title="statement not covered" >return this.parseDoStatement(node)</span>
case types._for:<span class="cstat-no" title="statement not covered" >return this.parseForStatement(node)</span>
case types._function:<span class="cstat-no" title="statement not covered" >if((context&amp;&amp;(this.strict||context!=="if"))&amp;&amp;this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.parseFunctionStatement(node,false,!context)</span>
case types._class:<span class="cstat-no" title="statement not covered" >if(context){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.parseClass(node,true)</span>
case types._if:<span class="cstat-no" title="statement not covered" >return this.parseIfStatement(node)</span>
case types._return:<span class="cstat-no" title="statement not covered" >return this.parseReturnStatement(node)</span>
case types._switch:<span class="cstat-no" title="statement not covered" >return this.parseSwitchStatement(node)</span>
case types._throw:<span class="cstat-no" title="statement not covered" >return this.parseThrowStatement(node)</span>
case types._try:<span class="cstat-no" title="statement not covered" >return this.parseTryStatement(node)</span>
case types._const:case types._var:<span class="cstat-no" title="statement not covered" >kind=kind||this.value;<span class="cstat-no" title="statement not covered" >i</span>f(context&amp;&amp;kind!=="var"){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.parseVarStatement(node,kind)</span>
case types._while:<span class="cstat-no" title="statement not covered" >return this.parseWhileStatement(node)</span>
case types._with:<span class="cstat-no" title="statement not covered" >return this.parseWithStatement(node)</span>
case types.braceL:<span class="cstat-no" title="statement not covered" >return this.parseBlock(true,node)</span>
case types.semi:<span class="cstat-no" title="statement not covered" >return this.parseEmptyStatement(node)</span>
case types._export:case types._import:<span class="cstat-no" title="statement not covered" >if(!this.options.allowImportExportEverywhere){<span class="cstat-no" title="statement not covered" >if(!topLevel)</span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'import' and 'export' may only appear at the top level");}</span>
<span class="cstat-no" title="statement not covered" >if(!this.inModule)</span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'");}</span>}
<span class="cstat-no" title="statement not covered" >return starttype===types._import?this.parseImport(node):this.parseExport(node,exports)</span>
default:<span class="cstat-no" title="statement not covered" >if(this.isAsyncFunction()){<span class="cstat-no" title="statement not covered" >if(context){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunctionStatement(node,true,!context)}</span>
var maybeName=<span class="cstat-no" title="statement not covered" >this.value,</span>expr=<span class="cstat-no" title="statement not covered" >this.parseExpression();<span class="cstat-no" title="statement not covered" ></span>if(starttype===types.name&amp;&amp;expr.type==="Identifier"&amp;&amp;this.eat(types.colon))</span>
{<span class="cstat-no" title="statement not covered" >return this.parseLabeledStatement(node,maybeName,expr,context)}</span>
else{<span class="cstat-no" title="statement not covered" >return this.parseExpressionStatement(node,expr)}</span>}};<span class="cstat-no" title="statement not covered" >pp$1.parseBreakContinueStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node,keyword){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var isBreak=<span class="cstat-no" title="statement not covered" >keyword==="break";<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(types.semi)||this.insertSemicolon()){<span class="cstat-no" title="statement not covered" >node.label=null;}</span></span></span>
else <span class="cstat-no" title="statement not covered" >if(this.type!==types.name){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span>
else{<span class="cstat-no" title="statement not covered" >node.label=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span>
var i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;this.labels.length;++i){var lab=<span class="cstat-no" title="statement not covered" >this$1.labels[i];<span class="cstat-no" title="statement not covered" ></span>if(node.label==null||lab.name===node.label.name){<span class="cstat-no" title="statement not covered" >if(lab.kind!=null&amp;&amp;(isBreak||lab.kind==="loop")){<span class="cstat-no" title="statement not covered" >break}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(node.label&amp;&amp;isBreak){<span class="cstat-no" title="statement not covered" >break}</span>}</span>}
<span class="cstat-no" title="statement not covered" >if(i===this.labels.length){<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Unsyntactic "+keyword);}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseDebuggerStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"DebuggerStatement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseDoStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(loopLabel);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement("do");<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >t</span>his.expect(types._while);<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)</span></span>
{<span class="cstat-no" title="statement not covered" >this.eat(types.semi);}</span>
else
{<span class="cstat-no" title="statement not covered" >this.semicolon();}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"DoWhileStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseForStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();v</span>ar awaitAt=<span class="cstat-no" title="statement not covered" >(this.options.ecmaVersion&gt;=9&amp;&amp;(this.inAsync||(!this.inFunction&amp;&amp;this.options.allowAwaitOutsideFunction))&amp;&amp;this.eatContextual("await"))?this.lastTokStart:-1;<span class="cstat-no" title="statement not covered" ></span>this.labels.push(loopLabel);<span class="cstat-no" title="statement not covered" >t</span>his.enterScope(0);<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.parenL);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===types.semi){<span class="cstat-no" title="statement not covered" >if(awaitAt&gt;-1){<span class="cstat-no" title="statement not covered" >this.unexpected(awaitAt);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.parseFor(node,null)}</span>
var isLet=<span class="cstat-no" title="statement not covered" >this.isLet();<span class="cstat-no" title="statement not covered" ></span>if(this.type===types._var||this.type===types._const||isLet){var init$1=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>kind=<span class="cstat-no" title="statement not covered" >isLet?"let":this.value;<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.parseVar(init$1,true,kind);<span class="cstat-no" title="statement not covered" >t</span>his.finishNode(init$1,"VariableDeclaration");<span class="cstat-no" title="statement not covered" >i</span>f((this.type===types._in||(this.options.ecmaVersion&gt;=6&amp;&amp;this.isContextual("of")))&amp;&amp;init$1.declarations.length===1&amp;&amp;!(kind!=="var"&amp;&amp;init$1.declarations[0].init)){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9){<span class="cstat-no" title="statement not covered" >if(this.type===types._in){<span class="cstat-no" title="statement not covered" >if(awaitAt&gt;-1){<span class="cstat-no" title="statement not covered" >this.unexpected(awaitAt);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >node.await=awaitAt&gt;-1;}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.parseForIn(node,init$1)}</span>
<span class="cstat-no" title="statement not covered" >if(awaitAt&gt;-1){<span class="cstat-no" title="statement not covered" >this.unexpected(awaitAt);}</span></span>
<span class="cstat-no" title="statement not covered" >return this.parseFor(node,init$1)}</span>
var refDestructuringErrors=<span class="cstat-no" title="statement not covered" >new DestructuringErrors;</span>var init=<span class="cstat-no" title="statement not covered" >this.parseExpression(true,refDestructuringErrors);<span class="cstat-no" title="statement not covered" ></span>if(this.type===types._in||(this.options.ecmaVersion&gt;=6&amp;&amp;this.isContextual("of"))){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9){<span class="cstat-no" title="statement not covered" >if(this.type===types._in){<span class="cstat-no" title="statement not covered" >if(awaitAt&gt;-1){<span class="cstat-no" title="statement not covered" >this.unexpected(awaitAt);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >node.await=awaitAt&gt;-1;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.toAssignable(init,false,refDestructuringErrors);<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(init);<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseForIn(node,init)}</span>else{<span class="cstat-no" title="statement not covered" >this.checkExpressionErrors(refDestructuringErrors,true);}</span>
<span class="cstat-no" title="statement not covered" >if(awaitAt&gt;-1){<span class="cstat-no" title="statement not covered" >this.unexpected(awaitAt);}</span></span>
<span class="cstat-no" title="statement not covered" >return this.parseFor(node,init)}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseFunctionStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isAsync,declarationPosition){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,FUNC_STATEMENT|(declarationPosition?0:FUNC_HANGING_STATEMENT),false,isAsync)}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseIfStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.consequent=this.parseStatement("if");<span class="cstat-no" title="statement not covered" >n</span>ode.alternate=this.eat(types._else)?this.parseStatement("if"):null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"IfStatement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseReturnStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >if(!this.inFunction&amp;&amp;!this.options.allowReturnOutsideFunction)</span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'return' outside of function");}</span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(types.semi)||this.insertSemicolon()){<span class="cstat-no" title="statement not covered" >node.argument=null;}</span></span>
else{<span class="cstat-no" title="statement not covered" >node.argument=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ReturnStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseSwitchStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.discriminant=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.cases=[];<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.braceL);<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(switchLabel);<span class="cstat-no" title="statement not covered" >t</span>his.enterScope(0);v</span>ar cur;<span class="cstat-no" title="statement not covered" >for(var sawDefault=false;this.type!==types.braceR;){<span class="cstat-no" title="statement not covered" >if(this$1.type===types._case||this$1.type===types._default){var isCase=<span class="cstat-no" title="statement not covered" >this$1.type===types._case;<span class="cstat-no" title="statement not covered" ></span>if(cur){<span class="cstat-no" title="statement not covered" >this$1.finishNode(cur,"SwitchCase");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.cases.push(cur=this$1.startNode());<span class="cstat-no" title="statement not covered" >c</span>ur.consequent=[];<span class="cstat-no" title="statement not covered" >t</span>his$1.next();<span class="cstat-no" title="statement not covered" >i</span>f(isCase){<span class="cstat-no" title="statement not covered" >cur.test=this$1.parseExpression();}</span>else{<span class="cstat-no" title="statement not covered" >if(sawDefault){<span class="cstat-no" title="statement not covered" >this$1.raiseRecoverable(this$1.lastTokStart,"Multiple default clauses");}</span></span></span>
<span class="cstat-no" title="statement not covered" >sawDefault=true;<span class="cstat-no" title="statement not covered" >c</span>ur.test=null;}</span>
<span class="cstat-no" title="statement not covered" >this$1.expect(types.colon);}</span>else{<span class="cstat-no" title="statement not covered" >if(!cur){<span class="cstat-no" title="statement not covered" >this$1.unexpected();}</span></span>
<span class="cstat-no" title="statement not covered" >cur.consequent.push(this$1.parseStatement(null));}</span>}
<span class="cstat-no" title="statement not covered" >this.exitScope();<span class="cstat-no" title="statement not covered" >i</span>f(cur){<span class="cstat-no" title="statement not covered" >this.finishNode(cur,"SwitchCase");}</span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"SwitchStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseThrowStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(lineBreak.test(this.input.slice(this.lastTokEnd,this.start)))</span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.lastTokEnd,"Illegal newline after throw");}</span>
<span class="cstat-no" title="statement not covered" >node.argument=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ThrowStatement")}</span>;var empty=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>pp$1.parseTryStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.block=this.parseBlock();<span class="cstat-no" title="statement not covered" >n</span>ode.handler=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.type===types._catch){var clause=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(types.parenL)){<span class="cstat-no" title="statement not covered" >clause.param=this.parseBindingAtom();v</span>ar simple=<span class="cstat-no" title="statement not covered" >clause.param.type==="Identifier";<span class="cstat-no" title="statement not covered" ></span>this.enterScope(simple?SCOPE_SIMPLE_CATCH:0);<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(clause.param,simple?BIND_SIMPLE_CATCH:BIND_LEXICAL);<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.parenR);}</span>else{<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;10){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >clause.param=null;<span class="cstat-no" title="statement not covered" >t</span>his.enterScope(0);}</span>
<span class="cstat-no" title="statement not covered" >clause.body=this.parseBlock(false);<span class="cstat-no" title="statement not covered" >t</span>his.exitScope();<span class="cstat-no" title="statement not covered" >n</span>ode.handler=this.finishNode(clause,"CatchClause");}</span>
<span class="cstat-no" title="statement not covered" >node.finalizer=this.eat(types._finally)?this.parseBlock():null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.handler&amp;&amp;!node.finalizer)</span>
{<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Missing catch or finally clause");}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"TryStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseVarStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node,kind){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.parseVar(node,false,kind);<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"VariableDeclaration")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseWhileStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >t</span>his.labels.push(loopLabel);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement("while");<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"WhileStatement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseWithStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >if(this.strict){<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'with' in strict mode");}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.object=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement("with");<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"WithStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseEmptyStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"EmptyStatement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseLabeledStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node,maybeName,expr,context){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i$1=0,list=this$1.labels;i$1&lt;list.length;i$1+=1)</span></span>
{var label=<span class="cstat-no" title="statement not covered" >list[i$1];<span class="cstat-no" title="statement not covered" ></span>if(label.name===maybeName)</span>
{<span class="cstat-no" title="statement not covered" >this$1.raise(expr.start,"Label '"+maybeName+"' is already declared");}</span>}
var kind=<span class="cstat-no" title="statement not covered" >this.type.isLoop?"loop":this.type===types._switch?"switch":null;<span class="cstat-no" title="statement not covered" ></span>for(var i=this.labels.length-1;i&gt;=0;i--){var label$1=<span class="cstat-no" title="statement not covered" >this$1.labels[i];<span class="cstat-no" title="statement not covered" ></span>if(label$1.statementStart===node.start){<span class="cstat-no" title="statement not covered" >label$1.statementStart=this$1.start;<span class="cstat-no" title="statement not covered" >l</span>abel$1.kind=kind;}</span>else{<span class="cstat-no" title="statement not covered" >break}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this.labels.push({name:maybeName,kind:kind,statementStart:this.start});<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement(context);<span class="cstat-no" title="statement not covered" >i</span>f(node.body.type==="ClassDeclaration"||node.body.type==="VariableDeclaration"&amp;&amp;node.body.kind!=="var"||node.body.type==="FunctionDeclaration"&amp;&amp;(this.strict||node.body.generator||node.body.async))</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(node.body.start,"Invalid labeled declaration");}</span>
<span class="cstat-no" title="statement not covered" >this.labels.pop();<span class="cstat-no" title="statement not covered" >n</span>ode.label=expr;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"LabeledStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseExpressionStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(node,expr){<span class="cstat-no" title="statement not covered" >node.expression=expr;<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ExpressionStatement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(createNewLexicalScope,node){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(createNewLexicalScope===void 0)<span class="cstat-no" title="statement not covered" >createNewLexicalScope=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(node===void 0)<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span></span>ode.body=[];<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.braceL);<span class="cstat-no" title="statement not covered" >i</span>f(createNewLexicalScope){<span class="cstat-no" title="statement not covered" >this.enterScope(0);}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(!this.eat(types.braceR)){var stmt=<span class="cstat-no" title="statement not covered" >this$1.parseStatement(null);<span class="cstat-no" title="statement not covered" ></span>node.body.push(stmt);}</span></span>
<span class="cstat-no" title="statement not covered" >if(createNewLexicalScope){<span class="cstat-no" title="statement not covered" >this.exitScope();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"BlockStatement")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseFor=<span class="fstat-no" title="function not covered" >fu</span>nction(node,init){<span class="cstat-no" title="statement not covered" >node.init=init;<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.semi);<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.type===types.semi?null:this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.semi);<span class="cstat-no" title="statement not covered" >n</span>ode.update=this.type===types.parenR?null:this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.parenR);<span class="cstat-no" title="statement not covered" >t</span>his.exitScope();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement("for");<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ForStatement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseForIn=<span class="fstat-no" title="function not covered" >fu</span>nction(node,init){var type=<span class="cstat-no" title="statement not covered" >this.type===types._in?"ForInStatement":"ForOfStatement";<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(type==="ForInStatement"){<span class="cstat-no" title="statement not covered" >if(init.type==="AssignmentPattern"||(init.type==="VariableDeclaration"&amp;&amp;init.declarations[0].init!=null&amp;&amp;(this.strict||init.declarations[0].id.type!=="Identifier")))</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(init.start,"Invalid assignment in for-in loop head");}</span>}
<span class="cstat-no" title="statement not covered" >node.left=init;<span class="cstat-no" title="statement not covered" >n</span>ode.right=type==="ForInStatement"?this.parseExpression():this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.parenR);<span class="cstat-no" title="statement not covered" >t</span>his.exitScope();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement("for");<span class="cstat-no" title="statement not covered" >t</span>his.labels.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,type)}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseVar=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isFor,kind){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>node.declarations=[];<span class="cstat-no" title="statement not covered" >n</span>ode.kind=kind;<span class="cstat-no" title="statement not covered" >f</span>or(;;){var decl=<span class="cstat-no" title="statement not covered" >this$1.startNode();<span class="cstat-no" title="statement not covered" ></span>this$1.parseVarId(decl,kind);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.eat(types.eq)){<span class="cstat-no" title="statement not covered" >decl.init=this$1.parseMaybeAssign(isFor);}</span>else <span class="cstat-no" title="statement not covered" >if(kind==="const"&amp;&amp;!(this$1.type===types._in||(this$1.options.ecmaVersion&gt;=6&amp;&amp;this$1.isContextual("of")))){<span class="cstat-no" title="statement not covered" >this$1.unexpected();}</span>else <span class="cstat-no" title="statement not covered" >if(decl.id.type!=="Identifier"&amp;&amp;!(isFor&amp;&amp;(this$1.type===types._in||this$1.isContextual("of")))){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.lastTokEnd,"Complex binding patterns require an initialization value");}</span>else{<span class="cstat-no" title="statement not covered" >decl.init=null;}</span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.declarations.push(this$1.finishNode(decl,"VariableDeclarator"));<span class="cstat-no" title="statement not covered" >i</span>f(!this$1.eat(types.comma)){<span class="cstat-no" title="statement not covered" >break}</span>}</span>
<span class="cstat-no" title="statement not covered" >return node}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseVarId=<span class="fstat-no" title="function not covered" >fu</span>nction(decl,kind){<span class="cstat-no" title="statement not covered" >decl.id=this.parseBindingAtom(kind);<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(decl.id,kind==="var"?BIND_VAR:BIND_LEXICAL,false);}</span>;v</span>ar FUNC_STATEMENT=<span class="cstat-no" title="statement not covered" >1;</span>var FUNC_HANGING_STATEMENT=<span class="cstat-no" title="statement not covered" >2;</span>var FUNC_NULLABLE_ID=<span class="cstat-no" title="statement not covered" >4;<span class="cstat-no" title="statement not covered" ></span>pp$1.parseFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(node,statement,allowExpressionBody,isAsync){<span class="cstat-no" title="statement not covered" >this.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=9||this.options.ecmaVersion&gt;=6&amp;&amp;!isAsync)</span></span>
{<span class="cstat-no" title="statement not covered" >node.generator=this.eat(types.star);}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8)</span>
{<span class="cstat-no" title="statement not covered" >node.async=!!isAsync;}</span>
<span class="cstat-no" title="statement not covered" >if(statement&amp;FUNC_STATEMENT){<span class="cstat-no" title="statement not covered" >node.id=(statement&amp;FUNC_NULLABLE_ID)&amp;&amp;this.type!==types.name?null:this.parseIdent();<span class="cstat-no" title="statement not covered" >i</span>f(node.id&amp;&amp;!(statement&amp;FUNC_HANGING_STATEMENT))</span></span>
{<span class="cstat-no" title="statement not covered" >this.checkLVal(node.id,this.inModule&amp;&amp;!this.inFunction?BIND_LEXICAL:BIND_FUNCTION);}</span>}
var oldYieldPos=<span class="cstat-no" title="statement not covered" >this.yieldPos,</span>oldAwaitPos=<span class="cstat-no" title="statement not covered" >this.awaitPos;<span class="cstat-no" title="statement not covered" ></span>this.yieldPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.enterScope(functionFlags(node.async,node.generator));<span class="cstat-no" title="statement not covered" >i</span>f(!(statement&amp;FUNC_STATEMENT))</span>
{<span class="cstat-no" title="statement not covered" >node.id=this.type===types.name?this.parseIdent():null;}</span>
<span class="cstat-no" title="statement not covered" >this.parseFunctionParams(node);<span class="cstat-no" title="statement not covered" >t</span>his.parseFunctionBody(node,allowExpressionBody);<span class="cstat-no" title="statement not covered" >t</span>his.yieldPos=oldYieldPos;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=oldAwaitPos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,(statement&amp;FUNC_STATEMENT)?"FunctionDeclaration":"FunctionExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseFunctionParams=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.expect(types.parenL);<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.parseBindingList(types.parenR,false,this.options.ecmaVersion&gt;=8);<span class="cstat-no" title="statement not covered" >t</span>his.checkYieldAwaitInDefaultParams();}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseClass=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isStatement){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.parseClassId(node,isStatement);<span class="cstat-no" title="statement not covered" >t</span>his.parseClassSuper(node);v</span>ar classBody=<span class="cstat-no" title="statement not covered" >this.startNode();</span>var hadConstructor=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>classBody.body=[];<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(types.braceR)){var element=<span class="cstat-no" title="statement not covered" >this$1.parseClassElement();<span class="cstat-no" title="statement not covered" ></span>if(element){<span class="cstat-no" title="statement not covered" >classBody.body.push(element);<span class="cstat-no" title="statement not covered" >i</span>f(element.type==="MethodDefinition"&amp;&amp;element.kind==="constructor"){<span class="cstat-no" title="statement not covered" >if(hadConstructor){<span class="cstat-no" title="statement not covered" >this$1.raise(element.start,"Duplicate constructor in the same class");}</span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >hadConstructor=true;}</span>}}
<span class="cstat-no" title="statement not covered" >node.body=this.finishNode(classBody,"ClassBody");<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseClassElement=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.eat(types.semi)){<span class="cstat-no" title="statement not covered" >return null}</span></span></span>
var method=<span class="cstat-no" title="statement not covered" >this.startNode();</span>var tryContextual=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(k,noLineBreak){<span class="cstat-no" title="statement not covered" >if(noLineBreak===void 0)<span class="cstat-no" title="statement not covered" >noLineBreak=false;v</span></span>ar start=<span class="cstat-no" title="statement not covered" >this$1.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this$1.startLoc;<span class="cstat-no" title="statement not covered" ></span>if(!this$1.eatContextual(k)){<span class="cstat-no" title="statement not covered" >return false}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this$1.type!==types.parenL&amp;&amp;(!noLineBreak||!this$1.canInsertSemicolon())){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(method.key){<span class="cstat-no" title="statement not covered" >this$1.unexpected();}</span></span>
<span class="cstat-no" title="statement not covered" >method.computed=false;<span class="cstat-no" title="statement not covered" >m</span>ethod.key=this$1.startNodeAt(start,startLoc);<span class="cstat-no" title="statement not covered" >m</span>ethod.key.name=k;<span class="cstat-no" title="statement not covered" >t</span>his$1.finishNode(method.key,"Identifier");<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>;<span class="cstat-no" title="statement not covered" >method.kind="method";<span class="cstat-no" title="statement not covered" >m</span>ethod.static=tryContextual("static");v</span>ar isGenerator=<span class="cstat-no" title="statement not covered" >this.eat(types.star);</span>var isAsync=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(!isGenerator){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8&amp;&amp;tryContextual("async",true)){<span class="cstat-no" title="statement not covered" >isAsync=true;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this.options.ecmaVersion&gt;=9&amp;&amp;this.eat(types.star);}</span>else <span class="cstat-no" title="statement not covered" >if(tryContextual("get")){<span class="cstat-no" title="statement not covered" >method.kind="get";}</span>else <span class="cstat-no" title="statement not covered" >if(tryContextual("set")){<span class="cstat-no" title="statement not covered" >method.kind="set";}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(!method.key){<span class="cstat-no" title="statement not covered" >this.parsePropertyName(method);}</span></span>
var key=<span class="cstat-no" title="statement not covered" >method.key;<span class="cstat-no" title="statement not covered" ></span>if(!method.computed&amp;&amp;!method.static&amp;&amp;(key.type==="Identifier"&amp;&amp;key.name==="constructor"||key.type==="Literal"&amp;&amp;key.value==="constructor")){<span class="cstat-no" title="statement not covered" >if(method.kind!=="method"){<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Constructor can't have get/set modifier");}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(isGenerator){<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Constructor can't be a generator");}</span></span>
<span class="cstat-no" title="statement not covered" >if(isAsync){<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Constructor can't be an async method");}</span></span>
<span class="cstat-no" title="statement not covered" >method.kind="constructor";}</span>else <span class="cstat-no" title="statement not covered" >if(method.static&amp;&amp;key.type==="Identifier"&amp;&amp;key.name==="prototype"){<span class="cstat-no" title="statement not covered" >this.raise(key.start,"Classes may not have a static property named prototype");}</span></span>
<span class="cstat-no" title="statement not covered" >this.parseClassMethod(method,isGenerator,isAsync);<span class="cstat-no" title="statement not covered" >i</span>f(method.kind==="get"&amp;&amp;method.value.params.length!==0)</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(method.value.start,"getter should have no params");}</span>
<span class="cstat-no" title="statement not covered" >if(method.kind==="set"&amp;&amp;method.value.params.length!==1)</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(method.value.start,"setter should have exactly one param");}</span>
<span class="cstat-no" title="statement not covered" >if(method.kind==="set"&amp;&amp;method.value.params[0].type==="RestElement")</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(method.value.params[0].start,"Setter cannot use rest params");}</span>
<span class="cstat-no" title="statement not covered" >return method}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseClassMethod=<span class="fstat-no" title="function not covered" >fu</span>nction(method,isGenerator,isAsync){<span class="cstat-no" title="statement not covered" >method.value=this.parseMethod(isGenerator,isAsync);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(method,"MethodDefinition")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseClassId=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isStatement){<span class="cstat-no" title="statement not covered" >node.id=this.type===types.name?this.parseIdent():isStatement===true?this.unexpected():null;}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseClassSuper=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >node.superClass=this.eat(types._extends)?this.parseExprSubscripts():null;}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseExport=<span class="fstat-no" title="function not covered" >fu</span>nction(node,exports){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(types.star)){<span class="cstat-no" title="statement not covered" >this.expectContextual("from");<span class="cstat-no" title="statement not covered" >i</span>f(this.type!==types.string){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.source=this.parseExprAtom();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ExportAllDeclaration")}</span>
<span class="cstat-no" title="statement not covered" >if(this.eat(types._default)){<span class="cstat-no" title="statement not covered" >this.checkExport(exports,"default",this.lastTokStart);v</span>ar isAsync;<span class="cstat-no" title="statement not covered" >if(this.type===types._function||(isAsync=this.isAsyncFunction())){var fNode=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(isAsync){<span class="cstat-no" title="statement not covered" >this.next();}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.declaration=this.parseFunction(fNode,FUNC_STATEMENT|FUNC_NULLABLE_ID,false,isAsync,true);}</span>else <span class="cstat-no" title="statement not covered" >if(this.type===types._class){var cNode=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>node.declaration=this.parseClass(cNode,"nullableID");}</span>else{<span class="cstat-no" title="statement not covered" >node.declaration=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ExportDefaultDeclaration")}</span>
<span class="cstat-no" title="statement not covered" >if(this.shouldParseExportStatement()){<span class="cstat-no" title="statement not covered" >node.declaration=this.parseStatement(null);<span class="cstat-no" title="statement not covered" >i</span>f(node.declaration.type==="VariableDeclaration")</span></span>
{<span class="cstat-no" title="statement not covered" >this.checkVariableExport(exports,node.declaration.declarations);}</span>
else
{<span class="cstat-no" title="statement not covered" >this.checkExport(exports,node.declaration.id.name,node.declaration.id.start);}</span>
<span class="cstat-no" title="statement not covered" >node.specifiers=[];<span class="cstat-no" title="statement not covered" >n</span>ode.source=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.declaration=null;<span class="cstat-no" title="statement not covered" >n</span>ode.specifiers=this.parseExportSpecifiers(exports);<span class="cstat-no" title="statement not covered" >i</span>f(this.eatContextual("from")){<span class="cstat-no" title="statement not covered" >if(this.type!==types.string){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span>
<span class="cstat-no" title="statement not covered" >node.source=this.parseExprAtom();}</span>else{<span class="cstat-no" title="statement not covered" >for(var i=0,list=node.specifiers;i&lt;list.length;i+=1){var spec=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.checkUnreserved(spec.local);}</span></span>
<span class="cstat-no" title="statement not covered" >node.source=null;}</span>
<span class="cstat-no" title="statement not covered" >this.semicolon();}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ExportNamedDeclaration")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.checkExport=<span class="fstat-no" title="function not covered" >fu</span>nction(exports,name,pos){<span class="cstat-no" title="statement not covered" >if(!exports){<span class="cstat-no" title="statement not covered" >return}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(has(exports,name))</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(pos,"Duplicate export '"+name+"'");}</span>
<span class="cstat-no" title="statement not covered" >exports[name]=true;}</span>;<span class="cstat-no" title="statement not covered" >pp$1.checkPatternExport=<span class="fstat-no" title="function not covered" >fu</span>nction(exports,pat){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var type=<span class="cstat-no" title="statement not covered" >pat.type;<span class="cstat-no" title="statement not covered" ></span>if(type==="Identifier")</span></span>
{<span class="cstat-no" title="statement not covered" >this.checkExport(exports,pat.name,pat.start);}</span>
else <span class="cstat-no" title="statement not covered" >if(type==="ObjectPattern")</span>
{<span class="cstat-no" title="statement not covered" >for(var i=0,list=pat.properties;i&lt;list.length;i+=1)</span>
{var prop=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.checkPatternExport(exports,prop);}</span>}
else <span class="cstat-no" title="statement not covered" >if(type==="ArrayPattern")</span>
{<span class="cstat-no" title="statement not covered" >for(var i$1=0,list$1=pat.elements;i$1&lt;list$1.length;i$1+=1){var elt=<span class="cstat-no" title="statement not covered" >list$1[i$1];<span class="cstat-no" title="statement not covered" ></span>if(elt){<span class="cstat-no" title="statement not covered" >this$1.checkPatternExport(exports,elt);}</span>}</span>}</span>
else <span class="cstat-no" title="statement not covered" >if(type==="Property")</span>
{<span class="cstat-no" title="statement not covered" >this.checkPatternExport(exports,pat.value);}</span>
else <span class="cstat-no" title="statement not covered" >if(type==="AssignmentPattern")</span>
{<span class="cstat-no" title="statement not covered" >this.checkPatternExport(exports,pat.left);}</span>
else <span class="cstat-no" title="statement not covered" >if(type==="RestElement")</span>
{<span class="cstat-no" title="statement not covered" >this.checkPatternExport(exports,pat.argument);}</span>
else <span class="cstat-no" title="statement not covered" >if(type==="ParenthesizedExpression")</span>
{<span class="cstat-no" title="statement not covered" >this.checkPatternExport(exports,pat.expression);}</span>};<span class="cstat-no" title="statement not covered" >pp$1.checkVariableExport=<span class="fstat-no" title="function not covered" >fu</span>nction(exports,decls){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!exports){<span class="cstat-no" title="statement not covered" >return}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(var i=0,list=decls;i&lt;list.length;i+=1)</span>
{var decl=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.checkPatternExport(exports,decl.id);}</span>};<span class="cstat-no" title="statement not covered" >pp$1.shouldParseExportStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.parseExportSpecifiers=<span class="fstat-no" title="function not covered" >fu</span>nction(exports){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var nodes=<span class="cstat-no" title="statement not covered" >[],</span>first=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>this.expect(types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(types.braceR)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this$1.expect(types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.afterTrailingComma(types.braceR)){<span class="cstat-no" title="statement not covered" >break}</span>}</span>else{<span class="cstat-no" title="statement not covered" >first=false;}</span></span></span></span>
var node=<span class="cstat-no" title="statement not covered" >this$1.startNode();<span class="cstat-no" title="statement not covered" ></span>node.local=this$1.parseIdent(true);<span class="cstat-no" title="statement not covered" >n</span>ode.exported=this$1.eatContextual("as")?this$1.parseIdent(true):node.local;<span class="cstat-no" title="statement not covered" >t</span>his$1.checkExport(exports,node.exported.name,node.exported.start);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this$1.finishNode(node,"ExportSpecifier"));}</span>
<span class="cstat-no" title="statement not covered" >return nodes}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseImport=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.type===types.string){<span class="cstat-no" title="statement not covered" >node.specifiers=empty;<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.parseExprAtom();}</span>else{<span class="cstat-no" title="statement not covered" >node.specifiers=this.parseImportSpecifiers();<span class="cstat-no" title="statement not covered" >t</span>his.expectContextual("from");<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.type===types.string?this.parseExprAtom():this.unexpected();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ImportDeclaration")}</span>;<span class="cstat-no" title="statement not covered" >pp$1.parseImportSpecifiers=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var nodes=<span class="cstat-no" title="statement not covered" >[],</span>first=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>if(this.type===types.name){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>node.local=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(node.local,BIND_LEXICAL);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this.finishNode(node,"ImportDefaultSpecifier"));<span class="cstat-no" title="statement not covered" >i</span>f(!this.eat(types.comma)){<span class="cstat-no" title="statement not covered" >return nodes}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.type===types.star){var node$1=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >t</span>his.expectContextual("as");<span class="cstat-no" title="statement not covered" >n</span>ode$1.local=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(node$1.local,BIND_LEXICAL);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this.finishNode(node$1,"ImportNamespaceSpecifier"));<span class="cstat-no" title="statement not covered" >r</span>eturn nodes}</span></span>
<span class="cstat-no" title="statement not covered" >this.expect(types.braceL);<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(types.braceR)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this$1.expect(types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.afterTrailingComma(types.braceR)){<span class="cstat-no" title="statement not covered" >break}</span>}</span>else{<span class="cstat-no" title="statement not covered" >first=false;}</span></span></span>
var node$2=<span class="cstat-no" title="statement not covered" >this$1.startNode();<span class="cstat-no" title="statement not covered" ></span>node$2.imported=this$1.parseIdent(true);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.eatContextual("as")){<span class="cstat-no" title="statement not covered" >node$2.local=this$1.parseIdent();}</span>else{<span class="cstat-no" title="statement not covered" >this$1.checkUnreserved(node$2.imported);<span class="cstat-no" title="statement not covered" >n</span>ode$2.local=node$2.imported;}</span></span>
<span class="cstat-no" title="statement not covered" >this$1.checkLVal(node$2.local,BIND_LEXICAL);<span class="cstat-no" title="statement not covered" >n</span>odes.push(this$1.finishNode(node$2,"ImportSpecifier"));}</span>
<span class="cstat-no" title="statement not covered" >return nodes}</span>;<span class="cstat-no" title="statement not covered" >pp$1.adaptDirectivePrologue=<span class="fstat-no" title="function not covered" >fu</span>nction(statements){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;statements.length&amp;&amp;this.isDirectiveCandidate(statements[i]);++i){<span class="cstat-no" title="statement not covered" >statements[i].directive=statements[i].expression.raw.slice(1,-1);}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$1.isDirectiveCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(statement){<span class="cstat-no" title="statement not covered" >return(statement.type==="ExpressionStatement"&amp;&amp;statement.expression.type==="Literal"&amp;&amp;typeof statement.expression.value==="string"&amp;&amp;(this.input[statement.start]==="\""||this.input[statement.start]==="'"))}</span>;v</span>ar pp$2=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$2.toAssignable=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isBinding,refDestructuringErrors){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;node){<span class="cstat-no" title="statement not covered" >switch(node.type){case"Identifier":<span class="cstat-no" title="statement not covered" >if(this.inAsync&amp;&amp;node.name==="await")</span></span></span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Can not use 'await' as identifier inside an async function");}</span>
<span class="cstat-no" title="statement not covered" >break</span>
case"ObjectPattern":case"ArrayPattern":case"RestElement":<span class="cstat-no" title="statement not covered" >break</span>
case"ObjectExpression":<span class="cstat-no" title="statement not covered" >node.type="ObjectPattern";<span class="cstat-no" title="statement not covered" >i</span>f(refDestructuringErrors){<span class="cstat-no" title="statement not covered" >this.checkPatternErrors(refDestructuringErrors,true);}</span></span>
<span class="cstat-no" title="statement not covered" >for(var i=0,list=node.properties;i&lt;list.length;i+=1){var prop=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.toAssignable(prop,isBinding);<span class="cstat-no" title="statement not covered" >i</span>f(prop.type==="RestElement"&amp;&amp;(prop.argument.type==="ArrayPattern"||prop.argument.type==="ObjectPattern")){<span class="cstat-no" title="statement not covered" >this$1.raise(prop.argument.start,"Unexpected token");}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >break</span>
case"Property":<span class="cstat-no" title="statement not covered" >if(node.kind!=="init"){<span class="cstat-no" title="statement not covered" >this.raise(node.key.start,"Object pattern can't contain getter or setter");}</span></span>
<span class="cstat-no" title="statement not covered" >this.toAssignable(node.value,isBinding);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
case"ArrayExpression":<span class="cstat-no" title="statement not covered" >node.type="ArrayPattern";<span class="cstat-no" title="statement not covered" >i</span>f(refDestructuringErrors){<span class="cstat-no" title="statement not covered" >this.checkPatternErrors(refDestructuringErrors,true);}</span></span>
<span class="cstat-no" title="statement not covered" >this.toAssignableList(node.elements,isBinding);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
case"SpreadElement":<span class="cstat-no" title="statement not covered" >node.type="RestElement";<span class="cstat-no" title="statement not covered" >t</span>his.toAssignable(node.argument,isBinding);<span class="cstat-no" title="statement not covered" >i</span>f(node.argument.type==="AssignmentPattern")</span>
{<span class="cstat-no" title="statement not covered" >this.raise(node.argument.start,"Rest elements cannot have a default value");}</span>
<span class="cstat-no" title="statement not covered" >break</span>
case"AssignmentExpression":<span class="cstat-no" title="statement not covered" >if(node.operator!=="="){<span class="cstat-no" title="statement not covered" >this.raise(node.left.end,"Only '=' operator can be used for specifying default value.");}</span></span>
<span class="cstat-no" title="statement not covered" >node.type="AssignmentPattern";<span class="cstat-no" title="statement not covered" >d</span>elete node.operator;<span class="cstat-no" title="statement not covered" >t</span>his.toAssignable(node.left,isBinding);c</span>ase"AssignmentPattern":<span class="cstat-no" title="statement not covered" >break</span>
case"ParenthesizedExpression":<span class="cstat-no" title="statement not covered" >this.toAssignable(node.expression,isBinding);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
case"MemberExpression":<span class="cstat-no" title="statement not covered" >if(!isBinding){<span class="cstat-no" title="statement not covered" >break}</span></span>
default:<span class="cstat-no" title="statement not covered" >this.raise(node.start,"Assigning to rvalue");}</span>}else <span class="cstat-no" title="statement not covered" >if(refDestructuringErrors){<span class="cstat-no" title="statement not covered" >this.checkPatternErrors(refDestructuringErrors,true);}</span></span>
<span class="cstat-no" title="statement not covered" >return node}</span>;<span class="cstat-no" title="statement not covered" >pp$2.toAssignableList=<span class="fstat-no" title="function not covered" >fu</span>nction(exprList,isBinding){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var end=<span class="cstat-no" title="statement not covered" >exprList.length;<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;end;i++){var elt=<span class="cstat-no" title="statement not covered" >exprList[i];<span class="cstat-no" title="statement not covered" ></span>if(elt){<span class="cstat-no" title="statement not covered" >this$1.toAssignable(elt,isBinding);}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(end){var last=<span class="cstat-no" title="statement not covered" >exprList[end-1];<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion===6&amp;&amp;isBinding&amp;&amp;last&amp;&amp;last.type==="RestElement"&amp;&amp;last.argument.type!=="Identifier")</span></span>
{<span class="cstat-no" title="statement not covered" >this.unexpected(last.argument.start);}</span>}
<span class="cstat-no" title="statement not covered" >return exprList}</span>;<span class="cstat-no" title="statement not covered" >pp$2.parseSpread=<span class="fstat-no" title="function not covered" >fu</span>nction(refDestructuringErrors){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeAssign(false,refDestructuringErrors);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"SpreadElement")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$2.parseRestBinding=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion===6&amp;&amp;this.type!==types.name)</span></span>
{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>
<span class="cstat-no" title="statement not covered" >node.argument=this.parseBindingAtom();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"RestElement")}</span>;<span class="cstat-no" title="statement not covered" >pp$2.parseBindingAtom=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >switch(this.type){case types.bracketL:var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.elements=this.parseBindingList(types.bracketR,true,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrayPattern")</span></span></span></span>
case types.braceL:<span class="cstat-no" title="statement not covered" >return this.parseObj(true)}</span>}
<span class="cstat-no" title="statement not covered" >return this.parseIdent()}</span>;<span class="cstat-no" title="statement not covered" >pp$2.parseBindingList=<span class="fstat-no" title="function not covered" >fu</span>nction(close,allowEmpty,allowTrailingComma){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var elts=<span class="cstat-no" title="statement not covered" >[],</span>first=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>while(!this.eat(close)){<span class="cstat-no" title="statement not covered" >if(first){<span class="cstat-no" title="statement not covered" >first=false;}</span></span></span></span>
else{<span class="cstat-no" title="statement not covered" >this$1.expect(types.comma);}</span>
<span class="cstat-no" title="statement not covered" >if(allowEmpty&amp;&amp;this$1.type===types.comma){<span class="cstat-no" title="statement not covered" >elts.push(null);}</span>else <span class="cstat-no" title="statement not covered" >if(allowTrailingComma&amp;&amp;this$1.afterTrailingComma(close)){<span class="cstat-no" title="statement not covered" >break}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.type===types.ellipsis){var rest=<span class="cstat-no" title="statement not covered" >this$1.parseRestBinding();<span class="cstat-no" title="statement not covered" ></span>this$1.parseBindingListItem(rest);<span class="cstat-no" title="statement not covered" >e</span>lts.push(rest);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.type===types.comma){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.start,"Comma is not permitted after the rest element");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >this$1.expect(close);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>else{var elem=<span class="cstat-no" title="statement not covered" >this$1.parseMaybeDefault(this$1.start,this$1.startLoc);<span class="cstat-no" title="statement not covered" ></span>this$1.parseBindingListItem(elem);<span class="cstat-no" title="statement not covered" >e</span>lts.push(elem);}</span>}
<span class="cstat-no" title="statement not covered" >return elts}</span>;<span class="cstat-no" title="statement not covered" >pp$2.parseBindingListItem=<span class="fstat-no" title="function not covered" >fu</span>nction(param){<span class="cstat-no" title="statement not covered" >return param}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$2.parseMaybeDefault=<span class="fstat-no" title="function not covered" >fu</span>nction(startPos,startLoc,left){<span class="cstat-no" title="statement not covered" >left=left||this.parseBindingAtom();<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&lt;6||!this.eat(types.eq)){<span class="cstat-no" title="statement not covered" >return left}</span></span></span>
var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node.left=left;<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"AssignmentPattern")}</span>;<span class="cstat-no" title="statement not covered" >pp$2.checkLVal=<span class="fstat-no" title="function not covered" >fu</span>nction(expr,bindingType,checkClashes){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(bindingType===void 0)<span class="cstat-no" title="statement not covered" >bindingType=BIND_NONE;<span class="cstat-no" title="statement not covered" >s</span></span>witch(expr.type){case"Identifier":<span class="cstat-no" title="statement not covered" >if(this.strict&amp;&amp;this.reservedWordsStrictBind.test(expr.name))</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(expr.start,(bindingType?"Binding ":"Assigning to ")+expr.name+" in strict mode");}</span>
<span class="cstat-no" title="statement not covered" >if(checkClashes){<span class="cstat-no" title="statement not covered" >if(has(checkClashes,expr.name))</span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(expr.start,"Argument name clash");}</span>
<span class="cstat-no" title="statement not covered" >checkClashes[expr.name]=true;}</span>
<span class="cstat-no" title="statement not covered" >if(bindingType!==BIND_NONE&amp;&amp;bindingType!==BIND_OUTSIDE){<span class="cstat-no" title="statement not covered" >this.declareName(expr.name,bindingType,expr.start);}</span></span>
<span class="cstat-no" title="statement not covered" >break</span>
case"MemberExpression":<span class="cstat-no" title="statement not covered" >if(bindingType){<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(expr.start,"Binding member expression");}</span></span>
<span class="cstat-no" title="statement not covered" >break</span>
case"ObjectPattern":<span class="cstat-no" title="statement not covered" >for(var i=0,list=expr.properties;i&lt;list.length;i+=1)</span>
{var prop=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.checkLVal(prop,bindingType,checkClashes);}</span>
<span class="cstat-no" title="statement not covered" >break</span>
case"Property":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.value,bindingType,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
case"ArrayPattern":<span class="cstat-no" title="statement not covered" >for(var i$1=0,list$1=expr.elements;i$1&lt;list$1.length;i$1+=1){var elem=<span class="cstat-no" title="statement not covered" >list$1[i$1];<span class="cstat-no" title="statement not covered" ></span>if(elem){<span class="cstat-no" title="statement not covered" >this$1.checkLVal(elem,bindingType,checkClashes);}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >break</span>
case"AssignmentPattern":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.left,bindingType,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
case"RestElement":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.argument,bindingType,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
case"ParenthesizedExpression":<span class="cstat-no" title="statement not covered" >this.checkLVal(expr.expression,bindingType,checkClashes);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
default:<span class="cstat-no" title="statement not covered" >this.raise(expr.start,(bindingType?"Binding":"Assigning to")+" rvalue");}</span>};var pp$3=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$3.checkPropClash=<span class="fstat-no" title="function not covered" >fu</span>nction(prop,propHash,refDestructuringErrors){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9&amp;&amp;prop.type==="SpreadElement")</span></span>
{<span class="cstat-no" title="statement not covered" >return}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6&amp;&amp;(prop.computed||prop.method||prop.shorthand))</span>
{<span class="cstat-no" title="statement not covered" >return}</span>
var key=<span class="cstat-no" title="statement not covered" >prop.key;</span>var name;<span class="cstat-no" title="statement not covered" >switch(key.type){case"Identifier":<span class="cstat-no" title="statement not covered" >name=key.name;<span class="cstat-no" title="statement not covered" >b</span>reak</span></span>
case"Literal":<span class="cstat-no" title="statement not covered" >name=String(key.value);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
default:<span class="cstat-no" title="statement not covered" >return}</span>
var kind=<span class="cstat-no" title="statement not covered" >prop.kind;<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(name==="__proto__"&amp;&amp;kind==="init"){<span class="cstat-no" title="statement not covered" >if(propHash.proto){<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors&amp;&amp;refDestructuringErrors.doubleProto&lt;0){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.doubleProto=key.start;}</span></span></span></span></span>
else{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(key.start,"Redefinition of __proto__ property");}</span>}
<span class="cstat-no" title="statement not covered" >propHash.proto=true;}</span>
<span class="cstat-no" title="statement not covered" >return}</span>
<span class="cstat-no" title="statement not covered" >name="$"+name;v</span>ar other=<span class="cstat-no" title="statement not covered" >propHash[name];<span class="cstat-no" title="statement not covered" ></span>if(other){var redefinition;<span class="cstat-no" title="statement not covered" >if(kind==="init"){<span class="cstat-no" title="statement not covered" >redefinition=this.strict&amp;&amp;other.init||other.get||other.set;}</span>else{<span class="cstat-no" title="statement not covered" >redefinition=other.init||other[kind];}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(redefinition)</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(key.start,"Redefinition of property");}</span>}else{<span class="cstat-no" title="statement not covered" >other=propHash[name]={init:false,get:false,set:false};}</span>
<span class="cstat-no" title="statement not covered" >other[kind]=true;}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn,refDestructuringErrors){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;</span>var expr=<span class="cstat-no" title="statement not covered" >this.parseMaybeAssign(noIn,refDestructuringErrors);<span class="cstat-no" title="statement not covered" ></span>if(this.type===types.comma){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node.expressions=[expr];<span class="cstat-no" title="statement not covered" >w</span>hile(this.eat(types.comma)){<span class="cstat-no" title="statement not covered" >node.expressions.push(this$1.parseMaybeAssign(noIn,refDestructuringErrors));}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"SequenceExpression")}</span>
<span class="cstat-no" title="statement not covered" >return expr}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseMaybeAssign=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn,refDestructuringErrors,afterLeftParse){<span class="cstat-no" title="statement not covered" >if(this.isContextual("yield")){<span class="cstat-no" title="statement not covered" >if(this.inGenerator){<span class="cstat-no" title="statement not covered" >return this.parseYield()}</span></span></span></span>
else{<span class="cstat-no" title="statement not covered" >this.exprAllowed=false;}</span>}
var ownDestructuringErrors=<span class="cstat-no" title="statement not covered" >false,</span>oldParenAssign=<span class="cstat-no" title="statement not covered" >-1,</span>oldTrailingComma=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if(refDestructuringErrors){<span class="cstat-no" title="statement not covered" >oldParenAssign=refDestructuringErrors.parenthesizedAssign;<span class="cstat-no" title="statement not covered" >o</span>ldTrailingComma=refDestructuringErrors.trailingComma;<span class="cstat-no" title="statement not covered" >r</span>efDestructuringErrors.parenthesizedAssign=refDestructuringErrors.trailingComma=-1;}</span>else{<span class="cstat-no" title="statement not covered" >refDestructuringErrors=new DestructuringErrors;<span class="cstat-no" title="statement not covered" >o</span>wnDestructuringErrors=true;}</span></span>
var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;<span class="cstat-no" title="statement not covered" ></span>if(this.type===types.parenL||this.type===types.name)</span>
{<span class="cstat-no" title="statement not covered" >this.potentialArrowAt=this.start;}</span>
var left=<span class="cstat-no" title="statement not covered" >this.parseMaybeConditional(noIn,refDestructuringErrors);<span class="cstat-no" title="statement not covered" ></span>if(afterLeftParse){<span class="cstat-no" title="statement not covered" >left=afterLeftParse.call(this,left,startPos,startLoc);}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.type.isAssign){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node.operator=this.value;<span class="cstat-no" title="statement not covered" >n</span>ode.left=this.type===types.eq?this.toAssignable(left,false,refDestructuringErrors):left;<span class="cstat-no" title="statement not covered" >i</span>f(!ownDestructuringErrors){<span class="cstat-no" title="statement not covered" >DestructuringErrors.call(refDestructuringErrors);}</span></span></span>
<span class="cstat-no" title="statement not covered" >refDestructuringErrors.shorthandAssign=-1;<span class="cstat-no" title="statement not covered" >t</span>his.checkLVal(left);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseMaybeAssign(noIn);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"AssignmentExpression")}</span>else{<span class="cstat-no" title="statement not covered" >if(ownDestructuringErrors){<span class="cstat-no" title="statement not covered" >this.checkExpressionErrors(refDestructuringErrors,true);}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(oldParenAssign&gt;-1){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedAssign=oldParenAssign;}</span></span>
<span class="cstat-no" title="statement not covered" >if(oldTrailingComma&gt;-1){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.trailingComma=oldTrailingComma;}</span></span>
<span class="cstat-no" title="statement not covered" >return left}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseMaybeConditional=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn,refDestructuringErrors){var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;</span>var expr=<span class="cstat-no" title="statement not covered" >this.parseExprOps(noIn,refDestructuringErrors);<span class="cstat-no" title="statement not covered" ></span>if(this.checkExpressionErrors(refDestructuringErrors)){<span class="cstat-no" title="statement not covered" >return expr}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.eat(types.question)){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node.test=expr;<span class="cstat-no" title="statement not covered" >n</span>ode.consequent=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.colon);<span class="cstat-no" title="statement not covered" >n</span>ode.alternate=this.parseMaybeAssign(noIn);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ConditionalExpression")}</span></span>
<span class="cstat-no" title="statement not covered" >return expr}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseExprOps=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn,refDestructuringErrors){var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;</span>var expr=<span class="cstat-no" title="statement not covered" >this.parseMaybeUnary(refDestructuringErrors,false);<span class="cstat-no" title="statement not covered" ></span>if(this.checkExpressionErrors(refDestructuringErrors)){<span class="cstat-no" title="statement not covered" >return expr}</span></span></span>
<span class="cstat-no" title="statement not covered" >return expr.start===startPos&amp;&amp;expr.type==="ArrowFunctionExpression"?expr:this.parseExprOp(expr,startPos,startLoc,-1,noIn)}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseExprOp=<span class="fstat-no" title="function not covered" >fu</span>nction(left,leftStartPos,leftStartLoc,minPrec,noIn){var prec=<span class="cstat-no" title="statement not covered" >this.type.binop;<span class="cstat-no" title="statement not covered" ></span>if(prec!=null&amp;&amp;(!noIn||this.type!==types._in)){<span class="cstat-no" title="statement not covered" >if(prec&gt;minPrec){var logical=<span class="cstat-no" title="statement not covered" >this.type===types.logicalOR||this.type===types.logicalAND;</span>var op=<span class="cstat-no" title="statement not covered" >this.value;<span class="cstat-no" title="statement not covered" ></span>this.next();v</span>ar startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;</span>var right=<span class="cstat-no" title="statement not covered" >this.parseExprOp(this.parseMaybeUnary(null,false),startPos,startLoc,prec,noIn);</span>var node=<span class="cstat-no" title="statement not covered" >this.buildBinary(leftStartPos,leftStartLoc,left,right,op,logical);<span class="cstat-no" title="statement not covered" ></span>return this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec,noIn)}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >return left}</span>;<span class="cstat-no" title="statement not covered" >pp$3.buildBinary=<span class="fstat-no" title="function not covered" >fu</span>nction(startPos,startLoc,left,right,op,logical){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node.left=left;<span class="cstat-no" title="statement not covered" >n</span>ode.operator=op;<span class="cstat-no" title="statement not covered" >n</span>ode.right=right;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,logical?"LogicalExpression":"BinaryExpression")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$3.parseMaybeUnary=<span class="fstat-no" title="function not covered" >fu</span>nction(refDestructuringErrors,sawUnary){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc,</span>expr;<span class="cstat-no" title="statement not covered" >if(this.isContextual("await")&amp;&amp;(this.inAsync||(!this.inFunction&amp;&amp;this.options.allowAwaitOutsideFunction))){<span class="cstat-no" title="statement not covered" >expr=this.parseAwait();<span class="cstat-no" title="statement not covered" >s</span>awUnary=true;}</span>else <span class="cstat-no" title="statement not covered" >if(this.type.prefix){var node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>update=<span class="cstat-no" title="statement not covered" >this.type===types.incDec;<span class="cstat-no" title="statement not covered" ></span>node.operator=this.value;<span class="cstat-no" title="statement not covered" >n</span>ode.prefix=true;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeUnary(null,true);<span class="cstat-no" title="statement not covered" >t</span>his.checkExpressionErrors(refDestructuringErrors,true);<span class="cstat-no" title="statement not covered" >i</span>f(update){<span class="cstat-no" title="statement not covered" >this.checkLVal(node.argument);}</span></span></span></span></span>
else <span class="cstat-no" title="statement not covered" >if(this.strict&amp;&amp;node.operator==="delete"&amp;&amp;node.argument.type==="Identifier")</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(node.start,"Deleting local variable in strict mode");}</span>
else{<span class="cstat-no" title="statement not covered" >sawUnary=true;}</span>
<span class="cstat-no" title="statement not covered" >expr=this.finishNode(node,update?"UpdateExpression":"UnaryExpression");}</span>else{<span class="cstat-no" title="statement not covered" >expr=this.parseExprSubscripts(refDestructuringErrors);<span class="cstat-no" title="statement not covered" >i</span>f(this.checkExpressionErrors(refDestructuringErrors)){<span class="cstat-no" title="statement not covered" >return expr}</span></span>
<span class="cstat-no" title="statement not covered" >while(this.type.postfix&amp;&amp;!this.canInsertSemicolon()){var node$1=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node$1.operator=this$1.value;<span class="cstat-no" title="statement not covered" >n</span>ode$1.prefix=false;<span class="cstat-no" title="statement not covered" >n</span>ode$1.argument=expr;<span class="cstat-no" title="statement not covered" >t</span>his$1.checkLVal(expr);<span class="cstat-no" title="statement not covered" >t</span>his$1.next();<span class="cstat-no" title="statement not covered" >e</span>xpr=this$1.finishNode(node$1,"UpdateExpression");}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(!sawUnary&amp;&amp;this.eat(types.starstar))</span>
{<span class="cstat-no" title="statement not covered" >return this.buildBinary(startPos,startLoc,expr,this.parseMaybeUnary(null,false),"**",false)}</span>
else
{<span class="cstat-no" title="statement not covered" >return expr}</span>};<span class="cstat-no" title="statement not covered" >pp$3.parseExprSubscripts=<span class="fstat-no" title="function not covered" >fu</span>nction(refDestructuringErrors){var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;</span>var expr=<span class="cstat-no" title="statement not covered" >this.parseExprAtom(refDestructuringErrors);</span>var skipArrowSubscripts=<span class="cstat-no" title="statement not covered" >expr.type==="ArrowFunctionExpression"&amp;&amp;this.input.slice(this.lastTokStart,this.lastTokEnd)!==")";<span class="cstat-no" title="statement not covered" ></span>if(this.checkExpressionErrors(refDestructuringErrors)||skipArrowSubscripts){<span class="cstat-no" title="statement not covered" >return expr}</span></span></span>
var result=<span class="cstat-no" title="statement not covered" >this.parseSubscripts(expr,startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>if(refDestructuringErrors&amp;&amp;result.type==="MemberExpression"){<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.parenthesizedAssign&gt;=result.start){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedAssign=-1;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.parenthesizedBind&gt;=result.start){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedBind=-1;}</span>}</span>
<span class="cstat-no" title="statement not covered" >return result}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseSubscripts=<span class="fstat-no" title="function not covered" >fu</span>nction(base,startPos,startLoc,noCalls){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var maybeAsyncArrow=<span class="cstat-no" title="statement not covered" >this.options.ecmaVersion&gt;=8&amp;&amp;base.type==="Identifier"&amp;&amp;base.name==="async"&amp;&amp;this.lastTokEnd===base.end&amp;&amp;!this.canInsertSemicolon()&amp;&amp;this.input.slice(base.start,base.end)==="async";<span class="cstat-no" title="statement not covered" ></span>for(var computed=(void 0);;){<span class="cstat-no" title="statement not covered" >if((computed=this$1.eat(types.bracketL))||this$1.eat(types.dot)){var node=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node.object=base;<span class="cstat-no" title="statement not covered" >n</span>ode.property=computed?this$1.parseExpression():this$1.parseIdent(true);<span class="cstat-no" title="statement not covered" >n</span>ode.computed=!!computed;<span class="cstat-no" title="statement not covered" >i</span>f(computed){<span class="cstat-no" title="statement not covered" >this$1.expect(types.bracketR);}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >base=this$1.finishNode(node,"MemberExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(!noCalls&amp;&amp;this$1.eat(types.parenL)){var refDestructuringErrors=<span class="cstat-no" title="statement not covered" >new DestructuringErrors,</span>oldYieldPos=<span class="cstat-no" title="statement not covered" >this$1.yieldPos,</span>oldAwaitPos=<span class="cstat-no" title="statement not covered" >this$1.awaitPos;<span class="cstat-no" title="statement not covered" ></span>this$1.yieldPos=0;<span class="cstat-no" title="statement not covered" >t</span>his$1.awaitPos=0;v</span>ar exprList=<span class="cstat-no" title="statement not covered" >this$1.parseExprList(types.parenR,this$1.options.ecmaVersion&gt;=8,false,refDestructuringErrors);<span class="cstat-no" title="statement not covered" ></span>if(maybeAsyncArrow&amp;&amp;!this$1.canInsertSemicolon()&amp;&amp;this$1.eat(types.arrow)){<span class="cstat-no" title="statement not covered" >this$1.checkPatternErrors(refDestructuringErrors,false);<span class="cstat-no" title="statement not covered" >t</span>his$1.checkYieldAwaitInDefaultParams();<span class="cstat-no" title="statement not covered" >t</span>his$1.yieldPos=oldYieldPos;<span class="cstat-no" title="statement not covered" >t</span>his$1.awaitPos=oldAwaitPos;<span class="cstat-no" title="statement not covered" >r</span>eturn this$1.parseArrowExpression(this$1.startNodeAt(startPos,startLoc),exprList,true)}</span></span></span>
<span class="cstat-no" title="statement not covered" >this$1.checkExpressionErrors(refDestructuringErrors,true);<span class="cstat-no" title="statement not covered" >t</span>his$1.yieldPos=oldYieldPos||this$1.yieldPos;<span class="cstat-no" title="statement not covered" >t</span>his$1.awaitPos=oldAwaitPos||this$1.awaitPos;v</span>ar node$1=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node$1.callee=base;<span class="cstat-no" title="statement not covered" >n</span>ode$1.arguments=exprList;<span class="cstat-no" title="statement not covered" >b</span>ase=this$1.finishNode(node$1,"CallExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.type===types.backQuote){var node$2=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>node$2.tag=base;<span class="cstat-no" title="statement not covered" >n</span>ode$2.quasi=this$1.parseTemplate({isTagged:true});<span class="cstat-no" title="statement not covered" >b</span>ase=this$1.finishNode(node$2,"TaggedTemplateExpression");}</span>else{<span class="cstat-no" title="statement not covered" >return base}</span>}</span>};<span class="cstat-no" title="statement not covered" >pp$3.parseExprAtom=<span class="fstat-no" title="function not covered" >fu</span>nction(refDestructuringErrors){var node,canBeArrow=<span class="cstat-no" title="statement not covered" >this.potentialArrowAt===this.start;<span class="cstat-no" title="statement not covered" ></span>switch(this.type){case types._super:<span class="cstat-no" title="statement not covered" >if(!this.inFunction)</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.raise(this.start,"'super' outside of function or class");}</span>
<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.type!==types.dot&amp;&amp;this.type!==types.bracketL&amp;&amp;this.type!==types.parenL)</span>
{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"Super")</span>
case types._this:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ThisExpression")</span>
case types.name:var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc,</span>containsEsc=<span class="cstat-no" title="statement not covered" >this.containsEsc;</span>var id=<span class="cstat-no" title="statement not covered" >this.parseIdent(this.type!==types.name);<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=8&amp;&amp;!containsEsc&amp;&amp;id.name==="async"&amp;&amp;!this.canInsertSemicolon()&amp;&amp;this.eat(types._function))</span>
{<span class="cstat-no" title="statement not covered" >return this.parseFunction(this.startNodeAt(startPos,startLoc),0,false,true)}</span>
<span class="cstat-no" title="statement not covered" >if(canBeArrow&amp;&amp;!this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >if(this.eat(types.arrow))</span></span>
{<span class="cstat-no" title="statement not covered" >return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],false)}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8&amp;&amp;id.name==="async"&amp;&amp;this.type===types.name&amp;&amp;!containsEsc){<span class="cstat-no" title="statement not covered" >id=this.parseIdent();<span class="cstat-no" title="statement not covered" >i</span>f(this.canInsertSemicolon()||!this.eat(types.arrow))</span></span>
{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>
<span class="cstat-no" title="statement not covered" >return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],true)}</span>}
<span class="cstat-no" title="statement not covered" >return id</span>
case types.regexp:var value=<span class="cstat-no" title="statement not covered" >this.value;<span class="cstat-no" title="statement not covered" ></span>node=this.parseLiteral(value.value);<span class="cstat-no" title="statement not covered" >n</span>ode.regex={pattern:value.pattern,flags:value.flags};<span class="cstat-no" title="statement not covered" >r</span>eturn node</span>
case types.num:case types.string:<span class="cstat-no" title="statement not covered" >return this.parseLiteral(this.value)</span>
case types._null:case types._true:case types._false:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.value=this.type===types._null?null:this.type===types._true;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.type.keyword;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal")</span>
case types.parenL:var start=<span class="cstat-no" title="statement not covered" >this.start,</span>expr=<span class="cstat-no" title="statement not covered" >this.parseParenAndDistinguishExpression(canBeArrow);<span class="cstat-no" title="statement not covered" ></span>if(refDestructuringErrors){<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.parenthesizedAssign&lt;0&amp;&amp;!this.isSimpleAssignTarget(expr))</span></span>
{<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedAssign=start;}</span>
<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.parenthesizedBind&lt;0)</span>
{<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedBind=start;}</span>}
<span class="cstat-no" title="statement not covered" >return expr</span>
case types.bracketL:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.elements=this.parseExprList(types.bracketR,true,true,refDestructuringErrors);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrayExpression")</span>
case types.braceL:<span class="cstat-no" title="statement not covered" >return this.parseObj(false,refDestructuringErrors)</span>
case types._function:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,0)</span>
case types._class:<span class="cstat-no" title="statement not covered" >return this.parseClass(this.startNode(),false)</span>
case types._new:<span class="cstat-no" title="statement not covered" >return this.parseNew()</span>
case types.backQuote:<span class="cstat-no" title="statement not covered" >return this.parseTemplate()</span>
default:<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>};<span class="cstat-no" title="statement not covered" >pp$3.parseLiteral=<span class="fstat-no" title="function not covered" >fu</span>nction(value){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>node.value=value;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.input.slice(this.start,this.end);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal")}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$3.parseParenExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.expect(types.parenL);v</span>ar val=<span class="cstat-no" title="statement not covered" >this.parseExpression();<span class="cstat-no" title="statement not covered" ></span>this.expect(types.parenR);<span class="cstat-no" title="statement not covered" >r</span>eturn val}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$3.parseParenAndDistinguishExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(canBeArrow){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc,</span>val,allowTrailingComma=<span class="cstat-no" title="statement not covered" >this.options.ecmaVersion&gt;=8;<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >this.next();v</span>ar innerStartPos=<span class="cstat-no" title="statement not covered" >this.start,</span>innerStartLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;</span>var exprList=<span class="cstat-no" title="statement not covered" >[],</span>first=<span class="cstat-no" title="statement not covered" >true,</span>lastIsComma=<span class="cstat-no" title="statement not covered" >false;</span>var refDestructuringErrors=<span class="cstat-no" title="statement not covered" >new DestructuringErrors,</span>oldYieldPos=<span class="cstat-no" title="statement not covered" >this.yieldPos,</span>oldAwaitPos=<span class="cstat-no" title="statement not covered" >this.awaitPos,</span>spreadStart;<span class="cstat-no" title="statement not covered" >this.yieldPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=0;<span class="cstat-no" title="statement not covered" >w</span>hile(this.type!==types.parenR){<span class="cstat-no" title="statement not covered" >first?first=false:this$1.expect(types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(allowTrailingComma&amp;&amp;this$1.afterTrailingComma(types.parenR,true)){<span class="cstat-no" title="statement not covered" >lastIsComma=true;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.type===types.ellipsis){<span class="cstat-no" title="statement not covered" >spreadStart=this$1.start;<span class="cstat-no" title="statement not covered" >e</span>xprList.push(this$1.parseParenItem(this$1.parseRestBinding()));<span class="cstat-no" title="statement not covered" >i</span>f(this$1.type===types.comma){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.start,"Comma is not permitted after the rest element");}</span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >break}</span>else{<span class="cstat-no" title="statement not covered" >exprList.push(this$1.parseMaybeAssign(false,refDestructuringErrors,this$1.parseParenItem));}</span>}
var innerEndPos=<span class="cstat-no" title="statement not covered" >this.start,</span>innerEndLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;<span class="cstat-no" title="statement not covered" ></span>this.expect(types.parenR);<span class="cstat-no" title="statement not covered" >i</span>f(canBeArrow&amp;&amp;!this.canInsertSemicolon()&amp;&amp;this.eat(types.arrow)){<span class="cstat-no" title="statement not covered" >this.checkPatternErrors(refDestructuringErrors,false);<span class="cstat-no" title="statement not covered" >t</span>his.checkYieldAwaitInDefaultParams();<span class="cstat-no" title="statement not covered" >t</span>his.yieldPos=oldYieldPos;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=oldAwaitPos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseParenArrowList(startPos,startLoc,exprList)}</span></span>
<span class="cstat-no" title="statement not covered" >if(!exprList.length||lastIsComma){<span class="cstat-no" title="statement not covered" >this.unexpected(this.lastTokStart);}</span></span>
<span class="cstat-no" title="statement not covered" >if(spreadStart){<span class="cstat-no" title="statement not covered" >this.unexpected(spreadStart);}</span></span>
<span class="cstat-no" title="statement not covered" >this.checkExpressionErrors(refDestructuringErrors,true);<span class="cstat-no" title="statement not covered" >t</span>his.yieldPos=oldYieldPos||this.yieldPos;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=oldAwaitPos||this.awaitPos;<span class="cstat-no" title="statement not covered" >i</span>f(exprList.length&gt;1){<span class="cstat-no" title="statement not covered" >val=this.startNodeAt(innerStartPos,innerStartLoc);<span class="cstat-no" title="statement not covered" >v</span>al.expressions=exprList;<span class="cstat-no" title="statement not covered" >t</span>his.finishNodeAt(val,"SequenceExpression",innerEndPos,innerEndLoc);}</span>else{<span class="cstat-no" title="statement not covered" >val=exprList[0];}</span>}</span>else{<span class="cstat-no" title="statement not covered" >val=this.parseParenExpression();}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.preserveParens){var par=<span class="cstat-no" title="statement not covered" >this.startNodeAt(startPos,startLoc);<span class="cstat-no" title="statement not covered" ></span>par.expression=val;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(par,"ParenthesizedExpression")}</span>else{<span class="cstat-no" title="statement not covered" >return val}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseParenItem=<span class="fstat-no" title="function not covered" >fu</span>nction(item){<span class="cstat-no" title="statement not covered" >return item}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$3.parseParenArrowList=<span class="fstat-no" title="function not covered" >fu</span>nction(startPos,startLoc,exprList){<span class="cstat-no" title="statement not covered" >return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList)}</span>;v</span>ar empty$1=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>pp$3.parseNew=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node=<span class="cstat-no" title="statement not covered" >this.startNode();</span>var meta=<span class="cstat-no" title="statement not covered" >this.parseIdent(true);<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;this.eat(types.dot)){<span class="cstat-no" title="statement not covered" >node.meta=meta;v</span>ar containsEsc=<span class="cstat-no" title="statement not covered" >this.containsEsc;<span class="cstat-no" title="statement not covered" ></span>node.property=this.parseIdent(true);<span class="cstat-no" title="statement not covered" >i</span>f(node.property.name!=="target"||containsEsc)</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(node.property.start,"The only valid meta property for new is new.target");}</span>
<span class="cstat-no" title="statement not covered" >if(!this.inNonArrowFunction())</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(node.start,"new.target can only be used in functions");}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"MetaProperty")}</span>
var startPos=<span class="cstat-no" title="statement not covered" >this.start,</span>startLoc=<span class="cstat-no" title="statement not covered" >this.startLoc;<span class="cstat-no" title="statement not covered" ></span>node.callee=this.parseSubscripts(this.parseExprAtom(),startPos,startLoc,true);<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(types.parenL)){<span class="cstat-no" title="statement not covered" >node.arguments=this.parseExprList(types.parenR,this.options.ecmaVersion&gt;=8,false);}</span></span>
else{<span class="cstat-no" title="statement not covered" >node.arguments=empty$1;}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"NewExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseTemplateElement=<span class="fstat-no" title="function not covered" >fu</span>nction(ref){var isTagged=<span class="cstat-no" title="statement not covered" >ref.isTagged;</span>var elem=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>if(this.type===types.invalidTemplate){<span class="cstat-no" title="statement not covered" >if(!isTagged){<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >elem.value={raw:this.value,cooked:null};}</span>else{<span class="cstat-no" title="statement not covered" >elem.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value};}</span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >e</span>lem.tail=this.type===types.backQuote;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(elem,"TemplateElement")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseTemplate=<span class="fstat-no" title="function not covered" >fu</span>nction(ref){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(ref===void 0)<span class="cstat-no" title="statement not covered" >ref={};v</span></span>ar isTagged=<span class="cstat-no" title="statement not covered" >ref.isTagged;<span class="cstat-no" title="statement not covered" ></span>if(isTagged===void 0)<span class="cstat-no" title="statement not covered" >isTagged=false;v</span></span>ar node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.expressions=[];v</span>ar curElt=<span class="cstat-no" title="statement not covered" >this.parseTemplateElement({isTagged:isTagged});<span class="cstat-no" title="statement not covered" ></span>node.quasis=[curElt];<span class="cstat-no" title="statement not covered" >w</span>hile(!curElt.tail){<span class="cstat-no" title="statement not covered" >if(this$1.type===types.eof){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.pos,"Unterminated template literal");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this$1.expect(types.dollarBraceL);<span class="cstat-no" title="statement not covered" >n</span>ode.expressions.push(this$1.parseExpression());<span class="cstat-no" title="statement not covered" >t</span>his$1.expect(types.braceR);<span class="cstat-no" title="statement not covered" >n</span>ode.quasis.push(curElt=this$1.parseTemplateElement({isTagged:isTagged}));}</span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"TemplateLiteral")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.isAsyncProp=<span class="fstat-no" title="function not covered" >fu</span>nction(prop){<span class="cstat-no" title="statement not covered" >return!prop.computed&amp;&amp;prop.key.type==="Identifier"&amp;&amp;prop.key.name==="async"&amp;&amp;(this.type===types.name||this.type===types.num||this.type===types.string||this.type===types.bracketL||this.type.keyword||(this.options.ecmaVersion&gt;=9&amp;&amp;this.type===types.star))&amp;&amp;!lineBreak.test(this.input.slice(this.lastTokEnd,this.start))}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$3.parseObj=<span class="fstat-no" title="function not covered" >fu</span>nction(isPattern,refDestructuringErrors){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>first=<span class="cstat-no" title="statement not covered" >true,</span>propHash=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>node.properties=[];<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >w</span>hile(!this.eat(types.braceR)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this$1.expect(types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.afterTrailingComma(types.braceR)){<span class="cstat-no" title="statement not covered" >break}</span>}</span>else{<span class="cstat-no" title="statement not covered" >first=false;}</span></span></span></span>
var prop=<span class="cstat-no" title="statement not covered" >this$1.parseProperty(isPattern,refDestructuringErrors);<span class="cstat-no" title="statement not covered" ></span>if(!isPattern){<span class="cstat-no" title="statement not covered" >this$1.checkPropClash(prop,propHash,refDestructuringErrors);}</span></span>
<span class="cstat-no" title="statement not covered" >node.properties.push(prop);}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,isPattern?"ObjectPattern":"ObjectExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseProperty=<span class="fstat-no" title="function not covered" >fu</span>nction(isPattern,refDestructuringErrors){var prop=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>isGenerator,isAsync,startPos,startLoc;<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9&amp;&amp;this.eat(types.ellipsis)){<span class="cstat-no" title="statement not covered" >if(isPattern){<span class="cstat-no" title="statement not covered" >prop.argument=this.parseIdent(false);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===types.comma){<span class="cstat-no" title="statement not covered" >this.raise(this.start,"Comma is not permitted after the rest element");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(prop,"RestElement")}</span>
<span class="cstat-no" title="statement not covered" >if(this.type===types.parenL&amp;&amp;refDestructuringErrors){<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.parenthesizedAssign&lt;0){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedAssign=this.start;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.parenthesizedBind&lt;0){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.parenthesizedBind=this.start;}</span>}</span>
<span class="cstat-no" title="statement not covered" >prop.argument=this.parseMaybeAssign(false,refDestructuringErrors);<span class="cstat-no" title="statement not covered" >i</span>f(this.type===types.comma&amp;&amp;refDestructuringErrors&amp;&amp;refDestructuringErrors.trailingComma&lt;0){<span class="cstat-no" title="statement not covered" >refDestructuringErrors.trailingComma=this.start;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(prop,"SpreadElement")}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >prop.method=false;<span class="cstat-no" title="statement not covered" >p</span>rop.shorthand=false;<span class="cstat-no" title="statement not covered" >i</span>f(isPattern||refDestructuringErrors){<span class="cstat-no" title="statement not covered" >startPos=this.start;<span class="cstat-no" title="statement not covered" >s</span>tartLoc=this.startLoc;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(!isPattern)</span>
{<span class="cstat-no" title="statement not covered" >isGenerator=this.eat(types.star);}</span>}
var containsEsc=<span class="cstat-no" title="statement not covered" >this.containsEsc;<span class="cstat-no" title="statement not covered" ></span>this.parsePropertyName(prop);<span class="cstat-no" title="statement not covered" >i</span>f(!isPattern&amp;&amp;!containsEsc&amp;&amp;this.options.ecmaVersion&gt;=8&amp;&amp;!isGenerator&amp;&amp;this.isAsyncProp(prop)){<span class="cstat-no" title="statement not covered" >isAsync=true;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this.options.ecmaVersion&gt;=9&amp;&amp;this.eat(types.star);<span class="cstat-no" title="statement not covered" >t</span>his.parsePropertyName(prop,refDestructuringErrors);}</span>else{<span class="cstat-no" title="statement not covered" >isAsync=false;}</span></span>
<span class="cstat-no" title="statement not covered" >this.parsePropertyValue(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors,containsEsc);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(prop,"Property")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parsePropertyValue=<span class="fstat-no" title="function not covered" >fu</span>nction(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors,containsEsc){<span class="cstat-no" title="statement not covered" >if((isGenerator||isAsync)&amp;&amp;this.type===types.colon)</span></span>
{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>
<span class="cstat-no" title="statement not covered" >if(this.eat(types.colon)){<span class="cstat-no" title="statement not covered" >prop.value=isPattern?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(false,refDestructuringErrors);<span class="cstat-no" title="statement not covered" >p</span>rop.kind="init";}</span>else <span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6&amp;&amp;this.type===types.parenL){<span class="cstat-no" title="statement not covered" >if(isPattern){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >prop.kind="init";<span class="cstat-no" title="statement not covered" >p</span>rop.method=true;<span class="cstat-no" title="statement not covered" >p</span>rop.value=this.parseMethod(isGenerator,isAsync);}</span>else <span class="cstat-no" title="statement not covered" >if(!isPattern&amp;&amp;!containsEsc&amp;&amp;this.options.ecmaVersion&gt;=5&amp;&amp;!prop.computed&amp;&amp;prop.key.type==="Identifier"&amp;&amp;(prop.key.name==="get"||prop.key.name==="set")&amp;&amp;(this.type!==types.comma&amp;&amp;this.type!==types.braceR)){<span class="cstat-no" title="statement not covered" >if(isGenerator||isAsync){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span>
<span class="cstat-no" title="statement not covered" >prop.kind=prop.key.name;<span class="cstat-no" title="statement not covered" >t</span>his.parsePropertyName(prop);<span class="cstat-no" title="statement not covered" >p</span>rop.value=this.parseMethod(false);v</span>ar paramCount=<span class="cstat-no" title="statement not covered" >prop.kind==="get"?0:1;<span class="cstat-no" title="statement not covered" ></span>if(prop.value.params.length!==paramCount){var start=<span class="cstat-no" title="statement not covered" >prop.value.start;<span class="cstat-no" title="statement not covered" ></span>if(prop.kind==="get")</span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(start,"getter should have no params");}</span>
else
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(start,"setter should have exactly one param");}</span>}else{<span class="cstat-no" title="statement not covered" >if(prop.kind==="set"&amp;&amp;prop.value.params[0].type==="RestElement")</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(prop.value.params[0].start,"Setter cannot use rest params");}</span>}}else <span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6&amp;&amp;!prop.computed&amp;&amp;prop.key.type==="Identifier"){<span class="cstat-no" title="statement not covered" >this.checkUnreserved(prop.key);<span class="cstat-no" title="statement not covered" >p</span>rop.kind="init";<span class="cstat-no" title="statement not covered" >i</span>f(isPattern){<span class="cstat-no" title="statement not covered" >prop.value=this.parseMaybeDefault(startPos,startLoc,prop.key);}</span>else <span class="cstat-no" title="statement not covered" >if(this.type===types.eq&amp;&amp;refDestructuringErrors){<span class="cstat-no" title="statement not covered" >if(refDestructuringErrors.shorthandAssign&lt;0)</span></span></span></span>
{<span class="cstat-no" title="statement not covered" >refDestructuringErrors.shorthandAssign=this.start;}</span>
<span class="cstat-no" title="statement not covered" >prop.value=this.parseMaybeDefault(startPos,startLoc,prop.key);}</span>else{<span class="cstat-no" title="statement not covered" >prop.value=prop.key;}</span>
<span class="cstat-no" title="statement not covered" >prop.shorthand=true;}</span>else{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span>};<span class="cstat-no" title="statement not covered" >pp$3.parsePropertyName=<span class="fstat-no" title="function not covered" >fu</span>nction(prop){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(this.eat(types.bracketL)){<span class="cstat-no" title="statement not covered" >prop.computed=true;<span class="cstat-no" title="statement not covered" >p</span>rop.key=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.bracketR);<span class="cstat-no" title="statement not covered" >r</span>eturn prop.key}</span>else{<span class="cstat-no" title="statement not covered" >prop.computed=false;}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >return prop.key=this.type===types.num||this.type===types.string?this.parseExprAtom():this.parseIdent(true)}</span>;<span class="cstat-no" title="statement not covered" >pp$3.initFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >node.id=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.generator=node.expression=false;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8){<span class="cstat-no" title="statement not covered" >node.async=false;}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseMethod=<span class="fstat-no" title="function not covered" >fu</span>nction(isGenerator,isAsync){var node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>oldYieldPos=<span class="cstat-no" title="statement not covered" >this.yieldPos,</span>oldAwaitPos=<span class="cstat-no" title="statement not covered" >this.awaitPos;<span class="cstat-no" title="statement not covered" ></span>this.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)</span></span>
{<span class="cstat-no" title="statement not covered" >node.generator=isGenerator;}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8)</span>
{<span class="cstat-no" title="statement not covered" >node.async=!!isAsync;}</span>
<span class="cstat-no" title="statement not covered" >this.yieldPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.enterScope(functionFlags(isAsync,node.generator));<span class="cstat-no" title="statement not covered" >t</span>his.expect(types.parenL);<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.parseBindingList(types.parenR,false,this.options.ecmaVersion&gt;=8);<span class="cstat-no" title="statement not covered" >t</span>his.checkYieldAwaitInDefaultParams();<span class="cstat-no" title="statement not covered" >t</span>his.parseFunctionBody(node,false);<span class="cstat-no" title="statement not covered" >t</span>his.yieldPos=oldYieldPos;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=oldAwaitPos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"FunctionExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseArrowExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(node,params,isAsync){var oldYieldPos=<span class="cstat-no" title="statement not covered" >this.yieldPos,</span>oldAwaitPos=<span class="cstat-no" title="statement not covered" >this.awaitPos;<span class="cstat-no" title="statement not covered" ></span>this.enterScope(functionFlags(isAsync,false)|SCOPE_ARROW);<span class="cstat-no" title="statement not covered" >t</span>his.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=8){<span class="cstat-no" title="statement not covered" >node.async=!!isAsync;}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.yieldPos=0;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=0;<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.toAssignableList(params,true);<span class="cstat-no" title="statement not covered" >t</span>his.parseFunctionBody(node,true);<span class="cstat-no" title="statement not covered" >t</span>his.yieldPos=oldYieldPos;<span class="cstat-no" title="statement not covered" >t</span>his.awaitPos=oldAwaitPos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrowFunctionExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseFunctionBody=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isArrowFunction){var isExpression=<span class="cstat-no" title="statement not covered" >isArrowFunction&amp;&amp;this.type!==types.braceL;</span>var oldStrict=<span class="cstat-no" title="statement not covered" >this.strict,</span>useStrict=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(isExpression){<span class="cstat-no" title="statement not covered" >node.body=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >n</span>ode.expression=true;<span class="cstat-no" title="statement not covered" >t</span>his.checkParams(node,false);}</span>else{var nonSimple=<span class="cstat-no" title="statement not covered" >this.options.ecmaVersion&gt;=7&amp;&amp;!this.isSimpleParamList(node.params);<span class="cstat-no" title="statement not covered" ></span>if(!oldStrict||nonSimple){<span class="cstat-no" title="statement not covered" >useStrict=this.strictDirective(this.end);<span class="cstat-no" title="statement not covered" >i</span>f(useStrict&amp;&amp;nonSimple)</span></span></span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(node.start,"Illegal 'use strict' directive in function with non-simple parameter list");}</span>}
var oldLabels=<span class="cstat-no" title="statement not covered" >this.labels;<span class="cstat-no" title="statement not covered" ></span>this.labels=[];<span class="cstat-no" title="statement not covered" >i</span>f(useStrict){<span class="cstat-no" title="statement not covered" >this.strict=true;}</span></span>
<span class="cstat-no" title="statement not covered" >this.checkParams(node,!oldStrict&amp;&amp;!useStrict&amp;&amp;!isArrowFunction&amp;&amp;this.isSimpleParamList(node.params));<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseBlock(false);<span class="cstat-no" title="statement not covered" >n</span>ode.expression=false;<span class="cstat-no" title="statement not covered" >t</span>his.adaptDirectivePrologue(node.body.body);<span class="cstat-no" title="statement not covered" >t</span>his.labels=oldLabels;}</span>
<span class="cstat-no" title="statement not covered" >this.exitScope();<span class="cstat-no" title="statement not covered" >i</span>f(this.strict&amp;&amp;node.id){<span class="cstat-no" title="statement not covered" >this.checkLVal(node.id,BIND_OUTSIDE);}</span></span>
<span class="cstat-no" title="statement not covered" >this.strict=oldStrict;}</span>;<span class="cstat-no" title="statement not covered" >pp$3.isSimpleParamList=<span class="fstat-no" title="function not covered" >fu</span>nction(params){<span class="cstat-no" title="statement not covered" >for(var i=0,list=params;i&lt;list.length;i+=1)</span></span>
{var param=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>if(param.type!=="Identifier"){<span class="cstat-no" title="statement not covered" >return false}</span>}</span>
<span class="cstat-no" title="statement not covered" >return true}</span>;<span class="cstat-no" title="statement not covered" >pp$3.checkParams=<span class="fstat-no" title="function not covered" >fu</span>nction(node,allowDuplicates){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var nameHash=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var i=0,list=node.params;i&lt;list.length;i+=1)</span></span>
{var param=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.checkLVal(param,BIND_VAR,allowDuplicates?null:nameHash);}</span>};<span class="cstat-no" title="statement not covered" >pp$3.parseExprList=<span class="fstat-no" title="function not covered" >fu</span>nction(close,allowTrailingComma,allowEmpty,refDestructuringErrors){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var elts=<span class="cstat-no" title="statement not covered" >[],</span>first=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>while(!this.eat(close)){<span class="cstat-no" title="statement not covered" >if(!first){<span class="cstat-no" title="statement not covered" >this$1.expect(types.comma);<span class="cstat-no" title="statement not covered" >i</span>f(allowTrailingComma&amp;&amp;this$1.afterTrailingComma(close)){<span class="cstat-no" title="statement not covered" >break}</span>}</span>else{<span class="cstat-no" title="statement not covered" >first=false;}</span></span></span></span>
var elt=(<span class="cstat-no" title="statement not covered" >void 0)</span>;<span class="cstat-no" title="statement not covered" >if(allowEmpty&amp;&amp;this$1.type===types.comma)</span>
{<span class="cstat-no" title="statement not covered" >elt=null;}</span>
else <span class="cstat-no" title="statement not covered" >if(this$1.type===types.ellipsis){<span class="cstat-no" title="statement not covered" >elt=this$1.parseSpread(refDestructuringErrors);<span class="cstat-no" title="statement not covered" >i</span>f(refDestructuringErrors&amp;&amp;this$1.type===types.comma&amp;&amp;refDestructuringErrors.trailingComma&lt;0)</span></span>
{<span class="cstat-no" title="statement not covered" >refDestructuringErrors.trailingComma=this$1.start;}</span>}else{<span class="cstat-no" title="statement not covered" >elt=this$1.parseMaybeAssign(false,refDestructuringErrors);}</span>
<span class="cstat-no" title="statement not covered" >elts.push(elt);}</span>
<span class="cstat-no" title="statement not covered" >return elts}</span>;<span class="cstat-no" title="statement not covered" >pp$3.checkUnreserved=<span class="fstat-no" title="function not covered" >fu</span>nction(ref){var start=<span class="cstat-no" title="statement not covered" >ref.start;</span>var end=<span class="cstat-no" title="statement not covered" >ref.end;</span>var name=<span class="cstat-no" title="statement not covered" >ref.name;<span class="cstat-no" title="statement not covered" ></span>if(this.inGenerator&amp;&amp;name==="yield")</span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(start,"Can not use 'yield' as identifier inside a generator");}</span>
<span class="cstat-no" title="statement not covered" >if(this.inAsync&amp;&amp;name==="await")</span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(start,"Can not use 'await' as identifier inside an async function");}</span>
<span class="cstat-no" title="statement not covered" >if(this.keywords.test(name))</span>
{<span class="cstat-no" title="statement not covered" >this.raise(start,("Unexpected keyword '"+name+"'"));}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6&amp;&amp;this.input.slice(start,end).indexOf("\\")!==-1){<span class="cstat-no" title="statement not covered" >return}</span></span>
var re=<span class="cstat-no" title="statement not covered" >this.strict?this.reservedWordsStrict:this.reservedWords;<span class="cstat-no" title="statement not covered" ></span>if(re.test(name)){<span class="cstat-no" title="statement not covered" >if(!this.inAsync&amp;&amp;name==="await")</span></span>
{<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(start,"Can not use keyword 'await' outside an async function");}</span>
<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(start,("The keyword '"+name+"' is reserved"));}</span>};<span class="cstat-no" title="statement not covered" >pp$3.parseIdent=<span class="fstat-no" title="function not covered" >fu</span>nction(liberal,isBinding){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>if(liberal&amp;&amp;this.options.allowReserved==="never"){<span class="cstat-no" title="statement not covered" >liberal=false;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.type===types.name){<span class="cstat-no" title="statement not covered" >node.name=this.value;}</span>else <span class="cstat-no" title="statement not covered" >if(this.type.keyword){<span class="cstat-no" title="statement not covered" >node.name=this.type.keyword;<span class="cstat-no" title="statement not covered" >i</span>f((node.name==="class"||node.name==="function")&amp;&amp;(this.lastTokEnd!==this.lastTokStart+1||this.input.charCodeAt(this.lastTokStart)!==46)){<span class="cstat-no" title="statement not covered" >this.context.pop();}</span>}</span>else{<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.finishNode(node,"Identifier");<span class="cstat-no" title="statement not covered" >i</span>f(!liberal){<span class="cstat-no" title="statement not covered" >this.checkUnreserved(node);}</span></span>
<span class="cstat-no" title="statement not covered" >return node}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseYield=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.yieldPos){<span class="cstat-no" title="statement not covered" >this.yieldPos=this.start;}</span></span></span>
var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.type===types.semi||this.canInsertSemicolon()||(this.type!==types.star&amp;&amp;!this.type.startsExpr)){<span class="cstat-no" title="statement not covered" >node.delegate=false;<span class="cstat-no" title="statement not covered" >n</span>ode.argument=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.delegate=this.eat(types.star);<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeAssign();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"YieldExpression")}</span>;<span class="cstat-no" title="statement not covered" >pp$3.parseAwait=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.awaitPos){<span class="cstat-no" title="statement not covered" >this.awaitPos=this.start;}</span></span></span>
var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeUnary(null,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"AwaitExpression")}</span>;var pp$4=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$4.raise=<span class="fstat-no" title="function not covered" >fu</span>nction(pos,message){var loc=<span class="cstat-no" title="statement not covered" >getLineInfo(this.input,pos);<span class="cstat-no" title="statement not covered" ></span>message+=" ("+loc.line+":"+loc.column+")";v</span>ar err=<span class="cstat-no" title="statement not covered" >new SyntaxError(message);<span class="cstat-no" title="statement not covered" ></span>err.pos=pos;<span class="cstat-no" title="statement not covered" >e</span>rr.loc=loc;<span class="cstat-no" title="statement not covered" >e</span>rr.raisedAt=this.pos;<span class="cstat-no" title="statement not covered" >t</span>hrow err}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$4.raiseRecoverable=pp$4.raise;<span class="cstat-no" title="statement not covered" >p</span>p$4.curPosition=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.options.locations){<span class="cstat-no" title="statement not covered" >return new Position(this.curLine,this.pos-this.lineStart)}</span>}</span>;v</span>ar pp$5=<span class="cstat-no" title="statement not covered" >Parser.prototype;</span>var Scope=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >Scope(</span>flags){<span class="cstat-no" title="statement not covered" >this.flags=flags;<span class="cstat-no" title="statement not covered" >t</span>his.var=[];<span class="cstat-no" title="statement not covered" >t</span>his.lexical=[];}</span>;<span class="cstat-no" title="statement not covered" ></span>pp$5.enterScope=<span class="fstat-no" title="function not covered" >fu</span>nction(flags){<span class="cstat-no" title="statement not covered" >this.scopeStack.push(new Scope(flags));}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$5.exitScope=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.scopeStack.pop();}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$5.declareName=<span class="fstat-no" title="function not covered" >fu</span>nction(name,bindingType,pos){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var redeclared=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(bindingType===BIND_LEXICAL){var scope=<span class="cstat-no" title="statement not covered" >this.currentScope();<span class="cstat-no" title="statement not covered" ></span>redeclared=scope.lexical.indexOf(name)&gt;-1||scope.var.indexOf(name)&gt;-1;<span class="cstat-no" title="statement not covered" >s</span>cope.lexical.push(name);}</span>else <span class="cstat-no" title="statement not covered" >if(bindingType===BIND_SIMPLE_CATCH){var scope$1=<span class="cstat-no" title="statement not covered" >this.currentScope();<span class="cstat-no" title="statement not covered" ></span>scope$1.lexical.push(name);}</span>else <span class="cstat-no" title="statement not covered" >if(bindingType===BIND_FUNCTION){var scope$2=<span class="cstat-no" title="statement not covered" >this.currentScope();<span class="cstat-no" title="statement not covered" ></span>redeclared=scope$2.lexical.indexOf(name)&gt;-1;<span class="cstat-no" title="statement not covered" >s</span>cope$2.var.push(name);}</span>else{<span class="cstat-no" title="statement not covered" >for(var i=this.scopeStack.length-1;i&gt;=0;--i){var scope$3=<span class="cstat-no" title="statement not covered" >this$1.scopeStack[i];<span class="cstat-no" title="statement not covered" ></span>if(scope$3.lexical.indexOf(name)&gt;-1&amp;&amp;!(scope$3.flags&amp;SCOPE_SIMPLE_CATCH)&amp;&amp;scope$3.lexical[0]===name){<span class="cstat-no" title="statement not covered" >redeclared=true;}</span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >scope$3.var.push(name);<span class="cstat-no" title="statement not covered" >i</span>f(scope$3.flags&amp;SCOPE_VAR){<span class="cstat-no" title="statement not covered" >break}</span>}</span>}
<span class="cstat-no" title="statement not covered" >if(redeclared){<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(pos,("Identifier '"+name+"' has already been declared"));}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp$5.currentScope=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.scopeStack[this.scopeStack.length-1]}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$5.currentVarScope=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i=this.scopeStack.length-1;;i--){var scope=<span class="cstat-no" title="statement not covered" >this$1.scopeStack[i];<span class="cstat-no" title="statement not covered" ></span>if(scope.flags&amp;SCOPE_VAR){<span class="cstat-no" title="statement not covered" >return scope}</span>}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$5.inNonArrowFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i=this.scopeStack.length-1;i&gt;=0;i--)</span></span>
{<span class="cstat-no" title="statement not covered" >if(this$1.scopeStack[i].flags&amp;SCOPE_FUNCTION&amp;&amp;!(this$1.scopeStack[i].flags&amp;SCOPE_ARROW)){<span class="cstat-no" title="statement not covered" >return true}</span>}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;var Node=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >Node(</span>parser,pos,loc){<span class="cstat-no" title="statement not covered" >this.type="";<span class="cstat-no" title="statement not covered" >t</span>his.start=pos;<span class="cstat-no" title="statement not covered" >t</span>his.end=0;<span class="cstat-no" title="statement not covered" >i</span>f(parser.options.locations)</span></span>
{<span class="cstat-no" title="statement not covered" >this.loc=new SourceLocation(parser,loc);}</span>
<span class="cstat-no" title="statement not covered" >if(parser.options.directSourceFile)</span>
{<span class="cstat-no" title="statement not covered" >this.sourceFile=parser.options.directSourceFile;}</span>
<span class="cstat-no" title="statement not covered" >if(parser.options.ranges)</span>
{<span class="cstat-no" title="statement not covered" >this.range=[pos,0];}</span>};var pp$6=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$6.startNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Node(this,this.start,this.startLoc)}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$6.startNodeAt=<span class="fstat-no" title="function not covered" >fu</span>nction(pos,loc){<span class="cstat-no" title="statement not covered" >return new Node(this,pos,loc)}</span>;f</span>unction <span class="fstat-no" title="function not covered" >finishNodeAt(</span>node,type,pos,loc){<span class="cstat-no" title="statement not covered" >node.type=type;<span class="cstat-no" title="statement not covered" >n</span>ode.end=pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations)</span>
{<span class="cstat-no" title="statement not covered" >node.loc.end=loc;}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ranges)</span>
{<span class="cstat-no" title="statement not covered" >node.range[1]=pos;}</span>
<span class="cstat-no" title="statement not covered" >return node}</span>
<span class="cstat-no" title="statement not covered" >pp$6.finishNode=<span class="fstat-no" title="function not covered" >fu</span>nction(node,type){<span class="cstat-no" title="statement not covered" >return finishNodeAt.call(this,node,type,this.lastTokEnd,this.lastTokEndLoc)}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$6.finishNodeAt=<span class="fstat-no" title="function not covered" >fu</span>nction(node,type,pos,loc){<span class="cstat-no" title="statement not covered" >return finishNodeAt.call(this,node,type,pos,loc)}</span>;v</span>ar TokContext=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >TokContext(</span>token,isExpr,preserveSpace,override,generator){<span class="cstat-no" title="statement not covered" >this.token=token;<span class="cstat-no" title="statement not covered" >t</span>his.isExpr=!!isExpr;<span class="cstat-no" title="statement not covered" >t</span>his.preserveSpace=!!preserveSpace;<span class="cstat-no" title="statement not covered" >t</span>his.override=override;<span class="cstat-no" title="statement not covered" >t</span>his.generator=!!generator;}</span>;</span>var types$1=<span class="cstat-no" title="statement not covered" >{b_stat:new TokContext("{",false),b_expr:new TokContext("{",true),b_tmpl:new TokContext("${",false),p_stat:new TokContext("(",false),p_expr:new TokContext("(",true),q_tmpl:new TokContext("`",true,true,<span class="fstat-no" title="function not covered" >fu</span>nction(p){<span class="cstat-no" title="statement not covered" >return p.tryReadTemplateToken();}</span>),f_stat:new TokContext("function",false),f_expr:new TokContext("function",true),f_expr_gen:new TokContext("function",true,false,null,true),f_gen:new TokContext("function",false,false,null,true)};</span>var pp$7=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$7.initialContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[types$1.b_stat]}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$7.braceIsBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){var parent=<span class="cstat-no" title="statement not covered" >this.curContext();<span class="cstat-no" title="statement not covered" ></span>if(parent===types$1.f_expr||parent===types$1.f_stat)</span></span>
{<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >if(prevType===types.colon&amp;&amp;(parent===types$1.b_stat||parent===types$1.b_expr))</span>
{<span class="cstat-no" title="statement not covered" >return!parent.isExpr}</span>
<span class="cstat-no" title="statement not covered" >if(prevType===types._return||prevType===types.name&amp;&amp;this.exprAllowed)</span>
{<span class="cstat-no" title="statement not covered" >return lineBreak.test(this.input.slice(this.lastTokEnd,this.start))}</span>
<span class="cstat-no" title="statement not covered" >if(prevType===types._else||prevType===types.semi||prevType===types.eof||prevType===types.parenR||prevType===types.arrow)</span>
{<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >if(prevType===types.braceL)</span>
{<span class="cstat-no" title="statement not covered" >return parent===types$1.b_stat}</span>
<span class="cstat-no" title="statement not covered" >if(prevType===types._var||prevType===types.name)</span>
{<span class="cstat-no" title="statement not covered" >return false}</span>
<span class="cstat-no" title="statement not covered" >return!this.exprAllowed}</span>;<span class="cstat-no" title="statement not covered" >pp$7.inGeneratorContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i=this.context.length-1;i&gt;=1;i--){var context=<span class="cstat-no" title="statement not covered" >this$1.context[i];<span class="cstat-no" title="statement not covered" ></span>if(context.token==="function")</span></span></span>
{<span class="cstat-no" title="statement not covered" >return context.generator}</span>}
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$7.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){var update,type=<span class="cstat-no" title="statement not covered" >this.type;<span class="cstat-no" title="statement not covered" ></span>if(type.keyword&amp;&amp;prevType===types.dot)</span></span>
{<span class="cstat-no" title="statement not covered" >this.exprAllowed=false;}</span>
else <span class="cstat-no" title="statement not covered" >if(update=type.updateContext)</span>
{<span class="cstat-no" title="statement not covered" >update.call(this,prevType);}</span>
else
{<span class="cstat-no" title="statement not covered" >this.exprAllowed=type.beforeExpr;}</span>};<span class="cstat-no" title="statement not covered" >types.parenR.updateContext=types.braceR.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.context.length===1){<span class="cstat-no" title="statement not covered" >this.exprAllowed=true;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span></span></span>
var out=<span class="cstat-no" title="statement not covered" >this.context.pop();<span class="cstat-no" title="statement not covered" ></span>if(out===types$1.b_stat&amp;&amp;this.curContext().token==="function"){<span class="cstat-no" title="statement not covered" >out=this.context.pop();}</span></span>
<span class="cstat-no" title="statement not covered" >this.exprAllowed=!out.isExpr;}</span>;<span class="cstat-no" title="statement not covered" >types.braceL.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){<span class="cstat-no" title="statement not covered" >this.context.push(this.braceIsBlock(prevType)?types$1.b_stat:types$1.b_expr);<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;}</span>;<span class="cstat-no" title="statement not covered" >t</span>ypes.dollarBraceL.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.context.push(types$1.b_tmpl);<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;}</span>;<span class="cstat-no" title="statement not covered" >t</span>ypes.parenL.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){var statementParens=<span class="cstat-no" title="statement not covered" >prevType===types._if||prevType===types._for||prevType===types._with||prevType===types._while;<span class="cstat-no" title="statement not covered" ></span>this.context.push(statementParens?types$1.p_stat:types$1.p_expr);<span class="cstat-no" title="statement not covered" >t</span>his.exprAllowed=true;}</span>;<span class="cstat-no" title="statement not covered" >t</span>ypes.incDec.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" >t</span>ypes._function.updateContext=types._class.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){<span class="cstat-no" title="statement not covered" >if(prevType.beforeExpr&amp;&amp;prevType!==types.semi&amp;&amp;prevType!==types._else&amp;&amp;!((prevType===types.colon||prevType===types.braceL)&amp;&amp;this.curContext()===types$1.b_stat))</span></span>
{<span class="cstat-no" title="statement not covered" >this.context.push(types$1.f_expr);}</span>
else
{<span class="cstat-no" title="statement not covered" >this.context.push(types$1.f_stat);}</span>
<span class="cstat-no" title="statement not covered" >this.exprAllowed=false;}</span>;<span class="cstat-no" title="statement not covered" >types.backQuote.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.curContext()===types$1.q_tmpl)</span></span>
{<span class="cstat-no" title="statement not covered" >this.context.pop();}</span>
else
{<span class="cstat-no" title="statement not covered" >this.context.push(types$1.q_tmpl);}</span>
<span class="cstat-no" title="statement not covered" >this.exprAllowed=false;}</span>;<span class="cstat-no" title="statement not covered" >types.star.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){<span class="cstat-no" title="statement not covered" >if(prevType===types._function){var index=<span class="cstat-no" title="statement not covered" >this.context.length-1;<span class="cstat-no" title="statement not covered" ></span>if(this.context[index]===types$1.f_expr)</span></span></span>
{<span class="cstat-no" title="statement not covered" >this.context[index]=types$1.f_expr_gen;}</span>
else
{<span class="cstat-no" title="statement not covered" >this.context[index]=types$1.f_gen;}</span>}
<span class="cstat-no" title="statement not covered" >this.exprAllowed=true;}</span>;<span class="cstat-no" title="statement not covered" >types.name.updateContext=<span class="fstat-no" title="function not covered" >fu</span>nction(prevType){var allowed=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;prevType!==types.dot){<span class="cstat-no" title="statement not covered" >if(this.value==="of"&amp;&amp;!this.exprAllowed||this.value==="yield"&amp;&amp;this.inGeneratorContext())</span></span></span>
{<span class="cstat-no" title="statement not covered" >allowed=true;}</span>}
<span class="cstat-no" title="statement not covered" >this.exprAllowed=allowed;}</span>;var data=<span class="cstat-no" title="statement not covered" >{"$LONE":["ASCII","ASCII_Hex_Digit","AHex","Alphabetic","Alpha","Any","Assigned","Bidi_Control","Bidi_C","Bidi_Mirrored","Bidi_M","Case_Ignorable","CI","Cased","Changes_When_Casefolded","CWCF","Changes_When_Casemapped","CWCM","Changes_When_Lowercased","CWL","Changes_When_NFKC_Casefolded","CWKCF","Changes_When_Titlecased","CWT","Changes_When_Uppercased","CWU","Dash","Default_Ignorable_Code_Point","DI","Deprecated","Dep","Diacritic","Dia","Emoji","Emoji_Component","Emoji_Modifier","Emoji_Modifier_Base","Emoji_Presentation","Extender","Ext","Grapheme_Base","Gr_Base","Grapheme_Extend","Gr_Ext","Hex_Digit","Hex","IDS_Binary_Operator","IDSB","IDS_Trinary_Operator","IDST","ID_Continue","IDC","ID_Start","IDS","Ideographic","Ideo","Join_Control","Join_C","Logical_Order_Exception","LOE","Lowercase","Lower","Math","Noncharacter_Code_Point","NChar","Pattern_Syntax","Pat_Syn","Pattern_White_Space","Pat_WS","Quotation_Mark","QMark","Radical","Regional_Indicator","RI","Sentence_Terminal","STerm","Soft_Dotted","SD","Terminal_Punctuation","Term","Unified_Ideograph","UIdeo","Uppercase","Upper","Variation_Selector","VS","White_Space","space","XID_Continue","XIDC","XID_Start","XIDS"],"General_Category":["Cased_Letter","LC","Close_Punctuation","Pe","Connector_Punctuation","Pc","Control","Cc","cntrl","Currency_Symbol","Sc","Dash_Punctuation","Pd","Decimal_Number","Nd","digit","Enclosing_Mark","Me","Final_Punctuation","Pf","Format","Cf","Initial_Punctuation","Pi","Letter","L","Letter_Number","Nl","Line_Separator","Zl","Lowercase_Letter","Ll","Mark","M","Combining_Mark","Math_Symbol","Sm","Modifier_Letter","Lm","Modifier_Symbol","Sk","Nonspacing_Mark","Mn","Number","N","Open_Punctuation","Ps","Other","C","Other_Letter","Lo","Other_Number","No","Other_Punctuation","Po","Other_Symbol","So","Paragraph_Separator","Zp","Private_Use","Co","Punctuation","P","punct","Separator","Z","Space_Separator","Zs","Spacing_Mark","Mc","Surrogate","Cs","Symbol","S","Titlecase_Letter","Lt","Unassigned","Cn","Uppercase_Letter","Lu"],"Script":["Adlam","Adlm","Ahom","Anatolian_Hieroglyphs","Hluw","Arabic","Arab","Armenian","Armn","Avestan","Avst","Balinese","Bali","Bamum","Bamu","Bassa_Vah","Bass","Batak","Batk","Bengali","Beng","Bhaiksuki","Bhks","Bopomofo","Bopo","Brahmi","Brah","Braille","Brai","Buginese","Bugi","Buhid","Buhd","Canadian_Aboriginal","Cans","Carian","Cari","Caucasian_Albanian","Aghb","Chakma","Cakm","Cham","Cherokee","Cher","Common","Zyyy","Coptic","Copt","Qaac","Cuneiform","Xsux","Cypriot","Cprt","Cyrillic","Cyrl","Deseret","Dsrt","Devanagari","Deva","Duployan","Dupl","Egyptian_Hieroglyphs","Egyp","Elbasan","Elba","Ethiopic","Ethi","Georgian","Geor","Glagolitic","Glag","Gothic","Goth","Grantha","Gran","Greek","Grek","Gujarati","Gujr","Gurmukhi","Guru","Han","Hani","Hangul","Hang","Hanunoo","Hano","Hatran","Hatr","Hebrew","Hebr","Hiragana","Hira","Imperial_Aramaic","Armi","Inherited","Zinh","Qaai","Inscriptional_Pahlavi","Phli","Inscriptional_Parthian","Prti","Javanese","Java","Kaithi","Kthi","Kannada","Knda","Katakana","Kana","Kayah_Li","Kali","Kharoshthi","Khar","Khmer","Khmr","Khojki","Khoj","Khudawadi","Sind","Lao","Laoo","Latin","Latn","Lepcha","Lepc","Limbu","Limb","Linear_A","Lina","Linear_B","Linb","Lisu","Lycian","Lyci","Lydian","Lydi","Mahajani","Mahj","Malayalam","Mlym","Mandaic","Mand","Manichaean","Mani","Marchen","Marc","Masaram_Gondi","Gonm","Meetei_Mayek","Mtei","Mende_Kikakui","Mend","Meroitic_Cursive","Merc","Meroitic_Hieroglyphs","Mero","Miao","Plrd","Modi","Mongolian","Mong","Mro","Mroo","Multani","Mult","Myanmar","Mymr","Nabataean","Nbat","New_Tai_Lue","Talu","Newa","Nko","Nkoo","Nushu","Nshu","Ogham","Ogam","Ol_Chiki","Olck","Old_Hungarian","Hung","Old_Italic","Ital","Old_North_Arabian","Narb","Old_Permic","Perm","Old_Persian","Xpeo","Old_South_Arabian","Sarb","Old_Turkic","Orkh","Oriya","Orya","Osage","Osge","Osmanya","Osma","Pahawh_Hmong","Hmng","Palmyrene","Palm","Pau_Cin_Hau","Pauc","Phags_Pa","Phag","Phoenician","Phnx","Psalter_Pahlavi","Phlp","Rejang","Rjng","Runic","Runr","Samaritan","Samr","Saurashtra","Saur","Sharada","Shrd","Shavian","Shaw","Siddham","Sidd","SignWriting","Sgnw","Sinhala","Sinh","Sora_Sompeng","Sora","Soyombo","Soyo","Sundanese","Sund","Syloti_Nagri","Sylo","Syriac","Syrc","Tagalog","Tglg","Tagbanwa","Tagb","Tai_Le","Tale","Tai_Tham","Lana","Tai_Viet","Tavt","Takri","Takr","Tamil","Taml","Tangut","Tang","Telugu","Telu","Thaana","Thaa","Thai","Tibetan","Tibt","Tifinagh","Tfng","Tirhuta","Tirh","Ugaritic","Ugar","Vai","Vaii","Warang_Citi","Wara","Yi","Yiii","Zanabazar_Square","Zanb"]};<span class="cstat-no" title="statement not covered" ></span>Array.prototype.push.apply(data.$LONE,data.General_Category);<span class="cstat-no" title="statement not covered" >d</span>ata.gc=data.General_Category;<span class="cstat-no" title="statement not covered" >d</span>ata.sc=data.Script_Extensions=data.scx=data.Script;v</span>ar pp$9=<span class="cstat-no" title="statement not covered" >Parser.prototype;</span>var RegExpValidationState=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >RegExpValidationState(</span>parser){<span class="cstat-no" title="statement not covered" >this.parser=parser;<span class="cstat-no" title="statement not covered" >t</span>his.validFlags="gim"+(parser.options.ecmaVersion&gt;=6?"uy":"")+(parser.options.ecmaVersion&gt;=9?"s":"");<span class="cstat-no" title="statement not covered" >t</span>his.source="";<span class="cstat-no" title="statement not covered" >t</span>his.flags="";<span class="cstat-no" title="statement not covered" >t</span>his.start=0;<span class="cstat-no" title="statement not covered" >t</span>his.switchU=false;<span class="cstat-no" title="statement not covered" >t</span>his.switchN=false;<span class="cstat-no" title="statement not covered" >t</span>his.pos=0;<span class="cstat-no" title="statement not covered" >t</span>his.lastIntValue=0;<span class="cstat-no" title="statement not covered" >t</span>his.lastStringValue="";<span class="cstat-no" title="statement not covered" >t</span>his.lastAssertionIsQuantifiable=false;<span class="cstat-no" title="statement not covered" >t</span>his.numCapturingParens=0;<span class="cstat-no" title="statement not covered" >t</span>his.maxBackReference=0;<span class="cstat-no" title="statement not covered" >t</span>his.groupNames=[];<span class="cstat-no" title="statement not covered" >t</span>his.backReferenceNames=[];}</span>;<span class="cstat-no" title="statement not covered" ></span>RegExpValidationState.prototype.reset=function <span class="fstat-no" title="function not covered" >reset(</span>start,pattern,flags){var unicode=<span class="cstat-no" title="statement not covered" >flags.indexOf("u")!==-1;<span class="cstat-no" title="statement not covered" ></span>this.start=start|0;<span class="cstat-no" title="statement not covered" >t</span>his.source=pattern+"";<span class="cstat-no" title="statement not covered" >t</span>his.flags=flags;<span class="cstat-no" title="statement not covered" >t</span>his.switchU=unicode&amp;&amp;this.parser.options.ecmaVersion&gt;=6;<span class="cstat-no" title="statement not covered" >t</span>his.switchN=unicode&amp;&amp;this.parser.options.ecmaVersion&gt;=9;}</span>;<span class="cstat-no" title="statement not covered" >R</span>egExpValidationState.prototype.raise=function <span class="fstat-no" title="function not covered" >raise(</span>message){<span class="cstat-no" title="statement not covered" >this.parser.raiseRecoverable(this.start,("Invalid regular expression: /"+(this.source)+"/: "+message));}</span>;<span class="cstat-no" title="statement not covered" >R</span>egExpValidationState.prototype.at=function <span class="fstat-no" title="function not covered" >at(</span>i){var s=<span class="cstat-no" title="statement not covered" >this.source;</span>var l=<span class="cstat-no" title="statement not covered" >s.length;<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=l){<span class="cstat-no" title="statement not covered" >return-1}</span></span></span>
var c=<span class="cstat-no" title="statement not covered" >s.charCodeAt(i);<span class="cstat-no" title="statement not covered" ></span>if(!this.switchU||c&lt;=0xD7FF||c&gt;=0xE000||i+1&gt;=l){<span class="cstat-no" title="statement not covered" >return c}</span></span>
<span class="cstat-no" title="statement not covered" >return(c&lt;&lt;10)+s.charCodeAt(i+1)-0x35FDC00}</span>;<span class="cstat-no" title="statement not covered" >RegExpValidationState.prototype.nextIndex=function <span class="fstat-no" title="function not covered" >nextIndex(</span>i){var s=<span class="cstat-no" title="statement not covered" >this.source;</span>var l=<span class="cstat-no" title="statement not covered" >s.length;<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=l){<span class="cstat-no" title="statement not covered" >return l}</span></span></span>
var c=<span class="cstat-no" title="statement not covered" >s.charCodeAt(i);<span class="cstat-no" title="statement not covered" ></span>if(!this.switchU||c&lt;=0xD7FF||c&gt;=0xE000||i+1&gt;=l){<span class="cstat-no" title="statement not covered" >return i+1}</span></span>
<span class="cstat-no" title="statement not covered" >return i+2}</span>;<span class="cstat-no" title="statement not covered" >RegExpValidationState.prototype.current=function <span class="fstat-no" title="function not covered" >current(</span>){<span class="cstat-no" title="statement not covered" >return this.at(this.pos)}</span>;<span class="cstat-no" title="statement not covered" >R</span>egExpValidationState.prototype.lookahead=function <span class="fstat-no" title="function not covered" >lookahead(</span>){<span class="cstat-no" title="statement not covered" >return this.at(this.nextIndex(this.pos))}</span>;<span class="cstat-no" title="statement not covered" >R</span>egExpValidationState.prototype.advance=function <span class="fstat-no" title="function not covered" >advance(</span>){<span class="cstat-no" title="statement not covered" >this.pos=this.nextIndex(this.pos);}</span>;<span class="cstat-no" title="statement not covered" >R</span>egExpValidationState.prototype.eat=function <span class="fstat-no" title="function not covered" >eat(</span>ch){<span class="cstat-no" title="statement not covered" >if(this.current()===ch){<span class="cstat-no" title="statement not covered" >this.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;function <span class="fstat-no" title="function not covered" >codePointToString$1(</span>ch){<span class="cstat-no" title="statement not covered" >if(ch&lt;=0xFFFF){<span class="cstat-no" title="statement not covered" >return String.fromCharCode(ch)}</span></span>
<span class="cstat-no" title="statement not covered" >ch-=0x10000;<span class="cstat-no" title="statement not covered" >r</span>eturn String.fromCharCode((ch&gt;&gt;10)+0xD800,(ch&amp;0x03FF)+0xDC00)}</span>
<span class="cstat-no" title="statement not covered" >pp$9.validateRegExpFlags=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var validFlags=<span class="cstat-no" title="statement not covered" >state.validFlags;</span>var flags=<span class="cstat-no" title="statement not covered" >state.flags;<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;flags.length;i++){var flag=<span class="cstat-no" title="statement not covered" >flags.charAt(i);<span class="cstat-no" title="statement not covered" ></span>if(validFlags.indexOf(flag)===-1){<span class="cstat-no" title="statement not covered" >this$1.raise(state.start,"Invalid regular expression flag");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(flags.indexOf(flag,i+1)&gt;-1){<span class="cstat-no" title="statement not covered" >this$1.raise(state.start,"Duplicate regular expression flag");}</span>}</span>};<span class="cstat-no" title="statement not covered" >pp$9.validateRegExpPattern=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >this.regexp_pattern(state);<span class="cstat-no" title="statement not covered" >i</span>f(!state.switchN&amp;&amp;this.options.ecmaVersion&gt;=9&amp;&amp;state.groupNames.length&gt;0){<span class="cstat-no" title="statement not covered" >state.switchN=true;<span class="cstat-no" title="statement not covered" >t</span>his.regexp_pattern(state);}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_pattern=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >state.pos=0;<span class="cstat-no" title="statement not covered" >s</span>tate.lastIntValue=0;<span class="cstat-no" title="statement not covered" >s</span>tate.lastStringValue="";<span class="cstat-no" title="statement not covered" >s</span>tate.lastAssertionIsQuantifiable=false;<span class="cstat-no" title="statement not covered" >s</span>tate.numCapturingParens=0;<span class="cstat-no" title="statement not covered" >s</span>tate.maxBackReference=0;<span class="cstat-no" title="statement not covered" >s</span>tate.groupNames.length=0;<span class="cstat-no" title="statement not covered" >s</span>tate.backReferenceNames.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.regexp_disjunction(state);<span class="cstat-no" title="statement not covered" >i</span>f(state.pos!==state.source.length){<span class="cstat-no" title="statement not covered" >if(state.eat(0x29)){<span class="cstat-no" title="statement not covered" >state.raise("Unmatched ')'");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x5D)||state.eat(0x7D)){<span class="cstat-no" title="statement not covered" >state.raise("Lone quantifier brackets");}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(state.maxBackReference&gt;state.numCapturingParens){<span class="cstat-no" title="statement not covered" >state.raise("Invalid escape");}</span></span>
<span class="cstat-no" title="statement not covered" >for(var i=0,list=state.backReferenceNames;i&lt;list.length;i+=1){var name=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>if(state.groupNames.indexOf(name)===-1){<span class="cstat-no" title="statement not covered" >state.raise("Invalid named capture referenced");}</span>}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_disjunction=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.regexp_alternative(state);<span class="cstat-no" title="statement not covered" >w</span>hile(state.eat(0x7C)){<span class="cstat-no" title="statement not covered" >this$1.regexp_alternative(state);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.regexp_eatQuantifier(state,true)){<span class="cstat-no" title="statement not covered" >state.raise("Nothing to repeat");}</span></span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x7B)){<span class="cstat-no" title="statement not covered" >state.raise("Lone quantifier brackets");}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_alternative=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >while(state.pos&lt;state.source.length&amp;&amp;this.regexp_eatTerm(state))</span></span>
{}};<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatTerm=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatAssertion(state)){<span class="cstat-no" title="statement not covered" >if(state.lastAssertionIsQuantifiable&amp;&amp;this.regexp_eatQuantifier(state)){<span class="cstat-no" title="statement not covered" >if(state.switchU){<span class="cstat-no" title="statement not covered" >state.raise("Invalid quantifier");}</span>}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >if(state.switchU?this.regexp_eatAtom(state):this.regexp_eatExtendedAtom(state)){<span class="cstat-no" title="statement not covered" >this.regexp_eatQuantifier(state);<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatAssertion=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>state.lastAssertionIsQuantifiable=false;<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x5E)||state.eat(0x24)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x5C)){<span class="cstat-no" title="statement not covered" >if(state.eat(0x42)||state.eat(0x62)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x28)&amp;&amp;state.eat(0x3F)){var lookbehind=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=9){<span class="cstat-no" title="statement not covered" >lookbehind=state.eat(0x3C);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x3D)||state.eat(0x21)){<span class="cstat-no" title="statement not covered" >this.regexp_disjunction(state);<span class="cstat-no" title="statement not covered" >i</span>f(!state.eat(0x29)){<span class="cstat-no" title="statement not covered" >state.raise("Unterminated group");}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.lastAssertionIsQuantifiable=!lookbehind;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>}
<span class="cstat-no" title="statement not covered" >state.pos=start;<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatQuantifier=<span class="fstat-no" title="function not covered" >fu</span>nction(state,noError){<span class="cstat-no" title="statement not covered" >if(noError===void 0)<span class="cstat-no" title="statement not covered" >noError=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.regexp_eatQuantifierPrefix(state,noError)){<span class="cstat-no" title="statement not covered" >state.eat(0x3F);<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatQuantifierPrefix=<span class="fstat-no" title="function not covered" >fu</span>nction(state,noError){<span class="cstat-no" title="statement not covered" >return(state.eat(0x2A)||state.eat(0x2B)||state.eat(0x3F)||this.regexp_eatBracedQuantifier(state,noError))}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_eatBracedQuantifier=<span class="fstat-no" title="function not covered" >fu</span>nction(state,noError){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x7B)){var min=<span class="cstat-no" title="statement not covered" >0,</span>max=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if(this.regexp_eatDecimalDigits(state)){<span class="cstat-no" title="statement not covered" >min=state.lastIntValue;<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x2C)&amp;&amp;this.regexp_eatDecimalDigits(state)){<span class="cstat-no" title="statement not covered" >max=state.lastIntValue;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x7D)){<span class="cstat-no" title="statement not covered" >if(max!==-1&amp;&amp;max&lt;min&amp;&amp;!noError){<span class="cstat-no" title="statement not covered" >state.raise("numbers out of order in {} quantifier");}</span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>}
<span class="cstat-no" title="statement not covered" >if(state.switchU&amp;&amp;!noError){<span class="cstat-no" title="statement not covered" >state.raise("Incomplete quantifier");}</span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatAtom=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >return(this.regexp_eatPatternCharacters(state)||state.eat(0x2E)||this.regexp_eatReverseSolidusAtomEscape(state)||this.regexp_eatCharacterClass(state)||this.regexp_eatUncapturingGroup(state)||this.regexp_eatCapturingGroup(state))}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_eatReverseSolidusAtomEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x5C)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatAtomEscape(state)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatUncapturingGroup=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x28)){<span class="cstat-no" title="statement not covered" >if(state.eat(0x3F)&amp;&amp;state.eat(0x3A)){<span class="cstat-no" title="statement not covered" >this.regexp_disjunction(state);<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x29)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Unterminated group");}</span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatCapturingGroup=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.eat(0x28)){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9){<span class="cstat-no" title="statement not covered" >this.regexp_groupSpecifier(state);}</span>else <span class="cstat-no" title="statement not covered" >if(state.current()===0x3F){<span class="cstat-no" title="statement not covered" >state.raise("Invalid group");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >this.regexp_disjunction(state);<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x29)){<span class="cstat-no" title="statement not covered" >state.numCapturingParens+=1;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Unterminated group");}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatExtendedAtom=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >return(state.eat(0x2E)||this.regexp_eatReverseSolidusAtomEscape(state)||this.regexp_eatCharacterClass(state)||this.regexp_eatUncapturingGroup(state)||this.regexp_eatCapturingGroup(state)||this.regexp_eatInvalidBracedQuantifier(state)||this.regexp_eatExtendedPatternCharacter(state))}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_eatInvalidBracedQuantifier=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatBracedQuantifier(state,true)){<span class="cstat-no" title="statement not covered" >state.raise("Nothing to repeat");}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatSyntaxCharacter=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(isSyntaxCharacter(ch)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;function <span class="fstat-no" title="function not covered" >isSyntaxCharacter(</span>ch){<span class="cstat-no" title="statement not covered" >return(ch===0x24||ch&gt;=0x28&amp;&amp;ch&lt;=0x2B||ch===0x2E||ch===0x3F||ch&gt;=0x5B&amp;&amp;ch&lt;=0x5E||ch&gt;=0x7B&amp;&amp;ch&lt;=0x7D)}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatPatternCharacters=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;</span>var ch=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while((ch=state.current())!==-1&amp;&amp;!isSyntaxCharacter(ch)){<span class="cstat-no" title="statement not covered" >state.advance();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return state.pos!==start}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatExtendedPatternCharacter=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(ch!==-1&amp;&amp;ch!==0x24&amp;&amp;!(ch&gt;=0x28&amp;&amp;ch&lt;=0x2B)&amp;&amp;ch!==0x2E&amp;&amp;ch!==0x3F&amp;&amp;ch!==0x5B&amp;&amp;ch!==0x5E&amp;&amp;ch!==0x7C){<span class="cstat-no" title="statement not covered" >state.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_groupSpecifier=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.eat(0x3F)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatGroupName(state)){<span class="cstat-no" title="statement not covered" >if(state.groupNames.indexOf(state.lastStringValue)!==-1){<span class="cstat-no" title="statement not covered" >state.raise("Duplicate capture group name");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.groupNames.push(state.lastStringValue);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>
<span class="cstat-no" title="statement not covered" >state.raise("Invalid group");}</span>};<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatGroupName=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >state.lastStringValue="";<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x3C)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatRegExpIdentifierName(state)&amp;&amp;state.eat(0x3E)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Invalid capture group name");}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatRegExpIdentifierName=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >state.lastStringValue="";<span class="cstat-no" title="statement not covered" >i</span>f(this.regexp_eatRegExpIdentifierStart(state)){<span class="cstat-no" title="statement not covered" >state.lastStringValue+=codePointToString$1(state.lastIntValue);<span class="cstat-no" title="statement not covered" >w</span>hile(this.regexp_eatRegExpIdentifierPart(state)){<span class="cstat-no" title="statement not covered" >state.lastStringValue+=codePointToString$1(state.lastIntValue);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatRegExpIdentifierStart=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;</span>var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>state.advance();<span class="cstat-no" title="statement not covered" >i</span>f(ch===0x5C&amp;&amp;this.regexp_eatRegExpUnicodeEscapeSequence(state)){<span class="cstat-no" title="statement not covered" >ch=state.lastIntValue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(isRegExpIdentifierStart(ch)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>;function <span class="fstat-no" title="function not covered" >isRegExpIdentifierStart(</span>ch){<span class="cstat-no" title="statement not covered" >return isIdentifierStart(ch,true)||ch===0x24||ch===0x5F}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatRegExpIdentifierPart=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;</span>var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>state.advance();<span class="cstat-no" title="statement not covered" >i</span>f(ch===0x5C&amp;&amp;this.regexp_eatRegExpUnicodeEscapeSequence(state)){<span class="cstat-no" title="statement not covered" >ch=state.lastIntValue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(isRegExpIdentifierPart(ch)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>;function <span class="fstat-no" title="function not covered" >isRegExpIdentifierPart(</span>ch){<span class="cstat-no" title="statement not covered" >return isIdentifierChar(ch,true)||ch===0x24||ch===0x5F||ch===0x200C||ch===0x200D}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatAtomEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatBackReference(state)||this.regexp_eatCharacterClassEscape(state)||this.regexp_eatCharacterEscape(state)||(state.switchN&amp;&amp;this.regexp_eatKGroupName(state))){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.switchU){<span class="cstat-no" title="statement not covered" >if(state.current()===0x63){<span class="cstat-no" title="statement not covered" >state.raise("Invalid unicode escape");}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Invalid escape");}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatBackReference=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(this.regexp_eatDecimalEscape(state)){var n=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(state.switchU){<span class="cstat-no" title="statement not covered" >if(n&gt;state.maxBackReference){<span class="cstat-no" title="statement not covered" >state.maxBackReference=n;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >if(n&lt;=state.numCapturingParens){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatKGroupName=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.eat(0x6B)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatGroupName(state)){<span class="cstat-no" title="statement not covered" >state.backReferenceNames.push(state.lastStringValue);<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Invalid named reference");}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatCharacterEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >return(this.regexp_eatControlEscape(state)||this.regexp_eatCControlLetter(state)||this.regexp_eatZero(state)||this.regexp_eatHexEscapeSequence(state)||this.regexp_eatRegExpUnicodeEscapeSequence(state)||(!state.switchU&amp;&amp;this.regexp_eatLegacyOctalEscapeSequence(state))||this.regexp_eatIdentityEscape(state))}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_eatCControlLetter=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x63)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatControlLetter(state)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatZero=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.current()===0x30&amp;&amp;!isDecimalDigit(state.lookahead())){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatControlEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(ch===0x74){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x09;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(ch===0x6E){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x0A;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >if(ch===0x76){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x0B;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >if(ch===0x66){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x0C;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >if(ch===0x72){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x0D;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatControlLetter=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(isControlLetter(ch)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch%0x20;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;function <span class="fstat-no" title="function not covered" >isControlLetter(</span>ch){<span class="cstat-no" title="statement not covered" >return((ch&gt;=0x41&amp;&amp;ch&lt;=0x5A)||(ch&gt;=0x61&amp;&amp;ch&lt;=0x7A))}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatRegExpUnicodeEscapeSequence=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x75)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatFixedHexDigits(state,4)){var lead=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(state.switchU&amp;&amp;lead&gt;=0xD800&amp;&amp;lead&lt;=0xDBFF){var leadSurrogateEnd=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x5C)&amp;&amp;state.eat(0x75)&amp;&amp;this.regexp_eatFixedHexDigits(state,4)){var trail=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(trail&gt;=0xDC00&amp;&amp;trail&lt;=0xDFFF){<span class="cstat-no" title="statement not covered" >state.lastIntValue=(lead-0xD800)*0x400+(trail-0xDC00)+0x10000;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>}</span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.pos=leadSurrogateEnd;<span class="cstat-no" title="statement not covered" >s</span>tate.lastIntValue=lead;}</span>
<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >if(state.switchU&amp;&amp;state.eat(0x7B)&amp;&amp;this.regexp_eatHexDigits(state)&amp;&amp;state.eat(0x7D)&amp;&amp;isValidUnicode(state.lastIntValue)){<span class="cstat-no" title="statement not covered" >return true}</span></span>
<span class="cstat-no" title="statement not covered" >if(state.switchU){<span class="cstat-no" title="statement not covered" >state.raise("Invalid unicode escape");}</span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;function <span class="fstat-no" title="function not covered" >isValidUnicode(</span>ch){<span class="cstat-no" title="statement not covered" >return ch&gt;=0&amp;&amp;ch&lt;=0x10FFFF}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatIdentityEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.switchU){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatSyntaxCharacter(state)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.eat(0x2F)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x2F;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>
var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(ch!==0x63&amp;&amp;(!state.switchN||ch!==0x6B)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatDecimalEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0;v</span>ar ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(ch&gt;=0x31&amp;&amp;ch&lt;=0x39){<span class="cstat-no" title="statement not covered" >do{<span class="cstat-no" title="statement not covered" >state.lastIntValue=10*state.lastIntValue+(ch-0x30);<span class="cstat-no" title="statement not covered" >s</span>tate.advance();}</span>while((ch=state.current())&gt;=0x30&amp;&amp;ch&lt;=0x39)</span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatCharacterClassEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(isCharacterClassEscape(ch)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=-1;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.switchU&amp;&amp;this.options.ecmaVersion&gt;=9&amp;&amp;(ch===0x50||ch===0x70)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=-1;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x7B)&amp;&amp;this.regexp_eatUnicodePropertyValueExpression(state)&amp;&amp;state.eat(0x7D)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Invalid property name");}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;function <span class="fstat-no" title="function not covered" >isCharacterClassEscape(</span>ch){<span class="cstat-no" title="statement not covered" >return(ch===0x64||ch===0x44||ch===0x73||ch===0x53||ch===0x77||ch===0x57)}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatUnicodePropertyValueExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(this.regexp_eatUnicodePropertyName(state)&amp;&amp;state.eat(0x3D)){var name=<span class="cstat-no" title="statement not covered" >state.lastStringValue;<span class="cstat-no" title="statement not covered" ></span>if(this.regexp_eatUnicodePropertyValue(state)){var value=<span class="cstat-no" title="statement not covered" >state.lastStringValue;<span class="cstat-no" title="statement not covered" ></span>this.regexp_validateUnicodePropertyNameAndValue(state,name,value);<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;<span class="cstat-no" title="statement not covered" >i</span>f(this.regexp_eatLoneUnicodePropertyNameOrValue(state)){var nameOrValue=<span class="cstat-no" title="statement not covered" >state.lastStringValue;<span class="cstat-no" title="statement not covered" ></span>this.regexp_validateUnicodePropertyNameOrValue(state,nameOrValue);<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_validateUnicodePropertyNameAndValue=<span class="fstat-no" title="function not covered" >fu</span>nction(state,name,value){<span class="cstat-no" title="statement not covered" >if(!data.hasOwnProperty(name)||data[name].indexOf(value)===-1){<span class="cstat-no" title="statement not covered" >state.raise("Invalid property name");}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_validateUnicodePropertyNameOrValue=<span class="fstat-no" title="function not covered" >fu</span>nction(state,nameOrValue){<span class="cstat-no" title="statement not covered" >if(data.$LONE.indexOf(nameOrValue)===-1){<span class="cstat-no" title="statement not covered" >state.raise("Invalid property name");}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_eatUnicodePropertyName=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>state.lastStringValue="";<span class="cstat-no" title="statement not covered" >w</span>hile(isUnicodePropertyNameCharacter(ch=state.current())){<span class="cstat-no" title="statement not covered" >state.lastStringValue+=codePointToString$1(ch);<span class="cstat-no" title="statement not covered" >s</span>tate.advance();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return state.lastStringValue!==""}</span>;function <span class="fstat-no" title="function not covered" >isUnicodePropertyNameCharacter(</span>ch){<span class="cstat-no" title="statement not covered" >return isControlLetter(ch)||ch===0x5F}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatUnicodePropertyValue=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>state.lastStringValue="";<span class="cstat-no" title="statement not covered" >w</span>hile(isUnicodePropertyValueCharacter(ch=state.current())){<span class="cstat-no" title="statement not covered" >state.lastStringValue+=codePointToString$1(ch);<span class="cstat-no" title="statement not covered" >s</span>tate.advance();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return state.lastStringValue!==""}</span>;function <span class="fstat-no" title="function not covered" >isUnicodePropertyValueCharacter(</span>ch){<span class="cstat-no" title="statement not covered" >return isUnicodePropertyNameCharacter(ch)||isDecimalDigit(ch)}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatLoneUnicodePropertyNameOrValue=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >return this.regexp_eatUnicodePropertyValue(state)}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$9.regexp_eatCharacterClass=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(state.eat(0x5B)){<span class="cstat-no" title="statement not covered" >state.eat(0x5E);<span class="cstat-no" title="statement not covered" >t</span>his.regexp_classRanges(state);<span class="cstat-no" title="statement not covered" >i</span>f(state.eat(0x5D)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Unterminated character class");}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_classRanges=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>while(this.regexp_eatClassAtom(state)){var left=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x2D)&amp;&amp;this$1.regexp_eatClassAtom(state)){var right=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(state.switchU&amp;&amp;(left===-1||right===-1)){<span class="cstat-no" title="statement not covered" >state.raise("Invalid character class");}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(left!==-1&amp;&amp;right!==-1&amp;&amp;left&gt;right){<span class="cstat-no" title="statement not covered" >state.raise("Range out of order in character class");}</span>}</span>}};<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatClassAtom=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x5C)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatClassEscape(state)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.switchU){var ch$1=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(ch$1===0x63||isOctalDigit(ch$1)){<span class="cstat-no" title="statement not covered" >state.raise("Invalid class escape");}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.raise("Invalid escape");}</span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(ch!==0x5D){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatClassEscape=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x62)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x08;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.switchU&amp;&amp;state.eat(0x2D)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=0x2D;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span>
<span class="cstat-no" title="statement not covered" >if(!state.switchU&amp;&amp;state.eat(0x63)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatClassControlLetter(state)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return(this.regexp_eatCharacterClassEscape(state)||this.regexp_eatCharacterEscape(state))}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatClassControlLetter=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(isDecimalDigit(ch)||ch===0x5F){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch%0x20;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatHexEscapeSequence=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>if(state.eat(0x78)){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatFixedHexDigits(state,2)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >if(state.switchU){<span class="cstat-no" title="statement not covered" >state.raise("Invalid escape");}</span></span>
<span class="cstat-no" title="statement not covered" >state.pos=start;}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatDecimalDigits=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;</span>var ch=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>state.lastIntValue=0;<span class="cstat-no" title="statement not covered" >w</span>hile(isDecimalDigit(ch=state.current())){<span class="cstat-no" title="statement not covered" >state.lastIntValue=10*state.lastIntValue+(ch-0x30);<span class="cstat-no" title="statement not covered" >s</span>tate.advance();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return state.pos!==start}</span>;function <span class="fstat-no" title="function not covered" >isDecimalDigit(</span>ch){<span class="cstat-no" title="statement not covered" >return ch&gt;=0x30&amp;&amp;ch&lt;=0x39}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatHexDigits=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var start=<span class="cstat-no" title="statement not covered" >state.pos;</span>var ch=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>state.lastIntValue=0;<span class="cstat-no" title="statement not covered" >w</span>hile(isHexDigit(ch=state.current())){<span class="cstat-no" title="statement not covered" >state.lastIntValue=16*state.lastIntValue+hexToInt(ch);<span class="cstat-no" title="statement not covered" >s</span>tate.advance();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return state.pos!==start}</span>;function <span class="fstat-no" title="function not covered" >isHexDigit(</span>ch){<span class="cstat-no" title="statement not covered" >return((ch&gt;=0x30&amp;&amp;ch&lt;=0x39)||(ch&gt;=0x41&amp;&amp;ch&lt;=0x46)||(ch&gt;=0x61&amp;&amp;ch&lt;=0x66))}</span>
function <span class="fstat-no" title="function not covered" >hexToInt(</span>ch){<span class="cstat-no" title="statement not covered" >if(ch&gt;=0x41&amp;&amp;ch&lt;=0x46){<span class="cstat-no" title="statement not covered" >return 10+(ch-0x41)}</span></span>
<span class="cstat-no" title="statement not covered" >if(ch&gt;=0x61&amp;&amp;ch&lt;=0x66){<span class="cstat-no" title="statement not covered" >return 10+(ch-0x61)}</span></span>
<span class="cstat-no" title="statement not covered" >return ch-0x30}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatLegacyOctalEscapeSequence=<span class="fstat-no" title="function not covered" >fu</span>nction(state){<span class="cstat-no" title="statement not covered" >if(this.regexp_eatOctalDigit(state)){var n1=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(this.regexp_eatOctalDigit(state)){var n2=<span class="cstat-no" title="statement not covered" >state.lastIntValue;<span class="cstat-no" title="statement not covered" ></span>if(n1&lt;=3&amp;&amp;this.regexp_eatOctalDigit(state)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=n1*64+n2*8+state.lastIntValue;}</span>else{<span class="cstat-no" title="statement not covered" >state.lastIntValue=n1*8+n2;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >state.lastIntValue=n1;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>
<span class="cstat-no" title="statement not covered" >return false}</span>;<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatOctalDigit=<span class="fstat-no" title="function not covered" >fu</span>nction(state){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(isOctalDigit(ch)){<span class="cstat-no" title="statement not covered" >state.lastIntValue=ch-0x30;<span class="cstat-no" title="statement not covered" >s</span>tate.advance();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span></span></span>
<span class="cstat-no" title="statement not covered" >state.lastIntValue=0;<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>;function <span class="fstat-no" title="function not covered" >isOctalDigit(</span>ch){<span class="cstat-no" title="statement not covered" >return ch&gt;=0x30&amp;&amp;ch&lt;=0x37}</span>
<span class="cstat-no" title="statement not covered" >pp$9.regexp_eatFixedHexDigits=<span class="fstat-no" title="function not covered" >fu</span>nction(state,length){var start=<span class="cstat-no" title="statement not covered" >state.pos;<span class="cstat-no" title="statement not covered" ></span>state.lastIntValue=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;length;++i){var ch=<span class="cstat-no" title="statement not covered" >state.current();<span class="cstat-no" title="statement not covered" ></span>if(!isHexDigit(ch)){<span class="cstat-no" title="statement not covered" >state.pos=start;<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >state.lastIntValue=16*state.lastIntValue+hexToInt(ch);<span class="cstat-no" title="statement not covered" >s</span>tate.advance();}</span>
<span class="cstat-no" title="statement not covered" >return true}</span>;var Token=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >Token(</span>p){<span class="cstat-no" title="statement not covered" >this.type=p.type;<span class="cstat-no" title="statement not covered" >t</span>his.value=p.value;<span class="cstat-no" title="statement not covered" >t</span>his.start=p.start;<span class="cstat-no" title="statement not covered" >t</span>his.end=p.end;<span class="cstat-no" title="statement not covered" >i</span>f(p.options.locations)</span></span>
{<span class="cstat-no" title="statement not covered" >this.loc=new SourceLocation(p,p.startLoc,p.endLoc);}</span>
<span class="cstat-no" title="statement not covered" >if(p.options.ranges)</span>
{<span class="cstat-no" title="statement not covered" >this.range=[p.start,p.end];}</span>};var pp$8=<span class="cstat-no" title="statement not covered" >Parser.prototype;<span class="cstat-no" title="statement not covered" ></span>pp$8.next=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.options.onToken)</span></span>
{<span class="cstat-no" title="statement not covered" >this.options.onToken(new Token(this));}</span>
<span class="cstat-no" title="statement not covered" >this.lastTokEnd=this.end;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokStart=this.start;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokEndLoc=this.endLoc;<span class="cstat-no" title="statement not covered" >t</span>his.lastTokStartLoc=this.startLoc;<span class="cstat-no" title="statement not covered" >t</span>his.nextToken();}</span>;<span class="cstat-no" title="statement not covered" >pp$8.getToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn new Token(this)}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(typeof Symbol!=="undefined")</span>
{<span class="cstat-no" title="statement not covered" >pp$8[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return{next:<span class="fstat-no" title="function not covered" >fu</span>nction(){var token=<span class="cstat-no" title="statement not covered" >this$1.getToken();<span class="cstat-no" title="statement not covered" ></span>return{done:token.type===types.eof,value:token}}</span>}}</span>;}</span>
<span class="cstat-no" title="statement not covered" >pp$8.curContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.context[this.context.length-1]}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$8.nextToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){var curContext=<span class="cstat-no" title="statement not covered" >this.curContext();<span class="cstat-no" title="statement not covered" ></span>if(!curContext||!curContext.preserveSpace){<span class="cstat-no" title="statement not covered" >this.skipSpace();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.start=this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >this.startLoc=this.curPosition();}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.pos&gt;=this.input.length){<span class="cstat-no" title="statement not covered" >return this.finishToken(types.eof)}</span></span>
<span class="cstat-no" title="statement not covered" >if(curContext.override){<span class="cstat-no" title="statement not covered" >return curContext.override(this)}</span></span>
else{<span class="cstat-no" title="statement not covered" >this.readToken(this.fullCharCodeAtPos());}</span>};<span class="cstat-no" title="statement not covered" >pp$8.readToken=<span class="fstat-no" title="function not covered" >fu</span>nction(code){<span class="cstat-no" title="statement not covered" >if(isIdentifierStart(code,this.options.ecmaVersion&gt;=6)||code===92)</span></span>
{<span class="cstat-no" title="statement not covered" >return this.readWord()}</span>
<span class="cstat-no" title="statement not covered" >return this.getTokenFromCode(code)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.fullCharCodeAtPos=<span class="fstat-no" title="function not covered" >fu</span>nction(){var code=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" ></span>if(code&lt;=0xd7ff||code&gt;=0xe000){<span class="cstat-no" title="statement not covered" >return code}</span></span></span>
var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>return(code&lt;&lt;10)+next-0x35fdc00}</span>;<span class="cstat-no" title="statement not covered" >pp$8.skipBlockComment=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var startLoc=<span class="cstat-no" title="statement not covered" >this.options.onComment&amp;&amp;this.curPosition();</span>var start=<span class="cstat-no" title="statement not covered" >this.pos,</span>end=<span class="cstat-no" title="statement not covered" >this.input.indexOf("*/",this.pos+=2);<span class="cstat-no" title="statement not covered" ></span>if(end===-1){<span class="cstat-no" title="statement not covered" >this.raise(this.pos-2,"Unterminated comment");}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.pos=end+2;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >lineBreakG.lastIndex=start;v</span>ar match;<span class="cstat-no" title="statement not covered" >while((match=lineBreakG.exec(this.input))&amp;&amp;match.index&lt;this.pos){<span class="cstat-no" title="statement not covered" >++this$1.curLine;<span class="cstat-no" title="statement not covered" >t</span>his$1.lineStart=match.index+match[0].length;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.onComment)</span>
{<span class="cstat-no" title="statement not covered" >this.options.onComment(true,this.input.slice(start+2,end),start,this.pos,startLoc,this.curPosition());}</span>};<span class="cstat-no" title="statement not covered" >pp$8.skipLineComment=<span class="fstat-no" title="function not covered" >fu</span>nction(startSkip){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var start=<span class="cstat-no" title="statement not covered" >this.pos;</span>var startLoc=<span class="cstat-no" title="statement not covered" >this.options.onComment&amp;&amp;this.curPosition();</span>var ch=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+=startSkip);<span class="cstat-no" title="statement not covered" ></span>while(this.pos&lt;this.input.length&amp;&amp;!isNewLine(ch)){<span class="cstat-no" title="statement not covered" >ch=this$1.input.charCodeAt(++this$1.pos);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.onComment)</span>
{<span class="cstat-no" title="statement not covered" >this.options.onComment(false,this.input.slice(start+startSkip,this.pos),start,this.pos,startLoc,this.curPosition());}</span>};<span class="cstat-no" title="statement not covered" >pp$8.skipSpace=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>loop:<span class="cstat-no" title="statement not covered" >while(this.pos&lt;this.input.length){var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(this$1.pos);<span class="cstat-no" title="statement not covered" ></span>switch(ch){case 32:case 160:<span class="cstat-no" title="statement not covered" >++this$1.pos;<span class="cstat-no" title="statement not covered" >b</span>reak</span></span></span></span></span>
case 13:<span class="cstat-no" title="statement not covered" >if(this$1.input.charCodeAt(this$1.pos+1)===10){<span class="cstat-no" title="statement not covered" >++this$1.pos;}</span></span>
case 10:case 8232:case 8233:<span class="cstat-no" title="statement not covered" >++this$1.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this$1.options.locations){<span class="cstat-no" title="statement not covered" >++this$1.curLine;<span class="cstat-no" title="statement not covered" >t</span>his$1.lineStart=this$1.pos;}</span></span>
<span class="cstat-no" title="statement not covered" >break</span>
case 47:<span class="cstat-no" title="statement not covered" >switch(this$1.input.charCodeAt(this$1.pos+1)){case 42:<span class="cstat-no" title="statement not covered" >this$1.skipBlockComment();<span class="cstat-no" title="statement not covered" >b</span>reak</span></span>
case 47:<span class="cstat-no" title="statement not covered" >this$1.skipLineComment(2);<span class="cstat-no" title="statement not covered" >b</span>reak</span>
default:<span class="cstat-no" title="statement not covered" >break loop}</span>
<span class="cstat-no" title="statement not covered" >break</span>
default:<span class="cstat-no" title="statement not covered" >if(ch&gt;8&amp;&amp;ch&lt;14||ch&gt;=5760&amp;&amp;nonASCIIwhitespace.test(String.fromCharCode(ch))){<span class="cstat-no" title="statement not covered" >++this$1.pos;}</span>else{<span class="cstat-no" title="statement not covered" >break loop}</span>}</span>}};<span class="cstat-no" title="statement not covered" >pp$8.finishToken=<span class="fstat-no" title="function not covered" >fu</span>nction(type,val){<span class="cstat-no" title="statement not covered" >this.end=this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >this.endLoc=this.curPosition();}</span></span></span>
var prevType=<span class="cstat-no" title="statement not covered" >this.type;<span class="cstat-no" title="statement not covered" ></span>this.type=type;<span class="cstat-no" title="statement not covered" >t</span>his.value=val;<span class="cstat-no" title="statement not covered" >t</span>his.updateContext(prevType);}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_dot=<span class="fstat-no" title="function not covered" >fu</span>nction(){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(next&gt;=48&amp;&amp;next&lt;=57){<span class="cstat-no" title="statement not covered" >return this.readNumber(true)}</span></span></span>
var next2=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+2);<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;next===46&amp;&amp;next2===46){<span class="cstat-no" title="statement not covered" >this.pos+=3;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.ellipsis)}</span>else{<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.dot)}</span>}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_slash=<span class="fstat-no" title="function not covered" >fu</span>nction(){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(this.exprAllowed){<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.readRegexp()}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(next===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.assign,2)}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(types.slash,1)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_mult_modulo_exp=<span class="fstat-no" title="function not covered" >fu</span>nction(code){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);</span>var size=<span class="cstat-no" title="statement not covered" >1;</span>var tokentype=<span class="cstat-no" title="statement not covered" >code===42?types.star:types.modulo;<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=7&amp;&amp;code===42&amp;&amp;next===42){<span class="cstat-no" title="statement not covered" >++size;<span class="cstat-no" title="statement not covered" >t</span>okentype=types.starstar;<span class="cstat-no" title="statement not covered" >n</span>ext=this.input.charCodeAt(this.pos+2);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(next===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.assign,size+1)}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(tokentype,size)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_pipe_amp=<span class="fstat-no" title="function not covered" >fu</span>nction(code){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(next===code){<span class="cstat-no" title="statement not covered" >return this.finishOp(code===124?types.logicalOR:types.logicalAND,2)}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(next===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.assign,2)}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(code===124?types.bitwiseOR:types.bitwiseAND,1)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_caret=<span class="fstat-no" title="function not covered" >fu</span>nction(){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(next===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.assign,2)}</span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(types.bitwiseXOR,1)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_plus_min=<span class="fstat-no" title="function not covered" >fu</span>nction(code){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(next===code){<span class="cstat-no" title="statement not covered" >if(next===45&amp;&amp;!this.inModule&amp;&amp;this.input.charCodeAt(this.pos+2)===62&amp;&amp;(this.lastTokEnd===0||lineBreak.test(this.input.slice(this.lastTokEnd,this.pos)))){<span class="cstat-no" title="statement not covered" >this.skipLineComment(3);<span class="cstat-no" title="statement not covered" >t</span>his.skipSpace();<span class="cstat-no" title="statement not covered" >r</span>eturn this.nextToken()}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(types.incDec,2)}</span>
<span class="cstat-no" title="statement not covered" >if(next===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.assign,2)}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(types.plusMin,1)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_lt_gt=<span class="fstat-no" title="function not covered" >fu</span>nction(code){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);</span>var size=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(next===code){<span class="cstat-no" title="statement not covered" >size=code===62&amp;&amp;this.input.charCodeAt(this.pos+2)===62?3:2;<span class="cstat-no" title="statement not covered" >i</span>f(this.input.charCodeAt(this.pos+size)===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.assign,size+1)}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(types.bitShift,size)}</span>
<span class="cstat-no" title="statement not covered" >if(next===33&amp;&amp;code===60&amp;&amp;!this.inModule&amp;&amp;this.input.charCodeAt(this.pos+2)===45&amp;&amp;this.input.charCodeAt(this.pos+3)===45){<span class="cstat-no" title="statement not covered" >this.skipLineComment(4);<span class="cstat-no" title="statement not covered" >t</span>his.skipSpace();<span class="cstat-no" title="statement not covered" >r</span>eturn this.nextToken()}</span></span>
<span class="cstat-no" title="statement not covered" >if(next===61){<span class="cstat-no" title="statement not covered" >size=2;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(types.relational,size)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readToken_eq_excl=<span class="fstat-no" title="function not covered" >fu</span>nction(code){var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(next===61){<span class="cstat-no" title="statement not covered" >return this.finishOp(types.equality,this.input.charCodeAt(this.pos+2)===61?3:2)}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(code===61&amp;&amp;next===62&amp;&amp;this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >this.pos+=2;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.arrow)}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishOp(code===61?types.eq:types.prefix,1)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.getTokenFromCode=<span class="fstat-no" title="function not covered" >fu</span>nction(code){<span class="cstat-no" title="statement not covered" >switch(code){case 46:<span class="cstat-no" title="statement not covered" >return this.readToken_dot()</span></span></span>
case 40:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.parenL)</span>
case 41:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.parenR)</span>
case 59:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.semi)</span>
case 44:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.comma)</span>
case 91:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.bracketL)</span>
case 93:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.bracketR)</span>
case 123:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.braceL)</span>
case 125:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.braceR)</span>
case 58:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.colon)</span>
case 63:<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.question)</span>
case 96:<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6){<span class="cstat-no" title="statement not covered" >break}</span></span>
<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.backQuote)</span>
case 48:var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos+1);<span class="cstat-no" title="statement not covered" ></span>if(next===120||next===88){<span class="cstat-no" title="statement not covered" >return this.readRadixNumber(16)}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(next===111||next===79){<span class="cstat-no" title="statement not covered" >return this.readRadixNumber(8)}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(next===98||next===66){<span class="cstat-no" title="statement not covered" >return this.readRadixNumber(2)}</span>}</span>
case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:<span class="cstat-no" title="statement not covered" >return this.readNumber(false)</span>
case 34:case 39:<span class="cstat-no" title="statement not covered" >return this.readString(code)</span>
case 47:<span class="cstat-no" title="statement not covered" >return this.readToken_slash()</span>
case 37:case 42:<span class="cstat-no" title="statement not covered" >return this.readToken_mult_modulo_exp(code)</span>
case 124:case 38:<span class="cstat-no" title="statement not covered" >return this.readToken_pipe_amp(code)</span>
case 94:<span class="cstat-no" title="statement not covered" >return this.readToken_caret()</span>
case 43:case 45:<span class="cstat-no" title="statement not covered" >return this.readToken_plus_min(code)</span>
case 60:case 62:<span class="cstat-no" title="statement not covered" >return this.readToken_lt_gt(code)</span>
case 61:case 33:<span class="cstat-no" title="statement not covered" >return this.readToken_eq_excl(code)</span>
case 126:<span class="cstat-no" title="statement not covered" >return this.finishOp(types.prefix,1)}</span>
<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'");}</span>;<span class="cstat-no" title="statement not covered" >pp$8.finishOp=<span class="fstat-no" title="function not covered" >fu</span>nction(type,size){var str=<span class="cstat-no" title="statement not covered" >this.input.slice(this.pos,this.pos+size);<span class="cstat-no" title="statement not covered" ></span>this.pos+=size;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(type,str)}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$8.readRegexp=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var escaped,inClass,start=<span class="cstat-no" title="statement not covered" >this.pos;<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >if(this$1.pos&gt;=this$1.input.length){<span class="cstat-no" title="statement not covered" >this$1.raise(start,"Unterminated regular expression");}</span></span></span></span>
var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charAt(this$1.pos);<span class="cstat-no" title="statement not covered" ></span>if(lineBreak.test(ch)){<span class="cstat-no" title="statement not covered" >this$1.raise(start,"Unterminated regular expression");}</span></span>
<span class="cstat-no" title="statement not covered" >if(!escaped){<span class="cstat-no" title="statement not covered" >if(ch==="["){<span class="cstat-no" title="statement not covered" >inClass=true;}</span></span></span>
else <span class="cstat-no" title="statement not covered" >if(ch==="]"&amp;&amp;inClass){<span class="cstat-no" title="statement not covered" >inClass=false;}</span></span>
else <span class="cstat-no" title="statement not covered" >if(ch==="/"&amp;&amp;!inClass){<span class="cstat-no" title="statement not covered" >break}</span></span>
<span class="cstat-no" title="statement not covered" >escaped=ch==="\\";}</span>else{<span class="cstat-no" title="statement not covered" >escaped=false;}</span>
<span class="cstat-no" title="statement not covered" >++this$1.pos;}</span>
var pattern=<span class="cstat-no" title="statement not covered" >this.input.slice(start,this.pos);<span class="cstat-no" title="statement not covered" ></span>++this.pos;v</span>ar flagsStart=<span class="cstat-no" title="statement not covered" >this.pos;</span>var flags=<span class="cstat-no" title="statement not covered" >this.readWord1();<span class="cstat-no" title="statement not covered" ></span>if(this.containsEsc){<span class="cstat-no" title="statement not covered" >this.unexpected(flagsStart);}</span></span>
var state=<span class="cstat-no" title="statement not covered" >this.regexpState||(this.regexpState=new RegExpValidationState(this));<span class="cstat-no" title="statement not covered" ></span>state.reset(start,pattern,flags);<span class="cstat-no" title="statement not covered" >t</span>his.validateRegExpFlags(state);<span class="cstat-no" title="statement not covered" >t</span>his.validateRegExpPattern(state);v</span>ar value=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >value=new RegExp(pattern,flags);}</span>catch(e){}</span>
<span class="cstat-no" title="statement not covered" >return this.finishToken(types.regexp,{pattern:pattern,flags:flags,value:value})}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readInt=<span class="fstat-no" title="function not covered" >fu</span>nction(radix,len){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var start=<span class="cstat-no" title="statement not covered" >this.pos,</span>total=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var i=0,e=len==null?Infinity:len;i&lt;e;++i){var code=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(this$1.pos),</span>val=(<span class="cstat-no" title="statement not covered" >void 0)</span>;<span class="cstat-no" title="statement not covered" >if(code&gt;=97){<span class="cstat-no" title="statement not covered" >val=code-97+10;}</span></span></span></span>
else <span class="cstat-no" title="statement not covered" >if(code&gt;=65){<span class="cstat-no" title="statement not covered" >val=code-65+10;}</span></span>
else <span class="cstat-no" title="statement not covered" >if(code&gt;=48&amp;&amp;code&lt;=57){<span class="cstat-no" title="statement not covered" >val=code-48;}</span></span>
else{<span class="cstat-no" title="statement not covered" >val=Infinity;}</span>
<span class="cstat-no" title="statement not covered" >if(val&gt;=radix){<span class="cstat-no" title="statement not covered" >break}</span></span>
<span class="cstat-no" title="statement not covered" >++this$1.pos;<span class="cstat-no" title="statement not covered" >t</span>otal=total*radix+val;}</span>
<span class="cstat-no" title="statement not covered" >if(this.pos===start||len!=null&amp;&amp;this.pos-start!==len){<span class="cstat-no" title="statement not covered" >return null}</span></span>
<span class="cstat-no" title="statement not covered" >return total}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readRadixNumber=<span class="fstat-no" title="function not covered" >fu</span>nction(radix){<span class="cstat-no" title="statement not covered" >this.pos+=2;v</span>ar val=<span class="cstat-no" title="statement not covered" >this.readInt(radix);<span class="cstat-no" title="statement not covered" ></span>if(val==null){<span class="cstat-no" title="statement not covered" >this.raise(this.start+2,"Expected number in radix "+radix);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(isIdentifierStart(this.fullCharCodeAtPos())){<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Identifier directly after number");}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishToken(types.num,val)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readNumber=<span class="fstat-no" title="function not covered" >fu</span>nction(startsWithDot){var start=<span class="cstat-no" title="statement not covered" >this.pos;<span class="cstat-no" title="statement not covered" ></span>if(!startsWithDot&amp;&amp;this.readInt(10)===null){<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid number");}</span></span></span>
var octal=<span class="cstat-no" title="statement not covered" >this.pos-start&gt;=2&amp;&amp;this.input.charCodeAt(start)===48;<span class="cstat-no" title="statement not covered" ></span>if(octal&amp;&amp;this.strict){<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid number");}</span></span>
<span class="cstat-no" title="statement not covered" >if(octal&amp;&amp;/[89]/.test(this.input.slice(start,this.pos))){<span class="cstat-no" title="statement not covered" >octal=false;}</span></span>
var next=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" ></span>if(next===46&amp;&amp;!octal){<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" >t</span>his.readInt(10);<span class="cstat-no" title="statement not covered" >n</span>ext=this.input.charCodeAt(this.pos);}</span></span>
<span class="cstat-no" title="statement not covered" >if((next===69||next===101)&amp;&amp;!octal){<span class="cstat-no" title="statement not covered" >next=this.input.charCodeAt(++this.pos);<span class="cstat-no" title="statement not covered" >i</span>f(next===43||next===45){<span class="cstat-no" title="statement not covered" >++this.pos;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.readInt(10)===null){<span class="cstat-no" title="statement not covered" >this.raise(start,"Invalid number");}</span>}</span>
<span class="cstat-no" title="statement not covered" >if(isIdentifierStart(this.fullCharCodeAtPos())){<span class="cstat-no" title="statement not covered" >this.raise(this.pos,"Identifier directly after number");}</span></span>
var str=<span class="cstat-no" title="statement not covered" >this.input.slice(start,this.pos);</span>var val=<span class="cstat-no" title="statement not covered" >octal?parseInt(str,8):parseFloat(str);<span class="cstat-no" title="statement not covered" ></span>return this.finishToken(types.num,val)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readCodePoint=<span class="fstat-no" title="function not covered" >fu</span>nction(){var ch=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(this.pos),</span>code;<span class="cstat-no" title="statement not covered" >if(ch===123){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6){<span class="cstat-no" title="statement not covered" >this.unexpected();}</span></span></span></span>
var codePos=<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" ></span>code=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos);<span class="cstat-no" title="statement not covered" >+</span>+this.pos;<span class="cstat-no" title="statement not covered" >i</span>f(code&gt;0x10FFFF){<span class="cstat-no" title="statement not covered" >this.invalidStringToken(codePos,"Code point out of bounds");}</span>}</span>else{<span class="cstat-no" title="statement not covered" >code=this.readHexChar(4);}</span>
<span class="cstat-no" title="statement not covered" >return code}</span>;function <span class="fstat-no" title="function not covered" >codePointToString(</span>code){<span class="cstat-no" title="statement not covered" >if(code&lt;=0xFFFF){<span class="cstat-no" title="statement not covered" >return String.fromCharCode(code)}</span></span>
<span class="cstat-no" title="statement not covered" >code-=0x10000;<span class="cstat-no" title="statement not covered" >r</span>eturn String.fromCharCode((code&gt;&gt;10)+0xD800,(code&amp;1023)+0xDC00)}</span>
<span class="cstat-no" title="statement not covered" >pp$8.readString=<span class="fstat-no" title="function not covered" >fu</span>nction(quote){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var out=<span class="cstat-no" title="statement not covered" >"",</span>chunkStart=<span class="cstat-no" title="statement not covered" >++this.pos;<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >if(this$1.pos&gt;=this$1.input.length){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.start,"Unterminated string constant");}</span></span></span></span>
var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(this$1.pos);<span class="cstat-no" title="statement not covered" ></span>if(ch===quote){<span class="cstat-no" title="statement not covered" >break}</span></span>
<span class="cstat-no" title="statement not covered" >if(ch===92){<span class="cstat-no" title="statement not covered" >out+=this$1.input.slice(chunkStart,this$1.pos);<span class="cstat-no" title="statement not covered" >o</span>ut+=this$1.readEscapedChar(false);<span class="cstat-no" title="statement not covered" >c</span>hunkStart=this$1.pos;}</span>else{<span class="cstat-no" title="statement not covered" >if(isNewLine(ch,this$1.options.ecmaVersion&gt;=10)){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.start,"Unterminated string constant");}</span></span></span>
<span class="cstat-no" title="statement not covered" >++this$1.pos;}</span>}
<span class="cstat-no" title="statement not covered" >out+=this.input.slice(chunkStart,this.pos++);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishToken(types.string,out)}</span>;var INVALID_TEMPLATE_ESCAPE_ERROR=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pp$8.tryReadTemplateToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.inTemplateElement=true;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.readTmplToken();}</span>catch(err){<span class="cstat-no" title="statement not covered" >if(err===INVALID_TEMPLATE_ESCAPE_ERROR){<span class="cstat-no" title="statement not covered" >this.readInvalidTemplateToken();}</span>else{<span class="cstat-no" title="statement not covered" >throw err}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.inTemplateElement=false;}</span>;<span class="cstat-no" title="statement not covered" >pp$8.invalidStringToken=<span class="fstat-no" title="function not covered" >fu</span>nction(position,message){<span class="cstat-no" title="statement not covered" >if(this.inTemplateElement&amp;&amp;this.options.ecmaVersion&gt;=9){<span class="cstat-no" title="statement not covered" >throw INVALID_TEMPLATE_ESCAPE_ERROR}</span>else{<span class="cstat-no" title="statement not covered" >this.raise(position,message);}</span>}</span>;<span class="cstat-no" title="statement not covered" >p</span>p$8.readTmplToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var out=<span class="cstat-no" title="statement not covered" >"",</span>chunkStart=<span class="cstat-no" title="statement not covered" >this.pos;<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >if(this$1.pos&gt;=this$1.input.length){<span class="cstat-no" title="statement not covered" >this$1.raise(this$1.start,"Unterminated template");}</span></span></span></span>
var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(this$1.pos);<span class="cstat-no" title="statement not covered" ></span>if(ch===96||ch===36&amp;&amp;this$1.input.charCodeAt(this$1.pos+1)===123){<span class="cstat-no" title="statement not covered" >if(this$1.pos===this$1.start&amp;&amp;(this$1.type===types.template||this$1.type===types.invalidTemplate)){<span class="cstat-no" title="statement not covered" >if(ch===36){<span class="cstat-no" title="statement not covered" >this$1.pos+=2;<span class="cstat-no" title="statement not covered" >r</span>eturn this$1.finishToken(types.dollarBraceL)}</span>else{<span class="cstat-no" title="statement not covered" >++this$1.pos;<span class="cstat-no" title="statement not covered" >r</span>eturn this$1.finishToken(types.backQuote)}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >out+=this$1.input.slice(chunkStart,this$1.pos);<span class="cstat-no" title="statement not covered" >r</span>eturn this$1.finishToken(types.template,out)}</span>
<span class="cstat-no" title="statement not covered" >if(ch===92){<span class="cstat-no" title="statement not covered" >out+=this$1.input.slice(chunkStart,this$1.pos);<span class="cstat-no" title="statement not covered" >o</span>ut+=this$1.readEscapedChar(true);<span class="cstat-no" title="statement not covered" >c</span>hunkStart=this$1.pos;}</span>else <span class="cstat-no" title="statement not covered" >if(isNewLine(ch)){<span class="cstat-no" title="statement not covered" >out+=this$1.input.slice(chunkStart,this$1.pos);<span class="cstat-no" title="statement not covered" >+</span>+this$1.pos;<span class="cstat-no" title="statement not covered" >s</span>witch(ch){case 13:<span class="cstat-no" title="statement not covered" >if(this$1.input.charCodeAt(this$1.pos)===10){<span class="cstat-no" title="statement not covered" >++this$1.pos;}</span></span></span></span></span>
case 10:<span class="cstat-no" title="statement not covered" >out+="\n";<span class="cstat-no" title="statement not covered" >b</span>reak</span>
default:<span class="cstat-no" title="statement not covered" >out+=String.fromCharCode(ch);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>
<span class="cstat-no" title="statement not covered" >if(this$1.options.locations){<span class="cstat-no" title="statement not covered" >++this$1.curLine;<span class="cstat-no" title="statement not covered" >t</span>his$1.lineStart=this$1.pos;}</span></span>
<span class="cstat-no" title="statement not covered" >chunkStart=this$1.pos;}</span>else{<span class="cstat-no" title="statement not covered" >++this$1.pos;}</span>}};<span class="cstat-no" title="statement not covered" >pp$8.readInvalidTemplateToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;this.pos&lt;this.input.length;this.pos++){<span class="cstat-no" title="statement not covered" >switch(this$1.input[this$1.pos]){case"\\":<span class="cstat-no" title="statement not covered" >++this$1.pos;<span class="cstat-no" title="statement not covered" >b</span>reak</span></span></span></span>
case"$":<span class="cstat-no" title="statement not covered" >if(this$1.input[this$1.pos+1]!=="{"){<span class="cstat-no" title="statement not covered" >break}</span></span>
case"`":<span class="cstat-no" title="statement not covered" >return this$1.finishToken(types.invalidTemplate,this$1.input.slice(this$1.start,this$1.pos))}</span>}
<span class="cstat-no" title="statement not covered" >this.raise(this.start,"Unterminated template");}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readEscapedChar=<span class="fstat-no" title="function not covered" >fu</span>nction(inTemplate){var ch=<span class="cstat-no" title="statement not covered" >this.input.charCodeAt(++this.pos);<span class="cstat-no" title="statement not covered" ></span>++this.pos;<span class="cstat-no" title="statement not covered" >s</span>witch(ch){case 110:<span class="cstat-no" title="statement not covered" >return"\n"</span></span></span>
case 114:<span class="cstat-no" title="statement not covered" >return"\r"</span>
case 120:<span class="cstat-no" title="statement not covered" >return String.fromCharCode(this.readHexChar(2))</span>
case 117:<span class="cstat-no" title="statement not covered" >return codePointToString(this.readCodePoint())</span>
case 116:<span class="cstat-no" title="statement not covered" >return"\t"</span>
case 98:<span class="cstat-no" title="statement not covered" >return"\b"</span>
case 118:<span class="cstat-no" title="statement not covered" >return"\u000b"</span>
case 102:<span class="cstat-no" title="statement not covered" >return"\f"</span>
case 13:<span class="cstat-no" title="statement not covered" >if(this.input.charCodeAt(this.pos)===10){<span class="cstat-no" title="statement not covered" >++this.pos;}</span></span>
case 10:<span class="cstat-no" title="statement not covered" >if(this.options.locations){<span class="cstat-no" title="statement not covered" >this.lineStart=this.pos;<span class="cstat-no" title="statement not covered" >+</span>+this.curLine;}</span></span>
<span class="cstat-no" title="statement not covered" >return""</span>
default:<span class="cstat-no" title="statement not covered" >if(ch&gt;=48&amp;&amp;ch&lt;=55){var octalStr=<span class="cstat-no" title="statement not covered" >this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0];</span>var octal=<span class="cstat-no" title="statement not covered" >parseInt(octalStr,8);<span class="cstat-no" title="statement not covered" ></span>if(octal&gt;255){<span class="cstat-no" title="statement not covered" >octalStr=octalStr.slice(0,-1);<span class="cstat-no" title="statement not covered" >o</span>ctal=parseInt(octalStr,8);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.pos+=octalStr.length-1;<span class="cstat-no" title="statement not covered" >c</span>h=this.input.charCodeAt(this.pos);<span class="cstat-no" title="statement not covered" >i</span>f((octalStr!=="0"||ch===56||ch===57)&amp;&amp;(this.strict||inTemplate)){<span class="cstat-no" title="statement not covered" >this.invalidStringToken(this.pos-1-octalStr.length,inTemplate?"Octal literal in template string":"Octal literal in strict mode");}</span></span>
<span class="cstat-no" title="statement not covered" >return String.fromCharCode(octal)}</span>
<span class="cstat-no" title="statement not covered" >return String.fromCharCode(ch)}</span>};<span class="cstat-no" title="statement not covered" >pp$8.readHexChar=<span class="fstat-no" title="function not covered" >fu</span>nction(len){var codePos=<span class="cstat-no" title="statement not covered" >this.pos;</span>var n=<span class="cstat-no" title="statement not covered" >this.readInt(16,len);<span class="cstat-no" title="statement not covered" ></span>if(n===null){<span class="cstat-no" title="statement not covered" >this.invalidStringToken(codePos,"Bad character escape sequence");}</span></span></span>
<span class="cstat-no" title="statement not covered" >return n}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readWord1=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.containsEsc=false;v</span>ar word=<span class="cstat-no" title="statement not covered" >"",</span>first=<span class="cstat-no" title="statement not covered" >true,</span>chunkStart=<span class="cstat-no" title="statement not covered" >this.pos;</span>var astral=<span class="cstat-no" title="statement not covered" >this.options.ecmaVersion&gt;=6;<span class="cstat-no" title="statement not covered" ></span>while(this.pos&lt;this.input.length){var ch=<span class="cstat-no" title="statement not covered" >this$1.fullCharCodeAtPos();<span class="cstat-no" title="statement not covered" ></span>if(isIdentifierChar(ch,astral)){<span class="cstat-no" title="statement not covered" >this$1.pos+=ch&lt;=0xffff?1:2;}</span>else <span class="cstat-no" title="statement not covered" >if(ch===92){<span class="cstat-no" title="statement not covered" >this$1.containsEsc=true;<span class="cstat-no" title="statement not covered" >w</span>ord+=this$1.input.slice(chunkStart,this$1.pos);v</span>ar escStart=<span class="cstat-no" title="statement not covered" >this$1.pos;<span class="cstat-no" title="statement not covered" ></span>if(this$1.input.charCodeAt(++this$1.pos)!==117)</span></span></span></span></span>
{<span class="cstat-no" title="statement not covered" >this$1.invalidStringToken(this$1.pos,"Expecting Unicode escape sequence \\uXXXX");}</span>
<span class="cstat-no" title="statement not covered" >++this$1.pos;v</span>ar esc=<span class="cstat-no" title="statement not covered" >this$1.readCodePoint();<span class="cstat-no" title="statement not covered" ></span>if(!(first?isIdentifierStart:isIdentifierChar)(esc,astral))</span>
{<span class="cstat-no" title="statement not covered" >this$1.invalidStringToken(escStart,"Invalid Unicode escape");}</span>
<span class="cstat-no" title="statement not covered" >word+=codePointToString(esc);<span class="cstat-no" title="statement not covered" >c</span>hunkStart=this$1.pos;}</span>else{<span class="cstat-no" title="statement not covered" >break}</span>
<span class="cstat-no" title="statement not covered" >first=false;}</span>
<span class="cstat-no" title="statement not covered" >return word+this.input.slice(chunkStart,this.pos)}</span>;<span class="cstat-no" title="statement not covered" >pp$8.readWord=<span class="fstat-no" title="function not covered" >fu</span>nction(){var word=<span class="cstat-no" title="statement not covered" >this.readWord1();</span>var type=<span class="cstat-no" title="statement not covered" >types.name;<span class="cstat-no" title="statement not covered" ></span>if(this.keywords.test(word)){<span class="cstat-no" title="statement not covered" >if(this.containsEsc){<span class="cstat-no" title="statement not covered" >this.raiseRecoverable(this.start,"Escape sequence in keyword "+word);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >type=keywords$1[word];}</span>
<span class="cstat-no" title="statement not covered" >return this.finishToken(type,word)}</span>;var version=<span class="cstat-no" title="statement not covered" >"6.0.1";</span>function <span class="fstat-no" title="function not covered" >parse(</span>input,options){<span class="cstat-no" title="statement not covered" >return Parser.parse(input,options)}</span>
function <span class="fstat-no" title="function not covered" >parseExpressionAt(</span>input,pos,options){<span class="cstat-no" title="statement not covered" >return Parser.parseExpressionAt(input,pos,options)}</span>
function <span class="fstat-no" title="function not covered" >tokenizer(</span>input,options){<span class="cstat-no" title="statement not covered" >return Parser.tokenizer(input,options)}</span>
<span class="cstat-no" title="statement not covered" >exports.version=version;<span class="cstat-no" title="statement not covered" >e</span>xports.parse=parse;<span class="cstat-no" title="statement not covered" >e</span>xports.parseExpressionAt=parseExpressionAt;<span class="cstat-no" title="statement not covered" >e</span>xports.tokenizer=tokenizer;<span class="cstat-no" title="statement not covered" >e</span>xports.Parser=Parser;<span class="cstat-no" title="statement not covered" >e</span>xports.defaultOptions=defaultOptions;<span class="cstat-no" title="statement not covered" >e</span>xports.Position=Position;<span class="cstat-no" title="statement not covered" >e</span>xports.SourceLocation=SourceLocation;<span class="cstat-no" title="statement not covered" >e</span>xports.getLineInfo=getLineInfo;<span class="cstat-no" title="statement not covered" >e</span>xports.Node=Node;<span class="cstat-no" title="statement not covered" >e</span>xports.TokenType=TokenType;<span class="cstat-no" title="statement not covered" >e</span>xports.tokTypes=types;<span class="cstat-no" title="statement not covered" >e</span>xports.keywordTypes=keywords$1;<span class="cstat-no" title="statement not covered" >e</span>xports.TokContext=TokContext;<span class="cstat-no" title="statement not covered" >e</span>xports.tokContexts=types$1;<span class="cstat-no" title="statement not covered" >e</span>xports.isIdentifierChar=isIdentifierChar;<span class="cstat-no" title="statement not covered" >e</span>xports.isIdentifierStart=isIdentifierStart;<span class="cstat-no" title="statement not covered" >e</span>xports.Token=Token;<span class="cstat-no" title="statement not covered" >e</span>xports.isNewLine=isNewLine;<span class="cstat-no" title="statement not covered" >e</span>xports.lineBreak=lineBreak;<span class="cstat-no" title="statement not covered" >e</span>xports.lineBreakG=lineBreakG;<span class="cstat-no" title="statement not covered" >e</span>xports.nonASCIIwhitespace=nonASCIIwhitespace;<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(exports,'__esModule',{value:true});}</span>)));;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(global,factory){<span class="cstat-no" title="statement not covered" >typeof exports==='object'&amp;&amp;typeof module!=='undefined'?factory(exports,require('acorn')):typeof define==='function'&amp;&amp;define.amd?define(['exports','acorn'],factory):(factory((global.acorn=global.acorn||{},global.acorn.loose={}),global.acorn));}</span>(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(exports,acorn){'use strict';function <span class="fstat-no" title="function not covered" >noop(</span>){}</span>
var LooseParser=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >LooseParser(</span>input,options){<span class="cstat-no" title="statement not covered" >if(options===void 0)<span class="cstat-no" title="statement not covered" >options={};<span class="cstat-no" title="statement not covered" >t</span></span>his.toks=this.constructor.BaseParser.tokenizer(input,options);<span class="cstat-no" title="statement not covered" >t</span>his.options=this.toks.options;<span class="cstat-no" title="statement not covered" >t</span>his.input=this.toks.input;<span class="cstat-no" title="statement not covered" >t</span>his.tok=this.last={type:acorn.tokTypes.eof,start:0,end:0};<span class="cstat-no" title="statement not covered" >t</span>his.tok.validateRegExpFlags=noop;<span class="cstat-no" title="statement not covered" >t</span>his.tok.validateRegExpPattern=noop;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){var here=<span class="cstat-no" title="statement not covered" >this.toks.curPosition();<span class="cstat-no" title="statement not covered" ></span>this.tok.loc=new acorn.SourceLocation(this.toks,here,here);}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.ahead=[];<span class="cstat-no" title="statement not covered" >t</span>his.context=[];<span class="cstat-no" title="statement not covered" >t</span>his.curIndent=0;<span class="cstat-no" title="statement not covered" >t</span>his.curLineStart=0;<span class="cstat-no" title="statement not covered" >t</span>his.nextLineStart=this.lineEnd(this.curLineStart)+1;<span class="cstat-no" title="statement not covered" >t</span>his.inAsync=false;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=false;}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.prototype.startNode=function <span class="fstat-no" title="function not covered" >startNode(</span>){<span class="cstat-no" title="statement not covered" >return new acorn.Node(this.toks,this.tok.start,this.options.locations?this.tok.loc.start:null)}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.storeCurrentPos=function <span class="fstat-no" title="function not covered" >storeCurrentPos(</span>){<span class="cstat-no" title="statement not covered" >return this.options.locations?[this.tok.start,this.tok.loc.start]:this.tok.start}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.startNodeAt=function <span class="fstat-no" title="function not covered" >startNodeAt(</span>pos){<span class="cstat-no" title="statement not covered" >if(this.options.locations){<span class="cstat-no" title="statement not covered" >return new acorn.Node(this.toks,pos[0],pos[1])}</span>else{<span class="cstat-no" title="statement not covered" >return new acorn.Node(this.toks,pos)}</span>}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.finishNode=function <span class="fstat-no" title="function not covered" >finishNode(</span>node,type){<span class="cstat-no" title="statement not covered" >node.type=type;<span class="cstat-no" title="statement not covered" >n</span>ode.end=this.last.end;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations)</span></span>
{<span class="cstat-no" title="statement not covered" >node.loc.end=this.last.loc.end;}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ranges)</span>
{<span class="cstat-no" title="statement not covered" >node.range[1]=this.last.end;}</span>
<span class="cstat-no" title="statement not covered" >return node}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.prototype.dummyNode=function <span class="fstat-no" title="function not covered" >dummyNode(</span>type){var dummy=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>dummy.type=type;<span class="cstat-no" title="statement not covered" >d</span>ummy.end=dummy.start;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations)</span></span>
{<span class="cstat-no" title="statement not covered" >dummy.loc.end=dummy.loc.start;}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ranges)</span>
{<span class="cstat-no" title="statement not covered" >dummy.range[1]=dummy.start;}</span>
<span class="cstat-no" title="statement not covered" >this.last={type:acorn.tokTypes.name,start:dummy.start,end:dummy.start,loc:dummy.loc};<span class="cstat-no" title="statement not covered" >r</span>eturn dummy}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.prototype.dummyIdent=function <span class="fstat-no" title="function not covered" >dummyIdent(</span>){var dummy=<span class="cstat-no" title="statement not covered" >this.dummyNode("Identifier");<span class="cstat-no" title="statement not covered" ></span>dummy.name="";<span class="cstat-no" title="statement not covered" >r</span>eturn dummy}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.dummyString=function <span class="fstat-no" title="function not covered" >dummyString(</span>){var dummy=<span class="cstat-no" title="statement not covered" >this.dummyNode("Literal");<span class="cstat-no" title="statement not covered" ></span>dummy.value=dummy.raw="";<span class="cstat-no" title="statement not covered" >r</span>eturn dummy}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.eat=function <span class="fstat-no" title="function not covered" >eat(</span>type){<span class="cstat-no" title="statement not covered" >if(this.tok.type===type){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>else{<span class="cstat-no" title="statement not covered" >return false}</span>}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.isContextual=function <span class="fstat-no" title="function not covered" >isContextual(</span>name){<span class="cstat-no" title="statement not covered" >return this.tok.type===acorn.tokTypes.name&amp;&amp;this.tok.value===name}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.eatContextual=function <span class="fstat-no" title="function not covered" >eatContextual(</span>name){<span class="cstat-no" title="statement not covered" >return this.tok.value===name&amp;&amp;this.eat(acorn.tokTypes.name)}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.canInsertSemicolon=function <span class="fstat-no" title="function not covered" >canInsertSemicolon(</span>){<span class="cstat-no" title="statement not covered" >return this.tok.type===acorn.tokTypes.eof||this.tok.type===acorn.tokTypes.braceR||acorn.lineBreak.test(this.input.slice(this.last.end,this.tok.start))}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.semicolon=function <span class="fstat-no" title="function not covered" >semicolon(</span>){<span class="cstat-no" title="statement not covered" >return this.eat(acorn.tokTypes.semi)}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.expect=function <span class="fstat-no" title="function not covered" >expect(</span>type){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.eat(type)){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >for(var i=1;i&lt;=2;i++){<span class="cstat-no" title="statement not covered" >if(this$1.lookAhead(i).type===type){<span class="cstat-no" title="statement not covered" >for(var j=0;j&lt;i;j++){<span class="cstat-no" title="statement not covered" >this$1.next();}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>}};<span class="cstat-no" title="statement not covered" >LooseParser.prototype.pushCx=function <span class="fstat-no" title="function not covered" >pushCx(</span>){<span class="cstat-no" title="statement not covered" >this.context.push(this.curIndent);}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.popCx=function <span class="fstat-no" title="function not covered" >popCx(</span>){<span class="cstat-no" title="statement not covered" >this.curIndent=this.context.pop();}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.lineEnd=function <span class="fstat-no" title="function not covered" >lineEnd(</span>pos){<span class="cstat-no" title="statement not covered" >while(pos&lt;this.input.length&amp;&amp;!acorn.isNewLine(this.input.charCodeAt(pos))){<span class="cstat-no" title="statement not covered" >++pos;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return pos}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.prototype.indentationAfter=function <span class="fstat-no" title="function not covered" >indentationAfter(</span>pos){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var count=0;;++pos){var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(pos);<span class="cstat-no" title="statement not covered" ></span>if(ch===32){<span class="cstat-no" title="statement not covered" >++count;}</span></span></span></span>
else <span class="cstat-no" title="statement not covered" >if(ch===9){<span class="cstat-no" title="statement not covered" >count+=this$1.options.tabSize;}</span></span>
else{<span class="cstat-no" title="statement not covered" >return count}</span>}};<span class="cstat-no" title="statement not covered" >LooseParser.prototype.closes=function <span class="fstat-no" title="function not covered" >closes(</span>closeTok,indent,line,blockHeuristic){<span class="cstat-no" title="statement not covered" >if(this.tok.type===closeTok||this.tok.type===acorn.tokTypes.eof){<span class="cstat-no" title="statement not covered" >return true}</span></span></span>
<span class="cstat-no" title="statement not covered" >return line!==this.curLineStart&amp;&amp;this.curIndent&lt;indent&amp;&amp;this.tokenStartsLine()&amp;&amp;(!blockHeuristic||this.nextLineStart&gt;=this.input.length||this.indentationAfter(this.nextLineStart)&lt;indent)}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.prototype.tokenStartsLine=function <span class="fstat-no" title="function not covered" >tokenStartsLine(</span>){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var p=this.tok.start-1;p&gt;=this.curLineStart;--p){var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(p);<span class="cstat-no" title="statement not covered" ></span>if(ch!==9&amp;&amp;ch!==32){<span class="cstat-no" title="statement not covered" >return false}</span>}</span></span></span>
<span class="cstat-no" title="statement not covered" >return true}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.prototype.extend=function <span class="fstat-no" title="function not covered" >extend(</span>name,f){<span class="cstat-no" title="statement not covered" >this[name]=f(this[name]);}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.prototype.parse=function <span class="fstat-no" title="function not covered" >parse(</span>){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseTopLevel()}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.extend=function <span class="fstat-no" title="function not covered" >extend(</span>){var plugins=<span class="cstat-no" title="statement not covered" >[],</span>len=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>while(len--)<span class="cstat-no" title="statement not covered" >plugins[len]=arguments[len];v</span></span>ar cls=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;plugins.length;i++){<span class="cstat-no" title="statement not covered" >cls=plugins[i](cls);}</span></span></span>
<span class="cstat-no" title="statement not covered" >return cls}</span>;<span class="cstat-no" title="statement not covered" >LooseParser.parse=function <span class="fstat-no" title="function not covered" >parse(</span>input,options){<span class="cstat-no" title="statement not covered" >return new this(input,options).parse()}</span>;<span class="cstat-no" title="statement not covered" >L</span>ooseParser.BaseParser=acorn.Parser;v</span>ar lp=<span class="cstat-no" title="statement not covered" >LooseParser.prototype;</span>function <span class="fstat-no" title="function not covered" >isSpace(</span>ch){<span class="cstat-no" title="statement not covered" >return(ch&lt;14&amp;&amp;ch&gt;8)||ch===32||ch===160||acorn.isNewLine(ch)}</span>
<span class="cstat-no" title="statement not covered" >lp.next=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.last=this.tok;<span class="cstat-no" title="statement not covered" >i</span>f(this.ahead.length)</span></span>
{<span class="cstat-no" title="statement not covered" >this.tok=this.ahead.shift();}</span>
else
{<span class="cstat-no" title="statement not covered" >this.tok=this.readToken();}</span>
<span class="cstat-no" title="statement not covered" >if(this.tok.start&gt;=this.nextLineStart){<span class="cstat-no" title="statement not covered" >while(this.tok.start&gt;=this.nextLineStart){<span class="cstat-no" title="statement not covered" >this$1.curLineStart=this$1.nextLineStart;<span class="cstat-no" title="statement not covered" >t</span>his$1.nextLineStart=this$1.lineEnd(this$1.curLineStart)+1;}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.curIndent=this.indentationAfter(this.curLineStart);}</span>};<span class="cstat-no" title="statement not covered" >lp.readToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this$1.toks.next();<span class="cstat-no" title="statement not covered" >i</span>f(this$1.toks.type===acorn.tokTypes.dot&amp;&amp;this$1.input.substr(this$1.toks.end,1)==="."&amp;&amp;this$1.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >this$1.toks.end++;<span class="cstat-no" title="statement not covered" >t</span>his$1.toks.type=acorn.tokTypes.ellipsis;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return new acorn.Token(this$1.toks)}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(!(e instanceof SyntaxError)){<span class="cstat-no" title="statement not covered" >throw e}</span></span>
var msg=<span class="cstat-no" title="statement not covered" >e.message,</span>pos=<span class="cstat-no" title="statement not covered" >e.raisedAt,</span>replace=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>if(/unterminated/i.test(msg)){<span class="cstat-no" title="statement not covered" >pos=this$1.lineEnd(e.pos+1);<span class="cstat-no" title="statement not covered" >i</span>f(/string/.test(msg)){<span class="cstat-no" title="statement not covered" >replace={start:e.pos,end:pos,type:acorn.tokTypes.string,value:this$1.input.slice(e.pos+1,pos)};}</span>else <span class="cstat-no" title="statement not covered" >if(/regular expr/i.test(msg)){var re=<span class="cstat-no" title="statement not covered" >this$1.input.slice(e.pos,pos);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >re=new RegExp(re);}</span>catch(e){}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >replace={start:e.pos,end:pos,type:acorn.tokTypes.regexp,value:re};}</span>else <span class="cstat-no" title="statement not covered" >if(/template/.test(msg)){<span class="cstat-no" title="statement not covered" >replace={start:e.pos,end:pos,type:acorn.tokTypes.template,value:this$1.input.slice(e.pos,pos)};}</span>else{<span class="cstat-no" title="statement not covered" >replace=false;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)){<span class="cstat-no" title="statement not covered" >while(pos&lt;this.input.length&amp;&amp;!isSpace(this.input.charCodeAt(pos))){<span class="cstat-no" title="statement not covered" >++pos;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(/character escape|expected hexadecimal/i.test(msg)){<span class="cstat-no" title="statement not covered" >while(pos&lt;this.input.length){var ch=<span class="cstat-no" title="statement not covered" >this$1.input.charCodeAt(pos++);<span class="cstat-no" title="statement not covered" ></span>if(ch===34||ch===39||acorn.isNewLine(ch)){<span class="cstat-no" title="statement not covered" >break}</span>}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(/unexpected character/i.test(msg)){<span class="cstat-no" title="statement not covered" >pos++;<span class="cstat-no" title="statement not covered" >r</span>eplace=false;}</span>else <span class="cstat-no" title="statement not covered" >if(/regular expression/i.test(msg)){<span class="cstat-no" title="statement not covered" >replace=true;}</span>else{<span class="cstat-no" title="statement not covered" >throw e}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >this$1.resetTo(pos);<span class="cstat-no" title="statement not covered" >i</span>f(replace===true){<span class="cstat-no" title="statement not covered" >replace={start:pos,end:pos,type:acorn.tokTypes.name,value:""};}</span></span>
<span class="cstat-no" title="statement not covered" >if(replace){<span class="cstat-no" title="statement not covered" >if(this$1.options.locations)</span></span>
{<span class="cstat-no" title="statement not covered" >replace.loc=new acorn.SourceLocation(this$1.toks,acorn.getLineInfo(this$1.input,replace.start),acorn.getLineInfo(this$1.input,replace.end));}</span>
<span class="cstat-no" title="statement not covered" >return replace}</span>}}};<span class="cstat-no" title="statement not covered" >lp.resetTo=<span class="fstat-no" title="function not covered" >fu</span>nction(pos){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.toks.pos=pos;v</span>ar ch=<span class="cstat-no" title="statement not covered" >this.input.charAt(pos-1);<span class="cstat-no" title="statement not covered" ></span>this.toks.exprAllowed=!ch||/[[{(,;:?/*=+\-~!|&amp;%^&lt;&gt;]/.test(ch)||/[enwfd]/.test(ch)&amp;&amp;/\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos-10,pos));<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >this.toks.curLine=1;<span class="cstat-no" title="statement not covered" >t</span>his.toks.lineStart=acorn.lineBreakG.lastIndex=0;v</span>ar match;<span class="cstat-no" title="statement not covered" >while((match=acorn.lineBreakG.exec(this.input))&amp;&amp;match.index&lt;pos){<span class="cstat-no" title="statement not covered" >++this$1.toks.curLine;<span class="cstat-no" title="statement not covered" >t</span>his$1.toks.lineStart=match.index+match[0].length;}</span>}</span>}</span>;<span class="cstat-no" title="statement not covered" >l</span>p.lookAhead=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>while(n&gt;this.ahead.length)</span></span>
{<span class="cstat-no" title="statement not covered" >this$1.ahead.push(this$1.readToken());}</span>
<span class="cstat-no" title="statement not covered" >return this.ahead[n-1]}</span>;function <span class="fstat-no" title="function not covered" >isDummy(</span>node){<span class="cstat-no" title="statement not covered" >return node.name===""}</span>
var lp$1=<span class="cstat-no" title="statement not covered" >LooseParser.prototype;<span class="cstat-no" title="statement not covered" ></span>lp$1.parseTopLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(this.options.locations?[0,acorn.getLineInfo(this.input,0)]:0);<span class="cstat-no" title="statement not covered" ></span>node.body=[];<span class="cstat-no" title="statement not covered" >w</span>hile(this.tok.type!==acorn.tokTypes.eof){<span class="cstat-no" title="statement not covered" >node.body.push(this$1.parseStatement());}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.toks.adaptDirectivePrologue(node.body);<span class="cstat-no" title="statement not covered" >t</span>his.last=this.tok;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.sourceType=this.options.sourceType;}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"Program")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseStatement=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var starttype=<span class="cstat-no" title="statement not covered" >this.tok.type,</span>node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>kind;<span class="cstat-no" title="statement not covered" >if(this.toks.isLet()){<span class="cstat-no" title="statement not covered" >starttype=acorn.tokTypes._var;<span class="cstat-no" title="statement not covered" >k</span>ind="let";}</span></span></span>
<span class="cstat-no" title="statement not covered" >switch(starttype){case acorn.tokTypes._break:case acorn.tokTypes._continue:<span class="cstat-no" title="statement not covered" >this.next();v</span>ar isBreak=<span class="cstat-no" title="statement not covered" >starttype===acorn.tokTypes._break;<span class="cstat-no" title="statement not covered" ></span>if(this.semicolon()||this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >node.label=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.label=this.tok.type===acorn.tokTypes.name?this.parseIdent():null;<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")</span>
case acorn.tokTypes._debugger:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"DebuggerStatement")</span>
case acorn.tokTypes._do:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.eat(acorn.tokTypes._while)?this.parseParenExpression():this.dummyIdent();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"DoWhileStatement")</span>
case acorn.tokTypes._for:<span class="cstat-no" title="statement not covered" >this.next();v</span>ar isAwait=<span class="cstat-no" title="statement not covered" >this.options.ecmaVersion&gt;=9&amp;&amp;this.inAsync&amp;&amp;this.eatContextual("await");<span class="cstat-no" title="statement not covered" ></span>this.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.parenL);<span class="cstat-no" title="statement not covered" >i</span>f(this.tok.type===acorn.tokTypes.semi){<span class="cstat-no" title="statement not covered" >return this.parseFor(node,null)}</span></span>
var isLet=<span class="cstat-no" title="statement not covered" >this.toks.isLet();<span class="cstat-no" title="statement not covered" ></span>if(isLet||this.tok.type===acorn.tokTypes._var||this.tok.type===acorn.tokTypes._const){var init$1=<span class="cstat-no" title="statement not covered" >this.parseVar(this.startNode(),true,isLet?"let":this.tok.value);<span class="cstat-no" title="statement not covered" ></span>if(init$1.declarations.length===1&amp;&amp;(this.tok.type===acorn.tokTypes._in||this.isContextual("of"))){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9&amp;&amp;this.tok.type!==acorn.tokTypes._in){<span class="cstat-no" title="statement not covered" >node.await=isAwait;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.parseForIn(node,init$1)}</span>
<span class="cstat-no" title="statement not covered" >return this.parseFor(node,init$1)}</span>
var init=<span class="cstat-no" title="statement not covered" >this.parseExpression(true);<span class="cstat-no" title="statement not covered" ></span>if(this.tok.type===acorn.tokTypes._in||this.isContextual("of")){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=9&amp;&amp;this.tok.type!==acorn.tokTypes._in){<span class="cstat-no" title="statement not covered" >node.await=isAwait;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return this.parseForIn(node,this.toAssignable(init))}</span>
<span class="cstat-no" title="statement not covered" >return this.parseFor(node,init)</span>
case acorn.tokTypes._function:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,true)</span>
case acorn.tokTypes._if:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.consequent=this.parseStatement();<span class="cstat-no" title="statement not covered" >n</span>ode.alternate=this.eat(acorn.tokTypes._else)?this.parseStatement():null;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"IfStatement")</span>
case acorn.tokTypes._return:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(acorn.tokTypes.semi)||this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >node.argument=null;}</span></span>
else{<span class="cstat-no" title="statement not covered" >node.argument=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ReturnStatement")</span>
case acorn.tokTypes._switch:var blockIndent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart;<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.discriminant=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.cases=[];<span class="cstat-no" title="statement not covered" >t</span>his.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.braceL);v</span>ar cur;<span class="cstat-no" title="statement not covered" >while(!this.closes(acorn.tokTypes.braceR,blockIndent,line,true)){<span class="cstat-no" title="statement not covered" >if(this$1.tok.type===acorn.tokTypes._case||this$1.tok.type===acorn.tokTypes._default){var isCase=<span class="cstat-no" title="statement not covered" >this$1.tok.type===acorn.tokTypes._case;<span class="cstat-no" title="statement not covered" ></span>if(cur){<span class="cstat-no" title="statement not covered" >this$1.finishNode(cur,"SwitchCase");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.cases.push(cur=this$1.startNode());<span class="cstat-no" title="statement not covered" >c</span>ur.consequent=[];<span class="cstat-no" title="statement not covered" >t</span>his$1.next();<span class="cstat-no" title="statement not covered" >i</span>f(isCase){<span class="cstat-no" title="statement not covered" >cur.test=this$1.parseExpression();}</span></span>
else{<span class="cstat-no" title="statement not covered" >cur.test=null;}</span>
<span class="cstat-no" title="statement not covered" >this$1.expect(acorn.tokTypes.colon);}</span>else{<span class="cstat-no" title="statement not covered" >if(!cur){<span class="cstat-no" title="statement not covered" >node.cases.push(cur=this$1.startNode());<span class="cstat-no" title="statement not covered" >c</span>ur.consequent=[];<span class="cstat-no" title="statement not covered" >c</span>ur.test=null;}</span></span>
<span class="cstat-no" title="statement not covered" >cur.consequent.push(this$1.parseStatement());}</span>}
<span class="cstat-no" title="statement not covered" >if(cur){<span class="cstat-no" title="statement not covered" >this.finishNode(cur,"SwitchCase");}</span></span>
<span class="cstat-no" title="statement not covered" >this.popCx();<span class="cstat-no" title="statement not covered" >t</span>his.eat(acorn.tokTypes.braceR);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"SwitchStatement")</span>
case acorn.tokTypes._throw:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ThrowStatement")</span>
case acorn.tokTypes._try:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.block=this.parseBlock();<span class="cstat-no" title="statement not covered" >n</span>ode.handler=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.tok.type===acorn.tokTypes._catch){var clause=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(acorn.tokTypes.parenL)){<span class="cstat-no" title="statement not covered" >clause.param=this.toAssignable(this.parseExprAtom(),true);<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.parenR);}</span>else{<span class="cstat-no" title="statement not covered" >clause.param=null;}</span></span></span>
<span class="cstat-no" title="statement not covered" >clause.body=this.parseBlock();<span class="cstat-no" title="statement not covered" >n</span>ode.handler=this.finishNode(clause,"CatchClause");}</span>
<span class="cstat-no" title="statement not covered" >node.finalizer=this.eat(acorn.tokTypes._finally)?this.parseBlock():null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.handler&amp;&amp;!node.finalizer){<span class="cstat-no" title="statement not covered" >return node.block}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"TryStatement")</span>
case acorn.tokTypes._var:case acorn.tokTypes._const:<span class="cstat-no" title="statement not covered" >return this.parseVar(node,false,kind||this.tok.value)</span>
case acorn.tokTypes._while:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.test=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"WhileStatement")</span>
case acorn.tokTypes._with:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.object=this.parseParenExpression();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"WithStatement")</span>
case acorn.tokTypes.braceL:<span class="cstat-no" title="statement not covered" >return this.parseBlock()</span>
case acorn.tokTypes.semi:<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"EmptyStatement")</span>
case acorn.tokTypes._class:<span class="cstat-no" title="statement not covered" >return this.parseClass(true)</span>
case acorn.tokTypes._import:<span class="cstat-no" title="statement not covered" >return this.parseImport()</span>
case acorn.tokTypes._export:<span class="cstat-no" title="statement not covered" >return this.parseExport()</span>
default:<span class="cstat-no" title="statement not covered" >if(this.toks.isAsyncFunction()){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,true,true)}</span></span>
var expr=<span class="cstat-no" title="statement not covered" >this.parseExpression();<span class="cstat-no" title="statement not covered" ></span>if(isDummy(expr)){<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.tok.type===acorn.tokTypes.eof){<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"EmptyStatement")}</span></span></span>
<span class="cstat-no" title="statement not covered" >return this.parseStatement()}</span>else <span class="cstat-no" title="statement not covered" >if(starttype===acorn.tokTypes.name&amp;&amp;expr.type==="Identifier"&amp;&amp;this.eat(acorn.tokTypes.colon)){<span class="cstat-no" title="statement not covered" >node.body=this.parseStatement();<span class="cstat-no" title="statement not covered" >n</span>ode.label=expr;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"LabeledStatement")}</span>else{<span class="cstat-no" title="statement not covered" >node.expression=expr;<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ExpressionStatement")}</span>}</span>};<span class="cstat-no" title="statement not covered" >lp$1.parseBlock=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.braceL);v</span>ar blockIndent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart;<span class="cstat-no" title="statement not covered" ></span>node.body=[];<span class="cstat-no" title="statement not covered" >w</span>hile(!this.closes(acorn.tokTypes.braceR,blockIndent,line,true))</span></span>
{<span class="cstat-no" title="statement not covered" >node.body.push(this$1.parseStatement());}</span>
<span class="cstat-no" title="statement not covered" >this.popCx();<span class="cstat-no" title="statement not covered" >t</span>his.eat(acorn.tokTypes.braceR);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"BlockStatement")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseFor=<span class="fstat-no" title="function not covered" >fu</span>nction(node,init){<span class="cstat-no" title="statement not covered" >node.init=init;<span class="cstat-no" title="statement not covered" >n</span>ode.test=node.update=null;<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(acorn.tokTypes.semi)&amp;&amp;this.tok.type!==acorn.tokTypes.semi){<span class="cstat-no" title="statement not covered" >node.test=this.parseExpression();}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.eat(acorn.tokTypes.semi)&amp;&amp;this.tok.type!==acorn.tokTypes.parenR){<span class="cstat-no" title="statement not covered" >node.update=this.parseExpression();}</span></span>
<span class="cstat-no" title="statement not covered" >this.popCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.parenR);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ForStatement")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseForIn=<span class="fstat-no" title="function not covered" >fu</span>nction(node,init){var type=<span class="cstat-no" title="statement not covered" >this.tok.type===acorn.tokTypes._in?"ForInStatement":"ForOfStatement";<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.left=init;<span class="cstat-no" title="statement not covered" >n</span>ode.right=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.popCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.parenR);<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseStatement();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,type)}</span>;<span class="cstat-no" title="statement not covered" >l</span>p$1.parseVar=<span class="fstat-no" title="function not covered" >fu</span>nction(node,noIn,kind){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>node.kind=kind;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.declarations=[];<span class="cstat-no" title="statement not covered" >d</span>o{var decl=<span class="cstat-no" title="statement not covered" >this$1.startNode();<span class="cstat-no" title="statement not covered" ></span>decl.id=this$1.options.ecmaVersion&gt;=6?this$1.toAssignable(this$1.parseExprAtom(),true):this$1.parseIdent();<span class="cstat-no" title="statement not covered" >d</span>ecl.init=this$1.eat(acorn.tokTypes.eq)?this$1.parseMaybeAssign(noIn):null;<span class="cstat-no" title="statement not covered" >n</span>ode.declarations.push(this$1.finishNode(decl,"VariableDeclarator"));}</span>while(this.eat(acorn.tokTypes.comma))</span></span>
<span class="cstat-no" title="statement not covered" >if(!node.declarations.length){var decl$1=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>decl$1.id=this.dummyIdent();<span class="cstat-no" title="statement not covered" >n</span>ode.declarations.push(this.finishNode(decl$1,"VariableDeclarator"));}</span></span>
<span class="cstat-no" title="statement not covered" >if(!noIn){<span class="cstat-no" title="statement not covered" >this.semicolon();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"VariableDeclaration")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseClass=<span class="fstat-no" title="function not covered" >fu</span>nction(isStatement){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.tok.type===acorn.tokTypes.name){<span class="cstat-no" title="statement not covered" >node.id=this.parseIdent();}</span></span></span>
else <span class="cstat-no" title="statement not covered" >if(isStatement===true){<span class="cstat-no" title="statement not covered" >node.id=this.dummyIdent();}</span></span>
else{<span class="cstat-no" title="statement not covered" >node.id=null;}</span>
<span class="cstat-no" title="statement not covered" >node.superClass=this.eat(acorn.tokTypes._extends)?this.parseExpression():null;<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.body.body=[];<span class="cstat-no" title="statement not covered" >t</span>his.pushCx();v</span>ar indent=<span class="cstat-no" title="statement not covered" >this.curIndent+1,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart;<span class="cstat-no" title="statement not covered" ></span>this.eat(acorn.tokTypes.braceL);<span class="cstat-no" title="statement not covered" >i</span>f(this.curIndent+1&lt;indent){<span class="cstat-no" title="statement not covered" >indent=this.curIndent;<span class="cstat-no" title="statement not covered" >l</span>ine=this.curLineStart;}</span></span>
<span class="cstat-no" title="statement not covered" >while(!this.closes(acorn.tokTypes.braceR,indent,line)){<span class="cstat-no" title="statement not covered" >if(this$1.semicolon()){<span class="cstat-no" title="statement not covered" >continue}</span></span></span>
var method=<span class="cstat-no" title="statement not covered" >this$1.startNode(),</span>isGenerator=(<span class="cstat-no" title="statement not covered" >void 0)</span>,isAsync=(<span class="cstat-no" title="statement not covered" >void 0)</span>;<span class="cstat-no" title="statement not covered" >if(this$1.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >method.static=false;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this$1.eat(acorn.tokTypes.star);}</span></span>
<span class="cstat-no" title="statement not covered" >this$1.parsePropertyName(method);<span class="cstat-no" title="statement not covered" >i</span>f(isDummy(method.key)){<span class="cstat-no" title="statement not covered" >if(isDummy(this$1.parseMaybeAssign())){<span class="cstat-no" title="statement not covered" >this$1.next();}<span class="cstat-no" title="statement not covered" ></span>t</span>his$1.eat(acorn.tokTypes.comma);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span></span>
<span class="cstat-no" title="statement not covered" >if(method.key.type==="Identifier"&amp;&amp;!method.computed&amp;&amp;method.key.name==="static"&amp;&amp;(this$1.tok.type!==acorn.tokTypes.parenL&amp;&amp;this$1.tok.type!==acorn.tokTypes.braceL)){<span class="cstat-no" title="statement not covered" >method.static=true;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this$1.eat(acorn.tokTypes.star);<span class="cstat-no" title="statement not covered" >t</span>his$1.parsePropertyName(method);}</span>else{<span class="cstat-no" title="statement not covered" >method.static=false;}</span></span>
<span class="cstat-no" title="statement not covered" >if(!method.computed&amp;&amp;method.key.type==="Identifier"&amp;&amp;method.key.name==="async"&amp;&amp;this$1.tok.type!==acorn.tokTypes.parenL&amp;&amp;!this$1.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >isAsync=true;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this$1.options.ecmaVersion&gt;=9&amp;&amp;this$1.eat(acorn.tokTypes.star);<span class="cstat-no" title="statement not covered" >t</span>his$1.parsePropertyName(method);}</span>else{<span class="cstat-no" title="statement not covered" >isAsync=false;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this$1.options.ecmaVersion&gt;=5&amp;&amp;method.key.type==="Identifier"&amp;&amp;!method.computed&amp;&amp;(method.key.name==="get"||method.key.name==="set")&amp;&amp;this$1.tok.type!==acorn.tokTypes.parenL&amp;&amp;this$1.tok.type!==acorn.tokTypes.braceL){<span class="cstat-no" title="statement not covered" >method.kind=method.key.name;<span class="cstat-no" title="statement not covered" >t</span>his$1.parsePropertyName(method);<span class="cstat-no" title="statement not covered" >m</span>ethod.value=this$1.parseMethod(false);}</span>else{<span class="cstat-no" title="statement not covered" >if(!method.computed&amp;&amp;!method.static&amp;&amp;!isGenerator&amp;&amp;!isAsync&amp;&amp;(method.key.type==="Identifier"&amp;&amp;method.key.name==="constructor"||method.key.type==="Literal"&amp;&amp;method.key.value==="constructor")){<span class="cstat-no" title="statement not covered" >method.kind="constructor";}</span>else{<span class="cstat-no" title="statement not covered" >method.kind="method";}</span></span></span>
<span class="cstat-no" title="statement not covered" >method.value=this$1.parseMethod(isGenerator,isAsync);}</span>
<span class="cstat-no" title="statement not covered" >node.body.body.push(this$1.finishNode(method,"MethodDefinition"));}</span>
<span class="cstat-no" title="statement not covered" >this.popCx();<span class="cstat-no" title="statement not covered" >i</span>f(!this.eat(acorn.tokTypes.braceR)){<span class="cstat-no" title="statement not covered" >this.last.end=this.tok.start;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >this.last.loc.end=this.tok.loc.start;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >this.semicolon();<span class="cstat-no" title="statement not covered" >t</span>his.finishNode(node.body,"ClassBody");<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(node,isStatement,isAsync){var oldInAsync=<span class="cstat-no" title="statement not covered" >this.inAsync,</span>oldInFunction=<span class="cstat-no" title="statement not covered" >this.inFunction;<span class="cstat-no" title="statement not covered" ></span>this.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.generator=this.eat(acorn.tokTypes.star);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8){<span class="cstat-no" title="statement not covered" >node.async=!!isAsync;}</span></span>
<span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes.name){<span class="cstat-no" title="statement not covered" >node.id=this.parseIdent();}</span></span>
else <span class="cstat-no" title="statement not covered" >if(isStatement===true){<span class="cstat-no" title="statement not covered" >node.id=this.dummyIdent();}</span></span>
<span class="cstat-no" title="statement not covered" >this.inAsync=node.async;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=true;<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.parseFunctionParams();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseBlock();<span class="cstat-no" title="statement not covered" >t</span>his.toks.adaptDirectivePrologue(node.body.body);<span class="cstat-no" title="statement not covered" >t</span>his.inAsync=oldInAsync;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=oldInFunction;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,isStatement?"FunctionDeclaration":"FunctionExpression")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseExport=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(acorn.tokTypes.star)){<span class="cstat-no" title="statement not covered" >node.source=this.eatContextual("from")?this.parseExprAtom():this.dummyString();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ExportAllDeclaration")}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.eat(acorn.tokTypes._default)){var isAsync;<span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes._function||(isAsync=this.toks.isAsyncFunction())){var fNode=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(isAsync){<span class="cstat-no" title="statement not covered" >this.next();}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.declaration=this.parseFunction(fNode,"nullableID",isAsync);}</span>else <span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes._class){<span class="cstat-no" title="statement not covered" >node.declaration=this.parseClass("nullableID");}</span>else{<span class="cstat-no" title="statement not covered" >node.declaration=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ExportDefaultDeclaration")}</span>
<span class="cstat-no" title="statement not covered" >if(this.tok.type.keyword||this.toks.isLet()||this.toks.isAsyncFunction()){<span class="cstat-no" title="statement not covered" >node.declaration=this.parseStatement();<span class="cstat-no" title="statement not covered" >n</span>ode.specifiers=[];<span class="cstat-no" title="statement not covered" >n</span>ode.source=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.declaration=null;<span class="cstat-no" title="statement not covered" >n</span>ode.specifiers=this.parseExportSpecifierList();<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.eatContextual("from")?this.parseExprAtom():null;<span class="cstat-no" title="statement not covered" >t</span>his.semicolon();}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ExportNamedDeclaration")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseImport=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.tok.type===acorn.tokTypes.string){<span class="cstat-no" title="statement not covered" >node.specifiers=[];<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.parseExprAtom();}</span>else{var elt;<span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes.name&amp;&amp;this.tok.value!=="from"){<span class="cstat-no" title="statement not covered" >elt=this.startNode();<span class="cstat-no" title="statement not covered" >e</span>lt.local=this.parseIdent();<span class="cstat-no" title="statement not covered" >t</span>his.finishNode(elt,"ImportDefaultSpecifier");<span class="cstat-no" title="statement not covered" >t</span>his.eat(acorn.tokTypes.comma);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.specifiers=this.parseImportSpecifiers();<span class="cstat-no" title="statement not covered" >n</span>ode.source=this.eatContextual("from")&amp;&amp;this.tok.type===acorn.tokTypes.string?this.parseExprAtom():this.dummyString();<span class="cstat-no" title="statement not covered" >i</span>f(elt){<span class="cstat-no" title="statement not covered" >node.specifiers.unshift(elt);}</span>}</span>
<span class="cstat-no" title="statement not covered" >this.semicolon();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ImportDeclaration")}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseImportSpecifiers=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var elts=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(this.tok.type===acorn.tokTypes.star){var elt=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >e</span>lt.local=this.eatContextual("as")?this.parseIdent():this.dummyIdent();<span class="cstat-no" title="statement not covered" >e</span>lts.push(this.finishNode(elt,"ImportNamespaceSpecifier"));}</span>else{var indent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart,</span>continuedLine=<span class="cstat-no" title="statement not covered" >this.nextLineStart;<span class="cstat-no" title="statement not covered" ></span>this.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his.eat(acorn.tokTypes.braceL);<span class="cstat-no" title="statement not covered" >i</span>f(this.curLineStart&gt;continuedLine){<span class="cstat-no" title="statement not covered" >continuedLine=this.curLineStart;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >while(!this.closes(acorn.tokTypes.braceR,indent+(this.curLineStart&lt;=continuedLine?1:0),line)){var elt$1=<span class="cstat-no" title="statement not covered" >this$1.startNode();<span class="cstat-no" title="statement not covered" ></span>if(this$1.eat(acorn.tokTypes.star)){<span class="cstat-no" title="statement not covered" >elt$1.local=this$1.eatContextual("as")?this$1.parseIdent():this$1.dummyIdent();<span class="cstat-no" title="statement not covered" >t</span>his$1.finishNode(elt$1,"ImportNamespaceSpecifier");}</span>else{<span class="cstat-no" title="statement not covered" >if(this$1.isContextual("from")){<span class="cstat-no" title="statement not covered" >break}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >elt$1.imported=this$1.parseIdent();<span class="cstat-no" title="statement not covered" >i</span>f(isDummy(elt$1.imported)){<span class="cstat-no" title="statement not covered" >break}</span></span>
<span class="cstat-no" title="statement not covered" >elt$1.local=this$1.eatContextual("as")?this$1.parseIdent():elt$1.imported;<span class="cstat-no" title="statement not covered" >t</span>his$1.finishNode(elt$1,"ImportSpecifier");}</span>
<span class="cstat-no" title="statement not covered" >elts.push(elt$1);<span class="cstat-no" title="statement not covered" >t</span>his$1.eat(acorn.tokTypes.comma);}</span>
<span class="cstat-no" title="statement not covered" >this.eat(acorn.tokTypes.braceR);<span class="cstat-no" title="statement not covered" >t</span>his.popCx();}</span>
<span class="cstat-no" title="statement not covered" >return elts}</span>;<span class="cstat-no" title="statement not covered" >lp$1.parseExportSpecifierList=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var elts=<span class="cstat-no" title="statement not covered" >[];</span>var indent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart,</span>continuedLine=<span class="cstat-no" title="statement not covered" >this.nextLineStart;<span class="cstat-no" title="statement not covered" ></span>this.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his.eat(acorn.tokTypes.braceL);<span class="cstat-no" title="statement not covered" >i</span>f(this.curLineStart&gt;continuedLine){<span class="cstat-no" title="statement not covered" >continuedLine=this.curLineStart;}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(!this.closes(acorn.tokTypes.braceR,indent+(this.curLineStart&lt;=continuedLine?1:0),line)){<span class="cstat-no" title="statement not covered" >if(this$1.isContextual("from")){<span class="cstat-no" title="statement not covered" >break}</span></span></span>
var elt=<span class="cstat-no" title="statement not covered" >this$1.startNode();<span class="cstat-no" title="statement not covered" ></span>elt.local=this$1.parseIdent();<span class="cstat-no" title="statement not covered" >i</span>f(isDummy(elt.local)){<span class="cstat-no" title="statement not covered" >break}</span></span>
<span class="cstat-no" title="statement not covered" >elt.exported=this$1.eatContextual("as")?this$1.parseIdent():elt.local;<span class="cstat-no" title="statement not covered" >t</span>his$1.finishNode(elt,"ExportSpecifier");<span class="cstat-no" title="statement not covered" >e</span>lts.push(elt);<span class="cstat-no" title="statement not covered" >t</span>his$1.eat(acorn.tokTypes.comma);}</span>
<span class="cstat-no" title="statement not covered" >this.eat(acorn.tokTypes.braceR);<span class="cstat-no" title="statement not covered" >t</span>his.popCx();<span class="cstat-no" title="statement not covered" >r</span>eturn elts}</span>;var lp$2=<span class="cstat-no" title="statement not covered" >LooseParser.prototype;<span class="cstat-no" title="statement not covered" ></span>lp$2.checkLVal=<span class="fstat-no" title="function not covered" >fu</span>nction(expr){<span class="cstat-no" title="statement not covered" >if(!expr){<span class="cstat-no" title="statement not covered" >return expr}</span></span></span>
<span class="cstat-no" title="statement not covered" >switch(expr.type){case"Identifier":case"MemberExpression":<span class="cstat-no" title="statement not covered" >return expr</span></span>
case"ParenthesizedExpression":<span class="cstat-no" title="statement not covered" >expr.expression=this.checkLVal(expr.expression);<span class="cstat-no" title="statement not covered" >r</span>eturn expr</span>
default:<span class="cstat-no" title="statement not covered" >return this.dummyIdent()}</span>};<span class="cstat-no" title="statement not covered" >lp$2.parseExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();</span>var expr=<span class="cstat-no" title="statement not covered" >this.parseMaybeAssign(noIn);<span class="cstat-no" title="statement not covered" ></span>if(this.tok.type===acorn.tokTypes.comma){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node.expressions=[expr];<span class="cstat-no" title="statement not covered" >w</span>hile(this.eat(acorn.tokTypes.comma)){<span class="cstat-no" title="statement not covered" >node.expressions.push(this$1.parseMaybeAssign(noIn));}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"SequenceExpression")}</span>
<span class="cstat-no" title="statement not covered" >return expr}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseParenExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.parenL);v</span>ar val=<span class="cstat-no" title="statement not covered" >this.parseExpression();<span class="cstat-no" title="statement not covered" ></span>this.popCx();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.parenR);<span class="cstat-no" title="statement not covered" >r</span>eturn val}</span>;<span class="cstat-no" title="statement not covered" >l</span>p$2.parseMaybeAssign=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn){<span class="cstat-no" title="statement not covered" >if(this.toks.isContextual("yield")){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.semicolon()||this.canInsertSemicolon()||(this.tok.type!==acorn.tokTypes.star&amp;&amp;!this.tok.type.startsExpr)){<span class="cstat-no" title="statement not covered" >node.delegate=false;<span class="cstat-no" title="statement not covered" >n</span>ode.argument=null;}</span>else{<span class="cstat-no" title="statement not covered" >node.delegate=this.eat(acorn.tokTypes.star);<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeAssign();}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"YieldExpression")}</span>
var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();</span>var left=<span class="cstat-no" title="statement not covered" >this.parseMaybeConditional(noIn);<span class="cstat-no" title="statement not covered" ></span>if(this.tok.type.isAssign){var node$1=<span class="cstat-no" title="statement not covered" >this.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node$1.operator=this.tok.value;<span class="cstat-no" title="statement not covered" >n</span>ode$1.left=this.tok.type===acorn.tokTypes.eq?this.toAssignable(left):this.checkLVal(left);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode$1.right=this.parseMaybeAssign(noIn);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node$1,"AssignmentExpression")}</span></span>
<span class="cstat-no" title="statement not covered" >return left}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseMaybeConditional=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn){var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();</span>var expr=<span class="cstat-no" title="statement not covered" >this.parseExprOps(noIn);<span class="cstat-no" title="statement not covered" ></span>if(this.eat(acorn.tokTypes.question)){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node.test=expr;<span class="cstat-no" title="statement not covered" >n</span>ode.consequent=this.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >n</span>ode.alternate=this.expect(acorn.tokTypes.colon)?this.parseMaybeAssign(noIn):this.dummyIdent();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ConditionalExpression")}</span></span></span>
<span class="cstat-no" title="statement not covered" >return expr}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseExprOps=<span class="fstat-no" title="function not covered" >fu</span>nction(noIn){var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();</span>var indent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart;<span class="cstat-no" title="statement not covered" ></span>return this.parseExprOp(this.parseMaybeUnary(false),start,-1,noIn,indent,line)}</span>;<span class="cstat-no" title="statement not covered" >l</span>p$2.parseExprOp=<span class="fstat-no" title="function not covered" >fu</span>nction(left,start,minPrec,noIn,indent,line){<span class="cstat-no" title="statement not covered" >if(this.curLineStart!==line&amp;&amp;this.curIndent&lt;indent&amp;&amp;this.tokenStartsLine()){<span class="cstat-no" title="statement not covered" >return left}</span></span></span>
var prec=<span class="cstat-no" title="statement not covered" >this.tok.type.binop;<span class="cstat-no" title="statement not covered" ></span>if(prec!=null&amp;&amp;(!noIn||this.tok.type!==acorn.tokTypes._in)){<span class="cstat-no" title="statement not covered" >if(prec&gt;minPrec){var node=<span class="cstat-no" title="statement not covered" >this.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node.left=left;<span class="cstat-no" title="statement not covered" >n</span>ode.operator=this.tok.value;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >i</span>f(this.curLineStart!==line&amp;&amp;this.curIndent&lt;indent&amp;&amp;this.tokenStartsLine()){<span class="cstat-no" title="statement not covered" >node.right=this.dummyIdent();}</span>else{var rightStart=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();<span class="cstat-no" title="statement not covered" ></span>node.right=this.parseExprOp(this.parseMaybeUnary(false),rightStart,prec,noIn,indent,line);}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >this.finishNode(node,/&amp;&amp;|\|\|/.test(node.operator)?"LogicalExpression":"BinaryExpression");<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseExprOp(node,start,minPrec,noIn,indent,line)}</span>}
<span class="cstat-no" title="statement not covered" >return left}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseMaybeUnary=<span class="fstat-no" title="function not covered" >fu</span>nction(sawUnary){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos(),</span>expr;<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8&amp;&amp;this.toks.isContextual("await")&amp;&amp;(this.inAsync||(!this.inFunction&amp;&amp;this.options.allowAwaitOutsideFunction))){<span class="cstat-no" title="statement not covered" >expr=this.parseAwait();<span class="cstat-no" title="statement not covered" >s</span>awUnary=true;}</span>else <span class="cstat-no" title="statement not covered" >if(this.tok.type.prefix){var node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>update=<span class="cstat-no" title="statement not covered" >this.tok.type===acorn.tokTypes.incDec;<span class="cstat-no" title="statement not covered" ></span>if(!update){<span class="cstat-no" title="statement not covered" >sawUnary=true;}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.operator=this.tok.value;<span class="cstat-no" title="statement not covered" >n</span>ode.prefix=true;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeUnary(true);<span class="cstat-no" title="statement not covered" >i</span>f(update){<span class="cstat-no" title="statement not covered" >node.argument=this.checkLVal(node.argument);}</span></span>
<span class="cstat-no" title="statement not covered" >expr=this.finishNode(node,update?"UpdateExpression":"UnaryExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes.ellipsis){var node$1=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode$1.argument=this.parseMaybeUnary(sawUnary);<span class="cstat-no" title="statement not covered" >e</span>xpr=this.finishNode(node$1,"SpreadElement");}</span>else{<span class="cstat-no" title="statement not covered" >expr=this.parseExprSubscripts();<span class="cstat-no" title="statement not covered" >w</span>hile(this.tok.type.postfix&amp;&amp;!this.canInsertSemicolon()){var node$2=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node$2.operator=this$1.tok.value;<span class="cstat-no" title="statement not covered" >n</span>ode$2.prefix=false;<span class="cstat-no" title="statement not covered" >n</span>ode$2.argument=this$1.checkLVal(expr);<span class="cstat-no" title="statement not covered" >t</span>his$1.next();<span class="cstat-no" title="statement not covered" >e</span>xpr=this$1.finishNode(node$2,"UpdateExpression");}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >if(!sawUnary&amp;&amp;this.eat(acorn.tokTypes.starstar)){var node$3=<span class="cstat-no" title="statement not covered" >this.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node$3.operator="**";<span class="cstat-no" title="statement not covered" >n</span>ode$3.left=expr;<span class="cstat-no" title="statement not covered" >n</span>ode$3.right=this.parseMaybeUnary(false);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node$3,"BinaryExpression")}</span></span>
<span class="cstat-no" title="statement not covered" >return expr}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseExprSubscripts=<span class="fstat-no" title="function not covered" >fu</span>nction(){var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();<span class="cstat-no" title="statement not covered" ></span>return this.parseSubscripts(this.parseExprAtom(),start,false,this.curIndent,this.curLineStart)}</span>;<span class="cstat-no" title="statement not covered" >l</span>p$2.parseSubscripts=<span class="fstat-no" title="function not covered" >fu</span>nction(base,start,noCalls,startIndent,line){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;;){<span class="cstat-no" title="statement not covered" >if(this$1.curLineStart!==line&amp;&amp;this$1.curIndent&lt;=startIndent&amp;&amp;this$1.tokenStartsLine()){<span class="cstat-no" title="statement not covered" >if(this$1.tok.type===acorn.tokTypes.dot&amp;&amp;this$1.curIndent===startIndent)</span></span></span></span>
{<span class="cstat-no" title="statement not covered" >--startIndent;}</span>
else
{<span class="cstat-no" title="statement not covered" >return base}</span>}
var maybeAsyncArrow=<span class="cstat-no" title="statement not covered" >base.type==="Identifier"&amp;&amp;base.name==="async"&amp;&amp;!this$1.canInsertSemicolon();<span class="cstat-no" title="statement not covered" ></span>if(this$1.eat(acorn.tokTypes.dot)){var node=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node.object=base;<span class="cstat-no" title="statement not covered" >i</span>f(this$1.curLineStart!==line&amp;&amp;this$1.curIndent&lt;=startIndent&amp;&amp;this$1.tokenStartsLine())</span></span>
{<span class="cstat-no" title="statement not covered" >node.property=this$1.dummyIdent();}</span>
else
{<span class="cstat-no" title="statement not covered" >node.property=this$1.parsePropertyAccessor()||this$1.dummyIdent();}</span>
<span class="cstat-no" title="statement not covered" >node.computed=false;<span class="cstat-no" title="statement not covered" >b</span>ase=this$1.finishNode(node,"MemberExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.tok.type===acorn.tokTypes.bracketL){<span class="cstat-no" title="statement not covered" >this$1.pushCx();<span class="cstat-no" title="statement not covered" >t</span>his$1.next();v</span>ar node$1=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node$1.object=base;<span class="cstat-no" title="statement not covered" >n</span>ode$1.property=this$1.parseExpression();<span class="cstat-no" title="statement not covered" >n</span>ode$1.computed=true;<span class="cstat-no" title="statement not covered" >t</span>his$1.popCx();<span class="cstat-no" title="statement not covered" >t</span>his$1.expect(acorn.tokTypes.bracketR);<span class="cstat-no" title="statement not covered" >b</span>ase=this$1.finishNode(node$1,"MemberExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(!noCalls&amp;&amp;this$1.tok.type===acorn.tokTypes.parenL){var exprList=<span class="cstat-no" title="statement not covered" >this$1.parseExprList(acorn.tokTypes.parenR);<span class="cstat-no" title="statement not covered" ></span>if(maybeAsyncArrow&amp;&amp;this$1.eat(acorn.tokTypes.arrow))</span></span></span>
{<span class="cstat-no" title="statement not covered" >return this$1.parseArrowExpression(this$1.startNodeAt(start),exprList,true)}</span>
var node$2=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node$2.callee=base;<span class="cstat-no" title="statement not covered" >n</span>ode$2.arguments=exprList;<span class="cstat-no" title="statement not covered" >b</span>ase=this$1.finishNode(node$2,"CallExpression");}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.tok.type===acorn.tokTypes.backQuote){var node$3=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>node$3.tag=base;<span class="cstat-no" title="statement not covered" >n</span>ode$3.quasi=this$1.parseTemplate();<span class="cstat-no" title="statement not covered" >b</span>ase=this$1.finishNode(node$3,"TaggedTemplateExpression");}</span>else{<span class="cstat-no" title="statement not covered" >return base}</span>}</span>};<span class="cstat-no" title="statement not covered" >lp$2.parseExprAtom=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node;<span class="cstat-no" title="statement not covered" >switch(this.tok.type){case acorn.tokTypes._this:case acorn.tokTypes._super:var type=<span class="cstat-no" title="statement not covered" >this.tok.type===acorn.tokTypes._this?"ThisExpression":"Super";<span class="cstat-no" title="statement not covered" ></span>node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,type)</span></span></span>
case acorn.tokTypes.name:var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();</span>var id=<span class="cstat-no" title="statement not covered" >this.parseIdent();</span>var isAsync=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(id.name==="async"&amp;&amp;!this.canInsertSemicolon()){<span class="cstat-no" title="statement not covered" >if(this.eat(acorn.tokTypes._function))</span></span>
{<span class="cstat-no" title="statement not covered" >return this.parseFunction(this.startNodeAt(start),false,true)}</span>
<span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes.name){<span class="cstat-no" title="statement not covered" >id=this.parseIdent();<span class="cstat-no" title="statement not covered" >i</span>sAsync=true;}</span>}</span>
<span class="cstat-no" title="statement not covered" >return this.eat(acorn.tokTypes.arrow)?this.parseArrowExpression(this.startNodeAt(start),[id],isAsync):id</span>
case acorn.tokTypes.regexp:<span class="cstat-no" title="statement not covered" >node=this.startNode();v</span>ar val=<span class="cstat-no" title="statement not covered" >this.tok.value;<span class="cstat-no" title="statement not covered" ></span>node.regex={pattern:val.pattern,flags:val.flags};<span class="cstat-no" title="statement not covered" >n</span>ode.value=val.value;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.input.slice(this.tok.start,this.tok.end);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal")</span>
case acorn.tokTypes.num:case acorn.tokTypes.string:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.value=this.tok.value;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.input.slice(this.tok.start,this.tok.end);<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal")</span>
case acorn.tokTypes._null:case acorn.tokTypes._true:case acorn.tokTypes._false:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.value=this.tok.type===acorn.tokTypes._null?null:this.tok.type===acorn.tokTypes._true;<span class="cstat-no" title="statement not covered" >n</span>ode.raw=this.tok.type.keyword;<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Literal")</span>
case acorn.tokTypes.parenL:var parenStart=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();<span class="cstat-no" title="statement not covered" ></span>this.next();v</span>ar inner=<span class="cstat-no" title="statement not covered" >this.parseExpression();<span class="cstat-no" title="statement not covered" ></span>this.expect(acorn.tokTypes.parenR);<span class="cstat-no" title="statement not covered" >i</span>f(this.eat(acorn.tokTypes.arrow)){var params=<span class="cstat-no" title="statement not covered" >inner.expressions||[inner];<span class="cstat-no" title="statement not covered" ></span>if(params.length&amp;&amp;isDummy(params[params.length-1]))</span></span>
{<span class="cstat-no" title="statement not covered" >params.pop();}</span>
<span class="cstat-no" title="statement not covered" >return this.parseArrowExpression(this.startNodeAt(parenStart),params)}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.preserveParens){var par=<span class="cstat-no" title="statement not covered" >this.startNodeAt(parenStart);<span class="cstat-no" title="statement not covered" ></span>par.expression=inner;<span class="cstat-no" title="statement not covered" >i</span>nner=this.finishNode(par,"ParenthesizedExpression");}</span></span>
<span class="cstat-no" title="statement not covered" >return inner</span>
case acorn.tokTypes.bracketL:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >n</span>ode.elements=this.parseExprList(acorn.tokTypes.bracketR,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrayExpression")</span>
case acorn.tokTypes.braceL:<span class="cstat-no" title="statement not covered" >return this.parseObj()</span>
case acorn.tokTypes._class:<span class="cstat-no" title="statement not covered" >return this.parseClass(false)</span>
case acorn.tokTypes._function:<span class="cstat-no" title="statement not covered" >node=this.startNode();<span class="cstat-no" title="statement not covered" >t</span>his.next();<span class="cstat-no" title="statement not covered" >r</span>eturn this.parseFunction(node,false)</span>
case acorn.tokTypes._new:<span class="cstat-no" title="statement not covered" >return this.parseNew()</span>
case acorn.tokTypes.backQuote:<span class="cstat-no" title="statement not covered" >return this.parseTemplate()</span>
default:<span class="cstat-no" title="statement not covered" >return this.dummyIdent()}</span>};<span class="cstat-no" title="statement not covered" >lp$2.parseNew=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>startIndent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart;</span>var meta=<span class="cstat-no" title="statement not covered" >this.parseIdent(true);<span class="cstat-no" title="statement not covered" ></span>if(this.options.ecmaVersion&gt;=6&amp;&amp;this.eat(acorn.tokTypes.dot)){<span class="cstat-no" title="statement not covered" >node.meta=meta;<span class="cstat-no" title="statement not covered" >n</span>ode.property=this.parseIdent(true);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"MetaProperty")}</span></span></span>
var start=<span class="cstat-no" title="statement not covered" >this.storeCurrentPos();<span class="cstat-no" title="statement not covered" ></span>node.callee=this.parseSubscripts(this.parseExprAtom(),start,true,startIndent,line);<span class="cstat-no" title="statement not covered" >i</span>f(this.tok.type===acorn.tokTypes.parenL){<span class="cstat-no" title="statement not covered" >node.arguments=this.parseExprList(acorn.tokTypes.parenR);}</span>else{<span class="cstat-no" title="statement not covered" >node.arguments=[];}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"NewExpression")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseTemplateElement=<span class="fstat-no" title="function not covered" >fu</span>nction(){var elem=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>if(this.tok.type===acorn.tokTypes.invalidTemplate){<span class="cstat-no" title="statement not covered" >elem.value={raw:this.tok.value,cooked:null};}</span>else{<span class="cstat-no" title="statement not covered" >elem.value={raw:this.input.slice(this.tok.start,this.tok.end).replace(/\r\n?/g,"\n"),cooked:this.tok.value};}</span></span></span>
<span class="cstat-no" title="statement not covered" >this.next();<span class="cstat-no" title="statement not covered" >e</span>lem.tail=this.tok.type===acorn.tokTypes.backQuote;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(elem,"TemplateElement")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseTemplate=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.expressions=[];v</span>ar curElt=<span class="cstat-no" title="statement not covered" >this.parseTemplateElement();<span class="cstat-no" title="statement not covered" ></span>node.quasis=[curElt];<span class="cstat-no" title="statement not covered" >w</span>hile(!curElt.tail){<span class="cstat-no" title="statement not covered" >this$1.next();<span class="cstat-no" title="statement not covered" >n</span>ode.expressions.push(this$1.parseExpression());<span class="cstat-no" title="statement not covered" >i</span>f(this$1.expect(acorn.tokTypes.braceR)){<span class="cstat-no" title="statement not covered" >curElt=this$1.parseTemplateElement();}</span>else{<span class="cstat-no" title="statement not covered" >curElt=this$1.startNode();<span class="cstat-no" title="statement not covered" >c</span>urElt.value={cooked:"",raw:""};<span class="cstat-no" title="statement not covered" >c</span>urElt.tail=true;<span class="cstat-no" title="statement not covered" >t</span>his$1.finishNode(curElt,"TemplateElement");}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >node.quasis.push(curElt);}</span>
<span class="cstat-no" title="statement not covered" >this.expect(acorn.tokTypes.backQuote);<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"TemplateLiteral")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseObj=<span class="fstat-no" title="function not covered" >fu</span>nction(){var this$1=<span class="cstat-no" title="statement not covered" >this;</span>var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>node.properties=[];<span class="cstat-no" title="statement not covered" >t</span>his.pushCx();v</span>ar indent=<span class="cstat-no" title="statement not covered" >this.curIndent+1,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart;<span class="cstat-no" title="statement not covered" ></span>this.eat(acorn.tokTypes.braceL);<span class="cstat-no" title="statement not covered" >i</span>f(this.curIndent+1&lt;indent){<span class="cstat-no" title="statement not covered" >indent=this.curIndent;<span class="cstat-no" title="statement not covered" >l</span>ine=this.curLineStart;}</span></span></span>
<span class="cstat-no" title="statement not covered" >while(!this.closes(acorn.tokTypes.braceR,indent,line)){var prop=<span class="cstat-no" title="statement not covered" >this$1.startNode(),</span>isGenerator=(<span class="cstat-no" title="statement not covered" >void 0)</span>,isAsync=(<span class="cstat-no" title="statement not covered" >void 0)</span>,start=(<span class="cstat-no" title="statement not covered" >void 0)</span>;<span class="cstat-no" title="statement not covered" >if(this$1.options.ecmaVersion&gt;=9&amp;&amp;this$1.eat(acorn.tokTypes.ellipsis)){<span class="cstat-no" title="statement not covered" >prop.argument=this$1.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >n</span>ode.properties.push(this$1.finishNode(prop,"SpreadElement"));<span class="cstat-no" title="statement not covered" >t</span>his$1.eat(acorn.tokTypes.comma);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this$1.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >start=this$1.storeCurrentPos();<span class="cstat-no" title="statement not covered" >p</span>rop.method=false;<span class="cstat-no" title="statement not covered" >p</span>rop.shorthand=false;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this$1.eat(acorn.tokTypes.star);}</span></span>
<span class="cstat-no" title="statement not covered" >this$1.parsePropertyName(prop);<span class="cstat-no" title="statement not covered" >i</span>f(this$1.toks.isAsyncProp(prop)){<span class="cstat-no" title="statement not covered" >isAsync=true;<span class="cstat-no" title="statement not covered" >i</span>sGenerator=this$1.options.ecmaVersion&gt;=9&amp;&amp;this$1.eat(acorn.tokTypes.star);<span class="cstat-no" title="statement not covered" >t</span>his$1.parsePropertyName(prop);}</span>else{<span class="cstat-no" title="statement not covered" >isAsync=false;}</span></span>
<span class="cstat-no" title="statement not covered" >if(isDummy(prop.key)){<span class="cstat-no" title="statement not covered" >if(isDummy(this$1.parseMaybeAssign())){<span class="cstat-no" title="statement not covered" >this$1.next();}<span class="cstat-no" title="statement not covered" ></span>t</span>his$1.eat(acorn.tokTypes.comma);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span></span>
<span class="cstat-no" title="statement not covered" >if(this$1.eat(acorn.tokTypes.colon)){<span class="cstat-no" title="statement not covered" >prop.kind="init";<span class="cstat-no" title="statement not covered" >p</span>rop.value=this$1.parseMaybeAssign();}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.options.ecmaVersion&gt;=6&amp;&amp;(this$1.tok.type===acorn.tokTypes.parenL||this$1.tok.type===acorn.tokTypes.braceL)){<span class="cstat-no" title="statement not covered" >prop.kind="init";<span class="cstat-no" title="statement not covered" >p</span>rop.method=true;<span class="cstat-no" title="statement not covered" >p</span>rop.value=this$1.parseMethod(isGenerator,isAsync);}</span>else <span class="cstat-no" title="statement not covered" >if(this$1.options.ecmaVersion&gt;=5&amp;&amp;prop.key.type==="Identifier"&amp;&amp;!prop.computed&amp;&amp;(prop.key.name==="get"||prop.key.name==="set")&amp;&amp;(this$1.tok.type!==acorn.tokTypes.comma&amp;&amp;this$1.tok.type!==acorn.tokTypes.braceR&amp;&amp;this$1.tok.type!==acorn.tokTypes.eq)){<span class="cstat-no" title="statement not covered" >prop.kind=prop.key.name;<span class="cstat-no" title="statement not covered" >t</span>his$1.parsePropertyName(prop);<span class="cstat-no" title="statement not covered" >p</span>rop.value=this$1.parseMethod(false);}</span>else{<span class="cstat-no" title="statement not covered" >prop.kind="init";<span class="cstat-no" title="statement not covered" >i</span>f(this$1.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(this$1.eat(acorn.tokTypes.eq)){var assign=<span class="cstat-no" title="statement not covered" >this$1.startNodeAt(start);<span class="cstat-no" title="statement not covered" ></span>assign.operator="=";<span class="cstat-no" title="statement not covered" >a</span>ssign.left=prop.key;<span class="cstat-no" title="statement not covered" >a</span>ssign.right=this$1.parseMaybeAssign();<span class="cstat-no" title="statement not covered" >p</span>rop.value=this$1.finishNode(assign,"AssignmentExpression");}</span>else{<span class="cstat-no" title="statement not covered" >prop.value=prop.key;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >prop.value=this$1.dummyIdent();}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >prop.shorthand=true;}</span>
<span class="cstat-no" title="statement not covered" >node.properties.push(this$1.finishNode(prop,"Property"));<span class="cstat-no" title="statement not covered" >t</span>his$1.eat(acorn.tokTypes.comma);}</span>
<span class="cstat-no" title="statement not covered" >this.popCx();<span class="cstat-no" title="statement not covered" >i</span>f(!this.eat(acorn.tokTypes.braceR)){<span class="cstat-no" title="statement not covered" >this.last.end=this.tok.start;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >this.last.loc.end=this.tok.loc.start;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return this.finishNode(node,"ObjectExpression")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parsePropertyName=<span class="fstat-no" title="function not covered" >fu</span>nction(prop){<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >if(this.eat(acorn.tokTypes.bracketL)){<span class="cstat-no" title="statement not covered" >prop.computed=true;<span class="cstat-no" title="statement not covered" >p</span>rop.key=this.parseExpression();<span class="cstat-no" title="statement not covered" >t</span>his.expect(acorn.tokTypes.bracketR);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>else{<span class="cstat-no" title="statement not covered" >prop.computed=false;}</span>}</span></span></span>
var key=<span class="cstat-no" title="statement not covered" >(this.tok.type===acorn.tokTypes.num||this.tok.type===acorn.tokTypes.string)?this.parseExprAtom():this.parseIdent();<span class="cstat-no" title="statement not covered" ></span>prop.key=key||this.dummyIdent();}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parsePropertyAccessor=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.tok.type===acorn.tokTypes.name||this.tok.type.keyword){<span class="cstat-no" title="statement not covered" >return this.parseIdent()}</span>}</span>;<span class="cstat-no" title="statement not covered" >l</span>p$2.parseIdent=<span class="fstat-no" title="function not covered" >fu</span>nction(){var name=<span class="cstat-no" title="statement not covered" >this.tok.type===acorn.tokTypes.name?this.tok.value:this.tok.type.keyword;<span class="cstat-no" title="statement not covered" ></span>if(!name){<span class="cstat-no" title="statement not covered" >return this.dummyIdent()}</span></span></span>
var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.name=name;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"Identifier")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.initFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(node){<span class="cstat-no" title="statement not covered" >node.id=null;<span class="cstat-no" title="statement not covered" >n</span>ode.params=[];<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6){<span class="cstat-no" title="statement not covered" >node.generator=false;<span class="cstat-no" title="statement not covered" >n</span>ode.expression=false;}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8)</span>
{<span class="cstat-no" title="statement not covered" >node.async=false;}</span>};<span class="cstat-no" title="statement not covered" >lp$2.toAssignable=<span class="fstat-no" title="function not covered" >fu</span>nction(node,binding){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!node||node.type==="Identifier"||(node.type==="MemberExpression"&amp;&amp;!binding)){}else <span class="cstat-no" title="statement not covered" >if(node.type==="ParenthesizedExpression"){<span class="cstat-no" title="statement not covered" >this.toAssignable(node.expression,binding);}</span>else <span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&lt;6){<span class="cstat-no" title="statement not covered" >return this.dummyIdent()}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==="ObjectExpression"){<span class="cstat-no" title="statement not covered" >node.type="ObjectPattern";<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,list=node.properties;i&lt;list.length;i+=1)</span></span></span></span></span></span>
{var prop=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.toAssignable(prop,binding);}</span>}else <span class="cstat-no" title="statement not covered" >if(node.type==="ArrayExpression"){<span class="cstat-no" title="statement not covered" >node.type="ArrayPattern";<span class="cstat-no" title="statement not covered" >t</span>his.toAssignableList(node.elements,binding);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==="Property"){<span class="cstat-no" title="statement not covered" >this.toAssignable(node.value,binding);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==="SpreadElement"){<span class="cstat-no" title="statement not covered" >node.type="RestElement";<span class="cstat-no" title="statement not covered" >t</span>his.toAssignable(node.argument,binding);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==="AssignmentExpression"){<span class="cstat-no" title="statement not covered" >node.type="AssignmentPattern";<span class="cstat-no" title="statement not covered" >d</span>elete node.operator;}</span>else{<span class="cstat-no" title="statement not covered" >return this.dummyIdent()}</span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >return node}</span>;<span class="cstat-no" title="statement not covered" >lp$2.toAssignableList=<span class="fstat-no" title="function not covered" >fu</span>nction(exprList,binding){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var i=0,list=exprList;i&lt;list.length;i+=1)</span></span>
{var expr=<span class="cstat-no" title="statement not covered" >list[i];<span class="cstat-no" title="statement not covered" ></span>this$1.toAssignable(expr,binding);}</span>
<span class="cstat-no" title="statement not covered" >return exprList}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseFunctionParams=<span class="fstat-no" title="function not covered" >fu</span>nction(params){<span class="cstat-no" title="statement not covered" >params=this.parseExprList(acorn.tokTypes.parenR);<span class="cstat-no" title="statement not covered" >r</span>eturn this.toAssignableList(params,true)}</span>;<span class="cstat-no" title="statement not covered" >l</span>p$2.parseMethod=<span class="fstat-no" title="function not covered" >fu</span>nction(isGenerator,isAsync){var node=<span class="cstat-no" title="statement not covered" >this.startNode(),</span>oldInAsync=<span class="cstat-no" title="statement not covered" >this.inAsync,</span>oldInFunction=<span class="cstat-no" title="statement not covered" >this.inFunction;<span class="cstat-no" title="statement not covered" ></span>this.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=6)</span></span>
{<span class="cstat-no" title="statement not covered" >node.generator=!!isGenerator;}</span>
<span class="cstat-no" title="statement not covered" >if(this.options.ecmaVersion&gt;=8)</span>
{<span class="cstat-no" title="statement not covered" >node.async=!!isAsync;}</span>
<span class="cstat-no" title="statement not covered" >this.inAsync=node.async;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=true;<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.parseFunctionParams();<span class="cstat-no" title="statement not covered" >n</span>ode.body=this.parseBlock();<span class="cstat-no" title="statement not covered" >t</span>his.toks.adaptDirectivePrologue(node.body.body);<span class="cstat-no" title="statement not covered" >t</span>his.inAsync=oldInAsync;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=oldInFunction;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"FunctionExpression")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseArrowExpression=<span class="fstat-no" title="function not covered" >fu</span>nction(node,params,isAsync){var oldInAsync=<span class="cstat-no" title="statement not covered" >this.inAsync,</span>oldInFunction=<span class="cstat-no" title="statement not covered" >this.inFunction;<span class="cstat-no" title="statement not covered" ></span>this.initFunction(node);<span class="cstat-no" title="statement not covered" >i</span>f(this.options.ecmaVersion&gt;=8)</span></span>
{<span class="cstat-no" title="statement not covered" >node.async=!!isAsync;}</span>
<span class="cstat-no" title="statement not covered" >this.inAsync=node.async;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=true;<span class="cstat-no" title="statement not covered" >n</span>ode.params=this.toAssignableList(params,true);<span class="cstat-no" title="statement not covered" >n</span>ode.expression=this.tok.type!==acorn.tokTypes.braceL;<span class="cstat-no" title="statement not covered" >i</span>f(node.expression){<span class="cstat-no" title="statement not covered" >node.body=this.parseMaybeAssign();}</span>else{<span class="cstat-no" title="statement not covered" >node.body=this.parseBlock();<span class="cstat-no" title="statement not covered" >t</span>his.toks.adaptDirectivePrologue(node.body.body);}</span></span>
<span class="cstat-no" title="statement not covered" >this.inAsync=oldInAsync;<span class="cstat-no" title="statement not covered" >t</span>his.inFunction=oldInFunction;<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"ArrowFunctionExpression")}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseExprList=<span class="fstat-no" title="function not covered" >fu</span>nction(close,allowEmpty){var this$1=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.pushCx();v</span>ar indent=<span class="cstat-no" title="statement not covered" >this.curIndent,</span>line=<span class="cstat-no" title="statement not covered" >this.curLineStart,</span>elts=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >w</span>hile(!this.closes(close,indent+1,line)){<span class="cstat-no" title="statement not covered" >if(this$1.eat(acorn.tokTypes.comma)){<span class="cstat-no" title="statement not covered" >elts.push(allowEmpty?null:this$1.dummyIdent());<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span></span></span></span>
var elt=<span class="cstat-no" title="statement not covered" >this$1.parseMaybeAssign();<span class="cstat-no" title="statement not covered" ></span>if(isDummy(elt)){<span class="cstat-no" title="statement not covered" >if(this$1.closes(close,indent,line)){<span class="cstat-no" title="statement not covered" >break}</span></span></span>
<span class="cstat-no" title="statement not covered" >this$1.next();}</span>else{<span class="cstat-no" title="statement not covered" >elts.push(elt);}</span>
<span class="cstat-no" title="statement not covered" >this$1.eat(acorn.tokTypes.comma);}</span>
<span class="cstat-no" title="statement not covered" >this.popCx();<span class="cstat-no" title="statement not covered" >i</span>f(!this.eat(close)){<span class="cstat-no" title="statement not covered" >this.last.end=this.tok.start;<span class="cstat-no" title="statement not covered" >i</span>f(this.options.locations){<span class="cstat-no" title="statement not covered" >this.last.loc.end=this.tok.loc.start;}</span>}</span></span>
<span class="cstat-no" title="statement not covered" >return elts}</span>;<span class="cstat-no" title="statement not covered" >lp$2.parseAwait=<span class="fstat-no" title="function not covered" >fu</span>nction(){var node=<span class="cstat-no" title="statement not covered" >this.startNode();<span class="cstat-no" title="statement not covered" ></span>this.next();<span class="cstat-no" title="statement not covered" >n</span>ode.argument=this.parseMaybeUnary();<span class="cstat-no" title="statement not covered" >r</span>eturn this.finishNode(node,"AwaitExpression")}</span>;<span class="cstat-no" title="statement not covered" >a</span>corn.defaultOptions.tabSize=4;f</span>unction <span class="fstat-no" title="function not covered" >parse(</span>input,options){<span class="cstat-no" title="statement not covered" >return LooseParser.parse(input,options)}</span>
<span class="cstat-no" title="statement not covered" >exports.parse=parse;<span class="cstat-no" title="statement not covered" >e</span>xports.LooseParser=LooseParser;<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(exports,'__esModule',{value:true});}</span>)));;<span class="cstat-no" title="statement not covered" >FormatterWorker.CSSFormatter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(builder){<span class="cstat-no" title="statement not covered" >this._builder=builder;}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>rmat(text,lineEndings,fromOffset,toOffset){<span class="cstat-no" title="statement not covered" >this._lineEndings=lineEndings;<span class="cstat-no" title="statement not covered" >t</span>his._fromOffset=fromOffset;<span class="cstat-no" title="statement not covered" >t</span>his._toOffset=toOffset;<span class="cstat-no" title="statement not covered" >t</span>his._lastLine=-1;<span class="cstat-no" title="statement not covered" >t</span>his._state={};c</span>onst tokenize=<span class="cstat-no" title="statement not covered" >FormatterWorker.createTokenizer('text/css');</span>const oldEnforce=<span class="cstat-no" title="statement not covered" >this._builder.setEnforceSpaceBetweenWords(false);<span class="cstat-no" title="statement not covered" ></span>tokenize(text.substring(this._fromOffset,this._toOffset),this._tokenCallback.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his._builder.setEnforceSpaceBetweenWords(oldEnforce);}</span>
<span class="fstat-no" title="function not covered" >_t</span>okenCallback(token,type,startPosition){<span class="cstat-no" title="statement not covered" >startPosition+=this._fromOffset;c</span>onst startLine=<span class="cstat-no" title="statement not covered" >this._lineEndings.lowerBound(startPosition);<span class="cstat-no" title="statement not covered" ></span>if(startLine!==this._lastLine)</span>
<span class="cstat-no" title="statement not covered" >this._state.eatWhitespace=true;<span class="cstat-no" title="statement not covered" >i</span>f(/^property/.test(type)&amp;&amp;!this._state.inPropertyValue)</span>
<span class="cstat-no" title="statement not covered" >this._state.seenProperty=true;<span class="cstat-no" title="statement not covered" >t</span>his._lastLine=startLine;c</span>onst isWhitespace=<span class="cstat-no" title="statement not covered" >/^\s+$/.test(token);<span class="cstat-no" title="statement not covered" ></span>if(isWhitespace){<span class="cstat-no" title="statement not covered" >if(!this._state.eatWhitespace)</span></span>
<span class="cstat-no" title="statement not covered" >this._builder.addSoftSpace();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >this._state.eatWhitespace=false;<span class="cstat-no" title="statement not covered" >i</span>f(token==='\n')</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(token!=='}'){<span class="cstat-no" title="statement not covered" >if(this._state.afterClosingBrace)</span></span>
<span class="cstat-no" title="statement not covered" >this._builder.addNewLine(true);<span class="cstat-no" title="statement not covered" >t</span>his._state.afterClosingBrace=false;}</span>
<span class="cstat-no" title="statement not covered" >if(token==='}'){<span class="cstat-no" title="statement not covered" >if(this._state.inPropertyValue)</span></span>
<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();<span class="cstat-no" title="statement not covered" >t</span>his._builder.decreaseNestingLevel();<span class="cstat-no" title="statement not covered" >t</span>his._state.afterClosingBrace=true;<span class="cstat-no" title="statement not covered" >t</span>his._state.inPropertyValue=false;}</span>else <span class="cstat-no" title="statement not covered" >if(token===':'&amp;&amp;!this._state.inPropertyValue&amp;&amp;this._state.seenProperty){<span class="cstat-no" title="statement not covered" >this._builder.addToken(token,startPosition);<span class="cstat-no" title="statement not covered" >t</span>his._builder.addSoftSpace();<span class="cstat-no" title="statement not covered" >t</span>his._state.eatWhitespace=true;<span class="cstat-no" title="statement not covered" >t</span>his._state.inPropertyValue=true;<span class="cstat-no" title="statement not covered" >t</span>his._state.seenProperty=false;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>else <span class="cstat-no" title="statement not covered" >if(token==='{'){<span class="cstat-no" title="statement not covered" >this._builder.addSoftSpace();<span class="cstat-no" title="statement not covered" >t</span>his._builder.addToken(token,startPosition);<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();<span class="cstat-no" title="statement not covered" >t</span>his._builder.increaseNestingLevel();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._builder.addToken(token,startPosition);<span class="cstat-no" title="statement not covered" >i</span>f(type==='comment'&amp;&amp;!this._state.inPropertyValue&amp;&amp;!this._state.seenProperty)</span>
<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();<span class="cstat-no" title="statement not covered" >i</span>f(token===';'&amp;&amp;this._state.inPropertyValue){<span class="cstat-no" title="statement not covered" >this._state.inPropertyValue=false;<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();}</span>else <span class="cstat-no" title="statement not covered" >if(token==='}'){<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();}</span>}</span></span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.AcornTokenizer=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(content){<span class="cstat-no" title="statement not covered" >this._content=content;<span class="cstat-no" title="statement not covered" >t</span>his._comments=[];<span class="cstat-no" title="statement not covered" >t</span>his._tokenizer=acorn.tokenizer(this._content,{ecmaVersion:8,onComment:this._comments});<span class="cstat-no" title="statement not covered" >t</span>his._textCursor=new TextUtils.TextCursor(this._content.computeLineEndings());<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineStart=0;<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineEnd=0;<span class="cstat-no" title="statement not covered" >t</span>his._nextTokenInternal();}</span></span>
<span class="fstat-no" title="function not covered" >st</span>atic punctuator(token,values){<span class="cstat-no" title="statement not covered" >return token.type!==acorn.tokTypes.num&amp;&amp;token.type!==acorn.tokTypes.regexp&amp;&amp;token.type!==acorn.tokTypes.string&amp;&amp;token.type!==acorn.tokTypes.name&amp;&amp;!token.type.keyword&amp;&amp;(!values||(token.type.label.length===1&amp;&amp;values.indexOf(token.type.label)!==-1));}</span>
<span class="fstat-no" title="function not covered" >st</span>atic keyword(token,keyword){<span class="cstat-no" title="statement not covered" >return!!token.type.keyword&amp;&amp;token.type!==acorn.tokTypes['_true']&amp;&amp;token.type!==acorn.tokTypes['_false']&amp;&amp;token.type!==acorn.tokTypes['_null']&amp;&amp;(!keyword||token.type.keyword===keyword);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic identifier(token,identifier){<span class="cstat-no" title="statement not covered" >return token.type===acorn.tokTypes.name&amp;&amp;(!identifier||token.value===identifier);}</span>
<span class="fstat-no" title="function not covered" >st</span>atic lineComment(token){<span class="cstat-no" title="statement not covered" >return token.type==='Line';}</span>
<span class="fstat-no" title="function not covered" >st</span>atic blockComment(token){<span class="cstat-no" title="statement not covered" >return token.type==='Block';}</span>
<span class="fstat-no" title="function not covered" >_n</span>extTokenInternal(){<span class="cstat-no" title="statement not covered" >if(this._comments.length)</span>
<span class="cstat-no" title="statement not covered" >return this._comments.shift();c</span>onst token=<span class="cstat-no" title="statement not covered" >this._bufferedToken;<span class="cstat-no" title="statement not covered" ></span>this._bufferedToken=this._tokenizer.getToken();<span class="cstat-no" title="statement not covered" >r</span>eturn token;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xtToken(){const token=<span class="cstat-no" title="statement not covered" >this._nextTokenInternal();<span class="cstat-no" title="statement not covered" ></span>if(token.type===acorn.tokTypes.eof)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span>his._textCursor.advance(token.start);<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineStart=this._textCursor.lineNumber();<span class="cstat-no" title="statement not covered" >t</span>his._tokenColumnStart=this._textCursor.columnNumber();<span class="cstat-no" title="statement not covered" >t</span>his._textCursor.advance(token.end);<span class="cstat-no" title="statement not covered" >t</span>his._tokenLineEnd=this._textCursor.lineNumber();<span class="cstat-no" title="statement not covered" >r</span>eturn token;}</span>
<span class="fstat-no" title="function not covered" >pe</span>ekToken(){<span class="cstat-no" title="statement not covered" >if(this._comments.length)</span>
<span class="cstat-no" title="statement not covered" >return this._comments[0];<span class="cstat-no" title="statement not covered" >r</span>eturn this._bufferedToken.type!==acorn.tokTypes.eof?this._bufferedToken:null;}</span>
<span class="fstat-no" title="function not covered" >to</span>kenLineStart(){<span class="cstat-no" title="statement not covered" >return this._tokenLineStart;}</span>
<span class="fstat-no" title="function not covered" >to</span>kenLineEnd(){<span class="cstat-no" title="statement not covered" >return this._tokenLineEnd;}</span>
<span class="fstat-no" title="function not covered" >to</span>kenColumnStart(){<span class="cstat-no" title="statement not covered" >return this._tokenColumnStart;}</span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.JavaScriptFormatter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(builder){<span class="cstat-no" title="statement not covered" >this._builder=builder;}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>rmat(text,lineEndings,fromOffset,toOffset){<span class="cstat-no" title="statement not covered" >this._fromOffset=fromOffset;<span class="cstat-no" title="statement not covered" >t</span>his._toOffset=toOffset;<span class="cstat-no" title="statement not covered" >t</span>his._content=text.substring(this._fromOffset,this._toOffset);<span class="cstat-no" title="statement not covered" >t</span>his._lastLineNumber=0;<span class="cstat-no" title="statement not covered" >t</span>his._tokenizer=new FormatterWorker.AcornTokenizer(this._content);c</span>onst ast=<span class="cstat-no" title="statement not covered" >acorn.parse(this._content,{ranges:false,ecmaVersion:8,preserveParens:true});</span>const walker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(this._beforeVisit.bind(this),this._afterVisit.bind(this));<span class="cstat-no" title="statement not covered" ></span>walker.walk(ast);}</span>
<span class="fstat-no" title="function not covered" >_p</span>ush(token,format){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;format.length;++i){<span class="cstat-no" title="statement not covered" >if(format[i]==='s'){<span class="cstat-no" title="statement not covered" >this._builder.addSoftSpace();}</span>else <span class="cstat-no" title="statement not covered" >if(format[i]==='S'){<span class="cstat-no" title="statement not covered" >this._builder.addHardSpace();}</span>else <span class="cstat-no" title="statement not covered" >if(format[i]==='n'){<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();}</span>else <span class="cstat-no" title="statement not covered" >if(format[i]==='&gt;'){<span class="cstat-no" title="statement not covered" >this._builder.increaseNestingLevel();}</span>else <span class="cstat-no" title="statement not covered" >if(format[i]==='&lt;'){<span class="cstat-no" title="statement not covered" >this._builder.decreaseNestingLevel();}</span>else <span class="cstat-no" title="statement not covered" >if(format[i]==='t'){<span class="cstat-no" title="statement not covered" >if(this._tokenizer.tokenLineStart()-this._lastLineNumber&gt;1)</span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >this._builder.addNewLine(true);<span class="cstat-no" title="statement not covered" >t</span>his._lastLineNumber=this._tokenizer.tokenLineEnd();<span class="cstat-no" title="statement not covered" >t</span>his._builder.addToken(this._content.substring(token.start,token.end),this._fromOffset+token.start);}</span>}}
<span class="fstat-no" title="function not covered" >_b</span>eforeVisit(node){<span class="cstat-no" title="statement not covered" >if(!node.parent)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >w</span>hile(this._tokenizer.peekToken()&amp;&amp;this._tokenizer.peekToken().start&lt;node.start){const token=(<span class="cstat-no" title="statement not covered" >this._tokenizer.nextToken())</span>;const format=<span class="cstat-no" title="statement not covered" >this._formatToken(node.parent,token);<span class="cstat-no" title="statement not covered" ></span>this._push(token,format);}</span>}</span>
<span class="fstat-no" title="function not covered" >_a</span>fterVisit(node){<span class="cstat-no" title="statement not covered" >while(this._tokenizer.peekToken()&amp;&amp;this._tokenizer.peekToken().start&lt;node.end){const token=(<span class="cstat-no" title="statement not covered" >this._tokenizer.nextToken())</span>;const format=<span class="cstat-no" title="statement not covered" >this._formatToken(node,token);<span class="cstat-no" title="statement not covered" ></span>this._push(token,format);}</span></span>
<span class="cstat-no" title="statement not covered" >this._push(null,this._finishNode(node));}</span>
<span class="fstat-no" title="function not covered" >_i</span>nForLoopHeader(node){const parent=<span class="cstat-no" title="statement not covered" >node.parent;<span class="cstat-no" title="statement not covered" ></span>if(!parent)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(parent.type==='ForStatement')</span>
<span class="cstat-no" title="statement not covered" >return node===parent.init||node===parent.test||node===parent.update;<span class="cstat-no" title="statement not covered" >i</span>f(parent.type==='ForInStatement'||parent.type==='ForOfStatement')</span>
<span class="cstat-no" title="statement not covered" >return node===parent.left||parent.right;<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>
<span class="fstat-no" title="function not covered" >_f</span>ormatToken(node,token){const AT=<span class="cstat-no" title="statement not covered" >FormatterWorker.AcornTokenizer;<span class="cstat-no" title="statement not covered" ></span>if(AT.lineComment(token))</span>
<span class="cstat-no" title="statement not covered" >return'tn';<span class="cstat-no" title="statement not covered" >i</span>f(AT.blockComment(token))</span>
<span class="cstat-no" title="statement not covered" >return'tn';<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ContinueStatement'||node.type==='BreakStatement'){<span class="cstat-no" title="statement not covered" >return node.label&amp;&amp;AT.keyword(token)?'ts':'t';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Identifier'){<span class="cstat-no" title="statement not covered" >return't';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ReturnStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,';'))</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return't';<span class="cstat-no" title="statement not covered" >r</span>eturn node.argument?'ts':'t';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Property'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,':'))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';<span class="cstat-no" title="statement not covered" >r</span>eturn't';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ArrayExpression'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,','))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';<span class="cstat-no" title="statement not covered" >r</span>eturn't';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='LabeledStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,':'))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='LogicalExpression'||node.type==='AssignmentExpression'||node.type==='BinaryExpression'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token)&amp;&amp;!AT.punctuator(token,'()'))</span></span>
<span class="cstat-no" title="statement not covered" >return'sts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ConditionalExpression'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,'?:'))</span></span>
<span class="cstat-no" title="statement not covered" >return'sts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='VariableDeclarator'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,'='))</span></span>
<span class="cstat-no" title="statement not covered" >return'sts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >if(node.parent&amp;&amp;node.parent.type==='VariableDeclarator'&amp;&amp;AT.punctuator(token,'{'))</span></span>
<span class="cstat-no" title="statement not covered" >return'st';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,','))</span>
<span class="cstat-no" title="statement not covered" >return'ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='FunctionDeclaration'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,',)'))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='FunctionExpression'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,',)'))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';<span class="cstat-no" title="statement not covered" >i</span>f(AT.keyword(token,'function'))</span>
<span class="cstat-no" title="statement not covered" >return node.id?'ts':'t';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='WithStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,')'))</span></span>
<span class="cstat-no" title="statement not covered" >return node.body&amp;&amp;node.body.type==='BlockStatement'?'ts':'tn&gt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SwitchStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,'{'))</span></span>
<span class="cstat-no" title="statement not covered" >return'tn&gt;';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,'}'))</span>
<span class="cstat-no" title="statement not covered" >return'n&lt;tn';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,')'))</span>
<span class="cstat-no" title="statement not covered" >return'ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SwitchCase'){<span class="cstat-no" title="statement not covered" >if(AT.keyword(token,'case'))</span></span>
<span class="cstat-no" title="statement not covered" >return'n&lt;ts';<span class="cstat-no" title="statement not covered" >i</span>f(AT.keyword(token,'default'))</span>
<span class="cstat-no" title="statement not covered" >return'n&lt;t';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,':'))</span>
<span class="cstat-no" title="statement not covered" >return'tn&gt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='VariableDeclaration'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,',')){let allVariablesInitialized=<span class="cstat-no" title="statement not covered" >true;</span>const declarations=(<span class="cstat-no" title="statement not covered" >node.declarations)</span>;<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;declarations.length;++i)</span></span></span>
<span class="cstat-no" title="statement not covered" >allVariablesInitialized=allVariablesInitialized&amp;&amp;!!declarations[i].init;<span class="cstat-no" title="statement not covered" >r</span>eturn!this._inForLoopHeader(node)&amp;&amp;allVariablesInitialized?'nSSts':'ts';}</span>}else <span class="cstat-no" title="statement not covered" >if(node.type==='BlockStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,'{'))</span></span>
<span class="cstat-no" title="statement not covered" >return node.body.length?'tn&gt;':'t';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,'}'))</span>
<span class="cstat-no" title="statement not covered" >return node.body.length?'n&lt;t':'t';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='CatchClause'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,')'))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectExpression'){<span class="cstat-no" title="statement not covered" >if(!node.properties.length)</span></span>
<span class="cstat-no" title="statement not covered" >return't';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,'{'))</span>
<span class="cstat-no" title="statement not covered" >return'tn&gt;';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,'}'))</span>
<span class="cstat-no" title="statement not covered" >return'n&lt;t';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,','))</span>
<span class="cstat-no" title="statement not covered" >return'tn';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='IfStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,')'))</span></span>
<span class="cstat-no" title="statement not covered" >return node.consequent&amp;&amp;node.consequent.type==='BlockStatement'?'ts':'tn&gt;';<span class="cstat-no" title="statement not covered" >i</span>f(AT.keyword(token,'else')){const preFormat=<span class="cstat-no" title="statement not covered" >node.consequent&amp;&amp;node.consequent.type==='BlockStatement'?'st':'n&lt;t';</span>let postFormat=<span class="cstat-no" title="statement not covered" >'n&gt;';<span class="cstat-no" title="statement not covered" ></span>if(node.alternate&amp;&amp;(node.alternate.type==='BlockStatement'||node.alternate.type==='IfStatement'))</span></span>
<span class="cstat-no" title="statement not covered" >postFormat='s';<span class="cstat-no" title="statement not covered" >r</span>eturn preFormat+postFormat;}</span>}else <span class="cstat-no" title="statement not covered" >if(node.type==='CallExpression'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,','))</span></span>
<span class="cstat-no" title="statement not covered" >return'ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SequenceExpression'&amp;&amp;AT.punctuator(token,',')){<span class="cstat-no" title="statement not covered" >return node.parent&amp;&amp;node.parent.type==='SwitchCase'?'ts':'tn';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ForStatement'||node.type==='ForOfStatement'||node.type==='ForInStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,';'))</span></span></span>
<span class="cstat-no" title="statement not covered" >return'ts';<span class="cstat-no" title="statement not covered" >i</span>f(AT.keyword(token,'in')||AT.identifier(token,'of'))</span>
<span class="cstat-no" title="statement not covered" >return'sts';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,')'))</span>
<span class="cstat-no" title="statement not covered" >return node.body&amp;&amp;node.body.type==='BlockStatement'?'ts':'tn&gt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='WhileStatement'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,')'))</span></span>
<span class="cstat-no" title="statement not covered" >return node.body&amp;&amp;node.body.type==='BlockStatement'?'ts':'tn&gt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='DoWhileStatement'){const blockBody=<span class="cstat-no" title="statement not covered" >node.body&amp;&amp;node.body.type==='BlockStatement';<span class="cstat-no" title="statement not covered" ></span>if(AT.keyword(token,'do'))</span></span>
<span class="cstat-no" title="statement not covered" >return blockBody?'ts':'tn&gt;';<span class="cstat-no" title="statement not covered" >i</span>f(AT.keyword(token,'while'))</span>
<span class="cstat-no" title="statement not covered" >return blockBody?'sts':'n&lt;ts';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassBody'){<span class="cstat-no" title="statement not covered" >if(AT.punctuator(token,'{'))</span></span>
<span class="cstat-no" title="statement not covered" >return'stn&gt;';<span class="cstat-no" title="statement not covered" >i</span>f(AT.punctuator(token,'}'))</span>
<span class="cstat-no" title="statement not covered" >return'&lt;ntn';<span class="cstat-no" title="statement not covered" >r</span>eturn't';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='YieldExpression'){<span class="cstat-no" title="statement not covered" >return't';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Super'){<span class="cstat-no" title="statement not covered" >return't';}</span></span></span>
<span class="cstat-no" title="statement not covered" >return AT.keyword(token)&amp;&amp;!AT.keyword(token,'this')?'ts':'t';}</span>
<span class="fstat-no" title="function not covered" >_f</span>inishNode(node){<span class="cstat-no" title="statement not covered" >if(node.type==='WithStatement'){<span class="cstat-no" title="statement not covered" >if(node.body&amp;&amp;node.body.type!=='BlockStatement')</span></span>
<span class="cstat-no" title="statement not covered" >return'n&lt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='VariableDeclaration'){<span class="cstat-no" title="statement not covered" >if(!this._inForLoopHeader(node))</span></span>
<span class="cstat-no" title="statement not covered" >return'n';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ForStatement'||node.type==='ForOfStatement'||node.type==='ForInStatement'){<span class="cstat-no" title="statement not covered" >if(node.body&amp;&amp;node.body.type!=='BlockStatement')</span></span>
<span class="cstat-no" title="statement not covered" >return'n&lt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='BlockStatement'){<span class="cstat-no" title="statement not covered" >if(node.parent&amp;&amp;node.parent.type==='IfStatement'&amp;&amp;node.parent.alternate&amp;&amp;node.parent.consequent===node)</span></span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='FunctionExpression'&amp;&amp;node.parent.parent&amp;&amp;node.parent.parent.type==='Property')</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='FunctionExpression'&amp;&amp;node.parent.parent&amp;&amp;node.parent.parent.type==='VariableDeclarator')</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='FunctionExpression'&amp;&amp;node.parent.parent&amp;&amp;node.parent.parent.type==='CallExpression')</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='DoWhileStatement')</span>
<span class="cstat-no" title="statement not covered" >return'';<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='TryStatement'&amp;&amp;node.parent.block===node)</span>
<span class="cstat-no" title="statement not covered" >return's';<span class="cstat-no" title="statement not covered" >i</span>f(node.parent&amp;&amp;node.parent.type==='CatchClause'&amp;&amp;node.parent.parent.finalizer)</span>
<span class="cstat-no" title="statement not covered" >return's';<span class="cstat-no" title="statement not covered" >r</span>eturn'n';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='WhileStatement'){<span class="cstat-no" title="statement not covered" >if(node.body&amp;&amp;node.body.type!=='BlockStatement')</span></span>
<span class="cstat-no" title="statement not covered" >return'n&lt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='IfStatement'){<span class="cstat-no" title="statement not covered" >if(node.alternate){<span class="cstat-no" title="statement not covered" >if(node.alternate.type!=='BlockStatement'&amp;&amp;node.alternate.type!=='IfStatement')</span></span></span>
<span class="cstat-no" title="statement not covered" >return'&lt;';}</span>else <span class="cstat-no" title="statement not covered" >if(node.consequent){<span class="cstat-no" title="statement not covered" >if(node.consequent.type!=='BlockStatement')</span></span>
<span class="cstat-no" title="statement not covered" >return'&lt;';}</span>}else <span class="cstat-no" title="statement not covered" >if(node.type==='BreakStatement'||node.type==='ContinueStatement'||node.type==='ThrowStatement'||node.type==='ReturnStatement'||node.type==='ExpressionStatement'){<span class="cstat-no" title="statement not covered" >return'n';}</span></span>
<span class="cstat-no" title="statement not covered" >return'';}</span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.FormattedContentBuilder=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(indentString){<span class="cstat-no" title="statement not covered" >this._lastOriginalPosition=0;<span class="cstat-no" title="statement not covered" >t</span>his._formattedContent=[];<span class="cstat-no" title="statement not covered" >t</span>his._formattedContentLength=0;<span class="cstat-no" title="statement not covered" >t</span>his._lastFormattedPosition=0;<span class="cstat-no" title="statement not covered" >t</span>his._mapping={original:[0],formatted:[0]};<span class="cstat-no" title="statement not covered" >t</span>his._nestingLevel=0;<span class="cstat-no" title="statement not covered" >t</span>his._indentString=indentString;<span class="cstat-no" title="statement not covered" >t</span>his._cachedIndents=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._newLines=0;<span class="cstat-no" title="statement not covered" >t</span>his._softSpace=false;<span class="cstat-no" title="statement not covered" >t</span>his._hardSpaces=0;<span class="cstat-no" title="statement not covered" >t</span>his._enforceSpaceBetweenWords=true;}</span></span>
<span class="fstat-no" title="function not covered" >se</span>tEnforceSpaceBetweenWords(value){const oldValue=<span class="cstat-no" title="statement not covered" >this._enforceSpaceBetweenWords;<span class="cstat-no" title="statement not covered" ></span>this._enforceSpaceBetweenWords=value;<span class="cstat-no" title="statement not covered" >r</span>eturn oldValue;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dToken(token,offset){const last=<span class="cstat-no" title="statement not covered" >this._formattedContent.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(this._enforceSpaceBetweenWords&amp;&amp;last&amp;&amp;/\w/.test(last[last.length-1])&amp;&amp;/\w/.test(token))</span>
<span class="cstat-no" title="statement not covered" >this.addSoftSpace();<span class="cstat-no" title="statement not covered" >t</span>his._appendFormatting();<span class="cstat-no" title="statement not covered" >t</span>his._addMappingIfNeeded(offset);<span class="cstat-no" title="statement not covered" >t</span>his._addText(token);}</span>
<span class="fstat-no" title="function not covered" >ad</span>dSoftSpace(){<span class="cstat-no" title="statement not covered" >if(!this._hardSpaces)</span>
<span class="cstat-no" title="statement not covered" >this._softSpace=true;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dHardSpace(){<span class="cstat-no" title="statement not covered" >this._softSpace=false;<span class="cstat-no" title="statement not covered" >+</span>+this._hardSpaces;}</span>
<span class="fstat-no" title="function not covered" >ad</span>dNewLine(noSquash){<span class="cstat-no" title="statement not covered" >if(!this._formattedContentLength)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(noSquash)</span>
<span class="cstat-no" title="statement not covered" >++this._newLines;e</span>lse
<span class="cstat-no" title="statement not covered" >this._newLines=this._newLines||1;}</span>
<span class="fstat-no" title="function not covered" >in</span>creaseNestingLevel(){<span class="cstat-no" title="statement not covered" >this._nestingLevel+=1;}</span>
<span class="fstat-no" title="function not covered" >de</span>creaseNestingLevel(){<span class="cstat-no" title="statement not covered" >if(this._nestingLevel&gt;0)</span>
<span class="cstat-no" title="statement not covered" >this._nestingLevel-=1;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ppendFormatting(){<span class="cstat-no" title="statement not covered" >if(this._newLines){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._newLines;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this._addText('\n');<span class="cstat-no" title="statement not covered" >t</span>his._addText(this._indent());}</span>else <span class="cstat-no" title="statement not covered" >if(this._softSpace){<span class="cstat-no" title="statement not covered" >this._addText(' ');}</span></span>
<span class="cstat-no" title="statement not covered" >if(this._hardSpaces){<span class="cstat-no" title="statement not covered" >for(let i=0;i&lt;this._hardSpaces;++i)</span></span>
<span class="cstat-no" title="statement not covered" >this._addText(' ');}</span>
<span class="cstat-no" title="statement not covered" >this._newLines=0;<span class="cstat-no" title="statement not covered" >t</span>his._softSpace=false;<span class="cstat-no" title="statement not covered" >t</span>his._hardSpaces=0;}</span>
<span class="fstat-no" title="function not covered" >co</span>ntent(){<span class="cstat-no" title="statement not covered" >return this._formattedContent.join('')+(this._newLines?'\n':'');}</span>
<span class="fstat-no" title="function not covered" >ma</span>pping(){<span class="cstat-no" title="statement not covered" >return this._mapping;}</span>
<span class="fstat-no" title="function not covered" >_i</span>ndent(){const cachedValue=<span class="cstat-no" title="statement not covered" >this._cachedIndents.get(this._nestingLevel);<span class="cstat-no" title="statement not covered" ></span>if(cachedValue)</span>
<span class="cstat-no" title="statement not covered" >return cachedValue;l</span>et fullIndent=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>for(let i=0;i&lt;this._nestingLevel;++i)</span>
<span class="cstat-no" title="statement not covered" >fullIndent+=this._indentString;<span class="cstat-no" title="statement not covered" >i</span>f(this._nestingLevel&lt;=20)</span>
<span class="cstat-no" title="statement not covered" >this._cachedIndents.set(this._nestingLevel,fullIndent);<span class="cstat-no" title="statement not covered" >r</span>eturn fullIndent;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddText(text){<span class="cstat-no" title="statement not covered" >this._formattedContent.push(text);<span class="cstat-no" title="statement not covered" >t</span>his._formattedContentLength+=text.length;}</span>
<span class="fstat-no" title="function not covered" >_a</span>ddMappingIfNeeded(originalPosition){<span class="cstat-no" title="statement not covered" >if(originalPosition-this._lastOriginalPosition===this._formattedContentLength-this._lastFormattedPosition)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._mapping.original.push(originalPosition);<span class="cstat-no" title="statement not covered" >t</span>his._lastOriginalPosition=originalPosition;<span class="cstat-no" title="statement not covered" >t</span>his._mapping.formatted.push(this._formattedContentLength);<span class="cstat-no" title="statement not covered" >t</span>his._lastFormattedPosition=this._formattedContentLength;}</span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.CSSParserStates={Initial:'Initial',Selector:'Selector',Style:'Style',PropertyName:'PropertyName',PropertyValue:'PropertyValue',AtRule:'AtRule'};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.parseCSS=<span class="fstat-no" title="function not covered" >fu</span>nction(text){<span class="cstat-no" title="statement not covered" >FormatterWorker._innerParseCSS(text,postMessage);}</span>;<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker._innerParseCSS=<span class="fstat-no" title="function not covered" >fu</span>nction(text,chunkCallback){const chunkSize=<span class="cstat-no" title="statement not covered" >100000;</span>const lines=<span class="cstat-no" title="statement not covered" >text.split('\n');</span>let rules=<span class="cstat-no" title="statement not covered" >[];</span>let processedChunkCharacters=<span class="cstat-no" title="statement not covered" >0;</span>let state=<span class="cstat-no" title="statement not covered" >FormatterWorker.CSSParserStates.Initial;</span>let rule;let property;const UndefTokenType=<span class="cstat-no" title="statement not covered" >new Set();</span>let disabledRules=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >disabledRulesCallback(</span>chunk){<span class="cstat-no" title="statement not covered" >disabledRules=disabledRules.concat(chunk.chunk);}</span></span>
function <span class="fstat-no" title="function not covered" >processToken(</span>tokenValue,tokenTypes,column,newColumn){const tokenType=<span class="cstat-no" title="statement not covered" >tokenTypes?new Set(tokenTypes.split(' ')):UndefTokenType;<span class="cstat-no" title="statement not covered" ></span>switch(state){case FormatterWorker.CSSParserStates.Initial:<span class="cstat-no" title="statement not covered" >if(tokenType.has('qualifier')||tokenType.has('builtin')||tokenType.has('tag')){<span class="cstat-no" title="statement not covered" >rule={selectorText:tokenValue,lineNumber:lineNumber,columnNumber:column,properties:[],};<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.Selector;}</span>else <span class="cstat-no" title="statement not covered" >if(tokenType.has('def')){<span class="cstat-no" title="statement not covered" >rule={atRule:tokenValue,lineNumber:lineNumber,columnNumber:column,};<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.AtRule;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase FormatterWorker.CSSParserStates.Selector:<span class="cstat-no" title="statement not covered" >if(tokenValue==='{'&amp;&amp;tokenType===UndefTokenType){<span class="cstat-no" title="statement not covered" >rule.selectorText=rule.selectorText.trim();<span class="cstat-no" title="statement not covered" >r</span>ule.styleRange=createRange(lineNumber,newColumn);<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.Style;}</span>else{<span class="cstat-no" title="statement not covered" >rule.selectorText+=tokenValue;}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase FormatterWorker.CSSParserStates.AtRule:<span class="cstat-no" title="statement not covered" >if((tokenValue===';'||tokenValue==='{')&amp;&amp;tokenType===UndefTokenType){<span class="cstat-no" title="statement not covered" >rule.atRule=rule.atRule.trim();<span class="cstat-no" title="statement not covered" >r</span>ules.push(rule);<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.Initial;}</span>else{<span class="cstat-no" title="statement not covered" >rule.atRule+=tokenValue;}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase FormatterWorker.CSSParserStates.Style:<span class="cstat-no" title="statement not covered" >if(tokenType.has('meta')||tokenType.has('property')){<span class="cstat-no" title="statement not covered" >property={name:tokenValue,value:'',range:createRange(lineNumber,column),nameRange:createRange(lineNumber,column)};<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.PropertyName;}</span>else <span class="cstat-no" title="statement not covered" >if(tokenValue==='}'&amp;&amp;tokenType===UndefTokenType){<span class="cstat-no" title="statement not covered" >rule.styleRange.endLine=lineNumber;<span class="cstat-no" title="statement not covered" >r</span>ule.styleRange.endColumn=column;<span class="cstat-no" title="statement not covered" >r</span>ules.push(rule);<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.Initial;}</span>else <span class="cstat-no" title="statement not covered" >if(tokenType.has('comment')){<span class="cstat-no" title="statement not covered" >if(tokenValue.substring(0,2)!=='/*'||tokenValue.substring(tokenValue.length-2)!=='*/')</span></span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst uncommentedText=<span class="cstat-no" title="statement not covered" >tokenValue.substring(2,tokenValue.length-2);</span>const fakeRule=<span class="cstat-no" title="statement not covered" >'a{\n'+uncommentedText+'}';<span class="cstat-no" title="statement not covered" ></span>disabledRules=[];<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker._innerParseCSS(fakeRule,disabledRulesCallback);<span class="cstat-no" title="statement not covered" >i</span>f(disabledRules.length===1&amp;&amp;disabledRules[0].properties.length===1){const disabledProperty=<span class="cstat-no" title="statement not covered" >disabledRules[0].properties[0];<span class="cstat-no" title="statement not covered" ></span>disabledProperty.disabled=true;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.range=createRange(lineNumber,column);<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.range.endColumn=newColumn;c</span>onst lineOffset=<span class="cstat-no" title="statement not covered" >lineNumber-1;</span>const columnOffset=<span class="cstat-no" title="statement not covered" >column+2;<span class="cstat-no" title="statement not covered" ></span>disabledProperty.nameRange.startLine+=lineOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.nameRange.startColumn+=columnOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.nameRange.endLine+=lineOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.nameRange.endColumn+=columnOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.valueRange.startLine+=lineOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.valueRange.startColumn+=columnOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.valueRange.endLine+=lineOffset;<span class="cstat-no" title="statement not covered" >d</span>isabledProperty.valueRange.endColumn+=columnOffset;<span class="cstat-no" title="statement not covered" >r</span>ule.properties.push(disabledProperty);}</span>}</span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase FormatterWorker.CSSParserStates.PropertyName:<span class="cstat-no" title="statement not covered" >if(tokenValue===':'&amp;&amp;tokenType===UndefTokenType){<span class="cstat-no" title="statement not covered" >property.name=property.name;<span class="cstat-no" title="statement not covered" >p</span>roperty.nameRange.endLine=lineNumber;<span class="cstat-no" title="statement not covered" >p</span>roperty.nameRange.endColumn=column;<span class="cstat-no" title="statement not covered" >p</span>roperty.valueRange=createRange(lineNumber,newColumn);<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.PropertyValue;}</span>else <span class="cstat-no" title="statement not covered" >if(tokenType.has('property')){<span class="cstat-no" title="statement not covered" >property.name+=tokenValue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase FormatterWorker.CSSParserStates.PropertyValue:<span class="cstat-no" title="statement not covered" >if((tokenValue===';'||tokenValue==='}')&amp;&amp;tokenType===UndefTokenType){<span class="cstat-no" title="statement not covered" >property.value=property.value;<span class="cstat-no" title="statement not covered" >p</span>roperty.valueRange.endLine=lineNumber;<span class="cstat-no" title="statement not covered" >p</span>roperty.valueRange.endColumn=column;<span class="cstat-no" title="statement not covered" >p</span>roperty.range.endLine=lineNumber;<span class="cstat-no" title="statement not covered" >p</span>roperty.range.endColumn=tokenValue===';'?newColumn:column;<span class="cstat-no" title="statement not covered" >r</span>ule.properties.push(property);<span class="cstat-no" title="statement not covered" >i</span>f(tokenValue==='}'){<span class="cstat-no" title="statement not covered" >rule.styleRange.endLine=lineNumber;<span class="cstat-no" title="statement not covered" >r</span>ule.styleRange.endColumn=column;<span class="cstat-no" title="statement not covered" >r</span>ules.push(rule);<span class="cstat-no" title="statement not covered" >s</span>tate=FormatterWorker.CSSParserStates.Initial;}</span>else{<span class="cstat-no" title="statement not covered" >state=FormatterWorker.CSSParserStates.Style;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(!tokenType.has('comment')){<span class="cstat-no" title="statement not covered" >property.value+=tokenValue;}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >console.assert(false,'Unknown CSS parser state.');}</span>
<span class="cstat-no" title="statement not covered" >processedChunkCharacters+=newColumn-column;<span class="cstat-no" title="statement not covered" >i</span>f(processedChunkCharacters&gt;chunkSize){<span class="cstat-no" title="statement not covered" >chunkCallback({chunk:rules,isLastChunk:false});<span class="cstat-no" title="statement not covered" >r</span>ules=[];<span class="cstat-no" title="statement not covered" >p</span>rocessedChunkCharacters=0;}</span>}</span>
const tokenizer=<span class="cstat-no" title="statement not covered" >FormatterWorker.createTokenizer('text/css');</span>let lineNumber;<span class="cstat-no" title="statement not covered" >for(lineNumber=0;lineNumber&lt;lines.length;++lineNumber){const line=<span class="cstat-no" title="statement not covered" >lines[lineNumber];<span class="cstat-no" title="statement not covered" ></span>tokenizer(line,processToken);<span class="cstat-no" title="statement not covered" >p</span>rocessToken('\n',null,line.length,line.length+1);}</span></span>
<span class="cstat-no" title="statement not covered" >chunkCallback({chunk:rules,isLastChunk:true});f</span>unction <span class="fstat-no" title="function not covered" >createRange(</span>lineNumber,columnNumber){<span class="cstat-no" title="statement not covered" >return{startLine:lineNumber,startColumn:columnNumber,endLine:lineNumber,endColumn:columnNumber};}</span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.HTMLFormatter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(builder){<span class="cstat-no" title="statement not covered" >this._builder=builder;<span class="cstat-no" title="statement not covered" >t</span>his._jsFormatter=new FormatterWorker.JavaScriptFormatter(builder);<span class="cstat-no" title="statement not covered" >t</span>his._cssFormatter=new FormatterWorker.CSSFormatter(builder);}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>rmat(text,lineEndings){<span class="cstat-no" title="statement not covered" >this._text=text;<span class="cstat-no" title="statement not covered" >t</span>his._lineEndings=lineEndings;<span class="cstat-no" title="statement not covered" >t</span>his._model=new FormatterWorker.HTMLModel(text);<span class="cstat-no" title="statement not covered" >t</span>his._walk(this._model.document());}</span>
<span class="fstat-no" title="function not covered" >_f</span>ormatTokensTill(element,offset){<span class="cstat-no" title="statement not covered" >while(this._model.peekToken()&amp;&amp;this._model.peekToken().startOffset&lt;offset){const token=<span class="cstat-no" title="statement not covered" >this._model.nextToken();<span class="cstat-no" title="statement not covered" ></span>this._formatToken(element,token);}</span>}</span>
<span class="fstat-no" title="function not covered" >_w</span>alk(element){<span class="cstat-no" title="statement not covered" >if(element.parent)</span>
<span class="cstat-no" title="statement not covered" >this._formatTokensTill(element.parent,element.openTag.startOffset);<span class="cstat-no" title="statement not covered" >t</span>his._beforeOpenTag(element);<span class="cstat-no" title="statement not covered" >t</span>his._formatTokensTill(element,element.openTag.endOffset);<span class="cstat-no" title="statement not covered" >t</span>his._afterOpenTag(element);<span class="cstat-no" title="statement not covered" >f</span>or(let i=0;i&lt;element.children.length;++i)</span>
<span class="cstat-no" title="statement not covered" >this._walk(element.children[i]);<span class="cstat-no" title="statement not covered" >t</span>his._formatTokensTill(element,element.closeTag.startOffset);<span class="cstat-no" title="statement not covered" >t</span>his._beforeCloseTag(element);<span class="cstat-no" title="statement not covered" >t</span>his._formatTokensTill(element,element.closeTag.endOffset);<span class="cstat-no" title="statement not covered" >t</span>his._afterCloseTag(element);}</span>
<span class="fstat-no" title="function not covered" >_b</span>eforeOpenTag(element){<span class="cstat-no" title="statement not covered" >if(!element.children.length||element===this._model.document())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();}</span>
<span class="fstat-no" title="function not covered" >_a</span>fterOpenTag(element){<span class="cstat-no" title="statement not covered" >if(!element.children.length||element===this._model.document())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._builder.increaseNestingLevel();<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();}</span>
<span class="fstat-no" title="function not covered" >_b</span>eforeCloseTag(element){<span class="cstat-no" title="statement not covered" >if(!element.children.length||element===this._model.document())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._builder.decreaseNestingLevel();<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();}</span>
<span class="fstat-no" title="function not covered" >_a</span>fterCloseTag(element){<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();}</span>
<span class="fstat-no" title="function not covered" >_f</span>ormatToken(element,token){<span class="cstat-no" title="statement not covered" >if(token.value.isWhitespace())</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span>f(token.type.has('comment')||token.type.has('meta')){<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();<span class="cstat-no" title="statement not covered" >t</span>his._builder.addToken(token.value.trim(),token.startOffset);<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
const isBodyToken=<span class="cstat-no" title="statement not covered" >element.openTag.endOffset&lt;=token.startOffset&amp;&amp;token.startOffset&lt;element.closeTag.startOffset;<span class="cstat-no" title="statement not covered" ></span>if(isBodyToken&amp;&amp;element.name==='style'){<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();<span class="cstat-no" title="statement not covered" >t</span>his._builder.increaseNestingLevel();<span class="cstat-no" title="statement not covered" >t</span>his._cssFormatter.format(this._text,this._lineEndings,token.startOffset,token.endOffset);<span class="cstat-no" title="statement not covered" >t</span>his._builder.decreaseNestingLevel();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span></span>
<span class="cstat-no" title="statement not covered" >if(isBodyToken&amp;&amp;element.name==='script'){<span class="cstat-no" title="statement not covered" >this._builder.addNewLine();<span class="cstat-no" title="statement not covered" >t</span>his._builder.increaseNestingLevel();<span class="cstat-no" title="statement not covered" >i</span>f(this._scriptTagIsJavaScript(element)){<span class="cstat-no" title="statement not covered" >this._jsFormatter.format(this._text,this._lineEndings,token.startOffset,token.endOffset);}</span>else{<span class="cstat-no" title="statement not covered" >this._builder.addToken(token.value,token.startOffset);<span class="cstat-no" title="statement not covered" >t</span>his._builder.addNewLine();}</span></span></span>
<span class="cstat-no" title="statement not covered" >this._builder.decreaseNestingLevel();<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >if(!isBodyToken&amp;&amp;token.type.has('attribute'))</span>
<span class="cstat-no" title="statement not covered" >this._builder.addSoftSpace();<span class="cstat-no" title="statement not covered" >t</span>his._builder.addToken(token.value,token.startOffset);}</span>
<span class="fstat-no" title="function not covered" >_s</span>criptTagIsJavaScript(element){<span class="cstat-no" title="statement not covered" >if(!element.openTag.attributes.has('type'))</span>
<span class="cstat-no" title="statement not covered" >return true;l</span>et type=<span class="cstat-no" title="statement not covered" >element.openTag.attributes.get('type').toLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(!type)</span>
<span class="cstat-no" title="statement not covered" >return true;c</span>onst isWrappedInQuotes=<span class="cstat-no" title="statement not covered" >/^(["\'])(.*)\1$/.exec(type.trim());<span class="cstat-no" title="statement not covered" ></span>if(isWrappedInQuotes)</span>
<span class="cstat-no" title="statement not covered" >type=isWrappedInQuotes[2];<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.HTMLFormatter.SupportedJavaScriptMimeTypes.has(type.trim());}</span>};<span class="cstat-no" title="statement not covered" >FormatterWorker.HTMLFormatter.SupportedJavaScriptMimeTypes=new Set(['application/ecmascript','application/javascript','application/x-ecmascript','application/x-javascript','text/ecmascript','text/javascript','text/javascript1.0','text/javascript1.1','text/javascript1.2','text/javascript1.3','text/javascript1.4','text/javascript1.5','text/jscript','text/livescript','text/x-ecmascript','text/x-javascript']);<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.HTMLModel=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(text){<span class="cstat-no" title="statement not covered" >this._state=FormatterWorker.HTMLModel.ParseState.Initial;<span class="cstat-no" title="statement not covered" >t</span>his._document=new FormatterWorker.HTMLModel.Element('document');<span class="cstat-no" title="statement not covered" >t</span>his._document.openTag=new FormatterWorker.HTMLModel.Tag('document',0,0,new Map(),true,false);<span class="cstat-no" title="statement not covered" >t</span>his._document.closeTag=new FormatterWorker.HTMLModel.Tag('document',text.length,text.length,new Map(),false,false);<span class="cstat-no" title="statement not covered" >t</span>his._stack=[this._document];<span class="cstat-no" title="statement not covered" >t</span>his._tokens=[];<span class="cstat-no" title="statement not covered" >t</span>his._tokenIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his._build(text);}</span></span>
<span class="fstat-no" title="function not covered" >_b</span>uild(text){const tokenizer=<span class="cstat-no" title="statement not covered" >FormatterWorker.createTokenizer('text/html');</span>let lastOffset=<span class="cstat-no" title="statement not covered" >0;</span>const lowerCaseText=<span class="cstat-no" title="statement not covered" >text.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>while(true){<span class="cstat-no" title="statement not covered" >tokenizer(text.substring(lastOffset),processToken.bind(this,lastOffset));<span class="cstat-no" title="statement not covered" >i</span>f(lastOffset&gt;=text.length)</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>onst element=<span class="cstat-no" title="statement not covered" >this._stack.peekLast();<span class="cstat-no" title="statement not covered" ></span>lastOffset=lowerCaseText.indexOf('&lt;/'+element.name,lastOffset);<span class="cstat-no" title="statement not covered" >i</span>f(lastOffset===-1)</span>
<span class="cstat-no" title="statement not covered" >lastOffset=text.length;c</span>onst tokenStart=<span class="cstat-no" title="statement not covered" >element.openTag.endOffset;</span>const tokenEnd=<span class="cstat-no" title="statement not covered" >lastOffset;</span>const tokenValue=<span class="cstat-no" title="statement not covered" >text.substring(tokenStart,tokenEnd);<span class="cstat-no" title="statement not covered" ></span>this._tokens.push(new FormatterWorker.HTMLModel.Token(tokenValue,new Set(),tokenStart,tokenEnd));}</span>
<span class="cstat-no" title="statement not covered" >while(this._stack.length&gt;1){const element=<span class="cstat-no" title="statement not covered" >this._stack.peekLast();<span class="cstat-no" title="statement not covered" ></span>this._popElement(new FormatterWorker.HTMLModel.Tag(element.name,text.length,text.length,new Map(),false,false));}</span></span>
function <span class="fstat-no" title="function not covered" >processToken(</span>baseOffset,tokenValue,type,tokenStart,tokenEnd){<span class="cstat-no" title="statement not covered" >tokenStart+=baseOffset;<span class="cstat-no" title="statement not covered" >t</span>okenEnd+=baseOffset;<span class="cstat-no" title="statement not covered" >l</span>astOffset=tokenEnd;c</span>onst tokenType=<span class="cstat-no" title="statement not covered" >type?new Set(type.split(' ')):new Set();</span>const token=<span class="cstat-no" title="statement not covered" >new FormatterWorker.HTMLModel.Token(tokenValue,tokenType,tokenStart,tokenEnd);<span class="cstat-no" title="statement not covered" ></span>this._tokens.push(token);<span class="cstat-no" title="statement not covered" >t</span>his._updateDOM(token);c</span>onst element=<span class="cstat-no" title="statement not covered" >this._stack.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(element&amp;&amp;(element.name==='script'||element.name==='style')&amp;&amp;element.openTag.endOffset===lastOffset)</span>
<span class="cstat-no" title="statement not covered" >return FormatterWorker.AbortTokenization;}</span>}
<span class="fstat-no" title="function not covered" >_u</span>pdateDOM(token){const S=<span class="cstat-no" title="statement not covered" >FormatterWorker.HTMLModel.ParseState;</span>const value=<span class="cstat-no" title="statement not covered" >token.value;</span>const type=<span class="cstat-no" title="statement not covered" >token.type;<span class="cstat-no" title="statement not covered" ></span>switch(this._state){case S.Initial:<span class="cstat-no" title="statement not covered" >if(type.has('bracket')&amp;&amp;(value==='&lt;'||value==='&lt;/')){<span class="cstat-no" title="statement not covered" >this._onStartTag(token);<span class="cstat-no" title="statement not covered" >t</span>his._state=S.Tag;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>ase S.Tag:<span class="cstat-no" title="statement not covered" >if(type.has('tag')&amp;&amp;!type.has('bracket')){<span class="cstat-no" title="statement not covered" >this._tagName=value.trim().toLowerCase();}</span>else <span class="cstat-no" title="statement not covered" >if(type.has('attribute')){<span class="cstat-no" title="statement not covered" >this._attributeName=value.trim().toLowerCase();<span class="cstat-no" title="statement not covered" >t</span>his._attributes.set(this._attributeName,'');<span class="cstat-no" title="statement not covered" >t</span>his._state=S.AttributeName;}</span>else <span class="cstat-no" title="statement not covered" >if(type.has('bracket')&amp;&amp;(value==='&gt;'||value==='/&gt;')){<span class="cstat-no" title="statement not covered" >this._onEndTag(token);<span class="cstat-no" title="statement not covered" >t</span>his._state=S.Initial;}</span></span></span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>ase S.AttributeName:<span class="cstat-no" title="statement not covered" >if(!type.size&amp;&amp;value==='='){<span class="cstat-no" title="statement not covered" >this._state=S.AttributeValue;}</span>else <span class="cstat-no" title="statement not covered" >if(type.has('bracket')&amp;&amp;(value==='&gt;'||value==='/&gt;')){<span class="cstat-no" title="statement not covered" >this._onEndTag(token);<span class="cstat-no" title="statement not covered" >t</span>his._state=S.Initial;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return;c</span>ase S.AttributeValue:<span class="cstat-no" title="statement not covered" >if(type.has('string')){<span class="cstat-no" title="statement not covered" >this._attributes.set(this._attributeName,value);<span class="cstat-no" title="statement not covered" >t</span>his._state=S.Tag;}</span>else <span class="cstat-no" title="statement not covered" >if(type.has('bracket')&amp;&amp;(value==='&gt;'||value==='/&gt;')){<span class="cstat-no" title="statement not covered" >this._onEndTag(token);<span class="cstat-no" title="statement not covered" >t</span>his._state=S.Initial;}</span></span></span>
<span class="cstat-no" title="statement not covered" >return;}</span>}
<span class="fstat-no" title="function not covered" >_o</span>nStartTag(token){<span class="cstat-no" title="statement not covered" >this._tagName='';<span class="cstat-no" title="statement not covered" >t</span>his._tagStartOffset=token.startOffset;<span class="cstat-no" title="statement not covered" >t</span>his._tagEndOffset=null;<span class="cstat-no" title="statement not covered" >t</span>his._attributes=new Map();<span class="cstat-no" title="statement not covered" >t</span>his._attributeName='';<span class="cstat-no" title="statement not covered" >t</span>his._isOpenTag=token.value==='&lt;';}</span>
<span class="fstat-no" title="function not covered" >_o</span>nEndTag(token){<span class="cstat-no" title="statement not covered" >this._tagEndOffset=token.endOffset;c</span>onst selfClosingTag=<span class="cstat-no" title="statement not covered" >token.value==='/&gt;'||FormatterWorker.HTMLModel.SelfClosingTags.has(this._tagName);</span>const tag=<span class="cstat-no" title="statement not covered" >new FormatterWorker.HTMLModel.Tag(this._tagName,this._tagStartOffset,this._tagEndOffset,this._attributes,this._isOpenTag,selfClosingTag);<span class="cstat-no" title="statement not covered" ></span>this._onTagComplete(tag);}</span>
<span class="fstat-no" title="function not covered" >_o</span>nTagComplete(tag){<span class="cstat-no" title="statement not covered" >if(tag.isOpenTag){const topElement=<span class="cstat-no" title="statement not covered" >this._stack.peekLast();<span class="cstat-no" title="statement not covered" ></span>if(topElement!==this._document&amp;&amp;topElement.openTag.selfClosingTag)</span></span>
<span class="cstat-no" title="statement not covered" >this._popElement(autocloseTag(topElement,topElement.openTag.endOffset));e</span>lse <span class="cstat-no" title="statement not covered" >if((topElement.name in FormatterWorker.HTMLModel.AutoClosingTags)&amp;&amp;FormatterWorker.HTMLModel.AutoClosingTags[topElement.name].has(tag.name))</span>
<span class="cstat-no" title="statement not covered" >this._popElement(autocloseTag(topElement,tag.startOffset));<span class="cstat-no" title="statement not covered" >t</span>his._pushElement(tag);<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>
<span class="cstat-no" title="statement not covered" >while(this._stack.length&gt;1&amp;&amp;this._stack.peekLast().name!==tag.name)</span>
<span class="cstat-no" title="statement not covered" >this._popElement(autocloseTag(this._stack.peekLast(),tag.startOffset));<span class="cstat-no" title="statement not covered" >i</span>f(this._stack.length===1)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span>his._popElement(tag);f</span>unction <span class="fstat-no" title="function not covered" >autocloseTag(</span>element,offset){<span class="cstat-no" title="statement not covered" >return new FormatterWorker.HTMLModel.Tag(element.name,offset,offset,new Map(),false,false);}</span>}
<span class="fstat-no" title="function not covered" >_p</span>opElement(closeTag){const element=<span class="cstat-no" title="statement not covered" >this._stack.pop();<span class="cstat-no" title="statement not covered" ></span>element.closeTag=closeTag;}</span>
<span class="fstat-no" title="function not covered" >_p</span>ushElement(openTag){const topElement=<span class="cstat-no" title="statement not covered" >this._stack.peekLast();</span>const newElement=<span class="cstat-no" title="statement not covered" >new FormatterWorker.HTMLModel.Element(openTag.name);<span class="cstat-no" title="statement not covered" ></span>newElement.parent=topElement;<span class="cstat-no" title="statement not covered" >t</span>opElement.children.push(newElement);<span class="cstat-no" title="statement not covered" >n</span>ewElement.openTag=openTag;<span class="cstat-no" title="statement not covered" >t</span>his._stack.push(newElement);}</span>
<span class="fstat-no" title="function not covered" >pe</span>ekToken(){<span class="cstat-no" title="statement not covered" >return this._tokenIndex&lt;this._tokens.length?this._tokens[this._tokenIndex]:null;}</span>
<span class="fstat-no" title="function not covered" >ne</span>xtToken(){<span class="cstat-no" title="statement not covered" >return this._tokens[this._tokenIndex++];}</span>
<span class="fstat-no" title="function not covered" >do</span>cument(){<span class="cstat-no" title="statement not covered" >return this._document;}</span>};<span class="cstat-no" title="statement not covered" >FormatterWorker.HTMLModel.SelfClosingTags=new Set(['area','base','br','col','command','embed','hr','img','input','keygen','link','meta','param','source','track','wbr']);<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.HTMLModel.AutoClosingTags={'head':new Set(['body']),'li':new Set(['li']),'dt':new Set(['dt','dd']),'dd':new Set(['dt','dd']),'p':new Set(['address','article','aside','blockquote','div','dl','fieldset','footer','form','h1','h2','h3','h4','h5','h6','header','hgroup','hr','main','nav','ol','p','pre','section','table','ul']),'rb':new Set(['rb','rt','rtc','rp']),'rt':new Set(['rb','rt','rtc','rp']),'rtc':new Set(['rb','rtc','rp']),'rp':new Set(['rb','rt','rtc','rp']),'optgroup':new Set(['optgroup']),'option':new Set(['option','optgroup']),'colgroup':new Set(['colgroup']),'thead':new Set(['tbody','tfoot']),'tbody':new Set(['tbody','tfoot']),'tfoot':new Set(['tbody']),'tr':new Set(['tr']),'td':new Set(['td','th']),'th':new Set(['td','th']),};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.HTMLModel.ParseState={Initial:'Initial',Tag:'Tag',AttributeName:'AttributeName',AttributeValue:'AttributeValue'};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.HTMLModel.Token=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(value,type,startOffset,endOffset){<span class="cstat-no" title="statement not covered" >this.value=value;<span class="cstat-no" title="statement not covered" >t</span>his.type=type;<span class="cstat-no" title="statement not covered" >t</span>his.startOffset=startOffset;<span class="cstat-no" title="statement not covered" >t</span>his.endOffset=endOffset;}</span>};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.HTMLModel.Tag=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(name,startOffset,endOffset,attributes,isOpenTag,selfClosingTag){<span class="cstat-no" title="statement not covered" >this.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.startOffset=startOffset;<span class="cstat-no" title="statement not covered" >t</span>his.endOffset=endOffset;<span class="cstat-no" title="statement not covered" >t</span>his.attributes=attributes;<span class="cstat-no" title="statement not covered" >t</span>his.isOpenTag=isOpenTag;<span class="cstat-no" title="statement not covered" >t</span>his.selfClosingTag=selfClosingTag;}</span>};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.HTMLModel.Element=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(name){<span class="cstat-no" title="statement not covered" >this.name=name;<span class="cstat-no" title="statement not covered" >t</span>his.children=[];<span class="cstat-no" title="statement not covered" >t</span>his.parent=null;<span class="cstat-no" title="statement not covered" >t</span>his.openTag=null;<span class="cstat-no" title="statement not covered" >t</span>his.closeTag=null;}</span>};;<span class="cstat-no" title="statement not covered" ></span>FormatterWorker.IdentityFormatter=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(builder){<span class="cstat-no" title="statement not covered" >this._builder=builder;}</span></span>
<span class="fstat-no" title="function not covered" >fo</span>rmat(text,lineEndings,fromOffset,toOffset){const content=<span class="cstat-no" title="statement not covered" >text.substring(fromOffset,toOffset);<span class="cstat-no" title="statement not covered" ></span>this._builder.addToken(content,fromOffset);}</span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.javaScriptOutline=<span class="fstat-no" title="function not covered" >fu</span>nction(content){const chunkSize=<span class="cstat-no" title="statement not covered" >100000;</span>let outlineChunk=<span class="cstat-no" title="statement not covered" >[];</span>let lastReportedOffset=<span class="cstat-no" title="statement not covered" >0;</span>let ast;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >ast=acorn.parse(content,{ranges:false,ecmaVersion:8});}</span>catch(e){<span class="cstat-no" title="statement not covered" >ast=acorn.loose.parse(content,{ranges:false,ecmaVersion:8});}</span></span></span>
const textCursor=<span class="cstat-no" title="statement not covered" >new TextUtils.TextCursor(content.computeLineEndings());</span>const walker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(beforeVisit);<span class="cstat-no" title="statement not covered" ></span>walker.walk(ast);<span class="cstat-no" title="statement not covered" >p</span>ostMessage({chunk:outlineChunk,isLastChunk:true});f</span>unction <span class="fstat-no" title="function not covered" >beforeVisit(</span>node){<span class="cstat-no" title="statement not covered" >if(node.type==='ClassDeclaration'){<span class="cstat-no" title="statement not covered" >reportClass((node.id));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='VariableDeclarator'&amp;&amp;isClassNode(node.init)){<span class="cstat-no" title="statement not covered" >reportClass((node.id));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='AssignmentExpression'&amp;&amp;isNameNode(node.left)&amp;&amp;isClassNode(node.right)){<span class="cstat-no" title="statement not covered" >reportClass((node.left));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Property'&amp;&amp;isNameNode(node.key)&amp;&amp;isClassNode(node.value)){<span class="cstat-no" title="statement not covered" >reportClass((node.key));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='FunctionDeclaration'){<span class="cstat-no" title="statement not covered" >reportFunction((node.id),node);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='VariableDeclarator'&amp;&amp;isFunctionNode(node.init)){<span class="cstat-no" title="statement not covered" >reportFunction((node.id),(node.init));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='AssignmentExpression'&amp;&amp;isNameNode(node.left)&amp;&amp;isFunctionNode(node.right)){<span class="cstat-no" title="statement not covered" >reportFunction((node.left),(node.right));}</span>else <span class="cstat-no" title="statement not covered" >if((node.type==='MethodDefinition'||node.type==='Property')&amp;&amp;isNameNode(node.key)&amp;&amp;isFunctionNode(node.value)){const namePrefix=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(node.kind==='get'||node.kind==='set')</span></span></span></span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >namePrefix.push(node.kind);<span class="cstat-no" title="statement not covered" >i</span>f(node.static)</span>
<span class="cstat-no" title="statement not covered" >namePrefix.push('static');<span class="cstat-no" title="statement not covered" >r</span>eportFunction(node.key,node.value,namePrefix.join(' '));}</span>}
function <span class="fstat-no" title="function not covered" >reportClass(</span>nameNode){const name=<span class="cstat-no" title="statement not covered" >'class '+stringifyNameNode(nameNode);<span class="cstat-no" title="statement not covered" ></span>textCursor.advance(nameNode.start);<span class="cstat-no" title="statement not covered" >a</span>ddOutlineItem({name:name,line:textCursor.lineNumber(),column:textCursor.columnNumber(),});}</span>
function <span class="fstat-no" title="function not covered" >reportFunction(</span>nameNode,functionNode,namePrefix){let name=<span class="cstat-no" title="statement not covered" >stringifyNameNode(nameNode);<span class="cstat-no" title="statement not covered" ></span>if(functionNode.generator)</span>
<span class="cstat-no" title="statement not covered" >name='*'+name;<span class="cstat-no" title="statement not covered" >i</span>f(namePrefix)</span>
<span class="cstat-no" title="statement not covered" >name=namePrefix+' '+name;<span class="cstat-no" title="statement not covered" >i</span>f(functionNode.async)</span>
<span class="cstat-no" title="statement not covered" >name='async '+name;<span class="cstat-no" title="statement not covered" >t</span>extCursor.advance(nameNode.start);<span class="cstat-no" title="statement not covered" >a</span>ddOutlineItem({name:name,line:textCursor.lineNumber(),column:textCursor.columnNumber(),arguments:stringifyArguments((functionNode.params))});}</span>
function <span class="fstat-no" title="function not covered" >isNameNode(</span>node){<span class="cstat-no" title="statement not covered" >if(!node)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='MemberExpression')</span>
<span class="cstat-no" title="statement not covered" >return!node.computed&amp;&amp;node.property.type==='Identifier';<span class="cstat-no" title="statement not covered" >r</span>eturn node.type==='Identifier';}</span>
function <span class="fstat-no" title="function not covered" >isFunctionNode(</span>node){<span class="cstat-no" title="statement not covered" >if(!node)</span>
<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span>eturn node.type==='FunctionExpression'||node.type==='ArrowFunctionExpression';}</span>
function <span class="fstat-no" title="function not covered" >isClassNode(</span>node){<span class="cstat-no" title="statement not covered" >return!!node&amp;&amp;node.type==='ClassExpression';}</span>
function <span class="fstat-no" title="function not covered" >stringifyNameNode(</span>node){<span class="cstat-no" title="statement not covered" >if(node.type==='MemberExpression')</span>
<span class="cstat-no" title="statement not covered" >node=(node.property);<span class="cstat-no" title="statement not covered" >c</span>onsole.assert(node.type==='Identifier','Cannot extract identifier from unknown type: '+node.type);<span class="cstat-no" title="statement not covered" >r</span>eturn(node.name);}</span>
function <span class="fstat-no" title="function not covered" >stringifyArguments(</span>params){const result=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const param of params){<span class="cstat-no" title="statement not covered" >if(param.type==='Identifier')</span></span>
<span class="cstat-no" title="statement not covered" >result.push(param.name);e</span>lse <span class="cstat-no" title="statement not covered" >if(param.type==='RestElement'&amp;&amp;param.argument.type==='Identifier')</span>
<span class="cstat-no" title="statement not covered" >result.push('...'+param.argument.name);e</span>lse
<span class="cstat-no" title="statement not covered" >console.error('Error: unexpected function parameter type: '+param.type);}</span>
<span class="cstat-no" title="statement not covered" >return'('+result.join(', ')+')';}</span>
function <span class="fstat-no" title="function not covered" >addOutlineItem(</span>item){<span class="cstat-no" title="statement not covered" >outlineChunk.push(item);<span class="cstat-no" title="statement not covered" >i</span>f(textCursor.offset()-lastReportedOffset&lt;chunkSize)</span>
<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span>ostMessage({chunk:outlineChunk,isLastChunk:false});<span class="cstat-no" title="statement not covered" >o</span>utlineChunk=[];<span class="cstat-no" title="statement not covered" >l</span>astReportedOffset=textCursor.offset();}</span>};;<span class="cstat-no" title="statement not covered" >FormatterWorker.RelaxedJSONParser={};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.RelaxedJSONParser.States={ExpectKey:'ExpectKey',ExpectValue:'ExpectValue'};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.RelaxedJSONParser.Keywords={'NaN':NaN,'true':true,'false':false,'Infinity':Infinity,'undefined':undefined,'null':null};<span class="cstat-no" title="statement not covered" >F</span>ormatterWorker.RelaxedJSONParser.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(content){const Keywords=<span class="cstat-no" title="statement not covered" >FormatterWorker.RelaxedJSONParser.Keywords;</span>const States=<span class="cstat-no" title="statement not covered" >FormatterWorker.RelaxedJSONParser.States;<span class="cstat-no" title="statement not covered" ></span>content='('+content+')';l</span>et root;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >root=acorn.parse(content,{});}</span>catch(e){<span class="cstat-no" title="statement not covered" >return null;}</span></span></span>
const walker=<span class="cstat-no" title="statement not covered" >new FormatterWorker.ESTreeWalker(beforeVisit,afterVisit);</span>const rootTip=<span class="cstat-no" title="statement not covered" >[];</span>const stack=<span class="cstat-no" title="statement not covered" >[];</span>let stackData=(<span class="cstat-no" title="statement not covered" >{key:0,tip:rootTip,state:States.ExpectValue,parentIsArray:true})</span>;<span class="cstat-no" title="statement not covered" >walker.setWalkNulls(true);l</span>et hasExpression=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>walker.walk(root);<span class="cstat-no" title="statement not covered" >i</span>f(hasExpression)</span>
<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span>eturn rootTip.length?rootTip[0]:null;f</span>unction <span class="fstat-no" title="function not covered" >pushStack(</span>newStack){<span class="cstat-no" title="statement not covered" >stack.push(stackData);<span class="cstat-no" title="statement not covered" >s</span>tackData=newStack;}</span>
function <span class="fstat-no" title="function not covered" >popStack(</span>){<span class="cstat-no" title="statement not covered" >stackData=stack.pop();}</span>
function <span class="fstat-no" title="function not covered" >applyValue(</span>value){<span class="cstat-no" title="statement not covered" >stackData.tip[stackData.key]=value;<span class="cstat-no" title="statement not covered" >i</span>f(stackData.parentIsArray)</span>
<span class="cstat-no" title="statement not covered" >stackData.key++;e</span>lse
<span class="cstat-no" title="statement not covered" >stackData.state=null;}</span>
function <span class="fstat-no" title="function not covered" >beforeVisit(</span>node){<span class="cstat-no" title="statement not covered" >switch(node.type){case'ObjectExpression':{const newTip=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>applyValue(newTip);<span class="cstat-no" title="statement not covered" >p</span>ushStack(({key:null,tip:newTip,state:null,parentIsArray:false}));<span class="cstat-no" title="statement not covered" >b</span>reak;}</span></span>
case'ArrayExpression':{const newTip=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>applyValue(newTip);<span class="cstat-no" title="statement not covered" >p</span>ushStack(({key:0,tip:newTip,state:States.ExpectValue,parentIsArray:true}));<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>
case'Property':<span class="cstat-no" title="statement not covered" >stackData.state=States.ExpectKey;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'Literal':<span class="cstat-no" title="statement not covered" >if(stackData.state===States.ExpectKey){<span class="cstat-no" title="statement not covered" >stackData.key=node.value;<span class="cstat-no" title="statement not covered" >s</span>tackData.state=States.ExpectValue;}</span>else <span class="cstat-no" title="statement not covered" >if(stackData.state===States.ExpectValue){<span class="cstat-no" title="statement not covered" >applyValue(extractValue(node));<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.ESTreeWalker.SkipSubtree;}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase'Identifier':<span class="cstat-no" title="statement not covered" >if(stackData.state===States.ExpectKey){<span class="cstat-no" title="statement not covered" >stackData.key=(node.name);<span class="cstat-no" title="statement not covered" >s</span>tackData.state=States.ExpectValue;}</span>else <span class="cstat-no" title="statement not covered" >if(stackData.state===States.ExpectValue){<span class="cstat-no" title="statement not covered" >applyValue(extractValue(node));<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.ESTreeWalker.SkipSubtree;}</span></span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase'UnaryExpression':<span class="cstat-no" title="statement not covered" >if(stackData.state===States.ExpectValue){<span class="cstat-no" title="statement not covered" >applyValue(extractValue(node));<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.ESTreeWalker.SkipSubtree;}</span></span>
<span class="cstat-no" title="statement not covered" >break;c</span>ase'Program':case'ExpressionStatement':<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >if(stackData.state===States.ExpectValue)</span>
<span class="cstat-no" title="statement not covered" >applyValue(extractValue(node));<span class="cstat-no" title="statement not covered" >r</span>eturn FormatterWorker.ESTreeWalker.SkipSubtree;}</span>}
function <span class="fstat-no" title="function not covered" >afterVisit(</span>node){<span class="cstat-no" title="statement not covered" >if(node.type==='ObjectExpression'||node.type==='ArrayExpression')</span>
<span class="cstat-no" title="statement not covered" >popStack();}</span>
function <span class="fstat-no" title="function not covered" >extractValue(</span>node){let isNegative=<span class="cstat-no" title="statement not covered" >false;</span>const originalNode=<span class="cstat-no" title="statement not covered" >node;</span>let value;<span class="cstat-no" title="statement not covered" >if(node.type==='UnaryExpression'&amp;&amp;(node.operator==='-'||node.operator==='+')){<span class="cstat-no" title="statement not covered" >if(node.operator==='-')</span></span>
<span class="cstat-no" title="statement not covered" >isNegative=true;<span class="cstat-no" title="statement not covered" >n</span>ode=(node.argument);}</span>
<span class="cstat-no" title="statement not covered" >if(node.type==='Literal'){<span class="cstat-no" title="statement not covered" >value=node.value;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Identifier'&amp;&amp;Keywords.hasOwnProperty(node.name)){<span class="cstat-no" title="statement not covered" >value=Keywords[node.name];}</span>else{<span class="cstat-no" title="statement not covered" >hasExpression=true;<span class="cstat-no" title="statement not covered" >r</span>eturn content.substring(originalNode.start,originalNode.end);}</span></span></span>
<span class="cstat-no" title="statement not covered" >if(isNegative){<span class="cstat-no" title="statement not covered" >if(typeof value!=='number'){<span class="cstat-no" title="statement not covered" >hasExpression=true;<span class="cstat-no" title="statement not covered" >r</span>eturn content.substring(originalNode.start,originalNode.end);}</span></span></span>
<span class="cstat-no" title="statement not covered" >value=-(value);}</span>
<span class="cstat-no" title="statement not covered" >return value;}</span>};<span class="cstat-no" title="statement not covered" >FormatterWorker.RelaxedJSONParser.Context;;</span>;;<span class="cstat-no" title="statement not covered" >if(!self.Runtime)</span>
<span class="cstat-no" title="statement not covered" >self.importScripts('Runtime.js');<span class="cstat-no" title="statement not covered" >R</span>untime.startWorker('formatter_worker');</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Wed May 15 2019 19:03:43 GMT+0800 (China Standard Time)
</div>
</div>
<script src="../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../sorter.js"></script>
<script src="../../../../block-navigation.js"></script>
</body>
</html>
